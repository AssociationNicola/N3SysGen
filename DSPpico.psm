;GV0B  To add code to take into account amplitude of start tone detected to adjust AGC, attack 32ms decay 1024ms BT mic routed through AGC MUX
;GV07 correct incorrect data archive and demod peak display problem (MSB/LSB mixup!)
;GV06 increase SSB amplitude on TX
;GV03 corrected OutAmp doubling and increased speaker volume
;GV02 Halved AGC thresholds to avoid clipping
;GV01 Reduce Speaker volume by increasing AGC value to 63 on startup
;GV00 return counter to zero for new Zynq design
;GVA5 for TE0722, with RX/TX frequencies adjusted for 32.768MHz (mod in Keypad assembler)
;GVA4 correct bad setting of AvesignalMSB instead of USB (caused crashing)
;GVA2 BT input from mic is taken externally in logic - also removed audio double so as not to saturate voice on transmission (but will drop volume on handset ~6dB)
;AND over haul AGC to use 24 bit average level registering so level is monitored with AveSignalUSB
;GVA1 Try to implement tone detect parts
 ;GVA0 Project to get AGC to act on external MUX, but still use last 4 bits for decrease 3dB and 1.5dB in the Pico
;GV9B to do - mods to detect start and end tones
;GV96 readjust AGC settings and bit offsets
;GV93add back divide by 2 on transmit line 567
; GV51 remove level divide by 2 on transmit to compensate for drop in AGC level (so only reduces level for receive)
;GV50, drop DSP AGC levels back to just below as in GV45
;GV47 increase DSP AGC thresholds
;GV46 added further double on RF out amplitude
;GV45 Corrected resetting of AveSignalMSB to middle value so as to avoid double jump and increased allowable rang to avoid unnecessary jumps (abd corrected AGC wrapping in GV44 when limiting if greater than 44 rather than to 44 ie CALL Z not CALL NC !!!)
;GV44 add 1_5dB decrease - still need to correct AGC range (increase another factor 2) and decrease limits
;GV43 correct beacon phase wander
;GV42 disable UART streaming
;GV3F Add streaming over UART on TX (State bit 2 set)
;GV3E try adding small sine wave - not yet implemented
;For GV3D, need to add further routines, increaseAGC2 and increaseAGC4 that increase attenuation 6dB and 12dB respectively (within limits) - look at how AveSignalMSB is reset.

;For GV3B try to correct incorrect AGC operation with twice as many values
;store TX AGCvalue before warble (or when stable) and add 3dB steps to AGCvalue
;31/1/13 Added 12dB to BT mic level using Audiodouble
;GV38 Use audio double on transmitpath
;For GV37 Adjusted AGC thresholds and increased time constant a factor 8.
;31/12/12 increase volume and transmitted power by increasing AGC setting a factor of 2 (from 4,12 to 8,24 - AGCupp/lowthreshold). Also set AGCvalue to 06 INITIALY (may need to be adjusted) recall last AGCvalue when switch mode. Line 439 increase TX modulation.
;removed LPF
;Increased AGC setting -36 OK, 72 too high (bad clipping noise)
;Slow saturation of SSBamp
;Added BT signal not present flag (16/1/12)
;Try to fix failure to un-block DSP problem (18/11/11 in DSPblock routine)
;Uses phase representation of TX audio - works in study OK 18/11/11
;29/8/11 Increased audio frequency resolution to 16 bits
;19/8/11, tweaked audio scaling of TX
;Modified vor BT input
;This needs to be modified for COTS version at 49.152MHz - in particular calibration of audio frequency output to SSB modulator has been modified see line 398
; Inputs sine wave as audio
; 20/7 updated input and output ports for multipico version

; Feb 09 Start testing AGC part of streamed signal
; Now implementing on SSBN.mdl
; 
; DSP routine for SSB picoblaze
; 
; Implemented commands:
; 0 = RX mode



;Different AGC threshold values are now used for RX and TX
;CONSTANT	AGClowthreshold,		6'd   			;;These are thresholds for the measured signal - Increase a factor of 2 17/4/14
;CONSTANT	AGClowthreshold2,		2'd   			;;These are thresholds for the measured signal
;CONSTANT	AGCInitial,		8'd   			;;This is mid way between thresholds Is upperthreshold2> SR0> minus 2




;CONSTANT	AGCuppthreshold,		10'd
;CONSTANT	AGCuppthreshold2,		16'd			;3dB above first threshold
;CONSTANT	AGCuppthreshold4,		22'd
;CONSTANT	AGCuppthresholdRX2,		10'd			;Change to 10 (June2017 after BCRC) Upp2 = 10 Upp =5 Initial = 4 low=2 low2=1
;CONSTANT	AGCuppthresholdTX2,		6'd			;Upp2=6 Upp=3 Initial=2 low=2 low2=1

CONSTANT	AGChigh,				40'd		;High threshold for AGC (accumulated over 32ms) (reduced back to 40)
CONSTANT	AGClow,					50'd		;Low threshold for AGC (accumulated over 1024ms) (increased from 20 with 512ms accumulation)
CONSTANT	AGClow2,				25'd		;Even lower threshold for AGC (accumulated over 1024ms)


CONSTANT    delay_1us_constant,       06                  ; Value (13)19 or 12? decimal suitable for 50MHz clock – about 6 for 33MHz?
CONSTANT	m,						8'd                   ; No. of iterations for cordic
CONSTANT	m_plus_1,				9'd                   ; No. of iterations for cordic
CONSTANT	count_1000_lsb,			E8                 	  ; lower 8-bits of 1000 count value
CONSTANT	count_1000_msb,			03                    ; upper 8-bits of 1000 count value
CONSTANT	half_pi_LSB,			00                     ; 
CONSTANT	half_pi_MSB,		 	40                    ; 360 degrees = $10000
CONSTANT	audioTest,				2'd                   ; Frequency 2=800Hz, 3=1200Hz, 4=1.6kHz 7=2.8kHz

;Frequency values for start and stop tones
;CONSTANT	StrtToneAInc,			9F
;CONSTANT	StrtToneBInc,			69
;CONSTANT	StopToneAInc,			5A
;CONSTANT	StopToneBInc,			78

; FIR coefficients for 0 and 90 degree filterred signals, these are SIGNED values!!
CONSTANT	coeffI0MSB,				F6                 ; Smallest coefficient (negative value!)
CONSTANT	coeffI0LSB,				92
CONSTANT	coeffI1MSB,				F4
CONSTANT	coeffI1LSB,				8A
CONSTANT	coeffI2MSB,				F2
CONSTANT	coeffI2LSB,				CC
CONSTANT	coeffI3MSB,				F1
CONSTANT	coeffI3LSB,				77
CONSTANT	coeffI4MSB,				F0
CONSTANT	coeffI4LSB,				A1
CONSTANT	coeffI5MSB,				40                 ; Actualy half value of peak
CONSTANT	coeffI5LSB,				00
; Q values are still signed but are all positive
CONSTANT	coeffQ0MSB,				00                 ; Smallest coefficient
CONSTANT	coeffQ0LSB,				A7
CONSTANT	coeffQ1MSB,				05
CONSTANT	coeffQ1LSB,				2D
CONSTANT	coeffQ2MSB,				0C
CONSTANT	coeffQ2LSB,				83
CONSTANT	coeffQ3MSB,				1B
CONSTANT	coeffQ3LSB,				4F
CONSTANT	coeffQ4MSB,				5C
CONSTANT	coeffQ4LSB,				2F


; Registers
NAMEREG		sF, AveSignal1024ms            ; In fact accumulate of magnitude over 1024ms
NAMEREG		sE, AveSignalMSB		;average up to 32ms
NAMEREG		sD, AveSignalLSB
;NAMEREG		sD, BaselineMSB                  ; In fact average of signed signal
;NAMEREG		sC, BaselineLSB
NAMEREG		sC, SineCtr				  ;Aargh sB is used by the Cordic!! - but not used now

; registers sA-sD are used for longish term storage...!
; sA used for cordic calcs and FIR work for relative pos of roving ptr

; Scratch pad
; registers 0-8 used for cordic table:
; reg 0=45degrees
; ..
; reg 7=0.44761degrees

; Input port
CONSTANT	AudioMSB,		0'd
CONSTANT	AudioLSB,		1'd
CONSTANT	Strobe,			2'd                   ; 	   bit0=6kHz square wave - the rest are now zeros
CONSTANT	Command,		3'd                   ; From interface pico
CONSTANT	MltplyMSB,		4'd                   ; Top significant byte of multiplier output
CONSTANT	MltplyLSB,		5'd                   ; (only 16 bits retained)
CONSTANT	BTaudioMSB,		6'd                   ; Input from headset micro
CONSTANT	BTaudioLSB,		7'd                   ; 
CONSTANT	SaturationBits,		8'd					  ;lowest 3 bits are the top 3 bits of the 18bit demod signal (indicate saturation) - the top 5 bits are zeros
CONSTANT	RAMdataLSB,		9'd
CONSTANT	Status,			10'd				  ;bit 0 is DSP2user fifo full, bit 1 is no BT audio stream from headset microphone, bit 2 is TX_high, bit 3 is signal received on (from tone detect not used Nov 2017)
CONSTANT	StartToneAmp,		11'd




; Output ports

CONSTANT	MSBAudio,			0'd
CONSTANT	LSBAudio,			1'd
CONSTANT	SSBAmp,				2'd
CONSTANT	CmdToUser,			3'd
CONSTANT	CoeffMSB,			4'd
CONSTANT	CoeffLSB,			5'd
CONSTANT	SignalMSB,			6'd
CONSTANT	SignalLSB,			7'd


CONSTANT	Data2archiveMSB,	10'd
CONSTANT	Data2archiveLSB,	11'd
CONSTANT	Controlbits,		12'd                  ; BIT OFFSETS:
; Bit offsets:
CONSTANT	EnMult,				1'd

CONSTANT	AckFIFO,			32'd                  ; 		5 Acknowledge FIFO (present character)



CONSTANT	PhaseIncrement ,	13'd
CONSTANT	AudioFreqLSB,		14'd
CONSTANT	AudioPhaseMSB,		15'd
CONSTANT	AudioPhaseLSB,		16'd
CONSTANT	EnableSpeaker,		17'd
CONSTANT	MUXport,			18'd 			  ;New port to drive AGC MUX (middle 4 bits)- called AGCvalue in Sysgen model
;CONSTANT	StartToneA,			19'd
;CONSTANT	StartToneALong,			20'd
;CONSTANT	StartToneB,			21'd
;CONSTANT	StartToneBLong,			22'd
;CONSTANT	NotUsed,			23'd
CONSTANT	AveSignal1024msport,			24'd
CONSTANT	AveSignalMSBport,			25'd
CONSTANT	AveSignalLSBport,			26'd

CONSTANT	MSBBTAudio,			27'd
CONSTANT	LSBBTAudio,			28'd


; Scratchpad registers
; 0-8 used for Cordic Table!
CONSTANT	AmpMSB,				10'd
CONSTANT	AmpLSB,				11'd                  ; Bit 0 toggles at 16kHz
CONSTANT	PhaseMSB,			12'd
CONSTANT	PhaseLSB,			13'd                  ; Is this necessary?
CONSTANT	AGCvalue,			14'd                  ; four times number of bits to shift (63-0) 63 is max attenuation
CONSTANT	VolSetting,			15'd
CONSTANT	OldPhaseMSB,		16'd
CONSTANT	AudioScratch,		17'd

CONSTANT	State,				18'd                  ; Bit 1 0=RX, 1=TX (TX_high), Bit 2 set is streaming TX data from UART, Bit 3 is 'Receiving' ie 0 when idle.

;CONSTANT	NormalisedSignalMSB,			19'd                  ; Current signal MSB after AGC
CONSTANT	LVPtr,				20'd                  ; From HistoryStart to HistoryStart+41 (place to store most recent signal value)

CONSTANT	IaccuMSB,			21'd
CONSTANT	IaccuLSB,			22'd
CONSTANT	QaccuMSB,			23'd
CONSTANT	QaccuLSB,			24'd
CONSTANT	OldPhaseLSB,		25'd

; Scratch pad 30-69 used for sinewave - 20 values for sinewave, 40 for dirac

CONSTANT	startsine,			30'd
CONSTANT	endsine,			45'd
CONSTANT	HistoryStart,		70'd                  ; 2 bytes per historical sample - 21 2byte history values
CONSTANT	HistoryStart42,		112'd                 ; 2 bytes per historical sample - 21 2byte history values
; History values up to and including 111


CONSTANT	AGCvalueTX,			112'd
CONSTANT	AGCvalueRX,			113'd
CONSTANT	AGCcounter,			114'd 			 	;store counter 0 to 255 to only perform AGC calc every 1 in 4 audio samples and sinewave increment every 8 samples

;Removed Tone related scratchregisters
CONSTANT	NormalisedMagMSB,		115'd   ;Absolute value of current signal
CONSTANT	NormalisedMagLSB,		116'd   ;Absolute value of current signal
;CONSTANT	AGCupperThresholdRX2,	117'd	;This is in fact twice the Upper threshold SR0 for Upper threshold, SRO and +1 for lower threshold and SR0 again for lower threshold2
;CONSTANT	AGCupperThresholdTX2,	118'd	;This is in fact twice the Upper threshold
;CONSTANT    AGCupperThresholdInUse,	119'd	;This is the value relevent to the current mode (RX/TX)

CONSTANT	AGCcounterMSB,		117'd	;Uses for 1024ms accumulation


;256 scratchpad addresses available

;GenerateCode        MEM       "S3eDSPprog.mem"


;start:              JUMP      cold_start	  	  	-Try without jump to $20 offset - should work!?
; Start of program (Jump instruction in preloaded memory!)
 ;                   ORG       $20
; pre-load scratchpad with cordic table.. 360 degrees is $0800 - then *32=$10000
cold_start:         LOAD      s0, 255'd             ; phase for 45 degrees- actually a bit less!
                    STORE     s0, 00
                    LOAD      s0, 151'd             ; phase for 26.565 degrees
                    STORE     s0, 01
                    LOAD      s0, 80'd              ; phase for 14.036 degrees
                    STORE     s0, 02
                    LOAD      s0, 41'd              ; phase for 7.125 degrees
                    STORE     s0, 03
                    LOAD      s0, 20'd              ; phase for 3.576 degrees
                    STORE     s0, 04
                    LOAD      s0, 10'd              ; phase for 1.79 degrees
                    STORE     s0, 05
                    LOAD      s0, 5'd               ; phase for 0.895 degrees
                    STORE     s0, 06
                    LOAD      s0, 3'd               ; phase for 0.448 degrees
                    STORE     s0, 07
                    LOAD      s0, 1'd               ; phase for 0.224 degrees
                    STORE     s0, 08


;Do still need this with new AGC !!                   
                    LOAD	  s0,50'd
                    STORE	  s0,AGCvalueTX		
                    LOAD	  s0,52'd
                    STORE	  s0,AGCvalueRX		;set to lowish value for RX
	;				LOAD	  s0,AGCuppthresholdRX2
	;				STORE     s0,AGCupperThresholdRX2
	;				LOAD	  s0,AGCuppthresholdTX2
	;				STORE     s0,AGCupperThresholdTX2
					

;Sinewave table: Step through this 1 in 8 loops to give 62.5Hz sinewave on transmission
                    LOAD      s0, 2'd               ; 1st element of sinewave
                    STORE     s0, 30'd
                    LOAD      s0, 3'd              ; 2nd element of sinewave
                    STORE     s0, 31'd
                    LOAD      s0, 4'd              ; 3rd element of sinewave
                    STORE     s0, 32'd
                    LOAD      s0, 4'd              ; etc
                    STORE     s0, 33'd
                    LOAD      s0, 4'd              ; etc
                    STORE     s0, 34'd
                    LOAD      s0, 3'd              ;
                    STORE     s0, 35'd
                    LOAD      s0, 2'd              ; etc
                    STORE     s0, 36'd
                    LOAD      s0, 0'd              ; etc
                    STORE     s0, 37'd
                    LOAD      s0, 254'd               ; etc
                    STORE     s0, 38'd
                    LOAD      s0, 253'd               ;
                    STORE     s0, 39'd
                    LOAD      s0, 252'd             ; etc
                    STORE     s0, 40'd
                    LOAD      s0, 252'd             ; etc
                    STORE     s0, 41'd
                    LOAD      s0, 252'd             ; etc
                    STORE     s0, 42'd
                    LOAD      s0, 253'd             ;
                    STORE     s0, 43'd
                    LOAD      s0, 254'd             ; etc
                    STORE     s0, 44'd
                    LOAD      s0, 0'd             ; etc
                    STORE     s0, 45'd
    ;                LOAD      s0, 254'd             ; etc
 ;                   STORE     s0, 46'd
  ;                  LOAD      s0, 0'd             ;
   ;                 STORE     s0, 47'd
    ;                LOAD      s0, 247'd             ; etc
     ;               STORE     s0, 48'd
      ;              LOAD      s0, 0'd               ; etc
       ;             STORE     s0, 49'd








                    LOAD      s0, 42'd
                    OUTPUT    s0, SSBAmp
                    LOAD      s0, 00
                    STORE     s0, State           ; Set state to 0 ie receive 

                    LOAD      SineCtr, startsine  ; reset SineCtr
                    LOAD      s0, HistoryStart	   	 ;aargh - had commented this out!!!! May2013
                    STORE     s0, LVPtr
                    
 

; Initialise AGC
                    LOAD      s0, 255'd             ; - 1
                    STORE     s0, VolSetting
                    LOAD	  s0,32'd				  ;Start with medium attenuation (max 63) value for external AGC MUX version
                    STORE     s0, AGCvalue		  ;maybe start with 16 (was 8)?



; Routine to look at lowest bit of Strobe to detect rising edge.
AwaitAudioVal:	  	INPUT     s0, Strobe
                    AND       s0, 01               ; look only at lowest bit
                    COMPARE   s0, 01
                    JUMP      Z, AwaitAudioVal    ; if 1 wait...
AwaitRise:          INPUT     s0, Strobe
                    AND       s0, 01               ; look only at lowest bit
                    COMPARE   s0, 00
                    JUMP      Z, AwaitRise        ; if 0 still, wait a bit more...

					INPUT     s0, SaturationBits	;to get 3 "saturation bits"
					COMPARE s0,07
					JUMP  Z,Allswell
					COMPARE s0,00
					JUMP  Z,Allswell
;So is hitting the rails!! but don't act on AGC as causes too much of a jump! - just clip instead!
;					FETCH s1,AGCvalue
;					COMPARE s1,60'd
;					JUMP NC,isTopAGCalready		;if AGCvalue 60,61,62 or 63
;					ADD  s1,04
;					AND  s1,FC	;Get rid of lower 2 bits
;					STORE s1,AGCvalue	;increase attenuation!

isTopAGCalready:			COMPARE s0,04
					JUMP C,SaturatedPositive
					LOAD s0,00		;Is actually saturated negative
					LOAD s1,80		;This is the most negative number
					JUMP HaveInput


SaturatedPositive:			LOAD s0,FF
					LOAD s1,7F
					JUMP HaveInput
		
                    

Allswell:				INPUT     s0, AudioLSB	   ; Now have the new value (different addresses from before!)
 					INPUT 	  s1,AudioMSB




; perform automatic gain contrl
HaveInput:                    FETCH     s3, AGCvalue		;This needs to be corrected from the value from tone detect when 'Receiving'
					CALL      AGC 		  						;Now with external MUX to adjust AGC
					CALL	  Abs16Val
					STORE	  s3,NormalisedMagMSB				
					STORE	  s2,NormalisedMagLSB				


                    
;Now check if we are transmitting this value!

                    FETCH     s2, State
                    AND       s2, 02
                    COMPARE   s2, 02               ; Check if transmit mode
                    JUMP      Z, TransmitAudio





 
		 				    OUTPUT    s1, MSBAudio	   
          					    OUTPUT    s0, LSBAudio

 						CALL	AudioDouble		   ;Add 12dB back in Nov 2017 to increase received BT volume
 						CALL	AudioDouble		   ;increase volume 12 dB! Add may 16
 ;						CALL	AudioDouble		   ;increase volume 12 dB! 

;						AND	s0, f8			;Make bottom 3 bits zero in case is 13 bit linear and these are attenuation bits
						    OUTPUT    s1, MSBBTAudio	   
          					    OUTPUT    s0, LSBBTAudio


;Display demodulated values only in receive
							OUTPUT  s1,Data2archiveMSB 	  	  		  ;This is received demodulated data
							OUTPUT  s0,Data2archiveLSB
							SLA		s0				  ;shift top bit into carry
							ADDCY	s1,00			  ;s1 now rounded value of upper 8 bits (but s0 wasted!)
					
                   

; Check if there is a command from the User, return here with JUMP command from TransmitAudio macro
BackfromTransmitting: 		INPUT   s0, Command         ; Check if FIFO character present
				COMPARE s0, 128'd             ; is there a character?
				CALL      C, Respond2Fifo



; Accumulate magnitudes over 32 and 1024ms
;__________________________________________________________________________________________
 	 	  	


                    FETCH      s3, NormalisedMagMSB
                    
                    
                    
                    	ADD       AveSignalLSB, s3
                    	ADDCY      AveSignalMSB, 00

                    
			CALL C,FourTimestooBig	 	; Has saturated so need to go and cool it! - increase AGC by 16 steps!


			FETCH s3,AGCvalue		;put AGCvalue in s3 incase we call BitTooBig

			COMPARE	AveSignalMSB,AGChigh
			CALL NC, BitTooBig		;Accumulated magnitude during 32ms period is too big


	  	 	FETCH   s3,AGCcounter
	  	 	ADD	   s3,01
	  	 	STORE   s3,AGCcounter


			COMPARE s3,00	;Has it overflowed - ie after 32ms
                	JUMP    NZ,   AwaitAudioVal	;Loop back if not
;The following executes every 32ms
;Add another counter here to go to 32x32ms
			FETCH s3,AGCvalue		;put AGCvalue in s3 incase we call BitTooBig

			ADD	AveSignal1024ms,AveSignalMSB	;accumulate 32ms sum into this register
			CALL C, BitTooBig		;If 1s average goes over 255, then increase AGCvalue (added 7 July2017)

			OUTPUT	AveSignalMSB,AveSignalMSBport   ;AveSignalMSB is actually a register 32ms average! - before resetting to zero!
			OUTPUT	AveSignalLSB,AveSignalLSBport    ;AveSignalMSB is actually a register!

			LOAD AveSignalMSB,00				;and reset 32ms sum to zero

			FETCH s3,AGCcounterMSB
			ADD s3,01
			STORE  s3,AGCcounterMSB   ;Increment second byte counter
			AND	s3,1F		;get 0-31 count of 32ms
			COMPARE s3, 00		;Are we at 1024ms
			JUMP	NZ, AwaitAudioVal

;Have reached 1024ms
;Output AveSignalMSB to PS - ever ~0.5s AveSignal1024ms
			OUTPUT	AveSignal1024ms,AveSignal1024msport   ;1024ms average


	 		FETCH   s3, AGCvalue

			
;AGCvalue still in s3
			COMPARE  AveSignal1024ms,AGClow
			CALL   C,BitTooLow

			LOAD AveSignal1024ms,00				;and reset 1024ms sum to zero (had forgotten this!!)

 

;disable the following 7 lines for the moment
;Don't do this if Speaker is ON - ie is receiving a message, but on first time that Speaker on is high do a correction of AGCvalue
;			INPUT	s0,Status
;			AND	s0,08		;Look at speaker on bit - this is information from the tone detect pico!
;			COMPARE s0,08
;			JUMP Z,Receiving	;Check if receiving state is alread latched or whether this is first time to notice that we are receiving
;If not receiving a signal better reset state bit 3
;			FETCH     s1, State
		
;            		AND        s1, F7		;bit 3 zero
 ;           		STORE     s1, State           ; reset bit 3 (ie set internal DSP state to 'not receiving')

;ContinueReceiving:


; Now adjust AGC value if necessary

                	JUMP      AwaitAudioVal
; -------------This is end of main loop--------------------------------
					

					



					
;Well big!!					
FourTimestooBig:	FETCH   s3,AGCvalue
			LOAD AveSignalMSB,00	;reset 32ms accumulation - so only increase once!
FourTimesLoop:		LOAD s2,04
			CALL      increaseAGC	;need to do this just 4 times!
			SUB s2,01				;decrement counter
			COMPARE s2,00			;Has counter reached zero
			JUMP  NZ,FourTimesLoop
			RETURN					;Return after 16 loops
					
					
; So need to adjust AGCvalue:
;Enter with AGCvalue in s3
BitTooBig:	LOAD AveSignalMSB,00				;and reset 32ms sum to zero
		CALL      increaseAGC     ; signal slightly too big, increase attenuation by 1_5dB
		RETURN			;keep to a single step

			CALL	  reduceAveSignalMSB_1_5dB		;reduce magnitude of 
			COMPARE	AveSignalMSB,AGChigh		;see if we need to reduce the level (ie increase AGC) some more
			JUMP	NC,BitTooBig					;loop back if still too big
			RETURN
			

;this effectively multiplies AveSignalMSB by 0.84375 (ie reduces it by 1.5dB) - maybe don't need?
reduceAveSignalMSB_1_5dB:  	SR0 AveSignalMSB		;half of AveSignalMSB
							LOAD s2,AveSignalMSB
							SR0 AveSignalMSB		;quarter of AveSignalMSB
							ADD s2,AveSignalMSB
							SR0 AveSignalMSB		;eighth of AveSignalMSB
							SR0 AveSignalMSB		;16th of AveSignalMSB
							ADD s2,AveSignalMSB
							SR0 AveSignalMSB		;32nd of AveSignalMSB
							ADD s2,AveSignalMSB		;now should be about 0.84375 times original value
							LOAD AveSignalMSB,s2	;put back in AveSignalMSB
							RETURN
							


;Again enter with AGCvalue in s3							
BitTooLow:	CALL      decreaseAGC
			COMPARE	AveSignal1024ms,AGClow2	;Is the level 2 times too low?
			RETURN	NC							;Return in Ave level over 1024ms is greater than the half the lower threshold
			CALL      decreaseAGC
			CALL      decreaseAGC
			CALL      decreaseAGC				;make up to a drop in AGCvalue of 4 (reduce attenuation a factor 2) to bring volume up quickly
			
			RETURN



				
					
					
					
					



;Receiving:	FETCH     s1, State
;			AND	      s1,08 ;look at current state of 'receiving' bit.
;			COMPARE   s1,08			;This is looking at the internal recorded state rather than the 'Status' input which takes bit 3 input from the TD pico
;			JUMP     Z,Somewhere??;	;Carry on if already acnowledged in receive mode (and still perform AGC)
;			FETCH     s1, State
;		
 ;           OR        s1, 08
  ;          STORE     s1, State           ; set bit 3 (ie set internal DSP state to 'receiving')
;!!!!!!!!!!!!!!!!!!!!!!!!! is this really needed??? - maybe need to return here, or jump??
;Now update AGC value
;First check if received tone is too strong and need to increase attenuation - Need to check Target values!!!!!!!!!!!!!!!!!!!!!!!!!!!!! (23/4/17)
;			FETCH s3, AGCvalue
;			INPUT	s1,StartToneAmp
;			COMPARE s1,36'd		;is it 36 of bigger (ie 1.5dB above target value of 30)
;			CALL	NC,increaseAGC
;			COMPARE s1,43'd		;is it 43 of bigger 
;			CALL	NC,increaseAGC
;			COMPARE s1,51'd		;is it 51 of bigger 
;			CALL	NC,increaseAGC
;			COMPARE s1,61'd		;is it 61 of bigger 
;			CALL	NC,increaseAGC
;			COMPARE s1,72'd		;is it 72 of bigger 
;			CALL	NC,increaseAGC
;			COMPARE s1,85'd		;is it 85 of bigger 
;			CALL	NC,increaseAGC
;			COMPARE s1,101'd		;is it 101 of bigger
;			CALL	NC,increaseAGC
;			COMPARE s1,121'd		;is it 121 of bigger
;			CALL	NC,increaseAGC
;			COMPARE s1,143'd		;is it 143 of bigger 
;			CALL	NC,increaseAGC
;			COMPARE s1,170'd		;is it 170 of bigger 
;			CALL	NC,increaseAGC
;			COMPARE s1,202'd		;is it 202 of bigger
;			CALL	NC,increaseAGC
;			COMPARE s1,241'd		;is it 241 of bigger
;			CALL	NC,increaseAGC
;			
;			COMPARE s1,26'd		;is it less than 26 (ie 1.5dB below target value of 30)
;			CALL	C,decreaseAGC
;			COMPARE s1,22'd		;is it less than 22 
;			CALL	C,decreaseAGC
;			COMPARE s1,18'd		;is it less than 18 
;			CALL	C,decreaseAGC
;			COMPARE s1,15'd		;is it less than 15 
;			CALL	C,decreaseAGC
;			COMPARE s1,13'd		;is it less than 13 
;			CALL	C,decreaseAGC
;			COMPARE s1,11'd		;is it less than 11 
;			CALL	C,decreaseAGC
;			COMPARE s1,9'd		;is it less than 9 
;			CALL	C,decreaseAGC
;			COMPARE s1,8'd		;is it less than 8 
;			CALL	C,decreaseAGC
;

;Now updata AGCvalue
;			STORE s3, AGCvalue
;LOOK carefully at this as may need to do AGC (and so do a return)			
 ;            JUMP      AwaitAudioVal
                    


;Routine to take 16 bit value in s3,s2 and shift right by 5 to divide by 32 and leave value in s3,s2
;Assumes this is an unsigned numbers - normally used on a magnitude.
Divide32:  CALL		Divide4
		   CALL		Divide4
		   SR0		s3
		   SRA		s2

		   RETURN
		
Divide4:   SR0		s3
		   SRA		s2
		   SR0		s3
		   SRA		s2
		   RETURN		




;This routine aims to double the signed analogue value in s0,s1 by finding sign of the value and doubling if small, increasing magnitude by 32 if less than 95 but more than 32 then limiting to 127 if more than 95

AudioDouble:  	   COMPARE s1,128'd
				   JUMP	C,Posvalue
;otherwise must be negative
Negvalue:		   COMPARE	   s1,225'd		;256-31
				   JUMP	   C,islessthanneg31
				   SL0	   s0
				   SLA	   s1			  ;double value
				   RETURN
				
islessthanneg31:   COMPARE	   s1,193'd			;256-63
				   JUMP	   C,islessthanneg63
				   SUB	   s1,32'd
				   RETURN
				
islessthanneg63:   SRX	   s1
				   SRA	   s0				;half value
				   SUB	   s1,64'd
				   RETURN
				   	

Posvalue:		   COMPARE	   s1,32'd
				   JUMP	   NC,ismorethan31
				   SL0	   s0
				   SLA	   s1			  ;double value
				   RETURN
				   
ismorethan31:	   COMPARE	   s1,64'd
				   JUMP	   NC,ismorethan63		  ;positive and 64 or greater
				   ADD	   s1,32'd
				   RETURN
				   
ismorethan63:	   SRX	   s1					  ;sign extension should be zero!
				   SRA	   s0
				   ADD	   s1,64'd
				   RETURN
				   	
;-----------End Audio double



;Divides 16 bit signed value in s0,s1 by 2.
Divide2:			SRX		  s1
		  	  		SRA		  s0
					RETURN


;SUB16bit:			SUB		  s8,s0
;					SUBC	  s9,s1				;16 bit subtract					
;					RETURN

;ADD16bit:			ADD		  s8,s0
;					ADDC	  s9,s1				;16 bit addition					
;					RETURN



TransmitAudio:			
;					IN 	s2,Status
;					AND	s2,2	 ;look at bit 1
					
;In this version switching to BT input is through external multiplexer to go through emphasis filter
;					COMP s2,0	 ;True if BT signal present
					
;					JUMP NZ,SkipNoBT   ;keep value from ADC if flag set
;					IN  s0,BTaudioLSB  ;Use BT values instead if present								
;					IN  s1,BTaudioMSB
;					CALL	AudioDouble		   ;increase volume 6 dB!  14/3/15


SkipNoBT:									

					
;Nov 2014 - have reduced DSP AGC level, so shouldn't need to do this? -reinstate Feb2015
;	               SRX		s1				;halve value before FIR to keep I and Q below $30 limit after FIR for CORDIC
;	               SRA		s0

;Store data in RAM
;				   OUTPUT     s0,Data2archiveLSB 		
;				   OUTPUT     s1,Data2archiveMSB


				CALL      PerformFIR
				;This should have decreased amplitude by about 6dB	
				
				OUTPUT     s1,Data2archiveMSB 		
				OUTPUT     s0,Data2archiveLSB
				


						
;need to make sure that s3/s2 and s1/s0 DO NOT EXCEED $3000, ie 48 in the MSBs!
				   CALL	  cordic		  ;This is upsettng the AGC when sinectr used sB!

;April 2017 try to stop tx saturation. - July cancel 2 of the doublings (in case a problem of noise at low mic signal!)
					CALL TryAndDouble	;Bump amplitude to saturate! (Jan 2016)
					CALL TryAndDouble
;					CALL TryAndDouble
;					CALL TryAndDouble
					CALL TryAndDouble	;try add for upgrade of production code TRY ADDING AGAIN (Sept 17)
					
					
								   		   	
OutAmp:		

;_______________________________
;Test value by sending out to Uart - shift this section as required - but check s3 not used! Disable in GV44a to allow receipt of other values!
;				   LOAD   s3,s1
;				   SRX	  s3   	   	 	   ;make sure am not spoiling s3!!!!!
;	                    OUT       s3, CmdToUser	  	;Send amp in 7 bits (divide by 2!) to user pico to send to UART
;__________________________________



				   OUTPUT	  s1,SSBAmp								;********************disable for beacon tests

				   FETCH  s3,OldPhaseMSB
				   FETCH  s2,OldPhaseLSB
				   STORE  s5,OldPhaseMSB
         		   STORE  s4,OldPhaseLSB						;s2,3 old phase, s4,5 new phase
         		   OUTPUT s3,AudioPhaseMSB							  ;send old phase directly
 				   OUTPUT s2,AudioPhaseLSB							  ;send old phase directly
 				   SUB	  s4,s2
 				   SUBCY  s5,s3										  ;New phase-old phase
 				   SRX	  s5
 				   LOAD	  s3,s5										  ;divide MSB by2 and copy
 				   SRX	  s3
 				   SRX	  s3										  ;s5/4
 				   ADD	  s5,s3
 				   SRX	  s3
 				   SRX	  s3										  ;s5/16, s5 should now be 4/3rds of Phase shift/2^9, or 2/3rds of phase shift/2^8 (should be 2/3rds of s5/2^11) so need further 2^3 attenuaion)
 				   ADD	  s5,s3
				   OUTPUT	  s5,PhaseIncrement				
 				   
			
								
				   JUMP      BackfromTransmitting

TryAndDouble:	   COMPARE	  s1,64'd	  ;see if it is not too big already
				   JUMP	  NC,BiggerThan63	  ;Skip if too big
				   SL0	  s0			  ;add 6dB 4/10/11
				   SLA	  s1
					RETURN
				   
				   
BiggerThan63:	   COMPARE s1,129'd
				   JUMP NC,BiggerThan128
				   ADD	s1,64'd
				   RETURN
				   
BiggerThan128:	   SR0	s1			;half value (127 max value)
				   ADD	s1,128'd		;add 128 (gives 255 max)
				   RETURN
				

;Enter with signed 16 bit value in s1,s0 and return magnitude in s3,s2
Abs16Val:		   	LOAD  	s3,s1
					LOAD	s2,s0
					COMPARE      s1, 128'd
					RETURN		  C
					LOAD	  s3,00
					LOAD	  s2,00
					SUB		  s2,s0
					SUBCY	  s3,s1	
					RETURN

absval:			    COMPARE      s3, 128'd
                    CALL      NC, makeposval
					RETURN


; Turn negative value in s3 into a positive one (well will actualy make a positive value negative as well).
makeposval:         LOAD      s4, 00
                    SUB       s4, s3
                    LOAD      s3, s4
                    RETURN      
;invert value - actually same as makeposval, but works on s1
invertval:	  		LOAD      s4, 00
                    SUB       s4, s1
                    LOAD      s1, s4
                    RETURN




;Feb 2013 icrease number of AGC steps factor 2 and another factor 2 July 2013 (now granularity 1.5dB)
; increment attenuation
increaseAGC:        COMPARE      s3, 63'd  		   ; was44
                    RETURN       NC                   ; don't do anything if already 63 or bigger (was 44 (was 22, before that 11))

                    ADD       s3, 1'd               ; so yes signal really has been too big for too long!
		    STORE s3,AGCvalue		;put s3 back in AGCvalue

                    RETURN       



; decrement attenuation
decreaseAGC:    COMPARE      s3, 00	  	   	   ; was232
                RETURN       Z                   ; don't do anything if already  0   (was 232 ie -24 (was 244, before that 250 ie -6) )	

				;				LOAD      s2,AveSignalMSB - this didn't seem to do anything (A0)

                SUB       s3, 01               ; so yes signal really has been too small for too long!
				
		STORE s3,AGCvalue		;put s3 back in AGCvalue

                RETURN       




; AGC takes 16 bit value, MSB in s1, LSB in s0 and returns normalised 16 bit value in s1,s0 using AGC value from s3, using external MUX for coarse control
;AGC value in s3 should vary  0-63 in this version - higher value is higher attenuation so use higher significant bits on input MUX (4 bits - 16 inputs)
; This routine can also be use for the volume setting if value put in s3 ????????
AGC:   				INPUT 	s2,Status
				AND	s2,06	 ;look at bit 1 and 2
					
;In this version switching to BT input is through external multiplexer to go through emphasis filter
				COMPARE s2,04	 ;True if TX_high - only look at bit 2
					
				RETURN Z   ;Don't do anything if TX_high
	   	   	        OUTPUT		  s3,MUXport		  ;Now simply use middle 4 bits to drive the MUX (or 'AGCvalue' in sysgen model) (this had been lower in the program and used the lowest bits)
	   		   	
				SRX		  s3   	 			  ;divide s3 by 2 to get last AGC and put last bit into carry
				CALL	  C,decrease1_5dB		  ;if last bit set then reduce by 3dB
				SRX		  s3   	 			  ;divide s3 by 2 to get old AGC and put last bit into carry
				CALL	  C,decrease3dB		  ;if last bit set then reduce by 3dB

	   		   	RETURN
                    
;AGCloop:            COMPARE      s3, 00
 ;                   RETURN       Z                   ; escape if AGC value zero
  ;                  SRX       s2
   ;                 SRA       s1
    ;                SRA       s0
     ;               SUB       s3, 1
      ;              JUMP      AGCloop

;negAGC:             COMP      s3, 0
;					RET       Z                   ; escape if AGC value zero
 ;                   SL0       s0				  ;increase 24 bit value by 6dB
  ;                  SLA       s1
   ;                 SLA       s2
    ;                ADD       s3, 1
     ;               JUMP      negAGC

;this decreases value in (not s2),s1,s0 by factor 0.6875 (roughly 1/sqrt(2)) s2 not used with external MUX
decrease3dB:        SRX       s1
                    SRA       s0
					LOAD	  s4,s0
					LOAD	  s5,s1
					
					SRX       s5
                    SRA       s4
					SRX       s5
                    SRA       s4
					ADD		  s0,s4
					ADDCY	  s1,s5
					SRX       s5
                    SRA       s4
					ADD		  s0,s4
					ADDCY	  s1,s5
					
					
					RETURN

;multiply by 0.875 - modified for using only s1,s0
decrease1_5dB:      SRX       s1
                    SRA       s0
					LOAD	  s4,s0
					LOAD	  s5,s1
					SRX       s5
                    SRA       s4
					ADD		  s0,s4
					ADDCY	  s1,s5
					SRX       s5
                    SRA       s4
					ADD		  s0,s4
					ADDCY	  s1,s5
					
					
					RETURN
					
;multiply s2 by factor 1.25 (only used for AveSignalMSB) (not needed?)
;increase1_5dB:      LOAD	  s6,s2
;					SRX       s6
 ;                   SRX       s6
  ;                  ADD 	  s2,s6
;										
;					RET

                    
;This is never called???????????????????
AGCtest:             LOAD	  s3,08
					 LOAD	  s0,s1
					 LOAD	  s1,s2
					 RETURN

;This is never called???????????????????
AGClooptst:         COMPARE   s3, 00
                    RETURN    Z                   ; escape if AGC value zero
                    SRX       s2
                    SRA       s1
                    SRA       s0
                    SUB       s3, 01
                    JUMP      AGClooptst



; Routine to perform FIR takes new signal value in s1,s0 (s1 is MSB) and puts into scratch buffer and then outputs new filterred values for I in s1,s0 and Q in s3,s2
; First store latest value then increment LVptr
;OK Sept 2010
;reasonable match between I and Q components (within ~1dB), but about 6dB attenuation from input - OK.
PerformFIR:         OUTPUT       s1, SignalMSB
                    OUTPUT       s0, SignalLSB


                    FETCH     s4, LVPtr           ; value of the previous latest value
                    ADD       s4, 02               ; advance LVptr
                    COMPARE   s4, HistoryStart42	; + 42
                    CALL      NC, resetLVptr      ; if gone past end of buffer reset pointer to start

                    STORE     s4, LVPtr           ; update incremented value of LVptr (by step +2)
                    STORE     s1, (s4)              ; Store signalMSB at LVptr in scratch
                    ADD       s4, 01
                    STORE     s0, (s4)              ; Store signalLSB at LVptr+1 in scratch
                    SUB       s4, 01               ; return to LVptr



                    LOAD      sA, 00               ; Reset the register used for the difference between LVptr and Rptr (diff)



                    STORE     sA, IaccuLSB
                    STORE     sA, IaccuMSB
                    STORE     sA, QaccuLSB
                    STORE     sA, QaccuMSB        ; Reset all accumulators


; now start filter with roving pointer in s5 starting at LVptr
; LOAD      s5, s4
                    CALL      UpdateRptr          ; this should be equivalent to previous line!

                    LOAD      s7, coeffI0MSB      ; Smallest coefficients of I FIR - load values to go to multiplier input.
                    LOAD      s6, coeffI0LSB
                    CALL      Ibussiness

                    LOAD      s7, coeffQ0MSB      ; Smallest coefficients of Q FIR
                    LOAD      s6, coeffQ0LSB
                    CALL      Qbussiness

                    LOAD      s7, coeffI1MSB      ; coefficient of I FIR
                    LOAD      s6, coeffI1LSB
                    CALL      Ibussiness

                    LOAD      s7, coeffQ1MSB      ; coefficient of Q FIR
                    LOAD      s6, coeffQ1LSB
                    CALL      Qbussiness

                    LOAD      s7, coeffI2MSB      ; coefficient of I FIR
                    LOAD      s6, coeffI2LSB
                    CALL      Ibussiness

                    LOAD      s7, coeffQ2MSB      ; coefficient of Q FIR
                    LOAD      s6, coeffQ2LSB
                    CALL      Qbussiness

                    LOAD      s7, coeffI3MSB      ; coefficient of I FIR
                    LOAD      s6, coeffI3LSB
                    CALL      Ibussiness

                    LOAD      s7, coeffQ3MSB      ; coefficient of Q FIR
                    LOAD      s6, coeffQ3LSB
                    CALL      Qbussiness

                    LOAD      s7, coeffI4MSB      ; coefficient of I FIR
                    LOAD      s6, coeffI4LSB
                    CALL      Ibussiness

                    LOAD      s7, coeffQ4MSB      ; coefficient of Q FIR
                    LOAD      s6, coeffQ4LSB
                    CALL      Qbussiness

                    LOAD      s7, coeffI5MSB      ; half of middle coefficient of I FIR
                    LOAD      s6, coeffI5LSB
                    CALL      Ibussiness          ; Roving pointer is advanced an 11th time but is reset before being used!

                    FETCH     s0, IaccuLSB
                    FETCH     s1, IaccuMSB
                    FETCH     s2, QaccuLSB
                    FETCH     s3, QaccuMSB


                    RETURN                           ; return from PerformFIR			


; These assume coefficient is in s6,7 (LSB,MSB)
Ibussiness:         CALL      doIplus
                    CALL      conjugateDiff       ; Roving, difference pointer in sA sent to conjugate value and update roving pointer s5
                    CALL      doIplus
                    CALL      conjugateDiff       ; Return difference pointer in sA from its conjugate value
                    CALL      AdvanceRptr         ; This is relative shift to roving pointer (0->10 x2 ie 20)
                    RETURN       


Qbussiness:         CALL      doQplus
                    CALL      conjugateDiff       ; Roving, difference pointer in sA sent to conjugate value, also update roving pointer.
                    CALL      doQminus
                    CALL      conjugateDiff       ; Roving, difference pointer in sA sent to conjugate value, should go back to value before calling this function.
                    CALL      AdvanceRptr         ; This uses relative shift to roving pointer (0->10x2 ie 20), sA used for difference value.
                    RETURN       

; These assume coefficient is in s6,7 (LSB,MSB) for doMult, so make sure it doesn't pollute it for the next time!
doIplus:            CALL      doMult
                    FETCH     s0, IaccuLSB
                    FETCH     s1, IaccuMSB

                    ADD       s0, s8
                    ADDCY     s1, s9
                    STORE     s0, IaccuLSB
                    STORE     s1, IaccuMSB

                    RETURN       

doQplus:            CALL      doMult
                    FETCH     s0, QaccuLSB
                    FETCH     s1, QaccuMSB

                    ADD       s0, s8
                    ADDCY     s1, s9
                    STORE     s0, QaccuLSB
                    STORE     s1, QaccuMSB

                    RETURN       

doQminus:           CALL      doMult
                    FETCH     s0, QaccuLSB
                    FETCH     s1, QaccuMSB

                    SUB       s0, s8
                    SUBCY     s1, s9
                    STORE     s0, QaccuLSB
                    STORE     s1, QaccuMSB

                    RETURN       


; History signal is first output to SignalMSB and SignalLSB, the signal is then multiplied by the coefficient (provided in s6,7 - LSB,MSB) and the result is returned in s8,9 (LSB,MSB)
doMult:             CALL  	  GetRovingHistoryValues
					OUTPUT    s1, SignalMSB
                    OUTPUT    s0, SignalLSB       ; Historical signal sent to multiplier

                    OUTPUT    s7, CoeffMSB
                    OUTPUT    s6, CoeffLSB
                    LOAD      s0, 00
                    LOAD      s0, 00
                    LOAD      s0, 00               ; wait a bit (8 clock cycles enough?)
                    LOAD      s0, 00
                    INPUT     s9, MltplyMSB
                    INPUT     s8, MltplyLSB
                    RETURN       


GetRovingHistoryValues:	FETCH     s1, (s5)              ; Historical SignalMSB
                    ADD       s5, 01
                    FETCH     s0, (s5)              ; Historical SignalLSB
                    SUB       s5, 01               ; return s5 vlue as there will be another mult before updating s5!!
					RETURN



; To reset LVptr to start of history rolling buffer space. LVptr is 'Last Value Pointer'
resetLVptr:         LOAD      s4, HistoryStart
                    RETURN       

; and Rptr (Rptr is 'Roving Pointer'), next value (back 2 places), using advance of diff (sA) diff takes even values 0-40 inclusive (10 steps, ie 11 values, should never go beyond!, at each value conjugate point is also used. 11 value is diff=20 repeats itself at conjugate point)
AdvanceRptr:        ADD       sA, 02               ; advance diff (goes from 0 to 20)
                    CALL      UpdateRptr
                    RETURN       

; uses value of diff to update value of Rptr
UpdateRptr:         LOAD      s5, s4              ; put LVptr in Rptr
                    SUB       s5, sA              ; take off value of diff (sA)
                    COMPARE   s5, HistoryStart

                    RETURN       NC                  ; if not gone below bottom of buffer return!, else....

                    ADD       s5, 42'd              ; send up again
                    RETURN      

; - acts on diff (sA)
conjugateDiff:      LOAD      s0, 40'd
                    SUB       s0, sA              ; 40-sA
                    LOAD      sA, s0              ; so sA is conjugate eg: 0->40,40->0, 20->20 etc
                    CALL      UpdateRptr          ; calculate corresponding Rptr
                    RETURN       

; the negative case means when the roving ptr is less than LVptr - is it done OK above 10 lines? diff is always positive (Rptr less than LVptr)
; conjugateneg:
; RET



; Takes value in s5 and converts to 2 ascii codes which are sent to the user picoblaze.
Export2User:        CALL      Byte2Chars
                    OUTPUT    s6, CmdToUser
                    OUTPUT    s7, CmdToUser
                    LOAD      s0, 13'd              ; terminate with CR
                    OUTPUT    s0, CmdToUser
                    LOAD      s0, 10'd              ; and with LF
                    OUTPUT    s0, CmdToUser
                    RETURN       

; Takes 16 bit value in s6,s7 (MSB,LSB) and outputs to the archive memory (write enabled and selected by user picoblaze)
ArchiveData:        OUTPUT    s6, Data2archiveLSB
                    OUTPUT    s7, Data2archiveMSB
                    RETURN      


; Frequency works out the phase increment - (this is to ~7 bit precission, but using LSB could get 8 bit?)
; Takes phase in s4 (and s5) and uses old phase value from scratchpad (which is then updated). The phase increment is returned in s4.
Frequency:          FETCH     s0, OldPhaseMSB
                    STORE     s4, OldPhaseMSB
                    SUB       s4, s0
                    RETURN       


; CORDIC  Takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
; Useable range is for I and Q up to about +/-$3000

cordic:	  		   	LOAD      s4, 00
                    LOAD      s5, 00

                    COMPARE   s1, 128'd
                    CALL      NC, rotate90        ; if I negative then need to bring back into RH 2 quadrants.
; now enter loop

                    LOAD      s8, 00              ; counter of times to iterate.
cordicloop:         LOAD      s7, s1              ; temporary store for I
                    LOAD      s6, s0              ; temp store

                    COMPARE   s3, 128'd           ; is Q negative?
                    JUMP      NC, posrotate       ; if negative rotate positive
negrotate:          LOAD      sA, s2
                    LOAD      sB, s3              ; put Q into working registers
                    CALL      shift               ; shift Q by the amount in s8
                    ADD       s0, sA              ; add shifted Q to I
                    ADDCY     s1, sB
                    LOAD      sA, s6              ; prepare working registers (sA,sB) with original value of I
                    LOAD      sB, s7
                    CALL      shift
                    SUB       s2, sA
                    SUBCY     s3, sB
                    CALL      GetPhaseIncrement
                    SUB       s4, sA
                    SUBCY     s5, sB
                    JUMP      testcordicend
posrotate:          LOAD      sA, s2
                    LOAD      sB, s3              ; put Q into working registers
                    CALL      shift               ; shift Q by the amount in s8
                    SUB       s0, sA              ; add shifted Q to I
                    SUBCY     s1, sB
                    LOAD      sA, s6              ; prepare working registers with original value of I
                    LOAD      sB, s7
                    CALL      shift
                    ADD       s2, sA
                    ADDCY     s3, sB
                    CALL      GetPhaseIncrement
                    ADD       s4, sA
                    ADDCY     s5, sB
testcordicend:      ADD       s8, 01
                    COMPARE   s8, m_plus_1 		;m + 1
                    JUMP      C, cordicloop
                    RETURN       

; routine to lookup from the cordic look up table (scratchpad), the phase increment - stored as 8 bits at the location pointed to be s8, returned as 16 bits in sA and sB
; sB is MSB
GetPhaseIncrement:  FETCH     sB, (s8)
                    SR0       sB
                    SRA       sA
                    SR0       sB
                    SRA       sA
                    SR0       sB
                    SRA       sA                  ; This multiplies the 8 bit stored value by 32 so that max scratchpad value 255->255*32 equivalent to 44.82degrees
                    RETURN       

shift:              LOAD      s9, s8
shiftloop:          COMPARE   s9, 00
                    RETURN    Z
                    SUB       s9, 01
                    SRX       sB
                    SRA       sA
                    JUMP      shiftloop



rotate90:           LOAD      s7, s1              ; temporary store for I
                    LOAD      s6, s0              ; temp store

                    COMPARE   s3, 128'd           ; is Q negative?
                    JUMP      NC, add90           ; if negative add 90
sub90:              LOAD      s1, s3
                    LOAD      s0, s2              ; I=Q
                    LOAD      s2, 00
                    LOAD      s3, 00

                    SUB       s2, s6
                    SUBCY     s3, s7              ; Q=-I
                    SUB       s4, half_pi_LSB
                    SUBCY     s5, half_pi_MSB
                    RETURN       

add90:              LOAD      s1, 00
                    LOAD      s0, 00
                    SUB       s0, s2
                    SUBCY     s1, s3              ; I=-Q

                    LOAD      s2, s6
                    LOAD      s3, s7              ; Q=I
                    LOAD      s4, half_pi_LSB
                    LOAD      s5, half_pi_MSB
                    RETURN       

Transmitmode:       FETCH     s1, State
                    OR        s1, 02
                    STORE     s1, State           ; set bit 1
                    
                    FETCH      s1,AGCvalue
                    STORE	  s1,AGCvalueRX
                    FETCH	  s1,AGCvalueTX		  ;recovers last used value for AGCvalur in this mode
                    STORE      s1,AGCvalue
;					FETCH      s1,AGCupperThresholdTX2
;					STORE		s1,AGCupperThresholdInUse	;Updates the threshold values in use
                    RETURN       

;Streammode:			CALL Transmitmode
;					FETCH     s1, State
 ;                   OR        s1, 4
  ;                  STORE     s1, State           ; set bit 2
;					RET
                    	
;GetUartValues:		CALL      Get2Chars			  ;Changed name of this routine
;					LOAD	  s1,$AA			  ;rough value
;					LOAD	  s2,s5				  ;now put into top byte
;					SRX		  s2
;					SRA		  s1				  ;divide signal by 2
;					SRX		  s2
;					SRA		  s1				  ;divide signal by 2 again
;					LOAD 	  s0,$AA				  ;set lowest bits to rough value
;				    RET
					


GrabTXAGCvalue:     FETCH     s1,AGCvalue
                    STORE	  s1,AGCvalueTX
					RETURN


Receivemode:        FETCH     s1, State
                    AND       s1, 253'd 			; 255 - 2
                    STORE     s1, State           ; reset bit 1
                    FETCH     s1,AGCvalue
                    STORE	  s1,AGCvalueTX
                    FETCH	  s1,AGCvalueRX		  ;recovers last used value for AGCvalur in this mode
                    STORE     s1,AGCvalue
;					FETCH      s1,AGCupperThresholdRX2
;					STORE		s1,AGCupperThresholdInUse	;Updates the threshold values in use
                    RETURN

BlockDSPpico:       LOAD      s1, 240'd
                    OUTPUT    s1, SSBAmp          ; Set signal amp to high
                    LOAD 	  s1,00
					OUTPUT	  s1,PhaseIncrement				;Make sure phase doesn't wander
                    INPUT     s0, Command         ; Check if FIFO character present
                    COMPARE   s0, 128'd           ; is there a character?
                    JUMP      NC, BlockDSPpico	  ; no command received so carry on blocking
					CALL      GetFifoChar		  ;is command so get charcter
                    
                    
                    COMPARE   s0, 82'd            ; character R
                    RETURN    Z	  				  ;escape when R received from User Pico

					JUMP	 BlockDSPpico




; Get fifo command and act on it.
Respond2Fifo:
;			 	   	FETCH  	  s0,State
;					AND		  s0,04
;					COMP	  s0,04	 	 		  ;is this stream mode
;					RETURN Z					  ;if so then stick (no backing out!)

			 	    CALL      GetFifoChar
;					COMPARE	  s0,51'd		 		  ;character 3
;					CALL	  Z,Streammode
					COMPARE   s0, 50'd              ; character 2
                    CALL      Z, GrabTXAGCvalue	  ;need to get this before userpico sends warble

                    COMPARE   s0, 49'd              ; character 1
                    CALL      Z, Transmitmode
                    COMPARE   s0, 48'd              ; character 0
                    CALL      Z, Receivemode
                    COMPARE   s0, 71'd              ; character G (request for AGCvalue info from userpico)
                    CALL      Z, SendGParamBack
                    COMPARE   s0, 83'd              ; character S (request for AVEsignal info from userpico)
                    CALL      Z, SendSParamBack

                    COMPARE   s0, 66'd              ; character B (block)
                    CALL      Z, BlockDSPpico
                    
                    

                    RETURN       



;This can be adjusted for de-bugging AGCvalue
SendGParamBack:     FETCH     s5, AGCvalue
                    CALL      Export2User
                    RETURN       

;This can be adjusted for de-bugging AVEsignal
SendSParamBack:     LOAD     s5, AveSignal1024ms
                    CALL      Export2User
                    RETURN

; Routine to recover a character from the FIFO in s0
GetFifoChar:        LOAD      s0, AckFIFO
                    OUTPUT    s0, Controlbits
                    LOAD      s0, AckFIFO         ; Wait

                    INPUT     s0, Command         ; now get my character
                    AND       s0, 7F             ; mask off top bit
                    RETURN       


; routine to look at command input and recover 2 characters and return the byte they represent in s5.
Get2Chars:          INPUT     s6, Command
                    COMPARE   s6, 128'd           ; if greater than 128, then no character
                    JUMP      NC, Get2Chars
                    CALL      GetFifoChar
                    LOAD      s6, s0


Get2ndChar:         INPUT     s7, Command
                    COMPARE   s7, 128'd           ; if greater than 128, then no character
                    JUMP      NC, Get2ndChar
                    CALL      GetFifoChar
                    LOAD      s7, s0

                    JUMP      Chars2Byte




; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
Chars2Byte:         LOAD      s8, s6
                    CALL      Get4bits
                    LOAD      s5, s8
                    SL0       s5
                    SL0       s5
                    SL0       s5
                    SL0       s5                  ; put these 4 bits to MSBs
                    LOAD      s8, s7
                    CALL      Get4bits
                    ADD       s5, s8
                    RETURN       

; This routine takes an ascii code in s8 and returns a 4 bit value in s8
Get4bits:           COMPARE   s8, 60'd           ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
                    JUMP      C, char0_9
                    SUB       s8, 55'd            ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
                    AND       s8, 0F             ; make sure only return 4 bits
                    RETURN       

char0_9:            SUB       s8, 48'd
                    AND       s8, 0F             ; make sure only return 4 bits
                    RETURN      


; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
Byte2Chars:         LOAD      s8, s5              ; assumes 8 bit data is in s5

                    SR0       s5
                    SR0       s5
                    SR0       s5
                    SR0       s5                  ; get first hex character
                    CALL      GetChar
                    LOAD      s6, s5              ; first ascii char
                    LOAD      s5, s8
                    AND       s5, 0F
                    CALL      GetChar             ; send to LCD or UART
                    LOAD      s7, s5              ; second ascii char
                    RETURN       

; routine to convert 4bit value in s5 to an ascii code, returned in s5
GetChar:            SUB       s5, 10'd            ; Test if s5 greater than 9
                    JUMP      C, is_0_9           ; Hex character is 0_9
                    ADD       s5, 65'd            ; offset for Ascii code 'A'
                    RETURN       
is_0_9:             ADD       s5, 10'd            ; return to range 0-9
                    ADD       s5, 48'd            ; offset to Ascii code for '0'
                    RETURN       






; Registers used s0, s1, s2, s3, s4 and s5.
; 
delay_1s:           LOAD      s5, 00               ; clear cycle counter
                    LOAD      s4, 00
wait_1s:            CALL      delay_1ms
                    ADD       s4, 01               ; increment cycle counter
                    ADDCY     s5, 00
                    COMPARE   s4, count_1000_lsb  ; test for 1000ms
                    JUMP      NZ, wait_1s
                    COMPARE   s5, count_1000_msb
                    JUMP      NZ, wait_1s
                    RETURN       
; 
; Delays of approximately 200ms and 300ms used for LCD display scrolling
; 
; 
; Registers used s0, s1, s2, s3 and s4.
; 
delay_300ms:        CALL      delay_100ms
delay_200ms:        CALL      delay_100ms
                    CALL      delay_100ms
                    RETURN       
; 
; Delay of approximately 100ms used for switch debounce
; 
; Registers used s0, s1, s2, s3 and s4.
; 
delay_100ms:        LOAD      s4, 64             ; repeat 1ms delay 100 times
wait_100ms:         CALL      delay_1ms
                    SUB       s4, 01
                    JUMP      NZ, wait_100ms
                    RETURN       
; 
; Delay of approximately 1ms required by LCD display
; 
; Registers used s0, s1, s2 and s3.
; 
delay_1ms:          LOAD      s3, 00               ; clear cycle counter
                    LOAD      s2, 00
wait_1ms:           CALL      delay_1us
                    ADD       s2, 01               ; increment cycle counter
                    ADDCY     s3, 00
                    COMPARE   s2, count_1000_lsb  ; test for 1000us
                    JUMP      NZ, wait_1ms
                    COMPARE   s3, count_1000_msb
                    JUMP      NZ, wait_1ms
                    RETURN       
; 
; Delay of approximately 50us required by LCD display
; 
; Registers used s0 and s1.
; 
delay_50us:         LOAD      s1, 50'd            ; repeat 1us delay 50 times
wait_50us:          CALL      delay_1us
                    SUB       s1, 01
                    JUMP      NZ, wait_50us
                    RETURN       

; Delay of approximately 1us used to provide timing reference for
; LCD operations. This must be adjusted to reflect the clock
; applied to KCPSM3. The provided code is for a 50MHz clock rate.
; 
; The software delay loop is formed using register s0. This register
; must be loaded with an integer value close to the result of....
; 
; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
; 
; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
; For clock rates below 8MHz the value of 1 must be used and the I2C bus
; operation will become lower than the 100KHz target intended.
; 
; Register used s0.
; 

delay_1us:          LOAD      s0, delay_1us_constant; delay value of 12 decimal for a 50MHz clock
wait_1us:           SUB       s0, 01
                    JUMP      NZ, wait_1us
                    RETURN       
; 
; 


