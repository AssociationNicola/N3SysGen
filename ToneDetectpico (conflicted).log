KCPSM6 Assembler log file for program 'Z:\home\gnaylor\Dropbox\N3SysGen\ToneDetectpico.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 14 May 2017
Assembly timestamp: 15:31:07

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 1FD hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 510
Memory locations available: 3586


Assembly listing

 Addr Code                           Instruction

 000                                 ;GV0B Tone detect working - getting AGC adjust to work thrugh DSP
 000                                 ;GV?? first tone detect
 000                                 CONSTANT delay_1us_constant, 06                        ; Value (13)19 or 12? decimal suitable for 50MHz clock – about 6 for 33MHz?
 000                                 CONSTANT m, 8'd                                        ; No. of iterations for cordic
 000                                 CONSTANT m_plus_1, 9'd                                 ; No. of iterations for cordic
 000                                 CONSTANT count_1000_lsb, E8                            ; lower 8-bits of 1000 count value
 000                                 CONSTANT count_1000_msb, 03                            ; upper 8-bits of 1000 count value
 000                                 CONSTANT half_pi_LSB, 00                               ;
 000                                 CONSTANT half_pi_MSB, 40                               ; 360 degrees = $10000
 000                                 CONSTANT phase_threshold, 30'd                         ;test for phase fairly constant
 000                                 CONSTANT count_value_to_trig, 9'd                      ;if low phase 12 succesive times, then this is significant! - try to increase sensitivity (was 10 - worth trying 6!)
 000                                 ;not sure about these (Aug2016)
 000                                 CONSTANT audioTest, 2'd                                ; Frequency 2=800Hz, 3=1200Hz, 4=1.6kHz 7=2.8kHz
 000                                 ;Frequency values for start and stop tones (decrease all by 1 29/1/17)
 000                                 CONSTANT StrtToneAInc, 9E
 000                                 CONSTANT StrtToneBInc, 68
 000                                 CONSTANT StopToneAInc, 59
 000                                 CONSTANT StopToneBInc, 77
 000                                 ; Registers
 000                                 NAMEREG sF, SampleCounter                              ;
 000                                 NAMEREG sE, TempScratchPointer
 000                                 NAMEREG sD, Mode                                       ;stores the operating mode: 0=idle, 1=Starting, 2=Receiving, 3=stopping, 4=TX
 000                                 NAMEREG sC, SampleTimer                                ;This counter does not stop!
 000                                 ; registers sA-sB are used for longish term storage...!
 000                                 ; sA used for cordic calcs
 000                                 ; Scratch pad
 000                                 ; registers 0-8 used for cordic table:
 000                                 ; reg 0=45degrees
 000                                 ; ..
 000                                 ; reg 7=0.44761degrees
 000                                 ; Input port
 000                                 CONSTANT AudioMSB, 0'd                                 ;Not used?
 000                                 CONSTANT AudioLSB, 1'd
 000                                 CONSTANT Strobe, 2'd                                   ;     bit0=8kHz square wave - Bit 1 is TX_High
 000                                 CONSTANT DemodMSB, 3'd                                 ; Top significant byte of multiplier output
 000                                 CONSTANT DemodLSB, 4'd                                 ; (only 16 bits retained)
 000                                 CONSTANT TBD0, 5'd                                     ;
 000                                 CONSTANT TBD1, 6'd                                     ;
 000                                 CONSTANT TBD2, 7'd                                     ;TBdefined
 000                                 ; Output ports
 000                                 CONSTANT CmdToUser, 0'd
 000                                 CONSTANT LOMSB, 1'd
 000                                 CONSTANT BRAMaddrMSB, 2'd                              ;Not currently used (Feb '17)
 000                                 CONSTANT BRAMaddrLSB, 3'd
 000                                 ;also used:8,9,13,14,18,19,23,24 -  8 STRTA,13  STRTB ,18 STPA or 23  STPB, and 9 STRTA,14  STRTB ,19 STPA or 24  STPB
 000                                 ; 6,11,16,21 used for running Itone values and 7,12,17,22 for Qtone values
 000                                 CONSTANT StartAmpOut, 25'd                             ;goes to DSP pico to calibrate AGC
 000                                 CONSTANT State, 26'd                                   ;Bit 0 enables speaker, Bit 1 is green light
 000                                 ; Scratchpad registers
 000                                 ; 0-8 used for Cordic Table!
 000                                 ;Now various pointers to create start and stop tones
 000                                 CONSTANT AVEtoneAmp, 9'd                               ;Is this needed?
 000                                 CONSTANT STRTAinc, 10'd                                ;This is the base address loaded into s0 before calling 'TreatTone'
 000                                 CONSTANT STRTAptrMSB, 11'd                             ;16 bit value used to generate the LUT ptr - won't use these names, just documented for reference
 000                                 CONSTANT STRTAptrLSB, 12'd                             ;fine resolution
 000                                 CONSTANT STRTAAccuDemodIMSB, 13'd                      ;This is the 16 bit value returned from the mulitplier
 000                                 CONSTANT STRTAAccuDemodILSB, 14'd                      ;Will this byte be used?
 000                                 CONSTANT STRTAAccuDemodQMSB, 15'd                      ;This is th e 16 bit value of the demod component accumulated
 000                                 CONSTANT STRTAAccuDemodQLSB, 16'd
 000                                 CONSTANT STRTAcurrentPhase, 17'd                       ;8 bit value of the current phase determined by the cordic
 000                                 CONSTANT STRTApreviousPhase, 18'd                      ;8 bit value of the previous phase determined by the cordic
 000                                 CONSTANT STRTAcounter, 19'd                            ;counts number of cycles of constant phase..
 000                                 CONSTANT STRTBinc, 20'd
 000                                 ;etc
 000                                 CONSTANT STPAinc, 30'd
 000                                 CONSTANT STPBinc, 40'd
 000                                 ;then second space at +40 from above numbers for another 4 tones
 000                                 ;uses up to Scratch register 89'd
 000                                 CONSTANT SampleCounterMSB, 90'd                        ;So as to have a 16 bit sample counter
 000                                 CONSTANT StartAmpA, 91'd                               ;Store the amplitude of the startA tone continuosly and output when whoopie.
 000  010FF              cold_start: LOAD s0, FF[255'd]                                     ; phase for 45 degrees- actually a bit less!
 001  2F000                          STORE s0, 00
 002  01097                          LOAD s0, 97[151'd]                                     ; phase for 26.565 degrees
 003  2F001                          STORE s0, 01
 004  01050                          LOAD s0, 50[80'd]                                      ; phase for 14.036 degrees
 005  2F002                          STORE s0, 02
 006  01029                          LOAD s0, 29[41'd]                                      ; phase for 7.125 degrees
 007  2F003                          STORE s0, 03
 008  01014                          LOAD s0, 14[20'd]                                      ; phase for 3.576 degrees
 009  2F004                          STORE s0, 04
 00A  0100A                          LOAD s0, 0A[10'd]                                      ; phase for 1.79 degrees
 00B  2F005                          STORE s0, 05
 00C  01005                          LOAD s0, 05[5'd]                                       ; phase for 0.895 degrees
 00D  2F006                          STORE s0, 06
 00E  01003                          LOAD s0, 03[3'd]                                       ; phase for 0.448 degrees
 00F  2F007                          STORE s0, 07
 010  01001                          LOAD s0, 01[1'd]                                       ; phase for 0.224 degrees
 011  2F008                          STORE s0, 08
 012  0109E                          LOAD s0, 9E[StrtToneAInc]                              ; Tone increments to detect
 013  2F00A                          STORE s0, 0A[STRTAinc]
 014  01068                          LOAD s0, 68[StrtToneBInc]                              ; Tone increments to detect
 015  2F014                          STORE s0, 14[STRTBinc]
 016  01059                          LOAD s0, 59[StopToneAInc]                              ; Tone increments to detect
 017  2F01E                          STORE s0, 1E[STPAinc]
 018  01077                          LOAD s0, 77[StopToneBInc]                              ; Tone increments to detect
 019  2F028                          STORE s0, 28[STPBinc]
 01A  20118                          CALL 118[SpeakerOn]                                    ;Start with speaker ON !!!!!!!!!!!!!!!!!!!!!!
 01B                                 ; Routine to look at lowest bit of Strobe to detect rising edge.
 01B  09002           AwaitAudioVal: INPUT s0, 02[Strobe]
 01C  03001                          AND s0, 01                                             ; look only at lowest bit
 01D  1D001                          COMPARE s0, 01
 01E  3201B                          JUMP Z, 01B[AwaitAudioVal]                             ; if 1 wait...
 01F  09002               AwaitRise: INPUT s0, 02[Strobe]
 020  03001                          AND s0, 01                                             ; look only at lowest bit
 021  1D000                          COMPARE s0, 00
 022  3201F                          JUMP Z, 01F[AwaitRise]                                 ; if 0 still, wait a bit more...
 023                                 ;Demod signal is not stable till ~6 clock cycles after rising edge, so should maybe use falling edge??
 023                                 ;so will be stable after ~3 instructions!
 023  09002                          INPUT s0, 02[Strobe]                                   ;To check if in TX mode
 024  03002                          AND s0, 02                                             ;look at bit 1
 025  1D000                          COMPARE s0, 00
 026  32029                          JUMP Z, 029[isReceiving]                               ;TX_High not set
 027  01D04                          LOAD sD[Mode], 04                                      ;keep in TX mode
 028  3201F                          JUMP Z, 01F[AwaitRise]                                 ; keep looping
 029                    isReceiving: 
 029  11C01                          ADD sC[SampleTimer], 01                                ;Always increment timer in receive mode
 02A  1DD04                          COMPARE sD[Mode], 04
 02B  3602D                          JUMP NZ, 02D[StartDemod]                               ;has not just come out of TX
 02C  01D00                          LOAD sD[Mode], 00                                      ;has just come out of TX, so reset mode to idle
 02D                                 ;start treating StrtToneA
 02D  0100A              StartDemod: LOAD s0, 0A[STRTAinc]                                  ;Note s0 is being used to point to the location of the values in scratch memory!
 02E  01100                          LOAD s1, 00[00'd]                                      ;(counter value when mature)
 02F  2003A                          CALL 03A[DemodulateTone]                               ;and checks if the accumulation has matured (from s1) and if so do cordic
 030                                 ;start treating StrtToneB
 030  01014                          LOAD s0, 14[STRTBinc]
 031  01110                          LOAD s1, 10[16'd]                                      ;(counter value when mature)
 032  2003A                          CALL 03A[DemodulateTone]
 033                                 ;start treating StpToneA
 033  0101E                          LOAD s0, 1E[STPAinc]
 034  01120                          LOAD s1, 20[32'd]                                      ;(counter value when mature)
 035  2003A                          CALL 03A[DemodulateTone]
 036                                 ;start treating StpToneB
 036  01028                          LOAD s0, 28[STPBinc]
 037  01130                          LOAD s1, 30[48'd]                                      ;(counter value when mature)
 038  2003A                          CALL 03A[DemodulateTone]
 039                                 ;add more tones to demodulate here for digital modes.
 039  2201B                          JUMP 01B[AwaitAudioVal]
 03A                                 ; -------------This is end of main loop--------------------------------
 03A                                 ;Accumulate and demodulate routine
 03A                                 ;Enter with mature index in s1 (0-63 to stagger output to the UART) and the scratch base address to treat in s0 - this is the scratch
 03A                                 ;address for the toneinc
 03A  0A200          DemodulateTone: FETCH s2, (s0)                                         ;Tone increment (pointed to in scratch by s0, to increment through sine wave LUT)
 03B  01300                          LOAD s3, 00
 03C                                 ;Need to right shift into s3 to scale correctly (as they are 4 times too big)
 03C  1420E                          SR0 s2                                                 ;The increment is a positive value (0-255 when x4) so should be kept positive!
 03D  14308                          SRA s3                                                 ;and carry containing lowest bit
 03E  1420E                          SR0 s2
 03F  14308                          SRA s3                                                 ;and carry containing lowest bit (doing this twice limits highest frequency to about 2kHz)
 040  11001                          ADD s0, 01
 041  0A400                          FETCH s4, (s0)                                         ;MSB of LUTptr
 042  11001                          ADD s0, 01
 043  0A500                          FETCH s5, (s0)                                         ;LSB of LUTptr
 044  10530                          ADD s5, s3                                             ;increment LUTptr
 045  12420                          ADDCY s4, s2                                           ;increment LUTptr
 046  2E500                          STORE s5, (s0)                                         ;update LSB LUTptr
 047  19001                          SUB s0, 01                                             ;decrement scratch pointer s0
 048  2E400                          STORE s4, (s0)                                         ;update MSB LUTptr
 049                                 ;           OUTPUT s5,LOLSB ;Send next sinewave address to LUT
 049  2D401                          OUTPUT s4, 01[LOMSB]                                   ;Actually only need to output MSB  - use write of MSB to delay trigger latch of multiplier
 04A  20145                          CALL 145[waitabit]
 04B                                 ;NEED To wait for multiplication otherwise cordic will be out of step
 04B  09203                          INPUT s2, 03[DemodMSB]                                 ;input previous LO tone multiplied by the signal (for accumulation)
 04C  09304                          INPUT s3, 04[DemodLSB]
 04D                                 ;This value may be too big as it stands to accumulate so need to scale down so as not to overflow
 04D                                 ;   SRX s2
 04D                                 ;   SRA s3
 04D                                 ;   SRX s2
 04D                                 ;   SRA s3
 04D                                 ;   SRX s2
 04D                                 ;   SRA s3
 04D  11002                          ADD s0, 02                                             ;move back up to scratch pointer location for MSB of I accumulating signal (of previous tone!)
 04E  0A600                          FETCH s6, (s0)                                         ;MSB of Accumulated I demod value
 04F                                 ;added this bit to get debug info again !!!!!!!!!!!!!!!!!!!!!!
 04F  19001                          SUB s0, 01                                             ;to get an even value!
 050  14008                          SRA s0                                                 ;divide by 2 to get 6,11,16 or 21
 051  2C600                          OUTPUT s6, (s0)                                        ;Export intermediate I value accumulated
 052  14000                          SLA s0                                                 ;now get s0 back on track
 053  11001                          ADD s0, 01                                             ;add one to get back and another to advance to I LSB accu
 054                                 ;Would be ADD s0,01 instead of the above debug
 054  11001                          ADD s0, 01                                             ;add one to get back and another to advance to I LSB accu
 055  0A700                          FETCH s7, (s0)                                         ;LSB of Accumulated I demod value (base + 4)
 056  10730                          ADD s7, s3                                             ;signed accumulate into Accumulated value
 057  12620                          ADDCY s6, s2                                           ;accumulate into Accumulated value
 058  200C0                          CALL 0C0[CheckNotTooBigI]                              ;Check s6(MSB),s7 not to big (ie bigger than 40)
 059  2E700                          STORE s7, (s0)                                         ;update LSB Accumulated value
 05A  19001                          SUB s0, 01                                             ;decrement scratch pointer s0
 05B  2E600                          STORE s6, (s0)                                         ;update MSB Accumulated value
 05C  00E00                          LOAD sE[TempScratchPointer], s0                        ;temporarily store pointer to MSB of accumulated I value
 05D                                 ;s4 and s5 still have LUTptr to add pi/2
 05D  11440                          ADD s4, 40[64'd]
 05E                                 ;    OUTPUT s5,LOLSB ;Send next sinewave address to LUT -  already done!
 05E  2D401                          OUTPUT s4, 01[LOMSB]                                   ;Actually only need to output MSB  - use write of MSB to delay trigger latch of multiplier
 05F  20145                          CALL 145[waitabit]
 060                                 ;NEED To wait for multiplication otherwise cordic will be out of step
 060  09203                          INPUT s2, 03[DemodMSB]                                 ;input previous LO tone multiplied by the signal (for accumulation)
 061  09304                          INPUT s3, 04[DemodLSB]
 062                                 ;This value may be too big as it stands to accumulate so need to scale down so as not to overflow?
 062                                 ;   SRX s2
 062                                 ;   SRA s3
 062                                 ;   SRX s2
 062                                 ;   SRA s3
 062                                 ;   SRX s2
 062                                 ;   SRA s3
 062  11002                          ADD s0, 02                                             ;move back up to scratch pointer location for Q MSB of accumulating signal (of previous tone!)
 063  0A600                          FETCH s6, (s0)                                         ;MSB of Accumulated Q demod value
 064                                 ;added this bit to get debug info renable !!!!!!!!!!!!!!!!!!!!!!!!!!
 064  19001                          SUB s0, 01                                             ;to get an even value!
 065  14008                          SRA s0                                                 ;divide by 2 to get 7,12,17 or 22
 066  2C600                          OUTPUT s6, (s0)                                        ;Export MSB of  Q value accumulated
 067  14000                          SLA s0                                                 ;now get s0 back on track
 068  11001                          ADD s0, 01                                             ;add one to get back and another to advance to I LSB accu
 069                                 ;Would be ADD s0,01 instead of the above debug
 069  11001                          ADD s0, 01                                             ;add one to get back and another to advance to I LSB accu
 06A  0A700                          FETCH s7, (s0)                                         ;LSB of Accumulated Q demod value (base + 6)
 06B  10730                          ADD s7, s3                                             ;signed accumulate into Accumulated value
 06C  12620                          ADDCY s6, s2                                           ;accumulate into Accumulated value
 06D  200D3                          CALL 0D3[CheckNotTooBigQ]                              ;Check s6(MSB),s7 not to0 big (ie bigger than 48)
 06E  2E700                          STORE s7, (s0)                                         ;update LSB Accumulated value
 06F  19001                          SUB s0, 01                                             ;decrement scratch pointer s0 (s0 now at base + 5)
 070  2E600                          STORE s6, (s0)                                         ;update MSB Accumulated value
 071  20073                          CALL 073[CheckMatureAndOutput]
 072  25000                          RETURN 
 073                                 ;Checks s1 is mature
 073  003C0    CheckMatureAndOutput: LOAD s3, sC[SampleTimer]                               ;Use the always incremented timer!
 074  0333F                          AND s3, 3F                                             ;mod 64
 075  1C310                          COMPARE s3, s1
 076  30078                          CALL Z, 078[Matured]                                   ;OK to do cordic and output - this will happen every 2ms (or every 1ms with 8 tones being decoded)
 077  25000                          RETURN 
 078                                 ;Cordic takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
 078                                 ; Useable range is for I and Q up to about +/-$3000
 078                                 ;normally get I and Q values from scratch. Scratch pointer
 078                                 ;need to use TempScratchPointer as s0 value which had pointed to the scratch area has been lost
 078  0A1E0                 Matured: FETCH s1, (sE[TempScratchPointer])                     ;pointer at MSB of I accumulated
 079  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to LSB of I accumulated
 07A  0A0E0                          FETCH s0, (sE[TempScratchPointer])
 07B  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to MSB of Q accumulated
 07C  0A3E0                          FETCH s3, (sE[TempScratchPointer])
 07D  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to LSB of Q accumulated
 07E  0A2E0                          FETCH s2, (sE[TempScratchPointer])                     ;TempScratchPointer has now increased by 3
 07F  20149                          CALL 149[cordic]
 080                                 ;now have amplitude and phase in s0/s1(MSB AMP)...s4,s5(MSB Phase) - need to calculate phase change and output the MSBs
 080                                 ;Use MSB amp in s1 - only interested in SartAmpA value - put in fixed scratch location if TempScratchPointer is +6,for this tone, ie is STRTAAccuDemodQLSB
 080  1DE10                          COMPARE sE[TempScratchPointer], 10[STRTAAccuDemodQLSB] ; are we treating StartToneA
 081  36083                          JUMP NZ, 083[CarryOn]                                  ;if not do not store in scratch
 082  2F15B                          STORE s1, 5B[StartAmpA]                                ;Save the current amplitude of the A tone
 083                                 ;have phase in s5
 083  11E02                 CarryOn: ADD sE[TempScratchPointer], 02
 084  0A4E0                          FETCH s4, (sE[TempScratchPointer])                     ;get last phase (inc+8)
 085  2E5E0                          STORE s5, (sE[TempScratchPointer])                     ;update current phase
 086  19E01                          SUB sE[TempScratchPointer], 01
 087  2E4E0                          STORE s4, (sE[TempScratchPointer])                     ;update previous phase (inc+7)
 088  19E01                          SUB sE[TempScratchPointer], 01
 089                                 ;Send to ARM
 089  20140                          CALL 140[StreamPhase]                                  ; This does not affect s5! - but does kill s0
 08A  00510                          LOAD s5, s1
 08B  2013C                          CALL 13C[StreamAmp]
 08C                                 ;Need to reset accumulators to zero! (Tempscratch (originally inc+3) is now inc+6 but need to reseet addresses of original! TempScratchPointer, TempScratchPointer+1,+2 +3)
 08C                                 ;This is executed every 2ms if 4 tones are treated as executed 4 times per cycle - if more tones added, this will run more frequently and so counter timeouts will need adjusting!
 08C  000E0                          LOAD s0, sE[TempScratchPointer]
 08D  01100                          LOAD s1, 00
 08E  2E100                          STORE s1, (s0)
 08F  19001                          SUB s0, 01
 090  2E100                          STORE s1, (s0)
 091  19001                          SUB s0, 01
 092  2E100                          STORE s1, (s0)
 093  19001                          SUB s0, 01
 094  2E100                          STORE s1, (s0)
 095  20102                          CALL 102[CheckforTimeOuts]
 096  1DD00                          COMPARE sD[Mode], 00
 097  340BA                          CALL NZ, 0BA[IncrementCounter]                         ;Unless Idle!
 098                                 ;This last part to be corrected to check magnitude of phase shift
 098                                 ;OK ready to do now using software multiply
 098  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to previous phase (inc+7)
 099  0A2E0                          FETCH s2, (sE[TempScratchPointer])                     ;s2 now has msb of previous phase
 09A  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to current phase (inc+8)
 09B  0A3E0                          FETCH s3, (sE[TempScratchPointer])                     ;s3 now has msb of current phase
 09C  18230                          SUB s2, s3                                             ;delta phase (signed)
 09D  20196                          CALL 196[absval]                                       ;gets absolute value of s2 (abs phase shift)
 09E  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to counter (inc+9)
 09F  0A1E0                          FETCH s1, (sE[TempScratchPointer])                     ;s1 has the counter
 0A0  000E0                          LOAD s0, sE[TempScratchPointer]
 0A1  19005                          SUB s0, 05                                             ;to get inc+4
 0A2  14008                          SRA s0                                                 ;divide by 2 to get 7,12,17 or 22
 0A3                                 ;
 0A3                                 ;Debug output Counter value and Phase difference
 0A3                                 ;   OUTPUT s1,(s0) ;Export Counter value come out on 'IQ stoptones', when value '5' is selected
 0A3                                 ;   SUB s0,01 ;to get 6,11,16,21 to align with 'IQStarttones' read by selecting '4' value
 0A3                                 ;   OUTPUT s2,(s0) ;Export phase difference value come out on 'IQ starttones', when value '4' is selected
 0A3  1D21E                          COMPARE s2, 1E[phase_threshold]                        ;is it less than threshold, then set carry
 0A4  3E0B5                          JUMP NC, 0B5[dropcounter]                              ; if failed then drop the counter and return
 0A5  11101                          ADD s1, 01                                             ;otherwise is small phase shift so advance counter
 0A6  2E1E0                          STORE s1, (sE[TempScratchPointer])                     ;now save the counter
 0A7  1D109                          COMPARE s1, 09[count_value_to_trig]                    ;s1 has phase constant counter, carry not set if count is high enough.
 0A8  3C0AA                          CALL NC, 0AA[Whoopie]                                  ;seem to have a tone here!
 0A9  25000                          RETURN 
 0AA                                 ;Ultimately will use TempScratchPointer to work out which tone was detected
 0AA                                 ;need to reset counter to Zero!!
 0AA  01000                 Whoopie: LOAD s0, 00
 0AB  2E0E0                          STORE s0, (sE[TempScratchPointer])                     ;reset counter to zero
 0AC  1DE13                          COMPARE sE[TempScratchPointer], 13[19'd]               ;if start tone A counter
 0AD  300E6                          CALL Z, 0E6[isStrtToneA]
 0AE  1DE1D                          COMPARE sE[TempScratchPointer], 1D[29'd]               ;if start tone B counter
 0AF  300EE                          CALL Z, 0EE[isStrtToneB]
 0B0  1DE27                          COMPARE sE[TempScratchPointer], 27[39'd]               ;if start tone A counter
 0B1  300F5                          CALL Z, 0F5[isStopToneA]
 0B2  1DE31                          COMPARE sE[TempScratchPointer], 31[49'd]               ;if start tone A counter
 0B3  300FB                          CALL Z, 0FB[isStopToneB]
 0B4  25000                          RETURN 
 0B5  1D102             dropcounter: COMPARE s1, 02
 0B6  39000                          RETURN C                                               ;return if counter 1 or zero
 0B7  19102                          SUB s1, 02                                             ;drop counter by 2
 0B8  2E1E0                          STORE s1, (sE[TempScratchPointer])                     ;now set counter to new value
 0B9  25000                          RETURN 
 0BA                                 ;Update sample counter (increments every 2ms if treating all 4 tones simultaneously, would be 1ms if treating 8 tones)
 0BA                                 ;This only advances in modes 1,2 and 3
 0BA  0B05A        IncrementCounter: FETCH s0, 5A[SampleCounterMSB]
 0BB  11F01                          ADD sF[SampleCounter], 01                              ;increment counter
 0BC  13000                          ADDCY s0, 00
 0BD  2F05A                          STORE s0, 5A[SampleCounterMSB]                         ;increment MSB on rollover
 0BE                                 ;Check if any of the time outs are passed
 0BE  20102                          CALL 102[CheckforTimeOuts]
 0BF  25000                          RETURN 
 0C0                                 ;This is to drop the value of the accumulated I and Q values so that don't end up getting too big for the Cordic
 0C0  00260         CheckNotTooBigI: LOAD s2, s6
 0C1  00360                          LOAD s3, s6                                            ;also have to save s6 as absval kills s6
 0C2  20196                          CALL 196[absval]                                       ;return absval in s2
 0C3  00630                          LOAD s6, s3                                            ;put value back in s6
 0C4  1D230                          COMPARE s2, 30                                         ;is absolute value bigger than or equal 30 (then NC)
 0C5  39000                          RETURN C                                               ;if not return
 0C6  1460A                          SRX s6
 0C7  14708                          SRA s7                                                 ;half value in s6/s7
 0C8                                 ;now need to drop value in accummulated Q
 0C8  11002                          ADD s0, 02                                             ;increase scratch pointer to Q accumulation values
 0C9  0A300                          FETCH s3, (s0)                                         ;LSB of Q accumulated
 0CA  19001                          SUB s0, 01
 0CB  0A200                          FETCH s2, (s0)                                         ;MSB of Q accumulated
 0CC  1420A                          SRX s2
 0CD  14308                          SRA s3                                                 ;half Q accumulated value
 0CE  2E200                          STORE s2, (s0)
 0CF  11001                          ADD s0, 01
 0D0  2E300                          STORE s3, (s0)
 0D1  19002                          SUB s0, 02                                             ;Get s0 back to its original value
 0D2  25000                          RETURN 
 0D3  00260         CheckNotTooBigQ: LOAD s2, s6
 0D4  00360                          LOAD s3, s6                                            ;also have to save s6 as absval kills s6
 0D5  20196                          CALL 196[absval]                                       ;return absval in s2
 0D6  00630                          LOAD s6, s3                                            ;put value back in s6
 0D7  1D230                          COMPARE s2, 30                                         ;is absolute value bigger than or equal 30 (then NC)
 0D8  39000                          RETURN C                                               ;if not return
 0D9  1460A                          SRX s6
 0DA  14708                          SRA s7                                                 ;half value in s6/s7
 0DB                                 ;now need to drop value in accummulated Q
 0DB  19002                          SUB s0, 02                                             ;reduce scratch pointer to I accumulation values
 0DC  0A300                          FETCH s3, (s0)                                         ;LSB of I accumulated
 0DD  19001                          SUB s0, 01
 0DE  0A200                          FETCH s2, (s0)                                         ;MSB of I accumulated
 0DF  1420A                          SRX s2
 0E0  14308                          SRA s3                                                 ;half I accumulated value
 0E1  2E200                          STORE s2, (s0)
 0E2  11001                          ADD s0, 01
 0E3  2E300                          STORE s3, (s0)
 0E4  11002                          ADD s0, 02                                             ;Get s0 back to its original value
 0E5  25000                          RETURN 
 0E6                                 ;Treat different mode cases
 0E6                                 ;Mode 0 Idle
 0E6                                 ;Mode 1 Starting  (Start tone A detected)
 0E6                                 ;Mode 2 Recieving Voice
 0E6                                 ;Mode 3 Stopping
 0E6                                 ;Mode 4 TX
 0E6  1DD00             isStrtToneA: COMPARE sD[Mode], 00                                   ;Check if currently idle
 0E7  35000                          RETURN NZ                                              ;Don't do anything if not currently idle
 0E8  0B05B                          FETCH s0, 5B[StartAmpA]                                ;Get thepreviously stored amplitude
 0E9  2D019                          OUTPUT s0, 19[StartAmpOut]                             ;and output to be read by the DSP Pico
 0EA  01D01                          LOAD sD[Mode], 01                                      ;Move in to starting mode
 0EB  01F00                          LOAD sF[SampleCounter], 00
 0EC  2FF5A                          STORE sF[SampleCounter], 5A[SampleCounterMSB]          ;Reset counter and allow about 160ms to receive tone B
 0ED  25000                          RETURN 
 0EE  1DD01             isStrtToneB: COMPARE sD[Mode], 01                                   ;Check if in starting mode
 0EF  35000                          RETURN NZ                                              ;Don't do anything if not starting
 0F0  01D02                          LOAD sD[Mode], 02                                      ;go ahead in to receive
 0F1  20118                          CALL 118[SpeakerOn]                                    ;Turn on speaker
 0F2  01F00                          LOAD sF[SampleCounter], 00
 0F3  2FF5A                          STORE sF[SampleCounter], 5A[SampleCounterMSB]          ;Reset counter and allow about 160ms to receive tone B
 0F4  25000                          RETURN 
 0F5  1DD02             isStopToneA: COMPARE sD[Mode], 02                                   ;Check if in RX mode
 0F6  35000                          RETURN NZ                                              ;Don't do anything if not in RX
 0F7  01D03                          LOAD sD[Mode], 03                                      ;Move in to stopping mode
 0F8  01F00                          LOAD sF[SampleCounter], 00
 0F9  2FF5A                          STORE sF[SampleCounter], 5A[SampleCounterMSB]          ;Reset counter and allow about 512ms to receive tone B
 0FA  25000                          RETURN 
 0FB  1DD03             isStopToneB: COMPARE sD[Mode], 03                                   ;Check if in stopping mode
 0FC  35000                          RETURN NZ                                              ;Don't do anything if not stopping
 0FD  01D00                          LOAD sD[Mode], 00                                      ;go back to idle
 0FE  2011B                          CALL 11B[SpeakerOff]                                   ;Turn speaker off
 0FF  01F00                          LOAD sF[SampleCounter], 00
 100  2FF5A                          STORE sF[SampleCounter], 5A[SampleCounterMSB]          ;Reset counter (not really needed, but just for tidiness)
 101  25000                          RETURN 
 102                                 ;timeout values in units of 2ms - this will drop to 1ms if more tones added, so timeout values will need re-adjusting
 102  1DD01        CheckforTimeOuts: COMPARE sD[Mode], 01
 103  30109                          CALL Z, 109[checkStarttoneAtimeout]
 104  1DD02                          COMPARE sD[Mode], 02
 105  3010D                          CALL Z, 10D[checkRXtimeout]
 106  1DD03                          COMPARE sD[Mode], 03
 107  30113                          CALL Z, 113[checkStoptoneAtimeout]
 108  25000                          RETURN 
 109  1DF50  checkStarttoneAtimeout: COMPARE sF[SampleCounter], 50[80'd]                    ;This will need to be 160'd with 8 tones
 10A  39000                          RETURN C                                               ;Counter<80 (160ms) so OK
 10B  01D00                          LOAD sD[Mode], 00                                      ;Set mode back to idle - tone B was not received in time
 10C  25000                          RETURN 
 10D  0B05A          checkRXtimeout: FETCH s0, 5A[SampleCounterMSB]                         ;Get counter
 10E  1D03D                          COMPARE s0, 3D[61'd]                                   ;-about 30 secs - COmpare with 122'd if using 8 tones
 10F  39000                          RETURN C                                               ;Can carry on listening (not timed out)
 110  01D00                          LOAD sD[Mode], 00                                      ;Set mode back to idle - seems to have been transmitting too long
 111  2011B                          CALL 11B[SpeakerOff]                                   ;on stop speaker again
 112  25000                          RETURN 
 113  0B05A   checkStoptoneAtimeout: FETCH s0, 5A[SampleCounterMSB]                         ;Get counter
 114  1D001                          COMPARE s0, 01                                         ;-about 512ms - need to compare with 02 if using 8 tones
 115  39000                          RETURN C                                               ;Counter MSB still 0 so within 512ms of receiving StoptoneB
 116  01D02                          LOAD sD[Mode], 02                                      ;Set mode back to RX - tone B was not received in time so must have been a chance tone
 117  25000                          RETURN 
 118  01001               SpeakerOn: LOAD s0, 01
 119  2D01A                          OUTPUT s0, 1A[State]
 11A  25000                          RETURN 
 11B  01002              SpeakerOff: LOAD s0, 02                                            ;Turns Green LED off (bit 1)? and stops speaker (currently driven directly off not speaker enable)
 11C  2D01A                          OUTPUT s0, 1A[State]
 11D  01D00                          LOAD sD[Mode], 00                                      ;return to idle state
 11E  25000                          RETURN 
 11F                                 ;Does 16 bit signed accumulation of 8 bit signed value in s1 into s4/s5 which are recoverred from scratch pad pointed to by s2 (loading here the offset to the actual tone
 11F                                 ;dependent on how many times round the loop we are)
 11F  10260            DoAccumulate: ADD s2, s6
 120  0A420                          FETCH s4, (s2)                                         ;Now Get AveSToneLSB_Is in s4 etc...
 121  19201                          SUB s2, 01                                             ;step back to MSB
 122  0A520                          FETCH s5, (s2)                                         ;Get AveSToneMSB_Is in s5
 123  013FF                          LOAD s3, FF                                            ;Assume s1 is negative and use s3 for sign extension
 124  1D180                          COMPARE s1, 80[128'd]                                  ;if s1 is 128 or bigger, then it is negative (carry not set)
 125  3E127                          JUMP NC, 127[negaccum]
 126  01300                          LOAD s3, 00                                            ;sign extend with zeros
 127  10410                negaccum: ADD s4, s1                                             ;Accumulate into averageLsB
 128  12530                          ADDCY s5, s3                                           ;do carry to add into upper byte (keeping carry from previous add!!)
 129  00050                          LOAD s0, s5
 12A  1400A                          SRX s0
 12B  1400A                          SRX s0                                                 ;reduce value to subtract by factor 4 to increase integration time constant and gain.
 12C  13000                          ADDCY s0, 00                                           ;round up if necessary
 12D  18400                          SUB s4, s0
 12E  013FF                          LOAD s3, FF                                            ;Assume s5 is negative and use s3 for sign extension
 12F  1D580                          COMPARE s5, 80[128'd]                                  ;is this a negative number?
 130  3E132                          JUMP NC, 132[negdecrmnt]
 131  01300                          LOAD s3, 00                                            ;do this if s5 is positive (sign extension)
 132  18400              negdecrmnt: SUB s4, s0
 133  1A530                          SUBCY s5, s3                                           ;subtract 1/256
 134  2E520                          STORE s5, (s2)
 135  11201                          ADD s2, 01                                             ;move down to LSB again
 136  2E420                          STORE s4, (s2)                                         ;update scratchpad values
 137  25000                          RETURN 
 138                                 ; This TBD, should output 16 bit value, that goes through a sinewave LUT and multiplies by the signal and recover
 138  2D101          LUTandMultiply: OUTPUT s1, 01[LOMSB]
 139  09903                          INPUT s9, 03[DemodMSB]                                 ;actually gets previously latched multiply corresponding to previous tone!
 13A  09804                          INPUT s8, 04[DemodLSB]
 13B  25000                          RETURN 
 13C  000E0               StreamAmp: LOAD s0, sE[TempScratchPointer]                        ;possible values are 16,26,36 and 46
 13D  1400E                          SR0 s0                                                 ;Divide by 0 to get 8 STRTA,13  STRTB ,18 STPA or 23  STPB
 13E  2C500                          OUTPUT s5, (s0)                                        ;direct amplitude MSB to the appropriate port
 13F  25000                          RETURN 
 140  000E0             StreamPhase: LOAD s0, sE[TempScratchPointer]
 141  1400E                          SR0 s0
 142  11001                          ADD s0, 01                                             ;Offset to output phase values get 9 STRTA,14  STRTB ,19 STPA or 24  STPB
 143  2C500                          OUTPUT s5, (s0)                                        ;direct phase MSB to the appropriate port
 144  25000                          RETURN 
 145  00220                waitabit: LOAD s2, s2
 146  00220                          LOAD s2, s2
 147  00220                          LOAD s2, s2                                            ;is this long enough?
 148  25000                          RETURN 
 149                                 ; CORDIC  Takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
 149                                 ; Useable range is for I and Q up to about +/-$3000
 149  01400                  cordic: LOAD s4, 00
 14A  01500                          LOAD s5, 00
 14B  1D180                          COMPARE s1, 80[128'd]
 14C  3C180                          CALL NC, 180[rotate90]                                 ; if I negative then need to bring back into RH 2 quadrants.
 14D                                 ; now enter loop
 14D  01800                          LOAD s8, 00                                            ; counter of times to iterate.
 14E  00710              cordicloop: LOAD s7, s1                                            ; temporary store for I
 14F  00600                          LOAD s6, s0                                            ; temp store
 150  1D380                          COMPARE s3, 80[128'd]                                  ; is Q negative?
 151  3E160                          JUMP NC, 160[posrotate]                                ; if negative rotate positive
 152  00A20               negrotate: LOAD sA, s2
 153  00B30                          LOAD sB, s3                                            ; put Q into working registers
 154  20179                          CALL 179[shift]                                        ; shift Q by the amount in s8
 155  100A0                          ADD s0, sA                                             ; add shifted Q to I
 156  121B0                          ADDCY s1, sB
 157  00A60                          LOAD sA, s6                                            ; prepare working registers (sA,sB) with original value of I
 158  00B70                          LOAD sB, s7
 159  20179                          CALL 179[shift]
 15A  182A0                          SUB s2, sA
 15B  1A3B0                          SUBCY s3, sB
 15C  20171                          CALL 171[GetPhaseIncrement]
 15D  184A0                          SUB s4, sA
 15E  1A5B0                          SUBCY s5, sB
 15F  2216D                          JUMP 16D[testcordicend]
 160  00A20               posrotate: LOAD sA, s2
 161  00B30                          LOAD sB, s3                                            ; put Q into working registers
 162  20179                          CALL 179[shift]                                        ; shift Q by the amount in s8
 163  180A0                          SUB s0, sA                                             ; add shifted Q to I
 164  1A1B0                          SUBCY s1, sB
 165  00A60                          LOAD sA, s6                                            ; prepare working registers with original value of I
 166  00B70                          LOAD sB, s7
 167  20179                          CALL 179[shift]
 168  102A0                          ADD s2, sA
 169  123B0                          ADDCY s3, sB
 16A  20171                          CALL 171[GetPhaseIncrement]
 16B  104A0                          ADD s4, sA
 16C  125B0                          ADDCY s5, sB
 16D  11801           testcordicend: ADD s8, 01
 16E  1D809                          COMPARE s8, 09[m_plus_1]                               ;m + 1
 16F  3A14E                          JUMP C, 14E[cordicloop]
 170  25000                          RETURN 
 171                                 ; routine to lookup from the cordic look up table (scratchpad), the phase increment - stored as 8 bits at the location pointed to be s8, returned as 16 bits in sA and sB
 171                                 ; sB is MSB
 171  0AB80       GetPhaseIncrement: FETCH sB, (s8)
 172  14B0E                          SR0 sB
 173  14A08                          SRA sA
 174  14B0E                          SR0 sB
 175  14A08                          SRA sA
 176  14B0E                          SR0 sB
 177  14A08                          SRA sA                                                 ; This multiplies the 8 bit stored value by 32 so that max scratchpad value 255->255*32 equivalent to 44.82degrees
 178  25000                          RETURN 
 179  00980                   shift: LOAD s9, s8
 17A  1D900               shiftloop: COMPARE s9, 00
 17B  31000                          RETURN Z
 17C  19901                          SUB s9, 01
 17D  14B0A                          SRX sB
 17E  14A08                          SRA sA
 17F  2217A                          JUMP 17A[shiftloop]
 180  00710                rotate90: LOAD s7, s1                                            ; temporary store for I
 181  00600                          LOAD s6, s0                                            ; temp store
 182  1D380                          COMPARE s3, 80[128'd]                                  ; is Q negative?
 183  3E18D                          JUMP NC, 18D[add90]                                    ; if negative add 90
 184  00130                   sub90: LOAD s1, s3
 185  00020                          LOAD s0, s2                                            ; I=Q
 186  01200                          LOAD s2, 00
 187  01300                          LOAD s3, 00
 188  18260                          SUB s2, s6
 189  1A370                          SUBCY s3, s7                                           ; Q=-I
 18A  19400                          SUB s4, 00[half_pi_LSB]
 18B  1B540                          SUBCY s5, 40[half_pi_MSB]
 18C  25000                          RETURN 
 18D  01100                   add90: LOAD s1, 00
 18E  01000                          LOAD s0, 00
 18F  18020                          SUB s0, s2
 190  1A130                          SUBCY s1, s3                                           ; I=-Q
 191  00260                          LOAD s2, s6
 192  00370                          LOAD s3, s7                                            ; Q=I
 193  01400                          LOAD s4, 00[half_pi_LSB]
 194  01540                          LOAD s5, 40[half_pi_MSB]
 195  25000                          RETURN 
 196                                 ;takes s2 and returns in s2 the absolute value of s2 (uses s6)
 196  1D280                  absval: COMPARE s2, 80[128'd]
 197  3C199                          CALL NC, 199[makeposval]
 198  25000                          RETURN 
 199                                 ; Turn negative value in s2 into a positive one (well will actualy make a positive value negative as well).
 199  01600              makeposval: LOAD s6, 00
 19A  18620                          SUB s6, s2
 19B  00260                          LOAD s2, s6
 19C  25000                          RETURN 
 19D                                 ; Takes value in s5 and converts to 2 ascii codes which are sent to the user picoblaze.
 19D  201BB             Export2User: CALL 1BB[Byte2Chars]
 19E  2D600                          OUTPUT s6, 00[CmdToUser]
 19F  2D700                          OUTPUT s7, 00[CmdToUser]
 1A0  01614                          LOAD s6, 14[20'd]                                      ; terminate with space character
 1A1  2D600                          OUTPUT s6, 00[CmdToUser]
 1A2  25000                          RETURN 
 1A3  0160D                 AddCRLF: LOAD s6, 0D[13'd]                                      ; terminate with CR
 1A4  2D600                          OUTPUT s6, 00[CmdToUser]
 1A5  0160A                          LOAD s6, 0A[10'd]                                      ; and with LF
 1A6  2D600                          OUTPUT s6, 00[CmdToUser]
 1A7  25000                          RETURN 
 1A8                                 ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 1A8  00860              Chars2Byte: LOAD s8, s6
 1A9  201B3                          CALL 1B3[Get4bits]
 1AA  00580                          LOAD s5, s8
 1AB  14506                          SL0 s5
 1AC  14506                          SL0 s5
 1AD  14506                          SL0 s5
 1AE  14506                          SL0 s5                                                 ; put these 4 bits to MSBs
 1AF  00870                          LOAD s8, s7
 1B0  201B3                          CALL 1B3[Get4bits]
 1B1  10580                          ADD s5, s8
 1B2  25000                          RETURN 
 1B3                                 ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 1B3  1D83C                Get4bits: COMPARE s8, 3C[60'd]                                   ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 1B4  3A1B8                          JUMP C, 1B8[char0_9]
 1B5  19837                          SUB s8, 37[55'd]                                       ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 1B6  0380F                          AND s8, 0F                                             ; make sure only return 4 bits
 1B7  25000                          RETURN 
 1B8  19830                 char0_9: SUB s8, 30[48'd]
 1B9  0380F                          AND s8, 0F                                             ; make sure only return 4 bits
 1BA  25000                          RETURN 
 1BB                                 ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 1BB  00850              Byte2Chars: LOAD s8, s5                                            ; assumes 8 bit data is in s5
 1BC  1450E                          SR0 s5
 1BD  1450E                          SR0 s5
 1BE  1450E                          SR0 s5
 1BF  1450E                          SR0 s5                                                 ; get first hex character
 1C0  201C7                          CALL 1C7[GetChar]
 1C1  00650                          LOAD s6, s5                                            ; first ascii char
 1C2  00580                          LOAD s5, s8
 1C3  0350F                          AND s5, 0F
 1C4  201C7                          CALL 1C7[GetChar]                                      ; send to LCD or UART
 1C5  00750                          LOAD s7, s5                                            ; second ascii char
 1C6  25000                          RETURN 
 1C7                                 ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 1C7  1950A                 GetChar: SUB s5, 0A[10'd]                                       ; Test if s5 greater than 9
 1C8  3A1CB                          JUMP C, 1CB[is_0_9]                                    ; Hex character is 0_9
 1C9  11541                          ADD s5, 41[65'd]                                       ; offset for Ascii code 'A'
 1CA  25000                          RETURN 
 1CB  1150A                  is_0_9: ADD s5, 0A[10'd]                                       ; return to range 0-9
 1CC  11530                          ADD s5, 30[48'd]                                       ; offset to Ascii code for '0'
 1CD  25000                          RETURN 
 1CE                                 ; Registers used s0, s1, s2, s3, s4 and s5.
 1CE                                 ;
 1CE  01500                delay_1s: LOAD s5, 00                                            ; clear cycle counter
 1CF  01400                          LOAD s4, 00
 1D0  201E1                 wait_1s: CALL 1E1[delay_1ms]
 1D1  11401                          ADD s4, 01                                             ; increment cycle counter
 1D2  13500                          ADDCY s5, 00
 1D3  1D4E8                          COMPARE s4, E8[count_1000_lsb]                         ; test for 1000ms
 1D4  361D0                          JUMP NZ, 1D0[wait_1s]
 1D5  1D503                          COMPARE s5, 03[count_1000_msb]
 1D6  361D0                          JUMP NZ, 1D0[wait_1s]
 1D7  25000                          RETURN 
 1D8                                 ;
 1D8                                 ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 1D8                                 ;
 1D8                                 ;
 1D8                                 ; Registers used s0, s1, s2, s3 and s4.
 1D8                                 ;
 1D8  201DC             delay_300ms: CALL 1DC[delay_100ms]
 1D9  201DC             delay_200ms: CALL 1DC[delay_100ms]
 1DA  201DC                          CALL 1DC[delay_100ms]
 1DB  25000                          RETURN 
 1DC                                 ;
 1DC                                 ; Delay of approximately 100ms used for switch debounce
 1DC                                 ;
 1DC                                 ; Registers used s0, s1, s2, s3 and s4.
 1DC                                 ;
 1DC  01464             delay_100ms: LOAD s4, 64                                            ; repeat 1ms delay 100 times
 1DD  201E1              wait_100ms: CALL 1E1[delay_1ms]
 1DE  19401                          SUB s4, 01
 1DF  361DD                          JUMP NZ, 1DD[wait_100ms]
 1E0  25000                          RETURN 
 1E1                                 ;
 1E1                                 ; Delay of approximately 1ms required by LCD display
 1E1                                 ;
 1E1                                 ; Registers used s0, s1, s2 and s3.
 1E1                                 ;
 1E1  01300               delay_1ms: LOAD s3, 00                                            ; clear cycle counter
 1E2  01200                          LOAD s2, 00
 1E3  201F0                wait_1ms: CALL 1F0[delay_1us]
 1E4  11201                          ADD s2, 01                                             ; increment cycle counter
 1E5  13300                          ADDCY s3, 00
 1E6  1D2E8                          COMPARE s2, E8[count_1000_lsb]                         ; test for 1000us
 1E7  361E3                          JUMP NZ, 1E3[wait_1ms]
 1E8  1D303                          COMPARE s3, 03[count_1000_msb]
 1E9  361E3                          JUMP NZ, 1E3[wait_1ms]
 1EA  25000                          RETURN 
 1EB                                 ;
 1EB                                 ; Delay of approximately 50us required by LCD display
 1EB                                 ;
 1EB                                 ; Registers used s0 and s1.
 1EB                                 ;
 1EB  01132              delay_50us: LOAD s1, 32[50'd]                                      ; repeat 1us delay 50 times
 1EC  201F0               wait_50us: CALL 1F0[delay_1us]
 1ED  19101                          SUB s1, 01
 1EE  361EC                          JUMP NZ, 1EC[wait_50us]
 1EF  25000                          RETURN 
 1F0                                 ; Delay of approximately 1us used to provide timing reference for
 1F0                                 ; LCD operations. This must be adjusted to reflect the clock
 1F0                                 ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 1F0                                 ;
 1F0                                 ; The software delay loop is formed using register s0. This register
 1F0                                 ; must be loaded with an integer value close to the result of....
 1F0                                 ;
 1F0                                 ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 1F0                                 ;
 1F0                                 ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 1F0                                 ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 1F0                                 ; operation will become lower than the 100KHz target intended.
 1F0                                 ;
 1F0                                 ; Register used s0.
 1F0                                 ;
 1F0  01006               delay_1us: LOAD s0, 06[delay_1us_constant]                        ; delay value of 12 decimal for a 50MHz clock
 1F1  19001                wait_1us: SUB s0, 01
 1F2  361F1                          JUMP NZ, 1F1[wait_1us]
 1F3  25000                          RETURN 
 1F4                                 ;
 1F4                                 ;
 1F4                                 ; Multiplier Routine (8-bit x 8-bit = 16-bit product) - Ken Chapman
 1F4                                 ; ==================================================
 1F4                                 ; Shift and add algorithm
 1F4                                 ;
 1F4                       mult_8x8: 
 1F4                                 NAMEREG s0, multiplicand                               ; preserved
 1F4                                 NAMEREG s1, multiplier                                 ; preserved
 1F4                                 NAMEREG s2, bit_mask                                   ; modified
 1F4                                 NAMEREG s3, result_msb                                 ; most-significant byte (MSB) of result,
 1F4                                 ; modified
 1F4                                 NAMEREG s4, result_lsb                                 ; least-significant byte (LSB) of result,
 1F4                                 ; modified
 1F4                                 ;
 1F4  01201                          LOAD s2[bit_mask], 01                                  ; start with least-significant bit (lsb)
 1F5  01300                          LOAD s3[result_msb], 00                                ; clear product MSB
 1F6  01400                          LOAD s4[result_lsb], 00                                ; clear product LSB (not required)
 1F7                                 ;
 1F7                                 ; loop through all bits in multiplier
 1F7  0C120               mult_loop: TEST s1[multiplier], s2[bit_mask]                      ; check if bit is set
 1F8  321FA                          JUMP Z, 1FA[no_add]                                    ; if bit is not set, skip addition
 1F9                                 ;
 1F9  10300                          ADD s3[result_msb], s0[multiplicand]                   ; addition only occurs in MSB
 1FA                                 ;
 1FA  14308                  no_add: SRA s3[result_msb]                                     ; shift MSB right, CARRY into bit 7,
 1FB                                 ; lsb into CARRY
 1FB  14408                          SRA s4[result_lsb]                                     ; shift LSB right,
 1FC                                 ; lsb from result_msb into bit 7
 1FC                                 ;
 1FC  14206                          SL0 s2[bit_mask]                                       ; shift bit_mask left to examine
 1FD                                 ; next bit in multiplier
 1FD                                 ;
 1FD  361F7                          JUMP NZ, 1F7[mult_loop]                                ; if all bit examined, then bit_mask = 0


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\home\gnaylor\Dropbox\N3SysGen\ToneDetectpico.psm



List of defined constants

 CONSTANT name       Value        Source PSM File

 timestamp_hours     15'd         
 timestamp_minutes   31'd         
 timestamp_seconds   07'd         
 datestamp_year      17'd         
 datestamp_month     5'd          
 datestamp_day       14'd         
 NUL                 00           
 BEL                 07           
 BS                  08           
 HT                  09           
 LF                  0A           
 VT                  0B           
 CR                  0D           
 ESC                 1B           
 DEL                 7F           
 DCS                 90           
 ST                  9C           
 delay_1us_constant  06           ToneDetectpico.psm
 m                   8'd          ToneDetectpico.psm
 m_plus_1            9'd          ToneDetectpico.psm
 count_1000_lsb      E8           ToneDetectpico.psm
 count_1000_msb      03           ToneDetectpico.psm
 half_pi_LSB         00           ToneDetectpico.psm
 half_pi_MSB         40           ToneDetectpico.psm
 phase_threshold     30'd         ToneDetectpico.psm
 count_value_to_trig 9'd          ToneDetectpico.psm
 audioTest           2'd          ToneDetectpico.psm
 StrtToneAInc        9E           ToneDetectpico.psm
 StrtToneBInc        68           ToneDetectpico.psm
 StopToneAInc        59           ToneDetectpico.psm
 StopToneBInc        77           ToneDetectpico.psm
 AudioMSB            0'd          ToneDetectpico.psm
 AudioLSB            1'd          ToneDetectpico.psm
 Strobe              2'd          ToneDetectpico.psm
 DemodMSB            3'd          ToneDetectpico.psm
 DemodLSB            4'd          ToneDetectpico.psm
 TBD0                5'd          ToneDetectpico.psm
 TBD1                6'd          ToneDetectpico.psm
 TBD2                7'd          ToneDetectpico.psm
 CmdToUser           0'd          ToneDetectpico.psm
 LOMSB               1'd          ToneDetectpico.psm
 BRAMaddrMSB         2'd          ToneDetectpico.psm
 BRAMaddrLSB         3'd          ToneDetectpico.psm
 StartAmpOut         25'd         ToneDetectpico.psm
 State               26'd         ToneDetectpico.psm
 AVEtoneAmp          9'd          ToneDetectpico.psm
 STRTAinc            10'd         ToneDetectpico.psm
 STRTAptrMSB         11'd         ToneDetectpico.psm
 STRTAptrLSB         12'd         ToneDetectpico.psm
 STRTAAccuDemodIMSB  13'd         ToneDetectpico.psm
 STRTAAccuDemodILSB  14'd         ToneDetectpico.psm
 STRTAAccuDemodQMSB  15'd         ToneDetectpico.psm
 STRTAAccuDemodQLSB  16'd         ToneDetectpico.psm
 STRTAcurrentPhase   17'd         ToneDetectpico.psm
 STRTApreviousPhase  18'd         ToneDetectpico.psm
 STRTAcounter        19'd         ToneDetectpico.psm
 STRTBinc            20'd         ToneDetectpico.psm
 STPAinc             30'd         ToneDetectpico.psm
 STPBinc             40'd         ToneDetectpico.psm
 SampleCounterMSB    90'd         ToneDetectpico.psm
 StartAmpA           91'd         ToneDetectpico.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "14 May 2017"  
 timestamp$        "15:31:07"     



List of line labels

   Label                    Addr  Source PSM File

 * cold_start               000   ToneDetectpico.psm
   AwaitAudioVal            01B   ToneDetectpico.psm
   AwaitRise                01F   ToneDetectpico.psm
   isReceiving              029   ToneDetectpico.psm
   StartDemod               02D   ToneDetectpico.psm
   DemodulateTone           03A   ToneDetectpico.psm
   CheckMatureAndOutput     073   ToneDetectpico.psm
   Matured                  078   ToneDetectpico.psm
   CarryOn                  083   ToneDetectpico.psm
   Whoopie                  0AA   ToneDetectpico.psm
   dropcounter              0B5   ToneDetectpico.psm
   IncrementCounter         0BA   ToneDetectpico.psm
   CheckNotTooBigI          0C0   ToneDetectpico.psm
   CheckNotTooBigQ          0D3   ToneDetectpico.psm
   isStrtToneA              0E6   ToneDetectpico.psm
   isStrtToneB              0EE   ToneDetectpico.psm
   isStopToneA              0F5   ToneDetectpico.psm
   isStopToneB              0FB   ToneDetectpico.psm
   CheckforTimeOuts         102   ToneDetectpico.psm
   checkStarttoneAtimeout   109   ToneDetectpico.psm
   checkRXtimeout           10D   ToneDetectpico.psm
   checkStoptoneAtimeout    113   ToneDetectpico.psm
   SpeakerOn                118   ToneDetectpico.psm
   SpeakerOff               11B   ToneDetectpico.psm
 * DoAccumulate             11F   ToneDetectpico.psm
   negaccum                 127   ToneDetectpico.psm
   negdecrmnt               132   ToneDetectpico.psm
 * LUTandMultiply           138   ToneDetectpico.psm
   StreamAmp                13C   ToneDetectpico.psm
   StreamPhase              140   ToneDetectpico.psm
   waitabit                 145   ToneDetectpico.psm
   cordic                   149   ToneDetectpico.psm
   cordicloop               14E   ToneDetectpico.psm
 * negrotate                152   ToneDetectpico.psm
   posrotate                160   ToneDetectpico.psm
   testcordicend            16D   ToneDetectpico.psm
   GetPhaseIncrement        171   ToneDetectpico.psm
   shift                    179   ToneDetectpico.psm
   shiftloop                17A   ToneDetectpico.psm
   rotate90                 180   ToneDetectpico.psm
 * sub90                    184   ToneDetectpico.psm
   add90                    18D   ToneDetectpico.psm
   absval                   196   ToneDetectpico.psm
   makeposval               199   ToneDetectpico.psm
 * Export2User              19D   ToneDetectpico.psm
 * AddCRLF                  1A3   ToneDetectpico.psm
 * Chars2Byte               1A8   ToneDetectpico.psm
   Get4bits                 1B3   ToneDetectpico.psm
   char0_9                  1B8   ToneDetectpico.psm
   Byte2Chars               1BB   ToneDetectpico.psm
   GetChar                  1C7   ToneDetectpico.psm
   is_0_9                   1CB   ToneDetectpico.psm
 * delay_1s                 1CE   ToneDetectpico.psm
   wait_1s                  1D0   ToneDetectpico.psm
 * delay_300ms              1D8   ToneDetectpico.psm
 * delay_200ms              1D9   ToneDetectpico.psm
   delay_100ms              1DC   ToneDetectpico.psm
   wait_100ms               1DD   ToneDetectpico.psm
   delay_1ms                1E1   ToneDetectpico.psm
   wait_1ms                 1E3   ToneDetectpico.psm
 * delay_50us               1EB   ToneDetectpico.psm
   wait_50us                1EC   ToneDetectpico.psm
   delay_1us                1F0   ToneDetectpico.psm
   wait_1us                 1F1   ToneDetectpico.psm
 * mult_8x8                 1F4   ToneDetectpico.psm
   mult_loop                1F7   ToneDetectpico.psm
   no_add                   1FA   ToneDetectpico.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            109
 STAR              -

 AND               7
 OR                -
 XOR               -

 ADD              41
 ADDCY            11
 SUB              34
 SUBCY             7

 TEST              1
 TESTCY            -
 COMPARE          39
 COMPARECY         -

 SL0               5
 SL1               -
 SLX               -
 SLA               2
 RL                -
 SR0              11
 SR1               -
 SRX               7
 SRA              15
 RR                -

 REGBANK           -

 INPUT             9
 OUTPUT           15
 OUTPUTK           -

 STORE            26
 FETCH            26

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             26
 JUMP@             -
 CALL             51
 CALL@             -
 RETURN           54
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
