KCPSM6 Assembler log file for program 'Z:\home\gnaylor\Dropbox\N3SysGen\KeyPadPico.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 14 May 2017
Assembly timestamp: 10:33:16

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 135 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 310
Memory locations available: 3786


Assembly listing

 Addr Code                        Instruction

 000                              ;Modified for 49.162MHz clock
 000                              ;A0 is version to get start and stop tone levels for speaker switching.
 000                              ;
 000                              ;99 - add latch on button facility so don't need handset plugged in.
 000                              ;Now display signal level and gain setting
 000                              ;Switch off key pad oscillation and
 000                              ;Mod to read key pad and display
 000                              ;Version using CoutA
 000                              ;Need to mod to send TX request to User when touchdown active
 000                              ;May 10
 000                              ;
 000                              ; KeyPad routine for SSB picoblaze
 000                              ;
 000                              CONSTANT delay_1us_constant, 06  ; Value (13)19 or 12? decimal suitable for 50MHz clock – about 6 for 33MHz?
 000                              CONSTANT count_1000_lsb, E8      ; hex lower 8-bits of 1000 count value
 000                              CONSTANT count_1000_msb, 03      ; hex upper 8-bits of 1000 count value
 000                              ; Input port - port numbering changed June 11
 000                              CONSTANT Command, 0'd            ; From main pico
 000                              CONSTANT PTT, 1'd                ;This is PTT and default frequency in bits 1 and 2
 000                              CONSTANT RAMdataInLSB, 2'd
 000                              CONSTANT RAMdataInMSB, 3'd
 000                              CONSTANT KP2userbufferFull, 4'd  ;Bit 0 KP2User buffer full, Bit 1 Touch counter running
 000                              CONSTANT TouchSignal2, 5'd       ;This is keypad Bit 0 On, Bit 1 Select, Bit 2 Down, Bit 3 Up
 000                              ;TouchSignal2=0E is On, 0D = Select, 0B = Down, 07= Up
 000                              CONSTANT ADCpeak, 6'd
 000                              CONSTANT DemodPeak, 7'd
 000                              ;CONSTANT SignalLevel,   8'd
 000                              CONSTANT StartToneA, 8'd
 000                              CONSTANT StartToneALong, 9'd
 000                              CONSTANT StartToneB, 10'd
 000                              CONSTANT StartToneBLong, 11'd
 000                              CONSTANT StopToneA, 12'd
 000                              CONSTANT StopToneALong, 13'd
 000                              CONSTANT StopToneB, 14'd
 000                              CONSTANT StopToneBLong, 15'd
 000                              ; Output ports
 000                              CONSTANT CmdToUser, 0'd
 000                              CONSTANT LCD_data_port, 1'd
 000                              CONSTANT LCD_control_port, 2'd
 000                              CONSTANT LCDcontrast, 3'd
 000                              CONSTANT Data2ArchiveMSB, 4'd
 000                              CONSTANT Data2ArchiveLSB, 5'd
 000                              CONSTANT Controlbits, 6'd
 000                              ;Bit offsets:
 000                              CONSTANT AckFIFO, 32'd           ;   bit 5 Acknowledge FIFO (present character)
 000                              CONSTANT RAM_ADD_MSB, 7'd        ;Bits 0 and 1 top too address bits, bit 2 write RAM
 000                              ;Bit offsets:
 000                              CONSTANT WriteKPRAM, 4'd
 000                              CONSTANT RAM_ADD_LSB, 8'd
 000                              CONSTANT LatchOn, 9'd
 000                              CONSTANT RXFreqMSB, 10'd         ; 7546 for 87.956kHz ie 86.956kHz carrier and allow range up to 154kHz 7555 Heyphone
 000                              CONSTANT RXFreqLSB, 11'd
 000                              CONSTANT TXFreqMSB, 12'd         ; 3710  with 49.152MHz clock, with 49.162MHz - need 3709 for N2 and 3711 for Heyphone
 000                              CONSTANT TXFreqLSB, 13'd
 000                              ;TX frequencies:
 000                              ;For 49.152MHz!
 000                              ;Heyphone - 0e80
 000                              ;N2 -       0e7e
 000                              ;N3_31 -    052b
 000                              ;RX frequencies:
 000                              ;Heyphone  - $7555
 000                              ;N2  -       $7546
 000                              ;N3_31  -    $2aad
 000                              ;But for 49.162MHz:
 000                              ;Heyphone - 0e7F
 000                              ;N2 -       0e7d
 000                              ;N3_31 -    052a
 000                              ;RX frequencies:
 000                              ;Heyphone  - $754F
 000                              ;N2  -       $753E
 000                              ;N3_31  -    $2953
 000                              ; Scratchpad registers
 000                              CONSTANT TouchUpLevel, 0'd
 000                              CONSTANT TouchDownLevel, 1'd
 000                              CONSTANT TouchSelectLevel, 2'd
 000                              CONSTANT TX_F_MSB, 3'd
 000                              CONSTANT TX_F_LSB, 4'd
 000                              CONSTANT RX_F_MSB, 5'd
 000                              CONSTANT RX_F_LSB, 6'd
 000                              CONSTANT Freq2Set, 7'd           ; values 0 nothing to set, 1>Hy, 2>N2, 3>N3 (31kHz)
 000                              CONSTANT PreviousKeyState, 10    ; 16d
 000                              CONSTANT PreviousPTTState, 11    ; 17d
 000                              CONSTANT KEYS_PRESSED, 12        ; 18d
 000                              CONSTANT KeyPressTimer, 13       ; 19d
 000                              CONSTANT KeyPressFast, 14        ; 20d
 000                              CONSTANT KeyPressFastLeadIn, 15  ; 20d
 000                              ;;;GenerateCode        MEM       "KeyPadProg.mem"
 000                  cold_start: 
 000             welcome_message: 
 000  01000           initialise: LOAD s0, 00                      ;This is now used to drive LatchOn which latches the device on!!
 001  2D009                       OUTPUT s0, 09[LatchOn]           ;Latch On if 1
 002  2F010                       STORE s0, 10[PreviousKeyState]   ; initial state
 003  2F011                       STORE s0, 11[PreviousPTTState]   ; initial state
 004  2F012                       STORE s0, 12[KEYS_PRESSED]
 005  2F013                       STORE s0, 13[KeyPressTimer]
 006  2F014                       STORE s0, 14[KeyPressFast]
 007  2010E                       CALL 10E[delay_1s]               ;Wait so it doesn't detect as turn off
 008                              ;LOAD      s5, "&"   ; key event flag
 008                              ;OUTPUT    s5, CmdToUser  ; write to user pico and onto ARM
 008                              ;FETCH   s5, KEYS_PRESSED ; get the keys pressed mask
 008                              ;ADD     s5, "P"   ; convert to appropriate character for key on
 008                              ;OUTPUT    s5, CmdToUser  ; write to user pico and onto ARM
 008                              ;set values for Hey by default
 008  09001                       INPUT s0, 01[PTT]                ;This is PTT but also has set default frequency bits in bits 1 and 2
 009  1400E                       SR0 s0
 00A  03003                       AND s0, 03
 00B                              ;   LOAD    s0,01   ;use 1 for Hey, 2 for N2 freq, 3 for 37kHz
 00B  2F007                       STORE s0, 07[Freq2Set]
 00C  200A4                       CALL 0A4[UpdateFreqRegisters]
 00D                              ;Wait and check if ON still pressed
 00D  2010E                       CALL 10E[delay_1s]
 00E  09505                       INPUT s5, 05[TouchSignal2]
 00F  0350F                       AND s5, 0F
 010  1D50E                       COMPARE s5, 0E                   ;is 'ON' pressed
 011  36016                       JUMP NZ, 016[loop]               ;if not ON button, skip
 012  01001                       LOAD s0, 01                      ;This is now used to drive PMOD1 which latches the device on!!
 013  2D009                       OUTPUT s0, 09[LatchOn]           ;Latch On
 014  2010E                       CALL 10E[delay_1s]               ;Wait so it doesn't detect as turn off!
 015  2010E                       CALL 10E[delay_1s]               ;Wait so it doesn't detect as turn off!
 016                        loop: 
 016  2011C                       CALL 11C[delay_50msecs]          ; period between checks
 017                              ;CALL   delay_1s    ;Wait so it doesn't detect as turn off!
 017  09000                       INPUT s0, 00[Command]            ;Check if FIFO character present
 018  1D080                       COMPARE s0, 80[128'd]            ; is there a character?
 019  380A7                       CALL C, 0A7[Respond2Fifo]        ;this should now receive value of mode from user pico and display on LCD
 01A  09105                       INPUT s1, 05[TouchSignal2]       ; read the keys touched register
 01B  071FF                       XOR s1, FF                       ; invert so ON is a 1
 01C  0310F                       AND s1, 0F                       ; mask to the key press bits
 01D                              ;LOAD      s5, "&"   ; key event flag
 01D                              ;OUTPUT    s5, CmdToUser  ; write to user pico and onto ARM
 01D                              ;LOAD      s5, s1
 01D                              ;ADD     s5, "@"   ; convert to appropriate character for key on
 01D                              ;ADD     s5, 60   ; temp should get a through h
 01D                              ;OUTPUT    s5, CmdToUser  ; write to user pico and onto ARM
 01D                              ;JUMP      CheckPTT
 01D  0B510                       FETCH s5, 10[PreviousKeyState]   ; get last key pressed state
 01E  1C150                       COMPARE s1, s5
 01F                              ;JUMP      Z, CheckPTT      ; skip if input state not changed
 01F  32031                       JUMP Z, 031[KeyNotChanged]       ; skip if input state not changed
 020  2F110                       STORE s1, 10[PreviousKeyState]   ; remember new state
 021  0B512                       FETCH s5, 12[KEYS_PRESSED]       ; get the keys pressed mask
 022  04510                       OR s5, s1                        ; remember which keys have been pressed
 023  2F512                       STORE s5, 12[KEYS_PRESSED]       ; remember new state
 024  1D100                       COMPARE s1, 00                   ; are there any keys pressed now?
 025  36031                       JUMP NZ, 031[KeyNotChanged]      ; skip if keys still pressed
 026                              ;JUMP      nz, CheckPTT          ; skip if keys still pressed
 026  01526                       LOAD s5, 26["&"]                 ; key event flag
 027  2D500                       OUTPUT s5, 00[CmdToUser]         ; write to user pico and onto ARM
 028  0B512                       FETCH s5, 12[KEYS_PRESSED]       ; get the keys pressed mask
 029  11540                       ADD s5, 40["@"]                  ; convert to appropriate character
 02A  2D500                       OUTPUT s5, 00[CmdToUser]         ; write to user pico and onto ARM
 02B                              ;#define KEY_UP  'H'  // up = 08
 02B                              ;#define KEY_DOWN 'D'  // down = 04
 02B                              ;#define KEY_RIGHT 'B'  // right = 02
 02B                              ;#define KEY_LEFT 'A'  // left = 01
 02B                              ;#define KEY_UPLEFT 'I'  // 08 + 01
 02B                              ;#define KEY_LEFTRIGHT 'C'  // 02 + 01
 02B                              ;#define KEY_PTT_ON  '0'
 02B                              ;#define KEY_PTT_OFF '1'
 02B  01000                       LOAD s0, 00                      ; reset the keys pressed
 02C  2F012                       STORE s0, 12[KEYS_PRESSED]
 02D  2F013                       STORE s0, 13[KeyPressTimer]
 02E  2F014                       STORE s0, 14[KeyPressFast]
 02F  2F015                       STORE s0, 15[KeyPressFastLeadIn]
 030  2204D                       JUMP 04D[CheckPTT]
 031                              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 031               KeyNotChanged: 
 031                              ;;; check for key pressed for a period and tell ARM if so
 031  0B112                       FETCH s1, 12[KEYS_PRESSED]       ; get the keys pressed mask
 032  1D100                       COMPARE s1, 00                   ; any keys pressed
 033  3204D                       JUMP Z, 04D[CheckPTT]            ; if not then do not time
 034  0B214                       FETCH s2, 14[KeyPressFast]       ; has key been pressed a while?
 035  1D200                       COMPARE s2, 00                   ;
 036  3203D                       JUMP Z, 03D[SlowPress]           ; skip if slow presses
 037                   FastPress: 
 037  0B213                       FETCH s2, 13[KeyPressTimer]
 038  11201                       ADD s2, 01                       ; increment by approx loop time (50 milli sec?)
 039  2F213                       STORE s2, 13[KeyPressTimer]
 03A  03207                       AND s2, 07                       ; if key pressed for .3 secs approx (32 ticks)
 03B  3604D                       JUMP NZ, 04D[CheckPTT]           ; if not then no message
 03C  22042                       JUMP 042[SlowPressSend]
 03D                   SlowPress: 
 03D  0B213                       FETCH s2, 13[KeyPressTimer]
 03E  11201                       ADD s2, 01                       ; increment by approx loop time (50 milli sec?)
 03F  2F213                       STORE s2, 13[KeyPressTimer]
 040  0320F                       AND s2, 0F                       ; if key pressed for 1.5 secs approx (32 ticks)
 041  3604D                       JUMP NZ, 04D[CheckPTT]           ; if not then no message
 042               SlowPressSend: 
 042  01526                       LOAD s5, 26["&"]                 ; key event flag
 043  2D500                       OUTPUT s5, 00[CmdToUser]         ; write to user pico and onto ARM
 044  0B512                       FETCH s5, 12[KEYS_PRESSED]       ; get the keys pressed mask
 045  11550                       ADD s5, 50["P"]                  ; convert to appropriate character for key on
 046  2D500                       OUTPUT s5, 00[CmdToUser]         ; write to user pico and onto ARM
 047  0B215                       FETCH s2, 15[KeyPressFastLeadIn]
 048  11201                       ADD s2, 01                       ; increment by approx loop time (50 milli sec?)
 049  2F215                       STORE s2, 15[KeyPressFastLeadIn]
 04A  1D204                       COMPARE s2, 04                   ; approx 2 seconds?
 04B  3604D                       JUMP NZ, 04D[CheckPTT]           ; keep slow presses till then
 04C  2F214                       STORE s2, 14[KeyPressFast]       ; start fast key press
 04D                              ;;; now check PTT
 04D                    CheckPTT: 
 04D  09101                       INPUT s1, 01[PTT]                ;Read PTT register
 04E  03101                       AND s1, 01                       ;Mask lowest bit
 04F  0B511                       FETCH s5, 11[PreviousPTTState]
 050  1C150                       COMPARE s1, s5                   ; has it changed
 051  32016                       JUMP Z, 016[loop]                ; loop back if not
 052  2F111                       STORE s1, 11[PreviousPTTState]
 053                              ; send PTT state -
 053                              ;  0 = PTT pressed   1 = PTT released
 053  01526                       LOAD s5, 26["&"]
 054  2D500                       OUTPUT s5, 00[CmdToUser]
 055  11130                       ADD s1, 30["0"]                  ; PTT pressed = '0'; PTT released = '1'
 056  2D100                       OUTPUT s1, 00[CmdToUser]
 057                              ;COMPARE    s1, 00 ; debug
 057                              ;JUMP       Z, PTTOFF ; debug
 057                              ; debug      LOAD   s5, "r"
 057                              ; debug      OUTPUT    s5, CmdToUser
 057  22016                       JUMP 016[loop]
 058                              ;PTTOFF:
 058                              ; debug      LOAD   s5, "t"
 058                              ; debug      OUTPUT    s5, CmdToUser
 058                              ;                   JUMP   loop
 058  2010E                       CALL 10E[delay_1s]
 059  09505                       INPUT s5, 05[TouchSignal2]
 05A  0350F                       AND s5, 0F
 05B  1D50F                       COMPARE s5, 0F                   ;not $F if pressed
 05C  31000                       RETURN Z                         ;return if key not still pressed
 05D  3005E                       CALL Z, 05E[TurnOff]
 05E                              ;Note key pad bits are: bit3 = On, bit 2 = up, bit 1 = select, bit 0 = down
 05E  01000              TurnOff: LOAD s0, 00                      ;This is now used to drive PMOD1 which latches the device on!!
 05F  2D009                       OUTPUT s0, 09[LatchOn]           ;Latch On if 1
 060  25000                       RETURN 
 061  0B007               upFreq: FETCH s0, 07[Freq2Set]
 062  11001                       ADD s0, 01
 063  03003                       AND s0, 03
 064  2F007                       STORE s0, 07[Freq2Set]
 065  2206B                       JUMP 06B[CheckWhichFreq]
 066  0B007             DownFreq: FETCH s0, 07[Freq2Set]
 067  19001                       SUB s0, 01
 068  03003                       AND s0, 03
 069  2F007                       STORE s0, 07[Freq2Set]
 06A  2206B                       JUMP 06B[CheckWhichFreq]
 06B  1D000       CheckWhichFreq: COMPARE s0, 00
 06C  30074                       CALL Z, 074[ClearFreq]           ;clear set display
 06D  1D001                       COMPARE s0, 01
 06E  30077                       CALL Z, 077[SetHeyphoneFreq]     ;set Hy freq and return
 06F  1D002                       COMPARE s0, 02
 070  30086                       CALL Z, 086[SetN2Freq]
 071  1D003                       COMPARE s0, 03
 072  30095                       CALL Z, 095[SetN3_31Freq]
 073  25000                       RETURN 
 074  01B20            ClearFreq: LOAD sB, 20[" "]                 ; character_space
 075  01C20                       LOAD sC, 20[" "]                 ; character_space
 076  25000                       RETURN 
 077                              ;TX frequencies:
 077                              ;for 49.162MHz!:
 077                              ;Heyphone - 0e7F
 077                              ;N2 -       0e7d
 077                              ;N3_31 -    052a
 077                              ;RX frequencies:
 077                              ;Heyphone  - $754F
 077                              ;N2  -       $753E
 077                              ;N3_31  -    $2953
 077                              ; with 49.162MHzMHz!
 077  0110E      SetHeyphoneFreq: LOAD s1, 0E
 078  2F103                       STORE s1, 03[TX_F_MSB]
 079  0117F                       LOAD s1, 7F
 07A  2F104                       STORE s1, 04[TX_F_LSB]
 07B  01175                       LOAD s1, 75
 07C  2F105                       STORE s1, 05[RX_F_MSB]
 07D  0114F                       LOAD s1, 4F
 07E  2F106                       STORE s1, 06[RX_F_LSB]
 07F                              ;LOAD   sB,"h"  ; character_h
 07F                              ;LOAD   sC,"y"  ; character_y
 07F  200C2                       CALL 0C2[SetTxFreq]
 080  200C7                       CALL 0C7[SetRxFreq]
 081  01526                       LOAD s5, 26["&"]                 ; key event flag
 082  2D500                       OUTPUT s5, 00[CmdToUser]         ; write to user pico and onto ARM
 083  01577                       LOAD s5, 77["w"]                 ; key event flag
 084  2D500                       OUTPUT s5, 00[CmdToUser]         ; write to user pico and onto ARM
 085  25000                       RETURN 
 086                              ;For N3 5565 (15BD) TX and  45032 (AFE8) RX with 32.768MHz!
 086  0110E            SetN2Freq: LOAD s1, 0E
 087  2F103                       STORE s1, 03[TX_F_MSB]
 088  0117D                       LOAD s1, 7D
 089  2F104                       STORE s1, 04[TX_F_LSB]
 08A  01175                       LOAD s1, 75
 08B  2F105                       STORE s1, 05[RX_F_MSB]
 08C  0113E                       LOAD s1, 3E
 08D  2F106                       STORE s1, 06[RX_F_LSB]
 08E                              ;LOAD   sB,"n"  ; character_n
 08E                              ;LOAD   sC,"2"  ; character_2
 08E  200C2                       CALL 0C2[SetTxFreq]
 08F  200C7                       CALL 0C7[SetRxFreq]
 090  01526                       LOAD s5, 26["&"]                 ; key event flag
 091  2D500                       OUTPUT s5, 00[CmdToUser]         ; write to user pico and onto ARM
 092  01578                       LOAD s5, 78["x"]                 ; key event flag
 093  2D500                       OUTPUT s5, 00[CmdToUser]         ; write to user pico and onto ARM
 094  25000                       RETURN 
 095                              ;For 31kH 1984 TX (07C0)    16384 for RX (4000 hex) with 32.768MHz!
 095  01105         SetN3_31Freq: LOAD s1, 05
 096  2F103                       STORE s1, 03[TX_F_MSB]
 097  0112A                       LOAD s1, 2A
 098  2F104                       STORE s1, 04[TX_F_LSB]
 099  01129                       LOAD s1, 29
 09A  2F105                       STORE s1, 05[RX_F_MSB]
 09B  01153                       LOAD s1, 53
 09C  2F106                       STORE s1, 06[RX_F_LSB]
 09D                              ;LOAD   sB,"3"  ; character_3
 09D                              ;LOAD   sC,"1"  ; character_1
 09D  200C2                       CALL 0C2[SetTxFreq]
 09E  200C7                       CALL 0C7[SetRxFreq]
 09F  01526                       LOAD s5, 26["&"]                 ; key event flag
 0A0  2D500                       OUTPUT s5, 00[CmdToUser]         ; write to user pico and onto ARM
 0A1  01579                       LOAD s5, 79["y"]                 ; key event flag
 0A2  2D500                       OUTPUT s5, 00[CmdToUser]         ; write to user pico and onto ARM
 0A3  25000                       RETURN 
 0A4         UpdateFreqRegisters: 
 0A4                              ;CALL    SetHeyphoneFreq    ;set Hy freq and return
 0A4  0B007                       FETCH s0, 07[Freq2Set]
 0A5  2006B                       CALL 06B[CheckWhichFreq]
 0A6  25000                       RETURN 
 0A7                              ;Get fifo command and act on it. Echo ascii value to LCD
 0A7                Respond2Fifo: ;CALL LCD_cursor_back
 0A7  200CF                       CALL 0CF[GetFifoChar]
 0A8               Respond2FifoW: 
 0A8  09000                       INPUT s0, 00[Command]            ;Check if FIFO character present
 0A9  1D080                       COMPARE s0, 80[128'd]            ; is there a character?
 0AA  3E0A8                       JUMP NC, 0A8[Respond2FifoW]      ;this should now receive value of mode from user pico and display on LCD
 0AB  200CF                       CALL 0CF[GetFifoChar]
 0AC  1D044                       COMPARE s0, 44["D"]              ;#define SEND_FREQUENCY_HEYPHONE ('D')
 0AD  30077                       CALL Z, 077[SetHeyphoneFreq]
 0AE  1D045                       COMPARE s0, 45["E"]              ;#define SEND_FREQUENCY_NICOLA2 ('E')
 0AF  30086                       CALL Z, 086[SetN2Freq]
 0B0  1D046                       COMPARE s0, 46["F"]              ;#define SEND_FREQUENCY_31KHZ ('F')
 0B1  30095                       CALL Z, 095[SetN3_31Freq]
 0B2  1D05A                       COMPARE s0, 5A["Z"]              ; Z = turn off
 0B3  3005E                       CALL Z, 05E[TurnOff]
 0B4  1D079                       COMPARE s0, 79["y"]              ; y - turn on LCD
 0B5  300BB                       CALL Z, 0BB[TurnLCDOn]
 0B6  1D059                       COMPARE s0, 59["Y"]              ; Y - turn off LCD
 0B7  300BE                       CALL Z, 0BE[TurnLCDOff]
 0B8  1D004                       COMPARE s0, 04                   ;character T (request for info from userpico) ->LESS TOP BIT WHICH IS NOT SENT!
 0B9  300CC                       CALL Z, 0CC[SendParamBack]
 0BA  25000                       RETURN 
 0BB                   TurnLCDOn: 
 0BB  01001                       LOAD s0, 01
 0BC  2D003                       OUTPUT s0, 03[LCDcontrast]       ;
 0BD  25000                       RETURN 
 0BE                  TurnLCDOff: 
 0BE  01000                       LOAD s0, 00
 0BF  2D003                       OUTPUT s0, 03[LCDcontrast]       ;
 0C0  25000                       RETURN 
 0C1                              ; Added code to display ADC and demod peak values
 0C1  25000                       RETURN 
 0C2                              ;Enter with s0 - LSB, s1 - MSB
 0C2  0B003            SetTxFreq: FETCH s0, 03[TX_F_MSB]           ; Value for TX frequency being used
 0C3  2D00C                       OUTPUT s0, 0C[TXFreqMSB]
 0C4  0B004                       FETCH s0, 04[TX_F_LSB]
 0C5  2D00D                       OUTPUT s0, 0D[TXFreqLSB]         ; and send value to SSB modulator
 0C6  25000                       RETURN 
 0C7  0B005            SetRxFreq: FETCH s0, 05[RX_F_MSB]           ; Value for RX frequency being used
 0C8  2D00A                       OUTPUT s0, 0A[RXFreqMSB]
 0C9  0B006                       FETCH s0, 06[RX_F_LSB]
 0CA  2D00B                       OUTPUT s0, 0B[RXFreqLSB]         ; and send value to SSB demodulator
 0CB  25000                       RETURN 
 0CC                              ;Select:   CALL GetFifoChar
 0CC                              ;     OUT  s0,ChooseTouchKey
 0CC                              ;     RETURN
 0CC  09501        SendParamBack: INPUT s5, 01[PTT]                ;********************TEST reading touch***********************************
 0CD  200D5                       CALL 0D5[Export2User]
 0CE  25000                       RETURN 
 0CF                              ; Routine to recover a character from the FIFO in s0
 0CF  01020          GetFifoChar: LOAD s0, 20[AckFIFO]
 0D0  2D006                       OUTPUT s0, 06[Controlbits]
 0D1  01020                       LOAD s0, 20[AckFIFO]             ;Wait
 0D2  09000                       INPUT s0, 00[Command]            ; now get my character
 0D3  0307F                       AND s0, 7F                       ; mask of top bit
 0D4  25000                       RETURN 
 0D5                              ; Takes value in s5 and converts to 2 ascii codes which are sent to the user picoblaze.
 0D5  200FB          Export2User: CALL 0FB[Byte2Chars]
 0D6  2D600                       OUTPUT s6, 00[CmdToUser]
 0D7  2D700                       OUTPUT s7, 00[CmdToUser]
 0D8  0100D                       LOAD s0, 0D[13'd]                ;terminate with CR
 0D9  2D000                       OUTPUT s0, 00[CmdToUser]
 0DA  0100A                       LOAD s0, 0A[10'd]                ;and with LF
 0DB  2D000                       OUTPUT s0, 00[CmdToUser]
 0DC  25000                       RETURN 
 0DD                              ; routine to look at command input and recover 2 characters and return the byte they represent in s5.
 0DD  09600            Get2Chars: INPUT s6, 00[Command]
 0DE  1D680                       COMPARE s6, 80[128'd]            ; if greater than 128, then no character
 0DF  3E0DD                       JUMP NC, 0DD[Get2Chars]
 0E0  200CF                       CALL 0CF[GetFifoChar]
 0E1  00600                       LOAD s6, s0
 0E2  09700           Get2ndChar: INPUT s7, 00[Command]
 0E3  1D780                       COMPARE s7, 80[128'd]            ; if greater than 128, then no character
 0E4  3E0E2                       JUMP NC, 0E2[Get2ndChar]
 0E5  200CF                       CALL 0CF[GetFifoChar]
 0E6  00700                       LOAD s7, s0
 0E7  220E8                       JUMP 0E8[Chars2Byte]
 0E8                              ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 0E8  00860           Chars2Byte: LOAD s8, s6
 0E9  200F3                       CALL 0F3[Get4bits]
 0EA  00580                       LOAD s5, s8
 0EB  14506                       SL0 s5
 0EC  14506                       SL0 s5
 0ED  14506                       SL0 s5
 0EE  14506                       SL0 s5                           ; put these 4 bits to MSBs
 0EF  00870                       LOAD s8, s7
 0F0  200F3                       CALL 0F3[Get4bits]
 0F1  10580                       ADD s5, s8
 0F2  25000                       RETURN 
 0F3                              ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 0F3  1D83C             Get4bits: COMPARE s8, 3C[60'd]             ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 0F4  3A0F8                       JUMP C, 0F8[char0_9]
 0F5  19837                       SUB s8, 37[55'd]                 ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 0F6  0380F                       AND s8, 0F                       ; make sure only return 4 bits
 0F7  25000                       RETURN 
 0F8  19830              char0_9: SUB s8, 30[48'd]
 0F9  0380F                       AND s8, 0F                       ; make sure only return 4 bits
 0FA  25000                       RETURN 
 0FB                              ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 0FB  00850           Byte2Chars: LOAD s8, s5                      ; assumes 8 bit data is in s5
 0FC  1450E                       SR0 s5
 0FD  1450E                       SR0 s5
 0FE  1450E                       SR0 s5
 0FF  1450E                       SR0 s5                           ; get first hex character
 100  20107                       CALL 107[GetChar]
 101  00650                       LOAD s6, s5                      ; first ascii char
 102  00580                       LOAD s5, s8
 103  0350F                       AND s5, 0F
 104  20107                       CALL 107[GetChar]                ; send to LCD or UART
 105  00750                       LOAD s7, s5                      ; second ascii char
 106  25000                       RETURN 
 107                              ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 107  1950A              GetChar: SUB s5, 0A[10'd]                 ; Test if s5 greater than 9
 108  3A10B                       JUMP C, 10B[is_0_9]              ; Hex character is 0_9
 109  11541                       ADD s5, 41[65'd]                 ; offset for Ascii code 'A'
 10A  25000                       RETURN 
 10B  1150A               is_0_9: ADD s5, 0A[10'd]                 ; return to range 0-9
 10C  11530                       ADD s5, 30[48'd]                 ; offset to Ascii code for '0'
 10D  25000                       RETURN 
 10E                              ; Registers used s0, s1, s2, s3, s4 and s5.
 10E                              ;
 10E  01500             delay_1s: LOAD s5, 00                      ; clear cycle counter
 10F  01400                       LOAD s4, 00
 110  20123              wait_1s: CALL 123[delay_1ms]
 111  11401                       ADD s4, 01                       ; increment cycle counter
 112  13500                       ADDCY s5, 00
 113  1D4E8                       COMPARE s4, E8[count_1000_lsb]   ; test for 1000ms
 114  36110                       JUMP NZ, 110[wait_1s]
 115  1D503                       COMPARE s5, 03[count_1000_msb]
 116  36110                       JUMP NZ, 110[wait_1s]
 117  25000                       RETURN 
 118                              ;
 118                              ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 118                              ;
 118                              ;
 118                              ; Registers used s0, s1, s2, s3 and s4.
 118                              ;
 118  2011E          delay_300ms: CALL 11E[delay_100ms]
 119  2011E          delay_200ms: CALL 11E[delay_100ms]
 11A  2011E                       CALL 11E[delay_100ms]
 11B  25000                       RETURN 
 11C                              ;
 11C                              ; Delay of approximately 100ms used for switch debounce
 11C                              ;
 11C                              ; Registers used s0, s1, s2, s3 and s4.
 11C                              ;
 11C  01432        delay_50msecs: LOAD s4, 32                      ; repeat 1ms delay 100 times
 11D  2211F                       JUMP 11F[wait_100ms]
 11E  01464          delay_100ms: LOAD s4, 64                      ; repeat 1ms delay 100 times
 11F  20123           wait_100ms: CALL 123[delay_1ms]
 120  19401                       SUB s4, 01
 121  3611F                       JUMP NZ, 11F[wait_100ms]
 122  25000                       RETURN 
 123                              ;
 123                              ; Delay of approximately 1ms required by LCD display
 123                              ;
 123                              ; Registers used s0, s1, s2 and s3.
 123                              ;
 123  01300            delay_1ms: LOAD s3, 00                      ; clear cycle counter
 124  01200                       LOAD s2, 00
 125  20132             wait_1ms: CALL 132[delay_1us]
 126  11201                       ADD s2, 01                       ; increment cycle counter
 127  13300                       ADDCY s3, 00
 128  1D2E8                       COMPARE s2, E8[count_1000_lsb]   ; test for 1000us
 129  36125                       JUMP NZ, 125[wait_1ms]
 12A  1D303                       COMPARE s3, 03[count_1000_msb]
 12B  36125                       JUMP NZ, 125[wait_1ms]
 12C  25000                       RETURN 
 12D                              ;
 12D                              ; Delay of approximately 50us required by LCD display
 12D                              ;
 12D                              ; Registers used s0 and s1.
 12D                              ;
 12D  01132           delay_50us: LOAD s1, 32[50'd]                ; repeat 1us delay 50 times
 12E  20132            wait_50us: CALL 132[delay_1us]
 12F  19101                       SUB s1, 01
 130  3612E                       JUMP NZ, 12E[wait_50us]
 131  25000                       RETURN 
 132                              ; Delay of approximately 1us used to provide timing reference for
 132                              ; LCD operations. This must be adjusted to reflect the clock
 132                              ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 132                              ;
 132                              ; The software delay loop is formed using register s0. This register
 132                              ; must be loaded with an integer value close to the result of....
 132                              ;
 132                              ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 132                              ;
 132                              ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 132                              ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 132                              ; operation will become lower than the 100KHz target intended.
 132                              ;
 132                              ; Register used s0.
 132                              ;
 132  01006            delay_1us: LOAD s0, 06[delay_1us_constant]  ; delay value of 12 decimal for a 50MHz clock
 133  19001             wait_1us: SUB s0, 01
 134  36133                       JUMP NZ, 133[wait_1us]
 135  25000                       RETURN 
 136                              ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\home\gnaylor\Dropbox\N3SysGen\KeyPadPico.psm



List of defined constants

 CONSTANT name      Value        Source PSM File

 timestamp_hours    10'd         
 timestamp_minutes  33'd         
 timestamp_seconds  16'd         
 datestamp_year     17'd         
 datestamp_month    5'd          
 datestamp_day      14'd         
 NUL                00           
 BEL                07           
 BS                 08           
 HT                 09           
 LF                 0A           
 VT                 0B           
 CR                 0D           
 ESC                1B           
 DEL                7F           
 DCS                90           
 ST                 9C           
 delay_1us_constant 06           KeyPadPico.psm
 count_1000_lsb     E8           KeyPadPico.psm
 count_1000_msb     03           KeyPadPico.psm
 Command            0'd          KeyPadPico.psm
 PTT                1'd          KeyPadPico.psm
 RAMdataInLSB       2'd          KeyPadPico.psm
 RAMdataInMSB       3'd          KeyPadPico.psm
 KP2userbufferFull  4'd          KeyPadPico.psm
 TouchSignal2       5'd          KeyPadPico.psm
 ADCpeak            6'd          KeyPadPico.psm
 DemodPeak          7'd          KeyPadPico.psm
 StartToneA         8'd          KeyPadPico.psm
 StartToneALong     9'd          KeyPadPico.psm
 StartToneB         10'd         KeyPadPico.psm
 StartToneBLong     11'd         KeyPadPico.psm
 StopToneA          12'd         KeyPadPico.psm
 StopToneALong      13'd         KeyPadPico.psm
 StopToneB          14'd         KeyPadPico.psm
 StopToneBLong      15'd         KeyPadPico.psm
 CmdToUser          0'd          KeyPadPico.psm
 LCD_data_port      1'd          KeyPadPico.psm
 LCD_control_port   2'd          KeyPadPico.psm
 LCDcontrast        3'd          KeyPadPico.psm
 Data2ArchiveMSB    4'd          KeyPadPico.psm
 Data2ArchiveLSB    5'd          KeyPadPico.psm
 Controlbits        6'd          KeyPadPico.psm
 AckFIFO            32'd         KeyPadPico.psm
 RAM_ADD_MSB        7'd          KeyPadPico.psm
 WriteKPRAM         4'd          KeyPadPico.psm
 RAM_ADD_LSB        8'd          KeyPadPico.psm
 LatchOn            9'd          KeyPadPico.psm
 RXFreqMSB          10'd         KeyPadPico.psm
 RXFreqLSB          11'd         KeyPadPico.psm
 TXFreqMSB          12'd         KeyPadPico.psm
 TXFreqLSB          13'd         KeyPadPico.psm
 TouchUpLevel       0'd          KeyPadPico.psm
 TouchDownLevel     1'd          KeyPadPico.psm
 TouchSelectLevel   2'd          KeyPadPico.psm
 TX_F_MSB           3'd          KeyPadPico.psm
 TX_F_LSB           4'd          KeyPadPico.psm
 RX_F_MSB           5'd          KeyPadPico.psm
 RX_F_LSB           6'd          KeyPadPico.psm
 Freq2Set           7'd          KeyPadPico.psm
 PreviousKeyState   10           KeyPadPico.psm
 PreviousPTTState   11           KeyPadPico.psm
 KEYS_PRESSED       12           KeyPadPico.psm
 KeyPressTimer      13           KeyPadPico.psm
 KeyPressFast       14           KeyPadPico.psm
 KeyPressFastLeadIn 15           KeyPadPico.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "14 May 2017"  
 timestamp$        "10:33:16"     



List of line labels

   Label                 Addr  Source PSM File

 * cold_start            000   KeyPadPico.psm
 * welcome_message       000   KeyPadPico.psm
 * initialise            000   KeyPadPico.psm
   loop                  016   KeyPadPico.psm
   KeyNotChanged         031   KeyPadPico.psm
 * FastPress             037   KeyPadPico.psm
   SlowPress             03D   KeyPadPico.psm
   SlowPressSend         042   KeyPadPico.psm
   CheckPTT              04D   KeyPadPico.psm
   TurnOff               05E   KeyPadPico.psm
 * upFreq                061   KeyPadPico.psm
 * DownFreq              066   KeyPadPico.psm
   CheckWhichFreq        06B   KeyPadPico.psm
   ClearFreq             074   KeyPadPico.psm
   SetHeyphoneFreq       077   KeyPadPico.psm
   SetN2Freq             086   KeyPadPico.psm
   SetN3_31Freq          095   KeyPadPico.psm
   UpdateFreqRegisters   0A4   KeyPadPico.psm
   Respond2Fifo          0A7   KeyPadPico.psm
   Respond2FifoW         0A8   KeyPadPico.psm
   TurnLCDOn             0BB   KeyPadPico.psm
   TurnLCDOff            0BE   KeyPadPico.psm
   SetTxFreq             0C2   KeyPadPico.psm
   SetRxFreq             0C7   KeyPadPico.psm
   SendParamBack         0CC   KeyPadPico.psm
   GetFifoChar           0CF   KeyPadPico.psm
   Export2User           0D5   KeyPadPico.psm
   Get2Chars             0DD   KeyPadPico.psm
   Get2ndChar            0E2   KeyPadPico.psm
   Chars2Byte            0E8   KeyPadPico.psm
   Get4bits              0F3   KeyPadPico.psm
   char0_9               0F8   KeyPadPico.psm
   Byte2Chars            0FB   KeyPadPico.psm
   GetChar               107   KeyPadPico.psm
   is_0_9                10B   KeyPadPico.psm
   delay_1s              10E   KeyPadPico.psm
   wait_1s               110   KeyPadPico.psm
 * delay_300ms           118   KeyPadPico.psm
 * delay_200ms           119   KeyPadPico.psm
   delay_50msecs         11C   KeyPadPico.psm
   delay_100ms           11E   KeyPadPico.psm
   wait_100ms            11F   KeyPadPico.psm
   delay_1ms             123   KeyPadPico.psm
   wait_1ms              125   KeyPadPico.psm
 * delay_50us            12D   KeyPadPico.psm
   wait_50us             12E   KeyPadPico.psm
   delay_1us             132   KeyPadPico.psm
   wait_1us              133   KeyPadPico.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             50
 STAR              -

 AND              13
 OR                1
 XOR               1

 ADD              13
 ADDCY             2
 SUB               7
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          28
 COMPARECY         -

 SL0               4
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               5
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT            11
 OUTPUT           26
 OUTPUTK           -

 STORE            17
 FETCH            17

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             28
 JUMP@             -
 CALL             44
 CALL@             -
 RETURN           29
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
