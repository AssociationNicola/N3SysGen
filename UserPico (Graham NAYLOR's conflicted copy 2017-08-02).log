KCPSM6 Assembler log file for program 'Z:\home\gnaylor\Dropbox\N3SysGen\UserPico.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 04 Mar 2017
Assembly timestamp: 16:57:14

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 374 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 885
Memory locations available: 3211


Assembly listing

 Addr Code                        Instruction

 000                              ;GV08 lower audio volume control to about 0.8V (Prod7)
 000                              ;GV07 correct incorrect data archive and demod peak display problem (MSB/LSB mixup!)
 000                              ;GV06 Increase output amplitude of SSB in DSPpico on TX
 000                              ;GV05 Modified frequencies (MMCM and KeypadPico values) to work with 33.333MHz clock for production model (Apr 2012)
 000                              ;GV04 Now using mic preamp so need to fix AGCs
 000                              ;GV03 Mods to DSP to try and get volume load and saturate OutAmp properly
 000                              ;GV02 Halved AGC thresholds to avoid clipping SysGen v1.18
 000                              ;GV01 add redirect command SW for UART to patch through to BT module
 000                              ;GV01 Reduce Speaker volume AGC on startup
 000                              ;GV00 Reset GV to 0 for new TE0722 working version
 000                              ;GVA5 for TE0722, with RX/TX frequencies adjusted for 32.768MHz
 000                              ;GVA4 corrected DSPprog to not crash (AGC suddenly dropping)
 000                              ;GVA2 send demod level to LCD display
 000                              ;GVA0 Add temporary measures around line 510 to transmit values from DSPpico (of tone demod levels as ascii characters on to the LCD)
 000                              ;GV9A, correct Earth Loop setting incorrect and make immediate.
 000                              ; GV99 corrected Attenuator not adding 30 on level display in TX mode, add turn on pad and entenna select
 000                              ; GV98 More BT mic boost
 000                              ; GV97 corrected BT combination
 000                              ; GV96 drop ADC gain RX to 70% and TX to 50%
 000                              ; GV95 Frequency now set from keypad pico
 000                              ; GV94  24 Feb 2015 Pete  -  re-enable BT commands and add scratchpad clear
 000                              ; GV93 add code in KP pico and firmware to display ADC and demod level
 000                              ; GV92 add Pete's new BTcode with shorter inquiry time - but hadn't put in the script at the end of model propertes to get the correct mem files from Pete
 000                              ; line407 disable loran blank for 31kHz
 000                              ; GV91 increased ADC level 10dB by increasing RXAGClevel
 000                              ; GV90 Version to run at 31.008kHz so use 1323 ($52B) for TX and 10925 ($2AAD) for RX
 000                              ; GV51 Use DSP 51 to only attenuate on receive (which had clipping - but transmit was OK)
 000                              ; GV50 Adjusted DSP AGC back down as there was still clipping
 000                              ; GV4F Adjusted AGC thresholds in SP3E and DSPprogN3GV47 to improve clarity of speech
 000                              ; GV4D PMOD2 now used to control extra attenuation (~30dB)
 000                              ; GV4C back to TX_LOW but PMOD1 held low
 000                              ; GV4B For proto D with TX_high  output instead of TX_LOW
 000                              ; GV4A For ProtoD with new keypad
 000                              ; GV48 changed CheckADClevel routine - but still need to change display (KP pico code) to display signal level and gain value. No Beacon
 000                              ; GV46 BT present cuts audio - modified BT detect logic
 000                              ; GV45 Corrected resetting of AveSignalMSB to middle value so as to avoid double jump and increased allowable rang to avoid unnecessary jumps
 000                              ; GV44 Add SU command to set UART output streaming
 000                              ; GV43 Correct beacon phase wander in DSP pico code
 000                              ; GV42 As 41 but with UART testing bits removed
 000                              ; GV41 send DSP data to UART in normal loop and streaming loop
 000                              ; GV40 correct streaming mode bits and shift beacon mode check to end of loop
 000                              ; GV3F  Add UART streaming command for transmit - SS<xx> where xx is hex value of number of bits to shift the values Add GL command to get Loran blank rate
 000                              ; GV3E some work on AGCcounter to include sinewave addition, but mainly add command GS to get AveSignalMSB
 000                              ; GV3D change the way the AGC works in the DSP pico to speed up increasing attenuation if the signal is very strong
 000                              ; GV3C change pincode in BTText to 1234 for HFP profile
 000                              ; GV3A send prompt to DSPcore to grab AGCvalue and store just before the EOT warble + store ADCgain (lower 4 bits) for TX and RX modes (that will be used by CALL SetAnGain )
 000                              ; GV39 Includes Pete's BT code and new DSP AGC stuff (from GV38)
 000                              ; GV36 reduce initial ADC gain on tranmit (reduce mic gain)
 000                              ; GV35 Uses nw I_Q demodulator
 000                              ; GV33 Add delay to audio stream (reduce fdbk?) and use phase incrementing on TX.
 000                              ; GV32 Adjust AGCs
 000                              ; GV31 Now starting to use LPF in DSPprogN3WithLPF and has SL command to set Loran Blanking (SL01)
 000                              ; GV30 reduce RX ADC gain and increase TX (mic) gain.
 000                              ; GV27 Default Loran Blanking on
 000                              ; GV26 for N2 with Higher gain on DSP RF output and shorter beacon period
 000                              ; GV24 for N2
 000                              ; GV23 Corrected some of the RAM block writing issues
 000                              ; GV22 Correct loop not completing when no character! Now displays ADC gain setting on
 000                              ; GV21 use with keypad prog to inhibit pad scan and here send adc level info (should auto gain on ADC to keep between 30 and 100 ie ~$20 and ~$60)
 000                              ; GV20 Corrected non switching of ADC input to MIC!
 000                              ; GV1F Normal orientation of ADC inputs with auto BT audio switching
 000                              ; GV1E temporarily switch ADC input channel as op amp blown!
 000                              ; GV1D Heyphone but for prototype 2 (using TX_HIGH!!)
 000                              ; GV1C For HeyPhone
 000                              ; GV1A Correct flash writing errors to point to right memory address
 000                              ; GV1A
 000                              ; GV19 corrected phase interpretation of SSB encoding
 000                              ; GV18 Try dirac input
 000                              ; GV17 Add STT command to send test sinewave for transmit - Now removed March 2012
 000                              ; GV16 Worked on Beacon lockup, now starts with beacon, press button for ~6secs
 000                              ; GV14 try beacon again at startup
 000                              ; GV15 try to fix not stopping beacon issue (don't start with beacon!) - display mode value on LCD (send to KPpico)
 000                              ; GV13 no beacon
 000                              ; GV11 fix beacon mode so that DSP is blocked at frequency offset and fixed amp for ~1s when ending TX mode - also set Beacon mode on power up which stops when button pressed
 000                              ; Set ADC gain in initialisation properly to calibrate aswell.
 000                              ; GV10 Add ADC signal level monitoring and try phase SSB encoding again with 2x phase to SSB module
 000                              ; Command GL in version GV10 allows the signal level to be returned from the ADC
 000                              ; GV0F Use phase encoding
 000                              ; GV0E full 16 bit frequency coding of TX 29/8/11
 000                              ; GV0D With Beacon
 000                              ; GV0C add BT mic input
 000                              ; GV09 stopped sending r/T t seria; port an adjusted reading from KPfifo
 000                              ; GV08 Added facility to switch RX/TX from keypad
 000                              ; GV07  Increased sensitivity of touch pads June 11
 000                              ; May 26- try and modify so that it starts correctly when powerred up with user program
 000                              ; MayA 11 use PMOD 2 to switch serial port and activate keypad
 000                              ; May 11, add SAO command to set audio channel (00, for BT, 01 for radio transceiver)
 000                              ; March 2011 testing SPI interface:
 000                              ; commands
 000                              ; WREN $06 (enable writing)
 000                              ; WRDI $04 (disable writing)
 000                              ; FAST_READ $0B followed by 3 address bytes, 1 dummy byte and then n bytes to feed back data and leave last 2 values for readback
 000                              ; BERASE  $C7 (bulk erase) - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                              ; SE     $D8 (sector erase) followed by 3 address bytes, - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                              ; PP     $02 (page program) followed by 3 address bytes,  then n bytes of data to be written (need then to pulse Send2Flash by writing 16 to ProgramM)
 000                              ;
 000                              ; Example commands:
 000                              ; SMW0102030405060708090A     -writes values 1-10 to flash addresses from 800000
 000                              ; SMR800002 should read the bytes 03 and 02 ??
 000                              ; Now for Godil Board
 000                              ; Version for multi pico boot with shifted bit offsets on oport
 000                              CONSTANT Versionno, 87               ; special 1 July 2016
 000                              CONSTANT InitialVolume, 133'd        ;lowerred volume
 000                              CONSTANT MinoxrVersionno, EE         ; Pete
 000                              ; CONSTANT TXType,       7E                 ; $7E for N2 and $80 for Heyphone
 000                              ; CONSTANT RXType,       46                 ; $46 for N2 and 55 for Heyphone)
 000                              CONSTANT Bmode, 00
 000                              ; Set thresholds for AGC
 000                              CONSTANT AGCupperRX, 32              ; Increased factor 2 on RX and TX with signal level monitor - increased RX 3 again from $18 (24 to 72, ie $48)
 000                              CONSTANT AGClowerRX, 12              ; was $0C, increased to 36=$24
 000                              CONSTANT AGCupperTX, 10
 000                              CONSTANT AGClowerTX, 06
 000                              ; SAI Set analogue input SAI<xx>  xx=00 or 01
 000                              ; SAO Set audio Output source
 000                              ; SAS Set archive source SAS<xx>
 000                              ; SAG Set analogue gain SAG<xx>
 000                              ; SB set beacon mode
 000                              ; SRM set receive mode
 000                              ; SRF set receive frequency
 000                              ; STM set transmit mode
 000                              ; STF set transmit frequency
 000                              ; SAG   Set analogue gain, use: 51-5E + automatic calibration
 000                              ; SAS <value> - set archive source (0 or 1)
 000                              ; GA get archive
 000                              ; GT get status of touch
 000                              ; GV get version
 000                              ; GP get response from DSP
 000                              ; GB get response from BT
 000                              ; GKT get touch response from KP
 000                              ; March 2009, now using loading over BT, implement server commands
 000                              ; Dec 2008 - implementing on SSBN3.mdl
 000                              ; Test Spartan 3e board May 2007
 000                              ; Program for user interface: Pico 1
 000                              ; Load SP3E with bit file - spartan3e_adcrx_tx_cw.bit using USB download cable (+ImpacT)
 000                              ; Connect serial lead and send file for test program from Matlab using somethng like
 000                              ; LCDtestprog=getpblazidefile('LCDUartS3e.mem');
 000                              ; Send6bitInstructionsPico1
 000                              ;
 000                              ; Addresses of latched data
 000                              ; 0 Cmd Control Pico2
 000                              ; 1 UartTx
 000                              ; 2 Gain ChA (bits 0-2)
 000                              ; Gain ChB(bits 4-6)
 000                              ; 3 Instruction first 6bits (MSB)
 000                              ; 4 Instruction 2nd 6 bits
 000                              ; 5 Instruction 3rd 6 bits
 000                              ; 6 Program Address LSB
 000                              ; 7 Program Address upper 2 bits
 000                              ;  bit 2,3 and 4 decoded to either Write ROM1,Write ROM2,Write ROM3,Write ROM4 or reset picos
 000                              ;  bit 5-Enable archive
 000                              ;  bit 6-Select archive source
 000                              ;  bit 7 TX_HIGH
 000                              ; 10 Set_RXFreq LSbyte
 000                              ; 11 Set_RXFreq USbyte
 000                              ; 12 Set_TXFreq LSbyte
 000                              ; 13 Set_TXFreq USbyte
 000                              ; 14 Message character 1 -***Note these data ports are for writing characters at the address bus to the message RAM!!
 000                              ; 15 Message character 2
 000                              ; 16 Message character 3 - RAM is written on write to this port (last 6 bit character)
 000                              ; 17 Relay ctrl
 000                              ; 18 Battery monitor
 000                              CONSTANT delay_1us_constant, 12'd    ; Now 49.152MHz Value (13)19 or 12? decimal suitable for 50MHz clock or about 6 for 33MHz?
 000                              CONSTANT WREN, 06                    ; (enable writing)
 000                              CONSTANT FAST_READ, 0B               ; followed by 3 address bytes, 1 dummy byte and then n bytes to feed back data and leave last 2 values for readback
 000                              CONSTANT BERASE, C7                  ; (bulk erase) - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                              CONSTANT SER, D8                     ; (sector erase) followed by 3 address bytes, - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                              CONSTANT RDID, 9F
 000                              CONSTANT PP, 02                      ; (page program) followed by 3 address bytes,  then n bytes of data to be written (need then to pulse Send2Flash by writing 16 to CMD2DSP)
 000                              CONSTANT RDSR, 05
 000                              ; Registers
 000                              ;counter             EQU       sC                  ; Counter - for Acquisitions
 000                              ;ScratchPointer      EQU       sB                  ; pointer for decoding command in scratch memory
 000                              NAMEREG sC, counter                  ; Counter - for Acquisitions
 000                              NAMEREG sB, ScratchPointer           ; pointer for decoding command in scratch memory
 000                              ; Scratch pad
 000                              ; Locations 0-15 reserved for incoming command
 000                              CONSTANT Latch7, 16'd                ; This is the current value of an output control register (ProgramM) - used to control writing etc.
 000                              CONSTANT LastDSPbyte, 17'd
 000                              CONSTANT Mode, 18'd                  ; N3 status: bit 0 Beacon mode, bit 1 RX/TX mode, bit 2 Uart streaming mode (TX), bit 3 RX to UART streaming, bit 4 to set loop antenna input
 000                              CONSTANT ADCstate, 19'd              ; saves ADC state
 000                              CONSTANT SelectScratch, 20'd         ; used to store selections (archive source etc.)
 000                              CONSTANT ADCLevel, 21'd
 000                              CONSTANT ADCgain, 22'd               ; 0 means no output, 0E is max gain of 128. Upper 4 bits contain ADC config data
 000                              CONSTANT TX_F_MSB, 23'd              ; Store TX req (16 bits)
 000                              CONSTANT TX_F_LSB, 24'd
 000                              CONSTANT ADCAGCUpperThreshold, 25'd  ; Sets value for AGC on RAW input
 000                              CONSTANT ADCAGCLowerThreshold, 26'd  ; Sets value for AGC on RAW input
 000                              CONSTANT ADCGainTX, 27'd             ; Analogue gain for TX
 000                              CONSTANT ADCGainRX, 28'd             ; Analogue gain for RX
 000                              CONSTANT peteTXMode, 40'd            ; Pete's transmit mode flag
 000                              ;removed Attenuator state
 000                              ;;CONSTANT BluetoothXmit,   43                 ; from Pete's build - assumes large scratchpad
 000                              ; Input port
 000                              CONSTANT Uart_rx, 00
 000                              CONSTANT Uart_status, 01             ; Uart RX data bit0, Uart TX half full bit 1
 000                              ; bits 2:
 000                              ; Bit 2 BattMon comparator
 000                              ; Offsets:
 000                              CONSTANT BattMon, 4'd
 000                              CONSTANT ArchiveDataLSB, 2'd
 000                              CONSTANT ArchiveDataMSB, 3'd
 000                              CONSTANT DSPcmd, 4'd                 ; message from DSP unit
 000                              CONSTANT BTcmd, 5'd                  ; message from BT unit
 000                              CONSTANT KPcmd, 6'd                  ; message from KeyPad unit
 000                              CONSTANT TDcmd, 7'd                  ; message from Tone detect
 000                              ;CONSTANT DataReadback_1,  8'd                   ; message from KeyPad unit TEMP - DataReadback_1 from Flash
 000                              CONSTANT DSPRAMrdbkMSB, 9'd
 000                              CONSTANT DSPRAMrdbkLSB, 10'd
 000                              CONSTANT BTRAMrdbkMSB, 11'd
 000                              CONSTANT BTRAMrdbkLSB, 12'd
 000                              CONSTANT KPRAMrdbkMSB, 13'd
 000                              CONSTANT KPRAMrdbkLSB, 14'd
 000                              CONSTANT ADCSignalLevel, 15'd
 000                              ; Output ports
 000                              CONSTANT CMD2DSP, 00                 ; ALSO USED for data to write to SPI flash (sends write automatically)
 000                              CONSTANT UART_TX, 01
 000                              CONSTANT GainPD, 02                  ; Lower 4 bits: 1=0 gain to E=gain 128, bits 4-6 should be 101 and bit 7 is for calibration
 000                              ; Lower 4 bits gain, bits 4-6 for PD0-2 - PD bits should be set to 0101 (ie 5 hex) to enable everything
 000                              CONSTANT Instructiona, 03
 000                              CONSTANT Instructionb, 04
 000                              CONSTANT Instructionc, 05
 000                              CONSTANT ProgramL, 06
 000                              CONSTANT ProgramM, 07
 000                              ; bits 0 and 1 for address, subsequent 4 bits to select which pico to write (bits 2,3,4,5 decoded) - these 3 bits are decoded such that:
 000                              ; if bits 2:5 represent:
 000                              ; 1 - Write Inst1 (User pico instruction) - ie MSB of address should be ORed with 4.
 000                              ; 2 - Write Inst2 (DSP pico instruction) - ie MSB of address should be ORed with 8.
 000                              ; 3 - Write Inst3 (BT pico instruction) - ie MSB of address should be ORed with $0C.
 000                              ; 4 - Write Inst4 (KP pico instruction)
 000                              ; 5 - Write DSP RAM
 000                              ; 6 - Write BT RAM
 000                              ; 7 - Reset other picos
 000                              ; 8 - Write KP RAM
 000                              ; 9 - Send Flash fifo contents (written to on FlashDATA port) to FLASH chip
 000                              ; bit 6 enable archive, and bit 7 TXhigh
 000                              ;
 000                              CONSTANT EnArchive, 64'd
 000                              CONSTANT TX_HIGH, 128'd              ; bit 7
 000                              CONSTANT SelectArchiveSource, 8'd
 000                              CONSTANT Configure, 9'd
 000                              CONSTANT RXFreqMSB, 10'd             ; 769A for 88.956kHz ie 86.956kHz carrier and allow range up to 154kHz
 000                              CONSTANT RXFreqLSB, 11'd
 000                              CONSTANT AudioVolume, 12'd           ; Initialy 141
 000                              CONSTANT Tone, 13'd                  ; Carrier increment to cause a tone modulation on TX
 000                              CONSTANT Acknowledge, 14'd
 000                              ; offsets:
 000                              CONSTANT DSPFifo, 16'd
 000                              CONSTANT BTFifo, 32'd
 000                              CONSTANT KPFifo, 64'd
 000                              CONSTANT TDFifo, 128'd
 000                              ; Set bit 4,5,6,7 to acknowledge FIFO of DSP,BT, Keypad, Tone Detect (ie write 16,32, 64 or 128)
 000                              CONSTANT FlashData, 17'd
 000                              ; CONSTANT BatteryMon,   18'd
 000                              CONSTANT ADCstate_port, 19'd         ; Lower 5 bits are not used, bit 6 indictes which ADC channel is read
 000                              ; offset of port 19
 000                              CONSTANT LoranBlank, 16'd            ; $10
 000                              CONSTANT AudioOutSelect, 32'd
 000                              CONSTANT AnalogueChannel, 64'd       ; bit 6
 000                              CONSTANT CMD2BT, 20'd
 000                              CONSTANT CMD2KP, 21'd
 000                              CONSTANT RAMDataMSB, 22'd            ; To send to KP, DSP or BT picos
 000                              CONSTANT RAMDataLSB, 23'd            ; To send to KP, DSP or BT picos
 000                              CONSTANT RAMwriteControl, 25'd
 000                              ; ;; Pete - Bluetooth
 000                              CONSTANT TRANSMIT_ON, 14             ; BT -> User
 000                              CONSTANT TRANSMIT_OFF, 15            ; BT -> User
 000                              ;GenerateCode        MEM       "S3eUser_interface.mem"
 000                              ; Start of test program Must send $40,$50 over serial port to initiate if not re-programming!
 000  22021                 boot: JUMP 021[cold_start]
 001                       start: 
 001  2001B               reboot: CALL 01B[GetByte]
 002  1D140                       COMPARE s1, 40[64'd]                 ; do we have for start byte (64 )
 003  32007                       JUMP Z, 007[DoUserProg]
 004  1D141                       COMPARE s1, 41[65'd]
 005  3E022                       JUMP NC, 022[ProgDSP]                ; This will actually write DSP or other prog (start byte =65 or greater) aargh 27/8/10 - was JUMP Z....
 006  22001                       JUMP 001[reboot]
 007  01704           DoUserProg: LOAD s7, 04
 008  01220                       LOAD s2, 20[32'd]
 009  01300                       LOAD s3, 00                          ; s2 (LSB),s3(USB) of prog counter of first address of new program!
 00A  2001B              GetProg: CALL 01B[GetByte]
 00B  1D150                       COMPARE s1, 50[80'd]                 ; 80 ($50) indicates end of program
 00C  32021                       JUMP Z, 021[cold_start]              ; When end of prog byte 80 is received
 00D  2D103                       OUTPUT s1, 03[Instructiona]
 00E  2001B                       CALL 01B[GetByte]
 00F  2D104                       OUTPUT s1, 04[Instructionb]
 010  2001B                       CALL 01B[GetByte]
 011  2D105                       OUTPUT s1, 05[Instructionc]          ; write 3x 6bits to latches ready for instruction write
 012  2D206                       OUTPUT s2, 06[ProgramL]
 013  2D307                       OUTPUT s3, 07[ProgramM]              ; Load memory address to write (starting from 32!)
 014  00470                       LOAD s4, s7                          ; Set bit 2 to perform write to RAM 1 or bit 3 to write RAM 2 depending whether start byte was 64 or 65
 015  2D419                       OUTPUT s4, 19[RAMwriteControl]
 016  01400                       LOAD s4, 00
 017  2D419                       OUTPUT s4, 19[RAMwriteControl]       ; Set write line back to zero
 018  11201                       ADD s2, 01
 019  13300                       ADDCY s3, 00                         ; Increment program counter
 01A  2200A                       JUMP 00A[GetProg]                    ; Get next instruction
 01B  09001              GetByte: INPUT s0, 01[Uart_status]            ; Is there a byte available?
 01C  03001                       AND s0, 01
 01D  1D001                       COMPARE s0, 01
 01E  3601B                       JUMP NZ, 01B[GetByte]                ; until there is a byte in the input buffer!
 01F  09100                       INPUT s1, 00[Uart_rx]
 020  25000                       RETURN 
 021  01000           cold_start: LOAD s0, 00                          ; Note the label 'ProgDSP' is only to allow re-boot to work!
 022                     ProgDSP: 
 022                              ; need to clear scratchpad
 022  01100                       LOAD s1, 00
 023                ScratchClear: 
 023  2E010                       STORE s0, (s1)                       ; zero location
 024  11101                       ADD s1, 01                           ; next
 025  1D100                       COMPARE s1, 00                       ; do all 256 bytes
 026  36023                       JUMP NZ, 023[ScratchClear]           ;
 027                              ;LOAD   s5,83      ;value for 'S'
 027                              ;CALL      Byte2UART
 027                              ;CALL      Byte2UART     ;send 'SS' to 'Uart' - ie ARM
 027                              ;CALL      SendCRLF            ; added to allow get line to read OK
 027                              ;LOAD      s6, 42'd             ; *
 027                              ;CALL      Send2UartTX
 027                              ;LOAD      s6, 43'd             ; +
 027                              ;CALL      Send2UartTX
 027                              ;CALL      SendCRLF            ; added to allow get line to read OK
 027  0160A                       LOAD s6, 0A                          ; ensure FIFO is flushed
 028  2033C                       CALL 33C[Send2UartTX]
 029  01B00                 init: LOAD sB[ScratchPointer], 00
 02A  01000                       LOAD s0, 00
 02B  2F010                       STORE s0, 10[Latch7]                 ; initialise latch 7 bits!
 02C  01553                       LOAD s5, 53                          ; gain to lowish
 02D  2F516                       STORE s5, 16[ADCgain]                ; save initial value
 02E  2F51C                       STORE s5, 1C[ADCGainRX]              ; save initial value for RX
 02F  2010B                       CALL 10B[SetAnGain]                  ; set gain and calibrate
 030  01559                       LOAD s5, 59                          ; gain to lowish
 031  2F51B                       STORE s5, 1B[ADCGainTX]              ; save initial value forTX
 032                              ;Frequency of TX/RX now set by keypad pico
 032  01032                       LOAD s0, 32[AGCupperRX]
 033  2F019                       STORE s0, 19[ADCAGCUpperThreshold]
 034  01012                       LOAD s0, 12[AGClowerRX]
 035  2F01A                       STORE s0, 1A[ADCAGCLowerThreshold]
 036  200C3                       CALL 0C3[RX]                         ; set receive mode
 037  01100                       LOAD s1, 00
 038  20317                       CALL 317[ArchiveSource]
 039  2031E                       CALL 31E[EnableArchive]
 03A  01085                       LOAD s0, 85[InitialVolume]           ;set lowish audio volume
 03B  2D00C                       OUTPUT s0, 0C[AudioVolume]
 03C  2035D                       CALL 35D[delay_100ms]
 03D  01020                       LOAD s0, 20[AudioOutSelect]          ; + 16; normal ADC channel, AudioOUtSelect doesn't do anything here! The 16also sets Loran Blanking if in firmware.
 03E  2F013                       STORE s0, 13[ADCstate]               ; save
 03F  2D013                       OUTPUT s0, 13[ADCstate_port]         ; Also sets analogue input to 0
 040                   startLoop: 
 040  01B00                       LOAD sB[ScratchPointer], 00
 041  2006C                 loop: CALL 06C[CheckADClevel]
 042  0B012                       FETCH s0, 12[Mode]
 043  03004                       AND s0, 04                           ; look at streaming bit
 044  1D004                       COMPARE s0, 04
 045  32197                       JUMP Z, 197[isSSloop]                ; if streaming TX mode, then send a Uart character and return (but will not be able to interpret any command so is stuck!)
 046  0B012                       FETCH s0, 12[Mode]
 047  03008                       AND s0, 08                           ; look at streaming RX bit
 048  1D008                       COMPARE s0, 08
 049  302B3                       CALL Z, 2B3[Check4CmdfromDSP]        ; If fifo character then send to terminal !!!!!!!!!!!!!!!!!!!! reinstate this 9/7/2013
 04A  302C1                       CALL Z, 2C1[Check4CmdfromTD]         ; If fifo character then send to terminal
 04B  202BC                       CALL 2BC[Check4CmdfromKP]
 04C  1D680                       COMPARE s6, 80[128'd]
 04D  380A8                       CALL C, 0A8[checkrqst]
 04E                              ; Re-enable Beacon mode
 04E  0B012                       FETCH s0, 12[Mode]
 04F                              ;      OUTPUT    s0,CMD2KP      ;send value to LCD for display - send adc level data instead
 04F  03001                       AND s0, 01                           ; only interrested in bit0
 050  1D001                       COMPARE s0, 01                       ; Is it beacon mode?
 051  30289                       CALL Z, 289[BeaconBeep]
 052                              ; Pete  enabled 24 Feb 2015 - inhibit in tonedetect
 052                              ;                    CALL      Check4CmdfromBT     ; receive from BT and echo to terminal
 052                              ;                    JUMP      C, HandleBTCommand  ; If less than 128 there is a value to give back and display.
 052                              ;HandleBTCommand_Done:
 052                              ; pete end
 052  20299                       CALL 299[getUARTchar]
 053                              ;COMPARE      s6, 32'd
 053                              ;JUMP      Z, loop             ; If a space then skip
 053                              ; Had mistankenly changed the next line!
 053  1D6FF                       COMPARE s6, FF
 054  32041                       JUMP Z, 041[loop]                    ; If no character then skip-MAKE SURE ANYTHINGTO BE PERFORMED REGULARLY IS DONE BEFORE THIS POINT
 055  1D60D                       COMPARE s6, 0D[13'd]
 056  32116                       JUMP Z, 116[interpcommand]           ; This is end of command character
 057  1D60A                       COMPARE s6, 0A[10'd]
 058  32041                       JUMP Z, 041[loop]                    ; If c/r ignore
 059  1DB10                       COMPARE sB[ScratchPointer], 10[16'd] ; Check we are not writing too many characters to the scratchpad
 05A  3E041                       JUMP NC, 041[loop]                   ; don't write to scratch if Pointer (counter) 16 or above
 05B  2E6B0                       STORE s6, (sB[ScratchPointer])       ; Save command character
 05C  11B01                       ADD sB[ScratchPointer], 01           ; is a command char so increment
 05D  22041                       JUMP 041[loop]
 05E                SendADCToARM: 
 05E  0B128                       FETCH s1, 28[peteTXMode]
 05F  1D101                       COMPARE s1, 01
 060  35000                       RETURN NZ                            ; do not send unless transmitting
 061  01626                       LOAD s6, 26["&"]
 062  2033C                       CALL 33C[Send2UartTX]                ; send the &
 063  01665                       LOAD s6, 65["e"]                     ; indicates 'earthing' quality
 064  2033C                       CALL 33C[Send2UartTX]                ; send the &
 065                              ; Byte2Chars takes data in s5 and returns two ascii codes in s6,s7
 065                              ;(s7 is character for lower 4 bits) sent as second character
 065  00500                       LOAD s5, s0
 066  202F1                       CALL 2F1[Byte2Chars]
 067  2033C                       CALL 33C[Send2UartTX]                ; send the upper ADC value
 068  00670                       LOAD s6, s7
 069  2033C                       CALL 33C[Send2UartTX]                ; send the lower ADC value
 06A  20347                       CALL 347[SendCRLF]
 06B  25000                       RETURN 
 06C  0900F        CheckADClevel: INPUT s0, 0F[ADCSignalLevel]
 06D  0B115                       FETCH s1, 15[ADCLevel]
 06E  1C010                       COMPARE s0, s1
 06F  31000                       RETURN Z                             ; return if the value is still the same (ie wait for new value)
 070                              ;__________________________________________________
 070                              ;TEMPORARY SKIP to TEMPskip:  (values will be redirected directly from DSP to KP in
 070                              ;      JUMP  Tempskip NOTnow 19 sep 2015
 070                              ;____________________________________________________
 070  0117F                       LOAD s1, 7F                          ; Note top bit is not received! Send command to expect signal level
 071                              ;OUTPUT       s1, CMD2KP          ; send ADCgain value to LCD for display
 071  2F015                       STORE s0, 15[ADCLevel]               ; save new value of ADClevel
 072  2005E                       CALL 05E[SendADCToARM]               ; send to ARM
 073                              ; Code to send a value for display as 2 decimal digits in the range 00 to 74 (~42dB) representing the broad band signal strength (5 units per gain step, 1 unit per 8 units of ADC level
 073                              ; assuming ADClevel kept betweeen $18 and $40, signal level within range covers ~8dB, display about 1.7 x value in dB in steps of 2 (~1.2dB)
 073  0B116                       FETCH s1, 16[ADCgain]
 074  0310F                       AND s1, 0F                           ; Gain level just in lower 4 bits
 075  0120E                       LOAD s2, 0E
 076  18210                       SUB s2, s1                           ; Invert gain level to signal level ie highest gain of $E becomes zero
 077  01100                       LOAD s1, 00                          ; use this as counter for lower decimal digit
 078  1420E                       SR0 s2                               ; half the value and send half to the carry flag (to add 5)
 079  3E07B                       JUMP NC, 07B[nofive]                 ; only add 5 to lower digit if carry set
 07A  01105                       LOAD s1, 05[5'd]
 07B  1D010               nofive: COMPARE s0, 10[16'd]                 ; skip if below first step (about 1.2dB)
 07C  3A07E                       JUMP C, 07E[First]
 07D  11102                       ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 07E  1D012                First: COMPARE s0, 12[18'd]                 ; skip if below second step (about 1.2dB)
 07F  3A081                       JUMP C, 081[Second]
 080  11102                       ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 081  1D015               Second: COMPARE s0, 15[21'd]                 ; skip if below third step (about 1.2dB)
 082  3A084                       JUMP C, 084[Third]
 083  11102                       ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 084  1D018                Third: COMPARE s0, 18[24'd]                 ; skip if below
 085  3A087                       JUMP C, 087[Fourth]
 086  11102                       ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 087  1D01C               Fourth: COMPARE s0, 1C[28'd]                 ; skip if below
 088  3A08A                       JUMP C, 08A[Fifth]
 089  11102                       ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 08A                              ; now check if s1 (lower decimal digit) is above 9
 08A  1D10A                Fifth: COMPARE s1, 0A[10'd]
 08B  3A08E                       JUMP C, 08E[ToLCD]
 08C  11201                       ADD s2, 01[1'd]                      ; Add 1 to first decimal digit
 08D  1910A                       SUB s1, 0A[10'd]                     ; subtract 10 from lower digit
 08E                              ;Deleted part that tried to apply attenuator
 08E                       ToLCD: ;OUTPUT       s2, CMD2KP          ; Send first decimal digit (as binary value 0-7)
 08E                              ;OUTPUT       s1, CMD2KP          ; send second decimal digit (as binary value for 0-9)
 08E                              ; s0 should hoperfully still have ADCsignal level!
 08E                              ;_______________________________
 08E                              ;Temp bit
 08E                    Tempskip: 
 08E                              ;_____________________________________
 08E                              ; LOAD      s5, s0
 08E                              ;      ;CALL      Byte2UART    ;and echo to UART  - not now!
 08E  0B119                       FETCH s1, 19[ADCAGCUpperThreshold]
 08F  0B015                       FETCH s0, 15[ADCLevel]               ; had lost the s0 value at this point!
 090  1C010                       COMPARE s0, s1                       ; aim to keep value around $15? - need to drop this further! Needs to be lower for transmission??
 091  3C096                       CALL NC, 096[ReduceADCgain]
 092  0B11A                       FETCH s1, 1A[ADCAGCLowerThreshold]
 093  1C010                       COMPARE s0, s1                       ; aim to keep value around $15? -
 094  3809F                       CALL C, 09F[IncreaseADCgain]
 095  25000                       RETURN 
 096  0B016        ReduceADCgain: FETCH s0, 16[ADCgain]
 097  00100                       LOAD s1, s0
 098  0310F                       AND s1, 0F                           ; mask lower 4 bits
 099  1D101                       COMPARE s1, 01                       ; don't drop to zero!
 09A  31000                       RETURN Z
 09B  19001                       SUB s0, 01[1'd]
 09C  2F016                       STORE s0, 16[ADCgain]
 09D  2D002                       OUTPUT s0, 02[GainPD]                ; set ADC pre-amp
 09E                              ; OUTPUT       s0, CMD2KP          ; send value to LCD for display - don't bother
 09E  25000                       RETURN 
 09F  0B016      IncreaseADCgain: FETCH s0, 16[ADCgain]
 0A0  00100                       LOAD s1, s0
 0A1  0310F                       AND s1, 0F                           ; mask lower 4 bits
 0A2  1D10E                       COMPARE s1, 0E                       ; don't go past $0E!
 0A3  31000                       RETURN Z
 0A4  11001                       ADD s0, 01[1'd]
 0A5  2F016                       STORE s0, 16[ADCgain]
 0A6  2D002                       OUTPUT s0, 02[GainPD]                ; set ADC pre-amp
 0A7                              ; OUTPUT       s0, CMD2KP          ; send value to LCD for display
 0A7  25000                       RETURN 
 0A8                              ;Delete setting and resetting Attenuator (March 2016)
 0A8                   checkrqst: ;COMPARE      s6, "r"    ;character_r
 0A8                              ;CALL      Z, checkRXmode
 0A8                              ;COMPARE      s6, "t"   ;character_t
 0A8                              ;CALL      Z, checkTXmode
 0A8                              ;COMPARE      s6, "e"   ;character_e
 0A8                              ;CALL      Z, setEarthAntennas
 0A8                              ;COMPARE      s6, "l"   ; character_l
 0A8                              ;CALL      Z, setLoopAntennas
 0A8  1D626                       COMPARE s6, 26["&"]
 0A9  300AB                       CALL Z, 0AB[SendToARM]
 0AA  25000                       RETURN 
 0AB                   SendToARM: 
 0AB  2033C                       CALL 33C[Send2UartTX]                ; send the &
 0AC  202BC           waitForKey: CALL 2BC[Check4CmdfromKP]
 0AD  1D680                       COMPARE s6, 80[128'd]
 0AE  320AC                       JUMP Z, 0AC[waitForKey]
 0AF  2033C                       CALL 33C[Send2UartTX]                ; send the keypress value
 0B0  20347                       CALL 347[SendCRLF]
 0B1                              ;LOAD      s6, 0D             ; c/r
 0B1                              ;CALL      Send2UartTX   ; send
 0B1                              ;LOAD      s6, 0A             ; only l/f is needed
 0B1                              ;CALL      Send2UartTX   ; send
 0B1  25000                       RETURN 
 0B2  0B012     setEarthAntennas: FETCH s0, 12[Mode]
 0B3  030EF                       AND s0, EF[239'd]                    ; 255-16  ;reset bit 4
 0B4  2F012                       STORE s0, 12[Mode]
 0B5  200F2                       CALL 0F2[setRXmode]                  ;Make active and return to RX
 0B6  25000                       RETURN 
 0B7  0B012      setLoopAntennas: FETCH s0, 12[Mode]
 0B8  05010                       OR s0, 10[16'd]                      ;set bit 4
 0B9  2F012                       STORE s0, 12[Mode]
 0BA  200F2                       CALL 0F2[setRXmode]
 0BB  25000                       RETURN 
 0BC                 checkRXmode: 
 0BC                              ; ;; Pete added for Bluetooth (temp)
 0BC                              ;FETCH     s0, BluetoothXmit
 0BC                              ;ADD       s0, 00
 0BC                              ;RETURN       NZ                  ; do nothing if BT transmitting
 0BC                              ; ;; end Pete added for BT
 0BC                              ;FETCH     s0, Mode
 0BC                              ;AND       s0, 02               ; mask bit 1
 0BC                              ;COMPARE      s0, 02               ; is it set ie currently in TX mode?
 0BC                              ;RETURN       NZ                  ; return if already in RX mode return
 0BC  01626                       LOAD s6, 26["&"]
 0BD  2033C                       CALL 33C[Send2UartTX]
 0BE  0165A                       LOAD s6, 5A["Z"]
 0BF  2033C                       CALL 33C[Send2UartTX]
 0C0  20347                       CALL 347[SendCRLF]
 0C1  200F2                       CALL 0F2[setRXmode]                  ; so go ahead and set up RX mode
 0C2  25000                       RETURN 
 0C3                              ; Routine to set receive mode - just basic function ie doesn't set mode etc.
 0C3                          RX: 
 0C3  01530                       LOAD s5, 30[48'd]                    ; Ascii code for '0' - set receive mode
 0C4  2D500                       OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 0C5  0B510                       FETCH s5, 10[Latch7]
 0C6  0357F                       AND s5, 7F[~TX_HIGH]                 ; reset bit 7
 0C7  2F510                       STORE s5, 10[Latch7]
 0C8  2D507                       OUTPUT s5, 07[ProgramM]
 0C9  25000                       RETURN 
 0CA                 checkTXmode: 
 0CA                              ;FETCH     s0, Mode
 0CA                              ;AND       s0, 02               ; mask bit 1 here 2 means TX mode 0 RX mode
 0CA                              ;COMPARE      s0, 00               ; is it not set ie currently in RX mode?
 0CA                              ;RETURN       NZ                  ; return if already in TX mode
 0CA  01626                       LOAD s6, 26["&"]
 0CB  2033C                       CALL 33C[Send2UartTX]
 0CC  01659                       LOAD s6, 59["Y"]
 0CD  2033C                       CALL 33C[Send2UartTX]
 0CE  20347                       CALL 347[SendCRLF]
 0CF  200D1                       CALL 0D1[setTXmode]                  ; so go ahead and set up TX mode
 0D0  25000                       RETURN 
 0D1                              ; need to set scratch pad mode, set RX freq to 0 (SRF0155), et TX freq to 86.95 STF0E7E, input channel with equivalent of SAI01 and send transmit mode command to DSP
 0D1                   setTXmode: 
 0D1                              ;FETCH     s0, Mode
 0D1                              ;OR        s0, 02               ; set TX bit
 0D1                              ;AND       s0, FE             ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 0D1                              ;STORE     s0, Mode
 0D1                              ; LOAD      s0, 01      Don't need this is keypad is sorting it!
 0D1                              ; OUTPUT       s0, RXFreqMSB
 0D1                              ; LOAD      s0, 55
 0D1                              ; OUTPUT       s0, RXFreqLSB       ; drop detection to baseband (for when using wired mic)
 0D1  01001                       LOAD s0, 01
 0D2  2F028                       STORE s0, 28[peteTXMode]
 0D3  0B013                       FETCH s0, 13[ADCstate]
 0D4  05040                       OR s0, 40[AnalogueChannel]           ; set bit 6 (SAI01) - Channel 1 in Matlab GUI
 0D5  2F013                       STORE s0, 13[ADCstate]               ; save
 0D6  2D013                       OUTPUT s0, 13[ADCstate_port]         ; set port to new ADC channel
 0D7  0B516                       FETCH s5, 16[ADCgain]                ; get gain used for RX
 0D8  2F51C                       STORE s5, 1C[ADCGainRX]              ; this value is tracked
 0D9  0B51B                       FETCH s5, 1B[ADCGainTX]              ; gain to last value used for TX
 0DA  2F516                       STORE s5, 16[ADCgain]                ; and make current ADCgain value
 0DB  2010B                       CALL 10B[SetAnGain]                  ; set analogue gain to moderate
 0DC  01010                       LOAD s0, 10[AGCupperTX]
 0DD  2F019                       STORE s0, 19[ADCAGCUpperThreshold]
 0DE  01006                       LOAD s0, 06[AGClowerTX]
 0DF  2F01A                       STORE s0, 1A[ADCAGCLowerThreshold]
 0E0  200EB                       CALL 0EB[TX]
 0E1  20224                       CALL 224[Twotone]                    ; added to give start of message beep
 0E2  01624                       LOAD s6, 24["$"]                     ; c/r
 0E3  2033C                       CALL 33C[Send2UartTX]                ; send
 0E4  01674                       LOAD s6, 74["t"]                     ; c/r
 0E5  2033C                       CALL 33C[Send2UartTX]                ; send
 0E6  0160D                       LOAD s6, 0D                          ; c/r
 0E7  2033C                       CALL 33C[Send2UartTX]                ; send
 0E8  0160A                       LOAD s6, 0A                          ; c/r
 0E9  2033C                       CALL 33C[Send2UartTX]                ; send
 0EA  25000                       RETURN 
 0EB                              ; routine to set transmit mode
 0EB  01531                   TX: LOAD s5, 31[49'd]                    ; Ascii code for '1' - set transmit mode
 0EC  2D500                       OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 0ED  0B510                       FETCH s5, 10[Latch7]
 0EE  05580                       OR s5, 80[TX_HIGH]                   ; set bit 7
 0EF  2F510                       STORE s5, 10[Latch7]
 0F0  2D507                       OUTPUT s5, 07[ProgramM]
 0F1  25000                       RETURN 
 0F2                              ; need to set scratch pad mode, set RX freq to 86.95 (SRF769A or for 87kHz need 76AB), input channel with equivalent of SAI00 and send receive mode command to DSP, set analog gain to 8
 0F2                   setRXmode: 
 0F2                              ;CALL      Warble             ; added to give start of message beep
 0F2  01532                       LOAD s5, 32[50'd]                    ; Ascii code for '2' - DSP to grap the AGCvalue before the warble
 0F3  2D500                       OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 0F4                              ;CALL      Warble             ; added to give start of message beep
 0F4  0B516                       FETCH s5, 16[ADCgain]                ; gain used during TX mode
 0F5  2F51B                       STORE s5, 1B[ADCGainTX]              ; Save for next TX mode
 0F6  20278                       CALL 278[Warble]
 0F7  01000                       LOAD s0, 00
 0F8  2F028                       STORE s0, 28[peteTXMode]
 0F9                              ;FETCH     s0, Mode
 0F9                              ;AND       s0, 252'd    ;255 - 3         ; reset TX bit AND becon on bit
 0F9                              ;STORE     s0, Mode
 0F9                              ; LOAD      s0, 2A             ; $75 for new demodulator   Don't need this from GV95 as keypad sets the frequency
 0F9                              ; OUTPUT       s0, RXFreqMSB
 0F9                              ; LOAD      s0, AD          ; $ N2 or Heyphone)
 0F9                              ; OUTPUT       s0, RXFreqLSB
 0F9                              ;Set ADC channel depending on whether using loop or earth wires (Mode bit 4 set for loop)
 0F9  0B012                       FETCH s0, 12[Mode]
 0FA  03010                       AND s0, 10[16'd]                     ;antenna input select bit (4)
 0FB  14006                       SL0 s0
 0FC  14006                       SL0 s0                               ;to affect bit 6
 0FD  0B113                       FETCH s1, 13[ADCstate]
 0FE  031BF                       AND s1, BF[191'd]                    ; 255 - 64        ; reset  bit 6
 0FF  04100                       OR s1, s0                            ;now affect bit 6 = Mode bit 4 setting
 100  2F113                       STORE s1, 13[ADCstate]               ; save
 101  2D113                       OUTPUT s1, 13[ADCstate_port]         ; set port to new ADC channel
 102  0B51C                       FETCH s5, 1C[ADCGainRX]              ; gain to last value used for RX
 103  2F516                       STORE s5, 16[ADCgain]                ; this value is tracked
 104  2010B                       CALL 10B[SetAnGain]                  ; set analogue gain to moderate
 105  01032                       LOAD s0, 32[AGCupperRX]
 106  2F019                       STORE s0, 19[ADCAGCUpperThreshold]
 107  01012                       LOAD s0, 12[AGClowerRX]
 108  2F01A                       STORE s0, 1A[ADCAGCLowerThreshold]
 109  200C3                       CALL 0C3[RX]
 10A  25000                       RETURN 
 10B                              ; set gain to 32 or is it 48?, enter with gain value in s5 (ie $DA for transmit)
 10B  0350F            SetAnGain: AND s5, 0F                           ; only affect lower 4 bits
 10C  0B016                       FETCH s0, 16[ADCgain]
 10D  030F0                       AND s0, F0                           ; keep upper bits
 10E  04500                       OR s5, s0                            ; combine
 10F  2F516                       STORE s5, 16[ADCgain]                ; save new value (includes all bits)
 110  05580                       OR s5, 80                            ; set bit 7 to start calibration
 111  2D502                       OUTPUT s5, 02[GainPD]
 112  20362                       CALL 362[delay_1ms]                  ; wait for calib
 113  0357F                       AND s5, 7F[127'd]                    ; reset bit 7
 114  2D502                       OUTPUT s5, 02[GainPD]
 115  25000                       RETURN 
 116                              ; Now interpret the command in the Scratch buffer and return to init
 116  01900        interpcommand: LOAD s9, 00                          ; counter through scratchpad addresses.
 117  1C9B0           interploop: COMPARE s9, sB[ScratchPointer]
 118  32040                       JUMP Z, 040[startLoop]               ; break out of loop after reading final character command.
 119  2032C                       CALL 32C[getnextscratchchar]
 11A  1D02A                       COMPARE s0, 2A["*"]                  ; is this a * = command from ARM menu
 11B  32124                       JUMP Z, 124[MsgFromARM]
 11C  1D053                       COMPARE s0, 53[83'd]                 ; is this a S?
 11D  32135                       JUMP Z, 135[isS]
 11E  1D047                       COMPARE s0, 47[71'd]                 ; is this a G?
 11F  32147                       JUMP Z, 147[isG]
 120                              ;      COMPARE      s0, 77'd              ; is this a M?
 120                              ; JUMP      Z, isM
 120  1D05A                       COMPARE s0, 5A[90'd]                 ; is this a Z?
 121  32001                       JUMP Z, 001[reboot]                  ; then go to reboot code (ie to reboot need to send Z<CR>, then do Prog...)
 122  20347                       CALL 347[SendCRLF]
 123  22040                       JUMP 040[startLoop]
 124                  MsgFromARM: 
 124  2032C                       CALL 32C[getnextscratchchar]
 125  1D672                       COMPARE s6, 72["r"]                  ;character_r
 126                              ;CALL      Z, checkRXmode
 126  300F2                       CALL Z, 0F2[setRXmode]
 127  1D674                       COMPARE s6, 74["t"]                  ;character_t
 128                              ;CALL      Z, checkTXmode
 128  300D1                       CALL Z, 0D1[setTXmode]
 129  1D663                       COMPARE s6, 63["c"]                  ;send confidence beep
 12A  30231                       CALL Z, 231[Confidence]
 12B  1D662                       COMPARE s6, 62["b"]                  ;send beacon beep
 12C  30289                       CALL Z, 289[BeaconBeep]
 12D  1D679                       COMPARE s6, 79["y"]                  ;send LCD on to Keypad
 12E  30295                       CALL Z, 295[SendToKeypad]
 12F  1D659                       COMPARE s6, 59["Y"]                  ;send LCD off to Keypad
 130  30295                       CALL Z, 295[SendToKeypad]
 131  1D65A                       COMPARE s6, 5A["Z"]                  ;send turn radio off to Keypad
 132  30294                       CALL Z, 294[SendTurnOffToKeypad]
 133                              ;LOAD      s6, "$"   ;send confidence beep
 133                              ;CALL      Send2UartTX   ; send the keypress value
 133  20347                       CALL 347[SendCRLF]
 134  22040                       JUMP 040[startLoop]
 135  2032C                  isS: CALL 32C[getnextscratchchar]
 136  1D042                       COMPARE s0, 42[66'd]                 ; is this a B?
 137  32163                       JUMP Z, 163[isSB]                    ;
 138  1D041                       COMPARE s0, 41[65'd]                 ; is this a A?
 139  32159                       JUMP Z, 159[isSA]
 13A  1D052                       COMPARE s0, 52[82'd]                 ; is this a R?
 13B  321A9                       JUMP Z, 1A9[isSR]
 13C  1D054                       COMPARE s0, 54[84'd]                 ; is this a T?
 13D  321AF                       JUMP Z, 1AF[isST]
 13E  1D04B                       COMPARE s0, 4B[75'd]                 ; is this a K?
 13F  3216A                       JUMP Z, 16A[isSK]                    ;
 140  1D04C                       COMPARE s0, 4C[76'd]                 ; is this a L?
 141  3216E                       JUMP Z, 16E[isSL]                    ; Set Loran Blanking
 142                              ;      COMPARE      s0, 83'd              ; is this a S?
 142                              ; JUMP      Z, isSS             ;
 142  1D055                       COMPARE s0, 55[85'd]                 ; is this a U
 143  32184                       JUMP Z, 184[isSU]
 144  1D057                       COMPARE s0, 57[87'd]                 ; is this a W
 145  32189                       JUMP Z, 189[isSW]
 146  22040                       JUMP 040[startLoop]
 147  2032C                  isG: CALL 32C[getnextscratchchar]
 148  1D041                       COMPARE s0, 41[65'd]                 ; is this a A?
 149  3221E                       JUMP Z, 21E[isGA]
 14A  1D042                       COMPARE s0, 42[66'd]                 ; is this a B?
 14B  321EF                       JUMP Z, 1EF[isGB]
 14C  1D043                       COMPARE s0, 43[67'd]                 ; is this a C?
 14D  321F7                       JUMP Z, 1F7[isGC]
 14E  1D04B                       COMPARE s0, 4B[75'd]                 ; is this a K?
 14F  321FA                       JUMP Z, 1FA[isGK]
 150  1D04C                       COMPARE s0, 4C[76'd]                 ; is this a L?
 151  32200                       JUMP Z, 200[isGL]
 152  1D056                       COMPARE s0, 56[86'd]                 ; is this a V?
 153  32220                       JUMP Z, 220[isGV]
 154  1D047                       COMPARE s0, 47[71'd]                 ; is this a G?
 155  321DD                       JUMP Z, 1DD[isGG]
 156  1D053                       COMPARE s0, 53[83'd]                 ; is this a S?
 157  321E6                       JUMP Z, 1E6[isGS]
 158  22040                       JUMP 040[startLoop]
 159  2032C                 isSA: CALL 32C[getnextscratchchar]
 15A  1D053                       COMPARE s0, 53[83'd]                 ; is this a S?
 15B  321B3                       JUMP Z, 1B3[isSAS]                   ;
 15C  1D047                       COMPARE s0, 47[71'd]                 ; is this a G?
 15D  321B7                       JUMP Z, 1B7[isSAG]                   ;
 15E  1D04F                       COMPARE s0, 4F[79'd]                 ; is this a O?
 15F  321C9                       JUMP Z, 1C9[isSAO]                   ;
 160  1D049                       COMPARE s0, 49[73'd]                 ; is this a I?
 161  321BE                       JUMP Z, 1BE[isSAI]                   ;
 162  22040                       JUMP 040[startLoop]
 163                              ; SB - set beacon mode (SB<xx>
 163  20331                 isSB: CALL 331[getnextvalue]
 164  03501                       AND s5, 01                           ; Mask bit 0
 165  0B012                       FETCH s0, 12[Mode]
 166  030FE                       AND s0, FE[254'd]                    ; reset bit 0
 167  04050                       OR s0, s5                            ; affect bit 0
 168  2F012                       STORE s0, 12[Mode]
 169  22029                       JUMP 029[init]
 16A                              ; Commands for keypad pico
 16A  2032C                 isSK: CALL 32C[getnextscratchchar]
 16B  1D053                       COMPARE s0, 53[83'd]                 ; is this a S?
 16C  32179                       JUMP Z, 179[isSKS]                   ;
 16D  22029                       JUMP 029[init]
 16E  20331                 isSL: CALL 331[getnextvalue]
 16F  01400                       LOAD s4, 00
 170  1D501                       COMPARE s5, 01                       ; is it 1
 171  36173                       JUMP NZ, 173[setLoranBlank]
 172  01410                       LOAD s4, 10[LoranBlank]
 173  0B013        setLoranBlank: FETCH s0, 13[ADCstate]
 174  030EF                       AND s0, EF[~LoranBlank]              ; reset bit for Loran blanking
 175  04040                       OR s0, s4                            ; affect this bit
 176  2F013                       STORE s0, 13[ADCstate]               ; save
 177  2D013                       OUTPUT s0, 13[ADCstate_port]         ; set port to new ADC channel
 178  22029                       JUMP 029[init]
 179                       isSKS: ; LOAD      s0, 83'd              ; letter S
 179                              ; OUTPUT       s0, CMD2KP          ; send S to KP
 179                              ; CALL      getnextscratchchar
 179                              ; SUB       s0, 48'd
 179                              ; OUTPUT       s0, CMD2KP          ; send select value as binary value to KP
 179  22029                       JUMP 029[init]
 17A                              ; This streams from UART data to DSP to TX and never exits!
 17A  2032C                 isSS: CALL 32C[getnextscratchchar]         ; get beacon offset in s0
 17B  01533                       LOAD s5, 33[51'd]                    ; Ascii code for '3' - set stream mode -NO ESCAPE!
 17C  2D500                       OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 17D  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send raw data byte of bit offset
 17E  200EB                       CALL 0EB[TX]
 17F  0B012                       FETCH s0, 12[Mode]
 180  05004                       OR s0, 04                            ; set 'Streaming TX' bit
 181  030FE                       AND s0, FE                           ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 182  2F012                       STORE s0, 12[Mode]
 183  22041                       JUMP 041[loop]                       ;
 184                              ; Stream RX data to UART
 184  0B012                 isSU: FETCH s0, 12[Mode]
 185  05008                       OR s0, 08                            ; set 'Streaming TX' bit
 186  030FE                       AND s0, FE                           ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 187  2F012                       STORE s0, 12[Mode]
 188  22029                       JUMP 029[init]                       ;
 189                              ; Redirect Serial to and from BT module
 189  01654                 isSW: LOAD s6, 54["T"]
 18A  2033C                       CALL 33C[Send2UartTX]
 18B  0164F                       LOAD s6, 4F["O"]
 18C  2033C                       CALL 33C[Send2UartTX]
 18D  01620                       LOAD s6, 20                          ;Space character
 18E  2033C                       CALL 33C[Send2UartTX]
 18F  01642                       LOAD s6, 42["B"]
 190  2033C                       CALL 33C[Send2UartTX]
 191  01654                       LOAD s6, 54["T"]
 192  2033C                       CALL 33C[Send2UartTX]
 193  20347                       CALL 347[SendCRLF]
 194  01001                       LOAD s0, 01
 195  2D009                       OUTPUT s0, 09[Configure]
 196  22029                       JUMP 029[init]                       ;
 197                              ; Now get a raw UART byte
 197  20338             isSSloop: CALL 338[CheckUartRx]
 198  36197                       JUMP NZ, 197[isSSloop]               ; loop if nothing in UART buffer
 199  09500                       INPUT s5, 00[Uart_rx]                ; get byte
 19A  202F1                       CALL 2F1[Byte2Chars]
 19B  2D600                       OUTPUT s6, 00[CMD2DSP]               ; Send audio MSBbyte to DSP
 19C  2D700                       OUTPUT s7, 00[CMD2DSP]               ; Send audio LSBbyte to DSP
 19D  202B3                       CALL 2B3[Check4CmdfromDSP]           ; If fifo character then send to terminal !!!!!!!!!!!!!!!!!!!! reinstate this 15/5/2013
 19E  22041                       JUMP 041[loop]                       ; Try making this a called routine, sending 1 value per loop
 19F                              ; this is same as following routine except it returns rather than jumping to init
 19F  01524    nowsend2flashback: LOAD s5, 24[36'd]                    ; was 16 should be 9x4=36
 1A0  2D507                       OUTPUT s5, 07[ProgramM]              ; initiates flash write - may take some time for pp command!
 1A1  20362                       CALL 362[delay_1ms]                  ; wait to complete
 1A2  20362                       CALL 362[delay_1ms]
 1A3  20362                       CALL 362[delay_1ms]                  ; TO be OPTIMIZED!!!!!!!!!!!!!!!!!!!!!!!
 1A4  01500                       LOAD s5, 00                          ; reset send2flash
 1A5  2D507                       OUTPUT s5, 07[ProgramM]              ; initiates flash write - may take some time for pp command!
 1A6  25000                       RETURN 
 1A7  2019F        nowsend2flash: CALL 19F[nowsend2flashback]
 1A8  22029                       JUMP 029[init]
 1A9  2032C                 isSR: CALL 32C[getnextscratchchar]
 1AA  1D046                       COMPARE s0, 46[70'd]                 ; is this a F?
 1AB  321D4                       JUMP Z, 1D4[isSRF]                   ;
 1AC  1D04D                       COMPARE s0, 4D[77'd]                 ; is this a M?
 1AD  321D9                       JUMP Z, 1D9[isSRM]                   ;
 1AE  22029                       JUMP 029[init]
 1AF                              ; Testmemory TEMP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END
 1AF  2032C                 isST: CALL 32C[getnextscratchchar]
 1B0                              ;                    COMPARE      s0, 70'd              ; is this a F?
 1B0                              ;                   JUMP      Z, isSTF            ;
 1B0  1D04D                       COMPARE s0, 4D[77'd]                 ; is this a M?
 1B1  321DB                       JUMP Z, 1DB[isSTM]                   ;
 1B2  22029                       JUMP 029[init]
 1B3                              ; SAS - set archive source
 1B3  20331                isSAS: CALL 331[getnextvalue]
 1B4  00150                       LOAD s1, s5
 1B5  20317                       CALL 317[ArchiveSource]
 1B6  22029                       JUMP 029[init]
 1B7                              ; SAG   Set analogue gain
 1B7  20331                isSAG: CALL 331[getnextvalue]
 1B8  05580                       OR s5, 80[128'd]                     ; set bit 7
 1B9  2D502                       OUTPUT s5, 02[GainPD]
 1BA  20362                       CALL 362[delay_1ms]                  ; wait for calib
 1BB  0357F                       AND s5, 7F[127'd]                    ; reset bit 7
 1BC  2D502                       OUTPUT s5, 02[GainPD]
 1BD  22029                       JUMP 029[init]
 1BE  20331                isSAI: CALL 331[getnextvalue]
 1BF  01400                       LOAD s4, 00
 1C0  1D501                       COMPARE s5, 01                       ; is it 1
 1C1  361C3                       JUMP NZ, 1C3[setADC]
 1C2  01440                       LOAD s4, 40[64'd]
 1C3  0B013               setADC: FETCH s0, 13[ADCstate]
 1C4  030BF                       AND s0, BF[191'd]                    ; reset bit 6
 1C5  04040                       OR s0, s4                            ; affect bit 6
 1C6  2F013                       STORE s0, 13[ADCstate]               ; save
 1C7  2D013                       OUTPUT s0, 13[ADCstate_port]         ; set port to new ADC channel
 1C8  22029                       JUMP 029[init]
 1C9  20331                isSAO: CALL 331[getnextvalue]
 1CA  01400                       LOAD s4, 00
 1CB  1D501                       COMPARE s5, 01                       ; is it 1
 1CC  361CE                       JUMP NZ, 1CE[setAudioOut]
 1CD  01420                       LOAD s4, 20[32'd]
 1CE  0B013          setAudioOut: FETCH s0, 13[ADCstate]
 1CF  030DF                       AND s0, DF[223'd]                    ; 255 - 32        ; reset bit5
 1D0  04040                       OR s0, s4                            ; affect bit 5
 1D1  2F013                       STORE s0, 13[ADCstate]               ; save
 1D2  2D013                       OUTPUT s0, 13[ADCstate_port]         ; set port to new audio channel
 1D3  22029                       JUMP 029[init]
 1D4                              ; SRF - set receive frequency (gets 4 hex digits
 1D4  20331                isSRF: CALL 331[getnextvalue]               ; get byte represented by 2 digits
 1D5  2D50A                       OUTPUT s5, 0A[RXFreqMSB]
 1D6  20331                       CALL 331[getnextvalue]
 1D7  2D50B                       OUTPUT s5, 0B[RXFreqLSB]
 1D8  22029                       JUMP 029[init]
 1D9                              ; set receive mode
 1D9  200F2                isSRM: CALL 0F2[setRXmode]                  ; used to be RX, but that doesn't change mode and frequency etc.
 1DA  22029                       JUMP 029[init]
 1DB                              ; set Tranmit mode
 1DB  200D1                isSTM: CALL 0D1[setTXmode]                  ; used to be TX 20/5/2013
 1DC  22029                       JUMP 029[init]
 1DD                              ; STF - set transmit frequency (gets 4 hex digits -Frequency now set by Keypad
 1DD                              ;isSTF:              CALL      getnextvalue        ; get byte represented by 2 digits
 1DD                              ;                   OUTPUT       s5, TXFreqMSB
 1DD                              ;                  CALL      getnextvalue
 1DD                              ;                 OUTPUT       s5, TXFreqLSB
 1DD                              ;                JUMP      init
 1DD                              ; GET AGC value from DSP
 1DD  01047                 isGG: LOAD s0, 47[71'd]                    ; letter G
 1DE  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send G to DSP
 1DF  20347                       CALL 347[SendCRLF]
 1E0  20362                       CALL 362[delay_1ms]
 1E1  202B3                       CALL 2B3[Check4CmdfromDSP]           ; if character send to terminal
 1E2  202B3                       CALL 2B3[Check4CmdfromDSP]           ; if character send to terminal
 1E3  202B3                       CALL 2B3[Check4CmdfromDSP]           ; if character send to terminal
 1E4  202B3                       CALL 2B3[Check4CmdfromDSP]           ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 1E5                              ;      CALL      SendCRLF
 1E5  22029                       JUMP 029[init]
 1E6                              ; Get AVEsignal level from DSP
 1E6  01053                 isGS: LOAD s0, 53[83'd]                    ; letter S
 1E7  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send S to DSP
 1E8  20347                       CALL 347[SendCRLF]
 1E9  20362                       CALL 362[delay_1ms]
 1EA  202B3                       CALL 2B3[Check4CmdfromDSP]           ; if character send to terminal
 1EB  202B3                       CALL 2B3[Check4CmdfromDSP]           ; if character send to terminal
 1EC  202B3                       CALL 2B3[Check4CmdfromDSP]           ; if character send to terminal
 1ED  202B3                       CALL 2B3[Check4CmdfromDSP]           ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 1EE                              ;      CALL      SendCRLF
 1EE  22029                       JUMP 029[init]
 1EF                              ; send test command to BT pico
 1EF  01047                 isGB: LOAD s0, 47[71'd]                    ; letter G
 1F0  2D014                       OUTPUT s0, 14[CMD2BT]                ; send G to BT
 1F1                              ;      CALL      SendCRLF
 1F1  20362                       CALL 362[delay_1ms]
 1F2  202B8                       CALL 2B8[Check4CmdfromBT]            ; if character send to terminal
 1F3  202B8                       CALL 2B8[Check4CmdfromBT]            ; if character send to terminal
 1F4  202B8                       CALL 2B8[Check4CmdfromBT]            ; if character send to terminal
 1F5  202B8                       CALL 2B8[Check4CmdfromBT]            ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 1F6                              ;      CALL      SendCRLF
 1F6  22029                       JUMP 029[init]
 1F7                              ; Return Loran inhibit rate
 1F7  09508                 isGC: INPUT s5, 08
 1F8  20342                       CALL 342[Byte2UART]
 1F9  25000                       RETURN 
 1FA                              ; Request from keypad pico
 1FA  2032C                 isGK: CALL 32C[getnextscratchchar]
 1FB  1D054                       COMPARE s0, 54[84'd]                 ; is this a T?
 1FC  3220C                       JUMP Z, 20C[isGKT]
 1FD  1D056                       COMPARE s0, 56[86'd]                 ; is this a V?
 1FE  32215                       JUMP Z, 215[isGKV]
 1FF  22029                       JUMP 029[init]
 200                              ; report signal level from the ADC
 200  0B515                 isGL: FETCH s5, 15[ADCLevel]
 201  20342                       CALL 342[Byte2UART]
 202  01620                       LOAD s6, 20                          ; space
 203  2033C                       CALL 33C[Send2UartTX]
 204  0950F                       INPUT s5, 0F[ADCSignalLevel]
 205  20342                       CALL 342[Byte2UART]
 206  01620                       LOAD s6, 20                          ; space
 207  2033C                       CALL 33C[Send2UartTX]
 208  0B516                       FETCH s5, 16[ADCgain]
 209  20342                       CALL 342[Byte2UART]
 20A  20347                       CALL 347[SendCRLF]
 20B  22029                       JUMP 029[init]
 20C                              ; send test command to KP pico
 20C  01054                isGKT: LOAD s0, 54[84'd]                    ; letter T
 20D  2D015                       OUTPUT s0, 15[CMD2KP]                ; send T to KP
 20E  20347                       CALL 347[SendCRLF]
 20F  20362                       CALL 362[delay_1ms]
 210  202BC                       CALL 2BC[Check4CmdfromKP]            ; if character send to terminal
 211  202BC                       CALL 2BC[Check4CmdfromKP]            ; if character send to terminal
 212  202BC                       CALL 2BC[Check4CmdfromKP]            ; if character send to terminal
 213  202BC                       CALL 2BC[Check4CmdfromKP]            ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 214                              ;      CALL      SendCRLF
 214  22029                       JUMP 029[init]
 215  01056                isGKV: LOAD s0, 56[86'd]                    ; letter V
 216  2D015                       OUTPUT s0, 15[CMD2KP]                ; send V to KP
 217  20347                       CALL 347[SendCRLF]
 218  20362                       CALL 362[delay_1ms]
 219  202BC                       CALL 2BC[Check4CmdfromKP]            ; if character send to terminal
 21A  202BC                       CALL 2BC[Check4CmdfromKP]            ; if character send to terminal
 21B  202BC                       CALL 2BC[Check4CmdfromKP]            ; if character send to terminal
 21C  202BC                       CALL 2BC[Check4CmdfromKP]            ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 21D                              ;      CALL      SendCRLF
 21D  22029                       JUMP 029[init]
 21E  20304                 isGA: CALL 304[SendArchive]
 21F  22029                       JUMP 029[init]
 220                        isGV: 
 220  01587                       LOAD s5, 87[Versionno]
 221  20342                       CALL 342[Byte2UART]
 222  20347                       CALL 347[SendCRLF]                   ; added to allow get line to read OK
 223  22029                       JUMP 029[init]
 224  01042              Twotone: LOAD s0, 42[66'd]                    ; Block DSPpico
 225  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send B to DSP to block it
 226                              ; need to output TX freq carrier plus 30 then 40 and then return to carrier - now simply as an increment
 226  01035                       LOAD s0, 35[53'd]
 227  2D00D                       OUTPUT s0, 0D[Tone]
 228  2035D                       CALL 35D[delay_100ms]
 229  01023                       LOAD s0, 23[35'd]
 22A  2D00D                       OUTPUT s0, 0D[Tone]
 22B  2035D                       CALL 35D[delay_100ms]
 22C  01000                       LOAD s0, 00
 22D  2D00D                       OUTPUT s0, 0D[Tone]                  ; and send value to SSB modulatorto reset to normal frequency
 22E  01052                       LOAD s0, 52[82'd]                    ; Un Block DSPpico
 22F  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send R to DSP (release)
 230  25000                       RETURN 
 231                  Confidence: 
 231  200EB                       CALL 0EB[TX]
 232  01500                       LOAD s5, 00
 233              Confidenceloop: 
 233  01042                       LOAD s0, 42[66'd]                    ; Block DSPpico 0x42
 234  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send B to DSP to block it
 235                              ; need to output TX freq carrier plus 30 then 40 and then
 235                              ; return to carrier - now simply as an increment
 235  01014                       LOAD s0, 14[20'd]
 236  2D00D                       OUTPUT s0, 0D[Tone]
 237  2035D                       CALL 35D[delay_100ms]
 238  01028                       LOAD s0, 28[40'd]
 239  2D00D                       OUTPUT s0, 0D[Tone]
 23A  2035D                       CALL 35D[delay_100ms]
 23B  0103C                       LOAD s0, 3C[60'd]
 23C  2D00D                       OUTPUT s0, 0D[Tone]
 23D  2035D                       CALL 35D[delay_100ms]
 23E  01050                       LOAD s0, 50[80'd]
 23F  2D00D                       OUTPUT s0, 0D[Tone]
 240  2035D                       CALL 35D[delay_100ms]
 241  01064                       LOAD s0, 64[100'd]
 242  2D00D                       OUTPUT s0, 0D[Tone]
 243  2035D                       CALL 35D[delay_100ms]
 244                              ;ADD       s5, 01
 244                              ;COMPARE      s5, 02               ; Do this 4 times
 244                              ;JUMP      NZ, Confidenceloop
 244  01000                       LOAD s0, 00
 245  2D00D                       OUTPUT s0, 0D[Tone]                  ; and send value to SSB modulatorto reset to normal frequency
 246  01052                       LOAD s0, 52[82'd]                    ; Un Block DSPpico 0x52
 247  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send R to DSP (release)
 248  200C3                       CALL 0C3[RX]
 249  25000                       RETURN 
 24A               TurnOffWarble: 
 24A  200EB                       CALL 0EB[TX]
 24B  01500                       LOAD s5, 00
 24C           TurnOffWarbleloop: 
 24C  01042                       LOAD s0, 42[66'd]                    ; Block DSPpico 0x42
 24D  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send B to DSP to block it
 24E                              ; need to output TX freq carrier plus 30 then 40 and then
 24E                              ; return to carrier - now simply as an increment
 24E  01050                       LOAD s0, 50[80'd]
 24F  2D00D                       OUTPUT s0, 0D[Tone]
 250  2035D                       CALL 35D[delay_100ms]
 251  0103C                       LOAD s0, 3C[60'd]
 252  2D00D                       OUTPUT s0, 0D[Tone]
 253  2035D                       CALL 35D[delay_100ms]
 254  01028                       LOAD s0, 28[40'd]
 255  2D00D                       OUTPUT s0, 0D[Tone]
 256  2035D                       CALL 35D[delay_100ms]
 257  01050                       LOAD s0, 50[80'd]
 258  2D00D                       OUTPUT s0, 0D[Tone]
 259  2035D                       CALL 35D[delay_100ms]
 25A  0103C                       LOAD s0, 3C[60'd]
 25B  2D00D                       OUTPUT s0, 0D[Tone]
 25C  2035D                       CALL 35D[delay_100ms]
 25D  01028                       LOAD s0, 28[40'd]
 25E  2D00D                       OUTPUT s0, 0D[Tone]
 25F  2035D                       CALL 35D[delay_100ms]
 260  01050                       LOAD s0, 50[80'd]
 261  2D00D                       OUTPUT s0, 0D[Tone]
 262  2035D                       CALL 35D[delay_100ms]
 263  0103C                       LOAD s0, 3C[60'd]
 264  2D00D                       OUTPUT s0, 0D[Tone]
 265  2035D                       CALL 35D[delay_100ms]
 266  01028                       LOAD s0, 28[40'd]
 267  2D00D                       OUTPUT s0, 0D[Tone]
 268  2035D                       CALL 35D[delay_100ms]
 269  01050                       LOAD s0, 50[80'd]
 26A  2D00D                       OUTPUT s0, 0D[Tone]
 26B  2035D                       CALL 35D[delay_100ms]
 26C  0103C                       LOAD s0, 3C[60'd]
 26D  2D00D                       OUTPUT s0, 0D[Tone]
 26E  2035D                       CALL 35D[delay_100ms]
 26F  01028                       LOAD s0, 28[40'd]
 270  2D00D                       OUTPUT s0, 0D[Tone]
 271  2035D                       CALL 35D[delay_100ms]
 272                              ;ADD       s5, 01
 272                              ;COMPARE      s5, 02               ; Do this 4 times
 272                              ;JUMP      NZ, TurnOffWarbleloop
 272  01000                       LOAD s0, 00
 273  2D00D                       OUTPUT s0, 0D[Tone]                  ; and send value to SSB modulatorto reset to normal frequency
 274  01052                       LOAD s0, 52[82'd]                    ; Un Block DSPpico 0x52
 275  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send R to DSP (release)
 276  200C3                       CALL 0C3[RX]
 277  25000                       RETURN 
 278  01500               Warble: LOAD s5, 00
 279  01042           Warbleloop: LOAD s0, 42[66'd]                    ; Block DSPpico 0x42
 27A  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send B to DSP to block it
 27B                              ; need to output TX freq carrier plus 30 then 40 and then return to carrier - now simply as an increment
 27B  0101E                       LOAD s0, 1E[30'd]
 27C  2D00D                       OUTPUT s0, 0D[Tone]
 27D  2035D                       CALL 35D[delay_100ms]
 27E  01028                       LOAD s0, 28[40'd]
 27F  2D00D                       OUTPUT s0, 0D[Tone]
 280  2035D                       CALL 35D[delay_100ms]
 281  11501                       ADD s5, 01
 282  1D504                       COMPARE s5, 04                       ; Do this 4 times
 283  36279                       JUMP NZ, 279[Warbleloop]
 284  01000                       LOAD s0, 00
 285  2D00D                       OUTPUT s0, 0D[Tone]                  ; and send value to SSB modulatorto reset to normal frequency
 286  01052                       LOAD s0, 52[82'd]                    ; Un Block DSPpico 0x52
 287  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send R to DSP (release)
 288  25000                       RETURN 
 289  200EB           BeaconBeep: CALL 0EB[TX]
 28A  01700                       LOAD s7, 00
 28B  20278           Beaconloop: CALL 278[Warble]
 28C                              ; Keep checking fifo for a character to keep it clear!
 28C                              ;CALL      Check4CmdfromKP
 28C                              ;COMPARE      s6, "t" ; character_t
 28C                              ;JUMP      Z, cancelbeacon     ; Escape if is key pressed - changed this 2/5/13 to speed up beacon cancel
 28C  11701                       ADD s7, 01
 28D  1D703                       COMPARE s7, 03
 28E                              ;JUMP      NZ, Beaconloop      ; do warble 3 times
 28E  200C3                       CALL 0C3[RX]
 28F                              ;CALL      delay_1s
 28F                              ; Keep checking fifo for a character to keep it clear!
 28F                              ;CALL      Check4CmdfromKP
 28F                              ;COMPARE      s6, "t"  ; character_t
 28F                              ;JUMP      Z, cancelbeacon     ; Escape if is key pressed
 28F                              ;CALL      delay_1s
 28F                              ; Keep checking fifo for a character to keep it clear!
 28F                              ;CALL      Check4CmdfromKP
 28F                              ;COMPARE      s6, "t"  ; character_t
 28F                              ;JUMP      Z, cancelbeacon     ; Escape if is key pressed
 28F                              ; 6/7/12 reduced receive period to 2s
 28F  25000                       RETURN 
 290  0B012         cancelbeacon: FETCH s0, 12[Mode]
 291  030FE                       AND s0, FE[254'd]                    ; cancel beaon mode
 292  2F012                       STORE s0, 12[Mode]                   ; Hah - had forgotton to update the mode! 20/5/13
 293  25000                       RETURN 
 294                              ; ;;Pete
 294                              ; ;;Pete
 294                              ; ;;Pete
 294                              ;HandleBTCommand:
 294                              ; ;;LOAD      s6, 'A'             ; get character
 294                              ; ;;CALL      Send2UartTX         ; and echo back to terminal
 294                              ;                    AND       s0, 7F             ; mask off top bit
 294                              ; need to interpret commands from BT Here
 294                              ;                    COMPARE      s0, TRANSMIT_ON
 294                              ;                    JUMP      Z, FromBT_XMIT      ; Bluetooth Headset transmit
 294                              ;                    COMPARE      s0, TRANSMIT_OFF
 294                              ;                    JUMP      Z, FromBT_RECEIVE   ; Bluetooth Headset stop transmit
 294         SendTurnOffToKeypad: 
 294  2024A                       CALL 24A[TurnOffWarble]              ; audio turn off to other end
 295                              ; only works if switching off through keypad
 295                SendToKeypad: 
 295  0102A                       LOAD s0, 2A["*"]
 296  2D015                       OUTPUT s0, 15[CMD2KP]                ; trigger message to keypad
 297  2D615                       OUTPUT s6, 15[CMD2KP]                ; send turn off
 298  25000                       RETURN 
 299                              ; ;;COMPARE      s0, FLASH_WRITE
 299                              ; ;;JUMP      Z, FromBT_WRITE     ; PC has sent a WRITE to Flash request
 299                              ; ;;COMPARE      s0, FLASH_WRITE_PAGE
 299                              ; ;;JUMP      Z, FromBT_WRITE_PAGE; PC has sent a WRITE PAGE to Flash request
 299                              ; ;;COMPARE      s0, FLASH_ERASE
 299                              ; ;;JUMP      Z, FromBT_ERASE     ; PC has sent a Erase the Write message
 299                              ; ;;COMPARE      s0, FLASH_READ
 299                              ; ;;JUMP      Z, FromBT_READ      ; PC has sent a Read request
 299                              ; ;;COMPARE      s0, FLASH_READ_PAGE
 299                              ; ;;JUMP      Z, FromBT_READ_PAGE ; PC has sent a Read Page request
 299                              ; ;;COMPARE      s0, FLASH_WRITE_TEXT
 299                              ; ;;JUMP      Z, FromBT_WRITE_TEXT; PC has sent a WRITE TEXT to Flash request
 299                              ; LOAD      s0, 2F             ; send message back
 299                              ; OUTPUT       s0, CMD2BT          ; send Go to BT
 299                              ; CALL      SendCharToBT
 299                              ;                    JUMP      HandleBTCommand_Done
 299                              ;FromBT_XMIT:
 299                              ;                    CALL      SendCRLF
 299                              ;                    LOAD      s6, "T"
 299                              ;                    CALL      Send2UartTX         ; and echo back to terminal. Message mode
 299                              ;                    LOAD      s6, "x"
 299                              ;                    CALL      Send2UartTX         ; and echo back to terminal. Message mode
 299                              ;                    CALL      setTXmode
 299                              ;                    CALL      SendCRLF
 299                              ;                    LOAD      s0, 01
 299                              ;                    STORE     s0, BluetoothXmit
 299                              ;                    JUMP      HandleBTCommand_Done
 299                              ;FromBT_RECEIVE:
 299                              ;                    CALL      SendCRLF
 299                              ;                    LOAD      s6, "R"
 299                              ;                    CALL      Send2UartTX         ; and echo back to terminal. Message mode
 299                              ;                    LOAD      s6, "c"
 299                              ;                    CALL      Send2UartTX         ; and echo back to terminal. Message mode
 299                              ;                    CALL      setRXmode
 299                              ;                    CALL      SendCRLF
 299                              ;                    LOAD      s0, 00
 299                              ;                    STORE     s0, BluetoothXmit
 299                              ;                    JUMP      HandleBTCommand_Done
 299                              ; ;; end Pete
 299                              ; ;; end Pete
 299                              ; ;; end Pete
 299  016FF          getUARTchar: LOAD s6, FF                          ; Return FF if no character
 29A  20338                       CALL 338[CheckUartRx]
 29B  35000                       RETURN NZ                            ; Return if no character with s6=$FF
 29C  09600                       INPUT s6, 00[Uart_rx]                ; get character
 29D  0367F                       AND s6, 7F
 29E                              ; CALL      Send2UartTX         ; and echo back to terminal. - SHOULD USE Send2UartTX (not in message mode)
 29E  25000                       RETURN 
 29F                              ; returns fifo character in s6 assuming present
 29F  202C6     sendDSP2Terminal: CALL 2C6[GetDSPFifoChar]
 2A0  01600                       LOAD s6, 00                          ; get character
 2A1  0367F                       AND s6, 7F                           ; top bit is for empty fifo flag!
 2A2                              ;Send to keypad pico (LCD) instead
 2A2                              ;                    CALL      Send2UartTX         ; and echo back to terminal.
 2A2  2D615                       OUTPUT s6, 15[CMD2KP]                ; send code 0-7F (normally ascii, but $7F would tell it to expect a value to display at a particular place)
 2A3  25000                       RETURN 
 2A4                              ; returns BT fifo character in s6 assuming present
 2A4  202CC      sendBT2Terminal: CALL 2CC[GetBTFifoChar]
 2A5  00600                       LOAD s6, s0                          ; get character
 2A6  0367F                       AND s6, 7F
 2A7  2033C                       CALL 33C[Send2UartTX]                ; and echo back to terminal.
 2A8  25000                       RETURN 
 2A9                              ; returns KP fifo character in s6 assuming present
 2A9  202D2      sendKP2Terminal: CALL 2D2[GetKPFifoChar]
 2AA  00600                       LOAD s6, s0                          ; get character
 2AB  0367F                       AND s6, 7F
 2AC  2033C                       CALL 33C[Send2UartTX]                ; and echo back to terminal.
 2AD  25000                       RETURN 
 2AE                              ; returns KP fifo character in s6 assuming present
 2AE  202D8      sendTD2Terminal: CALL 2D8[GetTDFifoChar]
 2AF  00600                       LOAD s6, s0                          ; get character
 2B0  0367F                       AND s6, 7F
 2B1  2033C                       CALL 33C[Send2UartTX]                ; and echo back to terminal.
 2B2  25000                       RETURN 
 2B3                              ; checks for command from DSP pico, if present in s6 and echo to terminal - otherwise s6>127
 2B3  09104     Check4CmdfromDSP: INPUT s1, 04[DSPcmd]                 ; Get character from DSP picoblaze (if present should be less than 128)
 2B4  00610                       LOAD s6, s1
 2B5  1D180                       COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 2B6  3829F                       CALL C, 29F[sendDSP2Terminal]        ; If less than 128 there is a value to give back and display.
 2B7  25000                       RETURN 
 2B8                              ; checks for command from BTpico, if present in s6 and echo to terminal - otherwise s6>127
 2B8  09105      Check4CmdfromBT: INPUT s1, 05[BTcmd]                  ; Get character from BT picoblaze (if present should be less than 128)
 2B9  00610                       LOAD s6, s1
 2BA  1D180                       COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 2BB                              ;CALL      C, sendBT2Terminal  ; If less than 128 there is a value to give back and display.
 2BB  25000                       RETURN 
 2BC                              ; checks for command from KPpico, if present in s6  - otherwise s6>127
 2BC  09106      Check4CmdfromKP: INPUT s1, 06[KPcmd]                  ; Get character from BT picoblaze (if present should be less than 128)
 2BD  00610                       LOAD s6, s1
 2BE  1D180                       COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 2BF  382D2                       CALL C, 2D2[GetKPFifoChar]
 2C0  25000                       RETURN 
 2C1                              ; checks for command from TDpico, if present in s6  - otherwise s6>127
 2C1  09107      Check4CmdfromTD: INPUT s1, 07[TDcmd]                  ; Get character from BT picoblaze (if present should be less than 128)
 2C2  00610                       LOAD s6, s1
 2C3  1D180                       COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 2C4  382D8                       CALL C, 2D8[GetTDFifoChar]
 2C5  25000                       RETURN 
 2C6                              ; Routine to recover a byte, (character?) from the FIFO in s0
 2C6  01010       GetDSPFifoChar: LOAD s0, 10[DSPFifo]
 2C7  2D00E                       OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 2C8  01010                       LOAD s0, 10[DSPFifo]                 ; dummy, wait a bit longer for character to present itself
 2C9  09004                       INPUT s0, 04[DSPcmd]                 ; now get my character
 2CA  0307F                       AND s0, 7F                           ; mask off top bit
 2CB  25000                       RETURN 
 2CC                              ; Routine to recover a character from the BTFIFO in s0
 2CC  01020        GetBTFifoChar: LOAD s0, 20[BTFifo]
 2CD  2D00E                       OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 2CE  01020                       LOAD s0, 20[BTFifo]                  ; dummy, wait a bit longer for character to present itself
 2CF  09005                       INPUT s0, 05[BTcmd]                  ; now get my character
 2D0  0307F                       AND s0, 7F                           ; mask off top bit
 2D1  25000                       RETURN 
 2D2                              ; Routine to recover a character from the KPFIFO in s6
 2D2  01040        GetKPFifoChar: LOAD s0, 40[KPFifo]
 2D3  2D00E                       OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 2D4  01040                       LOAD s0, 40[KPFifo]                  ; dummy, wait a bit longer for character to present itself
 2D5  09606                       INPUT s6, 06[KPcmd]                  ; now get my character
 2D6  0367F                       AND s6, 7F                           ; mask off top bit
 2D7  25000                       RETURN 
 2D8                              ; Routine to recover a character from the TDFIFO in s6
 2D8  01080        GetTDFifoChar: LOAD s0, 80[TDFifo]
 2D9  2D00E                       OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 2DA  01040                       LOAD s0, 40[KPFifo]                  ; dummy, wait a bit longer for character to present itself
 2DB  09607                       INPUT s6, 07[TDcmd]                  ; now get my character
 2DC  0367F                       AND s6, 7F                           ; mask off top bit
 2DD  25000                       RETURN 
 2DE                              ; sayOK:              CALL      SendCRLF
 2DE                              ; LOAD      s6, 79
 2DE                              ; CALL      Send2UartTX
 2DE                              ; LOAD      s6, 75
 2DE                              ; CALL      Send2UartTX
 2DE                              ; CALL      SendCRLF
 2DE                              ; RETURN
 2DE                              ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 2DE  00860           Chars2Byte: LOAD s8, s6
 2DF  202E9                       CALL 2E9[Get4bits]
 2E0  00580                       LOAD s5, s8
 2E1  14506                       SL0 s5
 2E2  14506                       SL0 s5
 2E3  14506                       SL0 s5
 2E4  14506                       SL0 s5                               ; put these 4 bits to MSBs
 2E5  00870                       LOAD s8, s7
 2E6  202E9                       CALL 2E9[Get4bits]
 2E7  10580                       ADD s5, s8
 2E8  25000                       RETURN 
 2E9                              ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 2E9  1D83C             Get4bits: COMPARE s8, 3C[60'd]                 ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 2EA  3A2EE                       JUMP C, 2EE[char0_9]
 2EB  19837                       SUB s8, 37[55'd]                     ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 2EC  0380F                       AND s8, 0F                           ; make sure only return 4 bits
 2ED  25000                       RETURN 
 2EE  19830              char0_9: SUB s8, 30[48'd]
 2EF  0380F                       AND s8, 0F                           ; make sure only return 4 bits
 2F0  25000                       RETURN 
 2F1                              ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 2F1  00850           Byte2Chars: LOAD s8, s5                          ; assumes 8 bit data is in s5
 2F2  1450E                       SR0 s5
 2F3  1450E                       SR0 s5
 2F4  1450E                       SR0 s5
 2F5  1450E                       SR0 s5                               ; get first hex character
 2F6  202FD                       CALL 2FD[GetChar]
 2F7  00650                       LOAD s6, s5                          ; first ascii char
 2F8  00580                       LOAD s5, s8
 2F9  0350F                       AND s5, 0F
 2FA  202FD                       CALL 2FD[GetChar]                    ;
 2FB  00750                       LOAD s7, s5                          ; second ascii char
 2FC  25000                       RETURN 
 2FD                              ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 2FD  1950A              GetChar: SUB s5, 0A[10'd]                     ; Test if s5 greater than 9
 2FE  3A301                       JUMP C, 301[is_0_9]                  ; Hex character is 0_9
 2FF  11541                       ADD s5, 41[65'd]                     ; offset for Ascii code 'A'
 300  25000                       RETURN 
 301  1150A               is_0_9: ADD s5, 0A[10'd]                     ; return to range 0-9
 302  11530                       ADD s5, 30[48'd]                     ; offset to Ascii code for '0'
 303  25000                       RETURN 
 304                              ; To send to Uart, simply use: OUTPUT       s3, UART_TX         ; Sends value in s3 to Uart Tx
 304                              ; Dump archive RAM to RS232 port as 4 Ascii codes per data value followed by carriage return and line feed.
 304  20323          SendArchive: CALL 323[DisableArchive]             ; Stop archiving
 305  01000                       LOAD s0, 00
 306  01100                       LOAD s1, 00
 307  0B410            SendAloop: FETCH s4, 10[Latch7]
 308  034FC                       AND s4, FC[252'd]                    ; set top 2 address bits to zero
 309  2D006                       OUTPUT s0, 06[ProgramL]
 30A  04410                       OR s4, s1                            ; patch in top 2 address bits
 30B  2D407                       OUTPUT s4, 07[ProgramM]              ; and send to the output port
 30C  09503                       INPUT s5, 03[ArchiveDataMSB]
 30D  20342                       CALL 342[Byte2UART]
 30E  09502                       INPUT s5, 02[ArchiveDataLSB]         ; grab bottom byte
 30F  20342                       CALL 342[Byte2UART]
 310  11001                       ADD s0, 01
 311  13100                       ADDCY s1, 00
 312  20347                       CALL 347[SendCRLF]
 313  1D104                       COMPARE s1, 04
 314  36307                       JUMP NZ, 307[SendAloop]
 315  2031E                       CALL 31E[EnableArchive]              ; Restart archiving
 316  25000                       RETURN 
 317                              ; Select Archiving source, if s1 is 0 then raw 16bit ADC data is archived, or if s1=1 then 16bit data from the DSP picoblaze (DATA2Archve) is archived at 6kHz
 317  03103        ArchiveSource: AND s1, 03
 318  0B014                       FETCH s0, 14[SelectScratch]          ; get current value of selections
 319  030FC                       AND s0, FC[252'd]                    ; first reset first 2 bits
 31A  04010                       OR s0, s1                            ; affect bits 0-1
 31B  2D008                       OUTPUT s0, 08[SelectArchiveSource]   ; update archive control port
 31C  2F014                       STORE s0, 14[SelectScratch]          ; Update scratchpad
 31D                              ;      LOAD   s5,s0
 31D                              ;      CALL   Byte2Chars
 31D  25000                       RETURN 
 31E                              ; Enable Archiving
 31E  0B010        EnableArchive: FETCH s0, 10[Latch7]                 ; get current value of control port
 31F  05040                       OR s0, 40[EnArchive]                 ; set bit 5
 320  2D007                       OUTPUT s0, 07[ProgramM]
 321  2F010                       STORE s0, 10[Latch7]                 ; get current value of control port
 322  25000                       RETURN 
 323                              ; Disable Archiving
 323  00600       DisableArchive: LOAD s6, s0
 324  2036C                       CALL 36C[delay_50us]                 ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 325  20362                       CALL 362[delay_1ms]                  ; wait for a bit more archiving first!
 326  0B010                       FETCH s0, 10[Latch7]                 ; get current value of control port
 327  030BF                       AND s0, BF[~EnArchive]               ; reset bit 5
 328  2D007                       OUTPUT s0, 07[ProgramM]
 329  2F010                       STORE s0, 10[Latch7]                 ; get current value of control port
 32A  00060                       LOAD s0, s6                          ; restore s0 value
 32B  25000                       RETURN 
 32C                              ; Character parsing:
 32C                              ; returns next command character in s0
 32C  0A090   getnextscratchchar: FETCH s0, (s9)
 32D  11901                       ADD s9, 01                           ; increment pointer
 32E  00600                       LOAD s6, s0
 32F  2033C                       CALL 33C[Send2UartTX]                ; and echo back to terminal. Message mode
 330  25000                       RETURN 
 331                              ; Reads 2 ascii codes and returns the byte represented in hex as binary value in s5
 331  2032C         getnextvalue: CALL 32C[getnextscratchchar]
 332  00400                       LOAD s4, s0
 333  2032C                       CALL 32C[getnextscratchchar]
 334  00700                       LOAD s7, s0
 335  00640                       LOAD s6, s4
 336  202DE                       CALL 2DE[Chars2Byte]                 ; return byte in s5
 337  25000                       RETURN 
 338                              ; UART control
 338  09001          CheckUartRx: INPUT s0, 01[Uart_status]            ; Check if there is RX data
 339  03001                       AND s0, 01
 33A  1D001                       COMPARE s0, 01
 33B  25000                       RETURN 
 33C                              ; send character in s6 to Uart - also uses s8!
 33C  09801          Send2UartTX: INPUT s8, 01[Uart_status]            ; Check if TX buffer is full
 33D  03802                       AND s8, 02
 33E  1D802                       COMPARE s8, 02                       ; if 2 then wait
 33F  3233C                       JUMP Z, 33C[Send2UartTX]
 340  2D601                       OUTPUT s6, 01[UART_TX]
 341  25000                       RETURN 
 342                              ; Convert byte in s5 into 2 ascii codes in hexadecimal and send to the serial port.
 342  202F1            Byte2UART: CALL 2F1[Byte2Chars]
 343  2033C                       CALL 33C[Send2UartTX]
 344  00670                       LOAD s6, s7
 345  2033C                       CALL 33C[Send2UartTX]
 346  25000                       RETURN 
 347  0160D             SendCRLF: LOAD s6, 0D
 348  2033C                       CALL 33C[Send2UartTX]
 349  0160A                       LOAD s6, 0A
 34A  2033C                       CALL 33C[Send2UartTX]
 34B  25000                       RETURN 
 34C  01620            SendSPACE: LOAD s6, 20
 34D  2033C                       CALL 33C[Send2UartTX]
 34E  25000                       RETURN 
 34F                              CONSTANT count_1000_lsb, E8          ; lower 8-bits of 1000 count value
 34F                              CONSTANT count_1000_msb, 03          ; upper 8-bits of 1000 count value
 34F                              ; Registers used s0, s1, s2, s3, s4 and s5.
 34F                              ;
 34F  01500             delay_1s: LOAD s5, 00                          ; clear cycle counter
 350  01400                       LOAD s4, 00
 351  20362              wait_1s: CALL 362[delay_1ms]
 352  11401                       ADD s4, 01                           ; increment cycle counter
 353  13500                       ADDCY s5, 00
 354  1D4E8                       COMPARE s4, E8[count_1000_lsb]       ; test for 1000ms
 355  36351                       JUMP NZ, 351[wait_1s]
 356  1D503                       COMPARE s5, 03[count_1000_msb]
 357  36351                       JUMP NZ, 351[wait_1s]
 358  25000                       RETURN 
 359                              ;
 359                              ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 359                              ;
 359                              ;
 359                              ; Registers used s0, s1, s2, s3 and s4.
 359                              ;
 359  2035D          delay_300ms: CALL 35D[delay_100ms]
 35A  2035D          delay_200ms: CALL 35D[delay_100ms]
 35B  2035D                       CALL 35D[delay_100ms]
 35C  25000                       RETURN 
 35D                              ;
 35D                              ; Delay of approximately 100ms used for switch debounce
 35D                              ;
 35D                              ; Registers used s0, s1, s2, s3 and s4.
 35D                              ;
 35D  01464          delay_100ms: LOAD s4, 64                          ; repeat 1ms delay 100 times
 35E  20362           wait_100ms: CALL 362[delay_1ms]
 35F  19401                       SUB s4, 01
 360  3635E                       JUMP NZ, 35E[wait_100ms]
 361  25000                       RETURN 
 362                              ;
 362                              ; Registers used s0, s1, s2 and s3.
 362                              ;
 362  01300            delay_1ms: LOAD s3, 00                          ; clear cycle counter
 363  01200                       LOAD s2, 00
 364  20371             wait_1ms: CALL 371[delay_1us]
 365  11201                       ADD s2, 01                           ; increment cycle counter
 366  13300                       ADDCY s3, 00
 367  1D2E8                       COMPARE s2, E8[count_1000_lsb]       ; test for 1000us
 368  36364                       JUMP NZ, 364[wait_1ms]
 369  1D303                       COMPARE s3, 03[count_1000_msb]
 36A  36364                       JUMP NZ, 364[wait_1ms]
 36B  25000                       RETURN 
 36C                              ;
 36C                              ; Delay of approximately 50us required by LCD display
 36C                              ;
 36C                              ; Registers used s0 and s1.
 36C                              ;
 36C  01132           delay_50us: LOAD s1, 32[50'd]                    ; repeat 1us delay 50 times
 36D  20371            wait_50us: CALL 371[delay_1us]
 36E  19101                       SUB s1, 01
 36F  3636D                       JUMP NZ, 36D[wait_50us]
 370  25000                       RETURN 
 371                              ; Delay of approximately 1us used to provide timing reference for
 371                              ; LCD operations. This must be adjusted to reflect the clock
 371                              ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 371                              ;
 371                              ; The software delay loop is formed using register s0. This register
 371                              ; must be loaded with an integer value close to the result of....
 371                              ;
 371                              ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 371                              ;
 371                              ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 371                              ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 371                              ; operation will become lower than the 100KHz target intended.
 371                              ;
 371                              ; Register used s0.
 371                              ;
 371  0100C            delay_1us: LOAD s0, 0C[delay_1us_constant]      ; delay value of 12 decimal for a 50MHz clock
 372  19001             wait_1us: SUB s0, 01
 373  36372                       JUMP NZ, 372[wait_1us]
 374  25000                       RETURN 
 375                              ;
 375                              ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\home\gnaylor\Dropbox\N3SysGen\UserPico.psm



List of defined constants

 CONSTANT name        Value        Source PSM File

 timestamp_hours      16'd         
 timestamp_minutes    57'd         
 timestamp_seconds    14'd         
 datestamp_year       17'd         
 datestamp_month      3'd          
 datestamp_day        04'd         
 NUL                  00           
 BEL                  07           
 BS                   08           
 HT                   09           
 LF                   0A           
 VT                   0B           
 CR                   0D           
 ESC                  1B           
 DEL                  7F           
 DCS                  90           
 ST                   9C           
 Versionno            87           UserPico.psm
 InitialVolume        133'd        UserPico.psm
 MinoxrVersionno      EE           UserPico.psm
 Bmode                00           UserPico.psm
 AGCupperRX           32           UserPico.psm
 AGClowerRX           12           UserPico.psm
 AGCupperTX           10           UserPico.psm
 AGClowerTX           06           UserPico.psm
 delay_1us_constant   12'd         UserPico.psm
 WREN                 06           UserPico.psm
 FAST_READ            0B           UserPico.psm
 BERASE               C7           UserPico.psm
 SER                  D8           UserPico.psm
 RDID                 9F           UserPico.psm
 PP                   02           UserPico.psm
 RDSR                 05           UserPico.psm
 Latch7               16'd         UserPico.psm
 LastDSPbyte          17'd         UserPico.psm
 Mode                 18'd         UserPico.psm
 ADCstate             19'd         UserPico.psm
 SelectScratch        20'd         UserPico.psm
 ADCLevel             21'd         UserPico.psm
 ADCgain              22'd         UserPico.psm
 TX_F_MSB             23'd         UserPico.psm
 TX_F_LSB             24'd         UserPico.psm
 ADCAGCUpperThreshold 25'd         UserPico.psm
 ADCAGCLowerThreshold 26'd         UserPico.psm
 ADCGainTX            27'd         UserPico.psm
 ADCGainRX            28'd         UserPico.psm
 peteTXMode           40'd         UserPico.psm
 Uart_rx              00           UserPico.psm
 Uart_status          01           UserPico.psm
 BattMon              4'd          UserPico.psm
 ArchiveDataLSB       2'd          UserPico.psm
 ArchiveDataMSB       3'd          UserPico.psm
 DSPcmd               4'd          UserPico.psm
 BTcmd                5'd          UserPico.psm
 KPcmd                6'd          UserPico.psm
 TDcmd                7'd          UserPico.psm
 DSPRAMrdbkMSB        9'd          UserPico.psm
 DSPRAMrdbkLSB        10'd         UserPico.psm
 BTRAMrdbkMSB         11'd         UserPico.psm
 BTRAMrdbkLSB         12'd         UserPico.psm
 KPRAMrdbkMSB         13'd         UserPico.psm
 KPRAMrdbkLSB         14'd         UserPico.psm
 ADCSignalLevel       15'd         UserPico.psm
 CMD2DSP              00           UserPico.psm
 UART_TX              01           UserPico.psm
 GainPD               02           UserPico.psm
 Instructiona         03           UserPico.psm
 Instructionb         04           UserPico.psm
 Instructionc         05           UserPico.psm
 ProgramL             06           UserPico.psm
 ProgramM             07           UserPico.psm
 EnArchive            64'd         UserPico.psm
 TX_HIGH              128'd        UserPico.psm
 SelectArchiveSource  8'd          UserPico.psm
 Configure            9'd          UserPico.psm
 RXFreqMSB            10'd         UserPico.psm
 RXFreqLSB            11'd         UserPico.psm
 AudioVolume          12'd         UserPico.psm
 Tone                 13'd         UserPico.psm
 Acknowledge          14'd         UserPico.psm
 DSPFifo              16'd         UserPico.psm
 BTFifo               32'd         UserPico.psm
 KPFifo               64'd         UserPico.psm
 TDFifo               128'd        UserPico.psm
 FlashData            17'd         UserPico.psm
 ADCstate_port        19'd         UserPico.psm
 LoranBlank           16'd         UserPico.psm
 AudioOutSelect       32'd         UserPico.psm
 AnalogueChannel      64'd         UserPico.psm
 CMD2BT               20'd         UserPico.psm
 CMD2KP               21'd         UserPico.psm
 RAMDataMSB           22'd         UserPico.psm
 RAMDataLSB           23'd         UserPico.psm
 RAMwriteControl      25'd         UserPico.psm
 TRANSMIT_ON          14           UserPico.psm
 TRANSMIT_OFF         15           UserPico.psm
 count_1000_lsb       E8           UserPico.psm
 count_1000_msb       03           UserPico.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "04 Mar 2017"  
 timestamp$        "16:57:14"     



List of line labels

   Label                 Addr  Source PSM File

 * boot                  000   UserPico.psm
 * start                 001   UserPico.psm
   reboot                001   UserPico.psm
   DoUserProg            007   UserPico.psm
   GetProg               00A   UserPico.psm
   GetByte               01B   UserPico.psm
   cold_start            021   UserPico.psm
   ProgDSP               022   UserPico.psm
   ScratchClear          023   UserPico.psm
   init                  029   UserPico.psm
   startLoop             040   UserPico.psm
   loop                  041   UserPico.psm
   SendADCToARM          05E   UserPico.psm
   CheckADClevel         06C   UserPico.psm
   nofive                07B   UserPico.psm
   First                 07E   UserPico.psm
   Second                081   UserPico.psm
   Third                 084   UserPico.psm
   Fourth                087   UserPico.psm
   Fifth                 08A   UserPico.psm
   ToLCD                 08E   UserPico.psm
 * Tempskip              08E   UserPico.psm
   ReduceADCgain         096   UserPico.psm
   IncreaseADCgain       09F   UserPico.psm
   checkrqst             0A8   UserPico.psm
   SendToARM             0AB   UserPico.psm
   waitForKey            0AC   UserPico.psm
 * setEarthAntennas      0B2   UserPico.psm
 * setLoopAntennas       0B7   UserPico.psm
 * checkRXmode           0BC   UserPico.psm
   RX                    0C3   UserPico.psm
 * checkTXmode           0CA   UserPico.psm
   setTXmode             0D1   UserPico.psm
   TX                    0EB   UserPico.psm
   setRXmode             0F2   UserPico.psm
   SetAnGain             10B   UserPico.psm
   interpcommand         116   UserPico.psm
 * interploop            117   UserPico.psm
   MsgFromARM            124   UserPico.psm
   isS                   135   UserPico.psm
   isG                   147   UserPico.psm
   isSA                  159   UserPico.psm
   isSB                  163   UserPico.psm
   isSK                  16A   UserPico.psm
   isSL                  16E   UserPico.psm
   setLoranBlank         173   UserPico.psm
   isSKS                 179   UserPico.psm
 * isSS                  17A   UserPico.psm
   isSU                  184   UserPico.psm
   isSW                  189   UserPico.psm
   isSSloop              197   UserPico.psm
   nowsend2flashback     19F   UserPico.psm
 * nowsend2flash         1A7   UserPico.psm
   isSR                  1A9   UserPico.psm
   isST                  1AF   UserPico.psm
   isSAS                 1B3   UserPico.psm
   isSAG                 1B7   UserPico.psm
   isSAI                 1BE   UserPico.psm
   setADC                1C3   UserPico.psm
   isSAO                 1C9   UserPico.psm
   setAudioOut           1CE   UserPico.psm
   isSRF                 1D4   UserPico.psm
   isSRM                 1D9   UserPico.psm
   isSTM                 1DB   UserPico.psm
   isGG                  1DD   UserPico.psm
   isGS                  1E6   UserPico.psm
   isGB                  1EF   UserPico.psm
   isGC                  1F7   UserPico.psm
   isGK                  1FA   UserPico.psm
   isGL                  200   UserPico.psm
   isGKT                 20C   UserPico.psm
   isGKV                 215   UserPico.psm
   isGA                  21E   UserPico.psm
   isGV                  220   UserPico.psm
   Twotone               224   UserPico.psm
   Confidence            231   UserPico.psm
 * Confidenceloop        233   UserPico.psm
   TurnOffWarble         24A   UserPico.psm
 * TurnOffWarbleloop     24C   UserPico.psm
   Warble                278   UserPico.psm
   Warbleloop            279   UserPico.psm
   BeaconBeep            289   UserPico.psm
 * Beaconloop            28B   UserPico.psm
 * cancelbeacon          290   UserPico.psm
   SendTurnOffToKeypad   294   UserPico.psm
   SendToKeypad          295   UserPico.psm
   getUARTchar           299   UserPico.psm
   sendDSP2Terminal      29F   UserPico.psm
 * sendBT2Terminal       2A4   UserPico.psm
 * sendKP2Terminal       2A9   UserPico.psm
 * sendTD2Terminal       2AE   UserPico.psm
   Check4CmdfromDSP      2B3   UserPico.psm
   Check4CmdfromBT       2B8   UserPico.psm
   Check4CmdfromKP       2BC   UserPico.psm
   Check4CmdfromTD       2C1   UserPico.psm
   GetDSPFifoChar        2C6   UserPico.psm
   GetBTFifoChar         2CC   UserPico.psm
   GetKPFifoChar         2D2   UserPico.psm
   GetTDFifoChar         2D8   UserPico.psm
   Chars2Byte            2DE   UserPico.psm
   Get4bits              2E9   UserPico.psm
   char0_9               2EE   UserPico.psm
   Byte2Chars            2F1   UserPico.psm
   GetChar               2FD   UserPico.psm
   is_0_9                301   UserPico.psm
   SendArchive           304   UserPico.psm
   SendAloop             307   UserPico.psm
   ArchiveSource         317   UserPico.psm
   EnableArchive         31E   UserPico.psm
   DisableArchive        323   UserPico.psm
   getnextscratchchar    32C   UserPico.psm
   getnextvalue          331   UserPico.psm
   CheckUartRx           338   UserPico.psm
   Send2UartTX           33C   UserPico.psm
   Byte2UART             342   UserPico.psm
   SendCRLF              347   UserPico.psm
 * SendSPACE             34C   UserPico.psm
 * delay_1s              34F   UserPico.psm
   wait_1s               351   UserPico.psm
 * delay_300ms           359   UserPico.psm
 * delay_200ms           35A   UserPico.psm
   delay_100ms           35D   UserPico.psm
   wait_100ms            35E   UserPico.psm
   delay_1ms             362   UserPico.psm
   wait_1ms              364   UserPico.psm
   delay_50us            36C   UserPico.psm
   wait_50us             36D   UserPico.psm
   delay_1us             371   UserPico.psm
   wait_1us              372   UserPico.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            151
 STAR              -

 AND              41
 OR               16
 XOR               -

 ADD              20
 ADDCY             4
 SUB               9
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          82
 COMPARECY         -

 SL0               6
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               5
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT            19
 OUTPUT           85
 OUTPUTK           -

 STORE            37
 FETCH            37

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP            101
 JUMP@             -
 CALL            204
 CALL@             -
 RETURN           66
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
