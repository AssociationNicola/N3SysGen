KCPSM6 Assembler log file for program 'C:\Users\gnaylor.CCFEPC\Dropbox\N3workingG\TE0722Rebuild\SP3eUserN3_GVA5.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 15 Dec 2015
Assembly timestamp: 16:17:30

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 3A2 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 931
Memory locations available: 3165


Assembly listing

 Addr Code                         Instruction

 000                               ;GVA5 for TE0722, with RX/TX frequencies adjusted for 32.768MHz
 000                               ;GVA4 corrected DSPprog to not crash (AGC suddenly dropping)
 000                               ;GVA2 send demod level to LCD display
 000                               ;GVA0 Add temporary measures around line 510 to transmit values from DSPpico (of tone demod levels as ascii characters on to the LCD)
 000                               ;GV9A, correct Earth Loop setting incorrect and make immediate.
 000                               ; GV99 corrected Attenuator not adding 30 on level display in TX mode, add turn on pad and entenna select
 000                               ; GV98 More BT mic boost
 000                               ; GV97 corrected BT combination
 000                               ; GV96 drop ADC gain RX to 70% and TX to 50%
 000                               ; GV95 Frequency now set from keypad pico
 000                               ; GV94  24 Feb 2015 Pete  -  re-enable BT commands and add scratchpad clear
 000                               ; GV93 add code in KP pico and firmware to display ADC and demod level
 000                               ; GV92 add Pete's new BTcode with shorter inquiry time - but hadn't put in the script at the end of model propertes to get the correct mem files from Pete
 000                               ; line407 disable loran blank for 31kHz
 000                               ; GV91 increased ADC level 10dB by increasing RXAGClevel
 000                               ; GV90 Version to run at 31.008kHz so use 1323 ($52B) for TX and 10925 ($2AAD) for RX
 000                               ; GV51 Use DSP 51 to only attenuate on receive (which had clipping - but transmit was OK)
 000                               ; GV50 Adjusted DSP AGC back down as there was still clipping
 000                               ; GV4F Adjusted AGC thresholds in SP3E and DSPprogN3GV47 to improve clarity of speech
 000                               ; GV4D PMOD2 now used to control extra attenuation (~30dB)
 000                               ; GV4C back to TX_LOW but PMOD1 held low
 000                               ; GV4B For proto D with TX_high  output instead of TX_LOW
 000                               ; GV4A For ProtoD with new keypad
 000                               ; GV48 changed CheckADClevel routine - but still need to change display (KP pico code) to display signal level and gain value. No Beacon
 000                               ; GV46 BT present cuts audio - modified BT detect logic
 000                               ; GV45 Corrected resetting of AveSignalMSB to middle value so as to avoid double jump and increased allowable rang to avoid unnecessary jumps
 000                               ; GV44 Add SU command to set UART output streaming
 000                               ; GV43 Correct beacon phase wander in DSP pico code
 000                               ; GV42 As 41 but with UART testing bits removed
 000                               ; GV41 send DSP data to UART in normal loop and streaming loop
 000                               ; GV40 correct streaming mode bits and shift beacon mode check to end of loop
 000                               ; GV3F  Add UART streaming command for transmit - SS<xx> where xx is hex value of number of bits to shift the values Add GL command to get Loran blank rate
 000                               ; GV3E some work on AGCcounter to include sinewave addition, but mainly add command GS to get AveSignalMSB
 000                               ; GV3D change the way the AGC works in the DSP pico to speed up increasing attenuation if the signal is very strong
 000                               ; GV3C change pincode in BTText to 1234 for HFP profile
 000                               ; GV3A send prompt to DSPcore to grab AGCvalue and store just before the EOT warble + store ADCgain (lower 4 bits) for TX and RX modes (that will be used by CALL SetAnGain )
 000                               ; GV39 Includes Pete's BT code and new DSP AGC stuff (from GV38)
 000                               ; GV36 reduce initial ADC gain on tranmit (reduce mic gain)
 000                               ; GV35 Uses nw I_Q demodulator
 000                               ; GV33 Add delay to audio stream (reduce fdbk?) and use phase incrementing on TX.
 000                               ; GV32 Adjust AGCs
 000                               ; GV31 Now starting to use LPF in DSPprogN3WithLPF and has SL command to set Loran Blanking (SL01)
 000                               ; GV30 reduce RX ADC gain and increase TX (mic) gain.
 000                               ; GV27 Default Loran Blanking on
 000                               ; GV26 for N2 with Higher gain on DSP RF output and shorter beacon period
 000                               ; GV24 for N2
 000                               ; GV23 Corrected some of the RAM block writing issues
 000                               ; GV22 Correct loop not completing when no character! Now displays ADC gain setting on
 000                               ; GV21 use with keypad prog to inhibit pad scan and here send adc level info (should auto gain on ADC to keep between 30 and 100 ie ~$20 and ~$60)
 000                               ; GV20 Corrected non switching of ADC input to MIC!
 000                               ; GV1F Normal orientation of ADC inputs with auto BT audio switching
 000                               ; GV1E temporarily switch ADC input channel as op amp blown!
 000                               ; GV1D Heyphone but for prototype 2 (using TX_HIGH!!)
 000                               ; GV1C For HeyPhone
 000                               ; GV1A Correct flash writing errors to point to right memory address
 000                               ; GV1A
 000                               ; GV19 corrected phase interpretation of SSB encoding
 000                               ; GV18 Try dirac input
 000                               ; GV17 Add STT command to send test sinewave for transmit - Now removed March 2012
 000                               ; GV16 Worked on Beacon lockup, now starts with beacon, press button for ~6secs
 000                               ; GV14 try beacon again at startup
 000                               ; GV15 try to fix not stopping beacon issue (don't start with beacon!) - display mode value on LCD (send to KPpico)
 000                               ; GV13 no beacon
 000                               ; GV11 fix beacon mode so that DSP is blocked at frequency offset and fixed amp for ~1s when ending TX mode - also set Beacon mode on power up which stops when button pressed
 000                               ; Set ADC gain in initialisation properly to calibrate aswell.
 000                               ; GV10 Add ADC signal level monitoring and try phase SSB encoding again with 2x phase to SSB module
 000                               ; Command GL in version GV10 allows the signal level to be returned from the ADC
 000                               ; GV0F Use phase encoding
 000                               ; GV0E full 16 bit frequency coding of TX 29/8/11
 000                               ; GV0D With Beacon
 000                               ; GV0C add BT mic input
 000                               ; GV09 stopped sending r/T t seria; port an adjusted reading from KPfifo
 000                               ; GV08 Added facility to switch RX/TX from keypad
 000                               ; GV07  Increased sensitivity of touch pads June 11
 000                               ; May 26- try and modify so that it starts correctly when powerred up with user program
 000                               ; MayA 11 use PMOD 2 to switch serial port and activate keypad
 000                               ; May 11, add SAO command to set audio channel (00, for BT, 01 for radio transceiver)
 000                               ; March 2011 testing SPI interface:
 000                               ; commands
 000                               ; WREN $06 (enable writing)
 000                               ; WRDI $04 (disable writing)
 000                               ; FAST_READ $0B followed by 3 address bytes, 1 dummy byte and then n bytes to feed back data and leave last 2 values for readback
 000                               ; BERASE  $C7 (bulk erase) - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                               ; SE     $D8 (sector erase) followed by 3 address bytes, - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                               ; PP     $02 (page program) followed by 3 address bytes,  then n bytes of data to be written (need then to pulse Send2Flash by writing 16 to ProgramM)
 000                               ;
 000                               ; Example commands:
 000                               ; SMW0102030405060708090A     -writes values 1-10 to flash addresses from 800000
 000                               ; SMR800002 should read the bytes 03 and 02 ??
 000                               ; Now for Godil Board
 000                               ; Version for multi pico boot with shifted bit offsets on oport
 000                               CONSTANT Versionno, A5              ; Dec 2015
 000                               CONSTANT MinorVersionno, EE         ; Pete
 000                               ; CONSTANT TXType,       7E                 ; $7E for N2 and $80 for Heyphone
 000                               ; CONSTANT RXType,       46                 ; $46 for N2 and 55 for Heyphone)
 000                               CONSTANT Bmode, 00
 000                               ; Set thresholds for AGC
 000                               CONSTANT AGCupperRX, 32             ; Increased factor 2 on RX and TX with signal level monitor - increased RX 3 again from $18 (24 to 72, ie $48)
 000                               CONSTANT AGClowerRX, 12             ; was $0C, increased to 36=$24
 000                               CONSTANT AGCupperTX, 10
 000                               CONSTANT AGClowerTX, 06
 000                               ; SAI Set analogue input SAI<xx>  xx=00 or 01
 000                               ; SAO Set audio Output source
 000                               ; SAS Set archive source SAS<xx>
 000                               ; SAG Set analogue gain SAG<xx>
 000                               ; SB set beacon mode
 000                               ; SRM set receive mode
 000                               ; SRF set receive frequency
 000                               ; STM set transmit mode
 000                               ; STF set transmit frequency
 000                               ; SAG   Set analogue gain, use: 51-5E + automatic calibration
 000                               ; SAS <value> - set archive source (0 or 1)
 000                               ; GA get archive
 000                               ; GT get status of touch
 000                               ; GV get version
 000                               ; GP get response from DSP
 000                               ; GB get response from BT
 000                               ; GKT get touch response from KP
 000                               ; March 2009, now using loading over BT, implement server commands
 000                               ; Dec 2008 - implementing on SSBN3.mdl
 000                               ; Test Spartan 3e board May 2007
 000                               ; Program for user interface: Pico 1
 000                               ; Load SP3E with bit file - spartan3e_adcrx_tx_cw.bit using USB download cable (+ImpacT)
 000                               ; Connect serial lead and send file for test program from Matlab using somethng like
 000                               ; LCDtestprog=getpblazidefile('LCDUartS3e.mem');
 000                               ; Send6bitInstructionsPico1
 000                               ;
 000                               ; Addresses of latched data
 000                               ; 0 Cmd Control Pico2
 000                               ; 1 UartTx
 000                               ; 2 Gain ChA (bits 0-2)
 000                               ; Gain ChB(bits 4-6)
 000                               ; 3 Instruction first 6bits (MSB)
 000                               ; 4 Instruction 2nd 6 bits
 000                               ; 5 Instruction 3rd 6 bits
 000                               ; 6 Program Address LSB
 000                               ; 7 Program Address upper 2 bits
 000                               ;  bit 2,3 and 4 decoded to either Write ROM1,Write ROM2,Write ROM3,Write ROM4 or reset picos
 000                               ;  bit 5-Enable archive
 000                               ;  bit 6-Select archive source
 000                               ;  bit 7 TX_HIGH
 000                               ; 10 Set_RXFreq LSbyte
 000                               ; 11 Set_RXFreq USbyte
 000                               ; 12 Set_TXFreq LSbyte
 000                               ; 13 Set_TXFreq USbyte
 000                               ; 14 Message character 1 -***Note these data ports are for writing characters at the address bus to the message RAM!!
 000                               ; 15 Message character 2
 000                               ; 16 Message character 3 - RAM is written on write to this port (last 6 bit character)
 000                               ; 17 Relay ctrl
 000                               ; 18 Battery monitor
 000                               CONSTANT delay_1us_constant, 12'd   ; Value (13)19 or 12? decimal suitable for 50MHz clock – about 8 for 20MHz
 000                               CONSTANT WREN, 06                   ; (enable writing)
 000                               CONSTANT FAST_READ, 0B              ; followed by 3 address bytes, 1 dummy byte and then n bytes to feed back data and leave last 2 values for readback
 000                               CONSTANT BERASE, C7                 ; (bulk erase) - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                               CONSTANT SER, D8                    ; (sector erase) followed by 3 address bytes, - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                               CONSTANT RDID, 9F
 000                               CONSTANT PP, 02                     ; (page program) followed by 3 address bytes,  then n bytes of data to be written (need then to pulse Send2Flash by writing 16 to CMD2DSP)
 000                               CONSTANT RDSR, 05
 000                               ; Registers
 000                               ;counter             EQU       sC                  ; Counter - for Acquisitions
 000                               ;ScratchPointer      EQU       sB                  ; pointer for decoding command in scratch memory
 000                               NAMEREG sC, counter                 ; Counter - for Acquisitions
 000                               NAMEREG sB, ScratchPointer          ; pointer for decoding command in scratch memory
 000                               ; Scratch pad
 000                               ; Locations 0-15 reserved for incoming command
 000                               CONSTANT Latch7, 16'd               ; This is the current value of an output control register (ProgramM) - used to control writing etc.
 000                               CONSTANT LastDSPbyte, 17'd
 000                               CONSTANT Mode, 18'd                 ; N3 status: bit 0 Beacon mode, bit 1 RX/TX mode, bit 2 Uart streaming mode (TX), bit 3 RX to UART streaming, bit 4 to set loop antenna input
 000                               CONSTANT ADCstate, 19'd             ; saves ADC state
 000                               CONSTANT SelectScratch, 20'd        ; used to store selections (archive source etc.)
 000                               CONSTANT ADCLevel, 21'd
 000                               CONSTANT ADCgain, 22'd              ; 0 means no output, 0E is max gain of 128. Upper 4 bits contain ADC config data
 000                               CONSTANT TX_F_MSB, 23'd             ; Store TX req (16 bits)
 000                               CONSTANT TX_F_LSB, 24'd
 000                               CONSTANT ADCAGCUpperThreshold, 25'd ; Sets value for AGC on RAW input
 000                               CONSTANT ADCAGCLowerThreshold, 26'd ; Sets value for AGC on RAW input
 000                               CONSTANT ADCGainTX, 27'd            ; Analogue gain for TX
 000                               CONSTANT ADCGainRX, 28'd            ; Analogue gain for RX
 000                               CONSTANT AttenuatorState, 29'd      ; Lowest bit indicates if Attenuator is used
 000                               CONSTANT BluetoothXmit, 43          ; from Pete's build - assumes large scratchpad
 000                               ; Input port
 000                               CONSTANT Uart_rx, 00
 000                               CONSTANT Uart_status, 01            ; Uart RX data bit0, Uart TX half full bit 1
 000                               ; bits 2:
 000                               ; Bit 2 BattMon comparator
 000                               ; Offsets:
 000                               CONSTANT BattMon, 4'd
 000                               CONSTANT ArchiveDataLSB, 2'd
 000                               CONSTANT ArchiveDataMSB, 3'd
 000                               CONSTANT DSPcmd, 4'd                ; message from DSP unit
 000                               CONSTANT BTcmd, 5'd                 ; message from BT unit   TEMP - DataReadback from Flash
 000                               CONSTANT KPcmd, 6'd                 ; message from KeyPad unit TEMP - DataReadback_1 from Flash
 000                               CONSTANT DataReadback, 7'd          ; message from BT unit   TEMP - DataReadback from Flash
 000                               CONSTANT DataReadback_1, 8'd        ; message from KeyPad unit TEMP - DataReadback_1 from Flash
 000                               CONSTANT DSPRAMrdbkMSB, 9'd
 000                               CONSTANT DSPRAMrdbkLSB, 10'd
 000                               CONSTANT BTRAMrdbkMSB, 11'd
 000                               CONSTANT BTRAMrdbkLSB, 12'd
 000                               CONSTANT KPRAMrdbkMSB, 13'd
 000                               CONSTANT KPRAMrdbkLSB, 14'd
 000                               CONSTANT ADCSignalLevel, 15'd
 000                               ; Output ports
 000                               CONSTANT CMD2DSP, 00                ; ALSO USED for data to write to SPI flash (sends write automatically)
 000                               CONSTANT UART_TX, 01
 000                               CONSTANT GainPD, 02                 ; Lower 4 bits: 1=0 gain to E=gain 128, bits 4-6 should be 101 and bit 7 is for calibration
 000                               ; Lower 4 bits gain, bits 4-6 for PD0-2 - PD bits should be set to 0101 (ie 5 hex) to enable everything
 000                               CONSTANT Instructiona, 03
 000                               CONSTANT Instructionb, 04
 000                               CONSTANT Instructionc, 05
 000                               CONSTANT ProgramL, 06
 000                               CONSTANT ProgramM, 07
 000                               ; bits 0 and 1 for address, subsequent 4 bits to select which pico to write (bits 2,3,4,5 decoded) - these 3 bits are decoded such that:
 000                               ; if bits 2:5 represent:
 000                               ; 1 - Write Inst1 (User pico instruction) - ie MSB of address should be ORed with 4.
 000                               ; 2 - Write Inst2 (DSP pico instruction) - ie MSB of address should be ORed with 8.
 000                               ; 3 - Write Inst3 (BT pico instruction) - ie MSB of address should be ORed with $0C.
 000                               ; 4 - Write Inst4 (KP pico instruction)
 000                               ; 5 - Write DSP RAM
 000                               ; 6 - Write BT RAM
 000                               ; 7 - Reset other picos
 000                               ; 8 - Write KP RAM
 000                               ; 9 - Send Flash fifo contents (written to on FlashDATA port) to FLASH chip
 000                               ; bit 6 enable archive, and bit 7 TXhigh
 000                               ;
 000                               CONSTANT EnArchive, 64'd
 000                               CONSTANT TX_HIGH, 128'd             ; bit 7
 000                               CONSTANT SelectArchiveSource, 8'd
 000                               CONSTANT RXFreqMSB, 10'd            ; 769A for 88.956kHz ie 86.956kHz carrier and allow range up to 154kHz
 000                               CONSTANT RXFreqLSB, 11'd
 000                               CONSTANT TXFreqMSB, 12'd            ; 3710  with 49MHz clock
 000                               CONSTANT TXFreqLSB, 13'd
 000                               CONSTANT Acknowledge, 14'd
 000                               ; offsets:
 000                               CONSTANT DSPFifo, 16'd
 000                               CONSTANT BTFifo, 32'd
 000                               CONSTANT KPFifo, 64'd
 000                               ; Set bit 4,5,6 to acknowledge FIFO of DSP,BT or Keypad (ie write 16,32 or 64)
 000                               CONSTANT FlashData, 17'd
 000                               ; CONSTANT BatteryMon,   18'd
 000                               CONSTANT ADCstate_port, 19'd        ; Lower 5 bits are not used, bit 6 indictes which ADC channel is read
 000                               ; offset of port 19
 000                               CONSTANT LoranBlank, 16'd           ; $10
 000                               CONSTANT AudioOutSelect, 32'd
 000                               CONSTANT AnalogueChannel, 64'd      ; bit 6
 000                               CONSTANT CMD2BT, 20'd
 000                               CONSTANT CMD2KP, 21'd
 000                               CONSTANT RAMDataMSB, 22'd           ; To send to KP, DSP or BT picos
 000                               CONSTANT RAMDataLSB, 23'd           ; To send to KP, DSP or BT picos
 000                               CONSTANT AttenuatorControl, 24'd
 000                               ; ;; Pete - Bluetooth
 000                               CONSTANT TRANSMIT_ON, 14            ; BT -> User
 000                               CONSTANT TRANSMIT_OFF, 15           ; BT -> User
 000                               ;GenerateCode        MEM       "S3eUser_interface.mem"
 000                               ; Start of test program Must send $40,$50 over serial port to initiate if not re-programming!
 000  22021                  boot: JUMP 021[cold_start]
 001  2001B                reboot: CALL 01B[GetByte]
 002  1D140                        COMPARE s1, 40[64'd]                ; do we have for start byte (64 )
 003  32007                        JUMP Z, 007[DoUserProg]
 004  1D141                        COMPARE s1, 41[65'd]
 005  3E022                        JUMP NC, 022[ProgDSP]               ; This will actually write DSP or other prog (start byte =65 or greater) aargh 27/8/10 - was JUMP Z....
 006  22001                        JUMP 001[reboot]
 007  01704            DoUserProg: LOAD s7, 04
 008  01220                        LOAD s2, 20[32'd]
 009  01300                        LOAD s3, 00                         ; s2 (LSB),s3(USB) of prog counter of first address of new program!
 00A  2001B               GetProg: CALL 01B[GetByte]
 00B  1D180                        COMPARE s1, 80                      ; 80 ($50) indicates end of program
 00C  32021                        JUMP Z, 021[cold_start]             ; When end of prog byte 80 is received
 00D  2D103                        OUTPUT s1, 03[Instructiona]
 00E  2001B                        CALL 01B[GetByte]
 00F  2D104                        OUTPUT s1, 04[Instructionb]
 010  2001B                        CALL 01B[GetByte]
 011  2D105                        OUTPUT s1, 05[Instructionc]         ; write 3x 6bits to latches ready for instruction write
 012  2D206                        OUTPUT s2, 06[ProgramL]
 013  2D307                        OUTPUT s3, 07[ProgramM]             ; Load memory address to write (starting from 32!)
 014  00430                        LOAD s4, s3
 015  04470                        OR s4, s7                           ; Set bit 2 to perform write to RAM 1 or bit 3 to write RAM 2 depending whether start byte was 64 or 65
 016  2D407                        OUTPUT s4, 07[ProgramM]
 017  2D307                        OUTPUT s3, 07[ProgramM]             ; Set write line back to zero
 018  11201                        ADD s2, 01
 019  13300                        ADDCY s3, 00                        ; Increment program counter
 01A  2200A                        JUMP 00A[GetProg]                   ; Get next instruction
 01B  09001               GetByte: INPUT s0, 01[Uart_status]           ; Is there a byte available?
 01C  03001                        AND s0, 01
 01D  1D001                        COMPARE s0, 01
 01E  3601B                        JUMP NZ, 01B[GetByte]               ; until there is a byte in the input buffer!
 01F  09100                        INPUT s1, 00[Uart_rx]
 020  25000                        RETURN 
 021                               ; Program re-written from here
 021                               ; LOAD   s0,0         ;dummy
 021                               ; ProgDSP:
 021                               ; -------------Test of BT chip
 021                               ;         CALL      CheckUartRx
 021                               ; JUMP      NZ,noInput        ;See if anything on input from serial port
 021                               ;
 021                               ; INPUT        s5, Uart_rx         ; get character
 021                               ;      CALL   Byte2Chars
 021                               ;
 021                               ; OUTPUT    s6,BTFifo     ;send MS4bits to BT pico
 021                               ; OUTPUT    s7,BTFifo     ;send LS4bits char to BT pico
 021                               ;
 021                               ;
 021                               ;
 021                               ; noInput:   INPUT        s1, BTcmd      ; Get character from BT picoblaze (if present should be less than 128)
 021                               ; COMPARE      s1, 128             ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 021                               ; CALL      NC,ProgDSP    ; If less than 128 there is a value to give back, otherwise re-start.
 021                               ;
 021                               ;
 021                               ; CALL      GetBTFifoChar
 021                               ;       LOAD      s6, s0              ; get character
 021                               ;       CALL      GetBTFifoChar
 021                               ;       LOAD      s7, s0              ; get character
 021                               ;       CALL  Chars2Byte
 021                               ;       LOAD  s6,s5      ;prepare byte in s6 for next call..
 021                               ; CALL   Send2UartTX    ;Echo back to terminal
 021                               ;
 021                               ;
 021                               ;         JUMP   ProgDSP     ;loop back
 021                               ; -----------------------------------
 021  01000            cold_start: LOAD s0, 00                         ; Note the label 'ProgDSP' is only to allow re-boot to work!
 022                      ProgDSP: 
 022                               ; need to clear scratchpad
 022                               ; ;;LOAD  s0, 0
 022  01100                        LOAD s1, 00
 023                 ScratchClear: 
 023  2E010                        STORE s0, (s1)                      ; zero location
 024  11101                        ADD s1, 01                          ; next
 025  1D100                        COMPARE s1, 00                      ; do all 256 bytes
 026  36023                        JUMP NZ, 023[ScratchClear]          ;
 027  01B00                  init: LOAD sB[ScratchPointer], 00
 028  2F010                        STORE s0, 10[Latch7]                ; initialise latch 7 bits!
 029  01553                        LOAD s5, 53                         ; gain to lowish
 02A  2F516                        STORE s5, 16[ADCgain]               ; save initial value
 02B  2F51C                        STORE s5, 1C[ADCGainRX]             ; save initial value for RX
 02C  2010F                        CALL 10F[SetAnGain]                 ; set gain and calibrate
 02D  01559                        LOAD s5, 59                         ; gain to lowish
 02E  2F51B                        STORE s5, 1B[ADCGainTX]             ; save initial value forTX
 02F                               ;Frequency of TX/RX now set by keypad pico
 02F                               ;                    LOAD      s0, Bmode           ; 1   ;start with beacon if mode =1 (should now work!)
 02F                               ;                    STORE     s0, Mode            ; store setting for beacon mode
 02F                               ;                    LOAD      s0, 05             ; for 31kHz    $0E
 02F                               ;                   STORE     s0, TX_F_MSB        ; store value for 86.95kHz
 02F                               ;                  OUTPUT       s0, TXFreqMSB
 02F                               ;                    LOAD      s0, 2B             ; $7E for N2 and $80 for Heyphone
 02F                               ;                   STORE     s0, TX_F_LSB
 02F                               ;                  OUTPUT       s0, TXFreqLSB       ; and send value to SSB modulator
 02F  01032                        LOAD s0, 32[AGCupperRX]
 030  2F019                        STORE s0, 19[ADCAGCUpperThreshold]
 031  01012                        LOAD s0, 12[AGClowerRX]
 032  2F01A                        STORE s0, 1A[ADCAGCLowerThreshold]
 033  2022F                        CALL 22F[RX]                        ; set receive mode
 034  01100                        LOAD s1, 00
 035  20345                        CALL 345[ArchiveSource]
 036  2034C                        CALL 34C[EnableArchive]
 037  2038B                        CALL 38B[delay_100ms]
 038  01020                        LOAD s0, 20[AudioOutSelect]         ; + 16; normal ADC channel, AudioOUtSelect doesn't do anything here! The 16also sets Loran Blanking if in firmware.
 039  2F013                        STORE s0, 13[ADCstate]              ; save
 03A  2D013                        OUTPUT s0, 13[ADCstate_port]        ; Also sets analogue input to 0
 03B  2005B                  loop: CALL 05B[CheckADClevel]
 03C  0B012                        FETCH s0, 12[Mode]
 03D  03004                        AND s0, 04                          ; look at streaming bit
 03E  1D004                        COMPARE s0, 04
 03F  321EB                        JUMP Z, 1EB[isSSloop]               ; if streaming TX mode, then send a Uart character and return (but will not be able to interpret any command so is stuck!)
 040  0B012                        FETCH s0, 12[Mode]
 041  03008                        AND s0, 08                          ; look at streaming RX bit
 042  1D008                        COMPARE s0, 08
 043  302EB                        CALL Z, 2EB[Check4CmdfromDSP]       ; If fifo character then send to terminal !!!!!!!!!!!!!!!!!!!! reinstate this 9/7/2013
 044  202F5                        CALL 2F5[Check4CmdfromKP]
 045  1D680                        COMPARE s6, 80[128'd]
 046  380C0                        CALL C, 0C0[checkrqst]
 047                               ; Re-enable Beacon mode
 047  0B012                        FETCH s0, 12[Mode]
 048                               ;      OUTPUT    s0,CMD2KP      ;send value to LCD for display - send adc level data instead
 048  03001                        AND s0, 01                          ; only interrested in bit0
 049  1D001                        COMPARE s0, 01                      ; Is it beacon mode?
 04A  302A5                        CALL Z, 2A5[BeaconBeep]
 04B                               ; Pete  enabled 24 Feb 2015
 04B  202F0                        CALL 2F0[Check4CmdfromBT]           ; receive from BT and echo to terminal
 04C  3A2BC                        JUMP C, 2BC[HandleBTCommand]        ; If less than 128 there is a value to give back and display.
 04D         HandleBTCommand_Done: 
 04D                               ; pete end
 04D  202D6                        CALL 2D6[getUARTchar]
 04E  1D620                        COMPARE s6, 20[32'd]
 04F  3203B                        JUMP Z, 03B[loop]                   ; If a space then skip
 050                               ; Had mistankenly changed the next line!
 050  1D6FF                        COMPARE s6, FF
 051  3203B                        JUMP Z, 03B[loop]                   ; If no character then skip-MAKE SURE ANYTHINGTO BE PERFORMED REGULARLY IS DONE BEFORE THIS POINT
 052  1D60D                        COMPARE s6, 0D[13'd]
 053  3211A                        JUMP Z, 11A[interpcommand]          ; This is end of command character
 054  1D60A                        COMPARE s6, 0A[10'd]
 055  3203B                        JUMP Z, 03B[loop]                   ; If LF ignore
 056  1DB16                        COMPARE sB[ScratchPointer], 16      ; Check we are not writing too many characters to the scratchpad
 057  3E03B                        JUMP NC, 03B[loop]                  ; don't write to scratch if Pointer (counter) 16 or above
 058  2E6B0                        STORE s6, (sB[ScratchPointer])      ; Save command character
 059  11B01                        ADD sB[ScratchPointer], 01          ; is a command char so increment
 05A  2203B                        JUMP 03B[loop]
 05B  0900F         CheckADClevel: INPUT s0, 0F[ADCSignalLevel]
 05C  0B115                        FETCH s1, 15[ADCLevel]
 05D  1C010                        COMPARE s0, s1
 05E  31000                        RETURN Z                            ; return if the value is still the same (ie wait for new value)
 05F                               ;__________________________________________________
 05F                               ;TEMPORARY SKIP to TEMPskip:  (values will be redirected directly from DSP to KP in
 05F                               ;      JUMP  Tempskip NOTnow 19 sep 2015
 05F                               ;____________________________________________________
 05F  0117F                        LOAD s1, 7F                         ; Note top bit is not received! Send command to expect signal level
 060  2D115                        OUTPUT s1, 15[CMD2KP]               ; send ADCgain value to LCD for display
 061  2F015                        STORE s0, 15[ADCLevel]              ; save new value of ADClevel
 062                               ; Code to send a value for display as 2 decimal digits in the range 00 to 74 (~42dB) representing the broad band signal strength (5 units per gain step, 1 unit per 8 units of ADC level
 062                               ; assuming ADClevel kept betweeen $18 and $40, signal level within range covers ~8dB, display about 1.7 x value in dB in steps of 2 (~1.2dB)
 062  0B116                        FETCH s1, 16[ADCgain]
 063  0310F                        AND s1, 0F                          ; Gain level just in lower 4 bits
 064  0120E                        LOAD s2, 0E
 065  18210                        SUB s2, s1                          ; Invert gain level to signal level ie highest gain of $E becomes zero
 066  01100                        LOAD s1, 00                         ; use this as counter for lower decimal digit
 067  1420E                        SR0 s2                              ; half the value and send half to the carry flag (to add 5)
 068  3E06A                        JUMP NC, 06A[nofive]                ; only add 5 to lower digit if carry set
 069  01105                        LOAD s1, 05[5'd]
 06A  1D010                nofive: COMPARE s0, 10[16'd]                ; skip if below first step (about 1.2dB)
 06B  3A06D                        JUMP C, 06D[First]
 06C  11102                        ADD s1, 02[2'd]                     ; add 2 units (~1.2dB)
 06D  1D012                 First: COMPARE s0, 12[18'd]                ; skip if below second step (about 1.2dB)
 06E  3A070                        JUMP C, 070[Second]
 06F  11102                        ADD s1, 02[2'd]                     ; add 2 units (~1.2dB)
 070  1D015                Second: COMPARE s0, 15[21'd]                ; skip if below third step (about 1.2dB)
 071  3A073                        JUMP C, 073[Third]
 072  11102                        ADD s1, 02[2'd]                     ; add 2 units (~1.2dB)
 073  1D018                 Third: COMPARE s0, 18[24'd]                ; skip if below
 074  3A076                        JUMP C, 076[Fourth]
 075  11102                        ADD s1, 02[2'd]                     ; add 2 units (~1.2dB)
 076  1D01C                Fourth: COMPARE s0, 1C[28'd]                ; skip if below
 077  3A079                        JUMP C, 079[Fifth]
 078  11102                        ADD s1, 02[2'd]                     ; add 2 units (~1.2dB)
 079                               ; now check if s1 (lower decimal digit) is above 9
 079  1D10A                 Fifth: COMPARE s1, 0A[10'd]
 07A  3A07D                        JUMP C, 07D[Below10]
 07B  11201                        ADD s2, 01[1'd]                     ; Add 1 to first decimal digit
 07C  1910A                        SUB s1, 0A[10'd]                    ; subtract 10 from lower digit
 07D  1D203               Below10: COMPARE s2, 03[3'd]                 ; check if 1st digit 3 or more
 07E  380A8                        CALL C, 0A8[resetAttenuator]        ; if not
 07F  1D207                        COMPARE s2, 07[7'd]                 ; check if already at 7
 080  36083                        JUMP NZ, 083[continue]              ; if below 7 then carry on
 081  1D103                        COMPARE s1, 03[3'd]
 082  3C0B9                        CALL NC, 0B9[setAttenuator]         ; Is 5 so must be 73
 083  0B01D              continue: FETCH s0, 1D[AttenuatorState]
 084  03001                        AND s0, 01[1'd]                     ; look at lowest bit
 085  1D001                        COMPARE s0, 01[1'd]
 086  3608C                        JUMP NZ, 08C[ToLCD]                 ; isn't set
 087  0B012                        FETCH s0, 12[Mode]                  ; check mode
 088  03002                        AND s0, 02[2'd]
 089  1D002                        COMPARE s0, 02[2'd]
 08A  3208C                        JUMP Z, 08C[ToLCD]                  ; If transmit mode then skip
 08B  11203                        ADD s2, 03[3'd]                     ; attenuator is set to add 30 to signal strength ONLY ON RECEIVE!
 08C  2D215                 ToLCD: OUTPUT s2, 15[CMD2KP]               ; Send first decimal digit (as binary value 0-7)
 08D  2D115                        OUTPUT s1, 15[CMD2KP]               ; send second decimal digit (as binary value for 0-9)
 08E                               ; s0 should hoperfully still have ADCsignal level!
 08E                               ;_______________________________
 08E                               ;Temp bit
 08E                     Tempskip: 
 08E                               ;_____________________________________
 08E                               ; LOAD      s5, s0
 08E                               ;      CALL      Byte2UART    ;and echo to UART  - not now!
 08E  0B119                        FETCH s1, 19[ADCAGCUpperThreshold]
 08F  0B015                        FETCH s0, 15[ADCLevel]              ; had lost the s0 value at this point!
 090  1C010                        COMPARE s0, s1                      ; aim to keep value around $15? - need to drop this further! Needs to be lower for transmission??
 091  3C096                        CALL NC, 096[ReduceADCgain]
 092  0B11A                        FETCH s1, 1A[ADCAGCLowerThreshold]
 093  1C010                        COMPARE s0, s1                      ; aim to keep value around $15? -
 094  3809F                        CALL C, 09F[IncreaseADCgain]
 095  25000                        RETURN 
 096  0B016         ReduceADCgain: FETCH s0, 16[ADCgain]
 097  00100                        LOAD s1, s0
 098  0310F                        AND s1, 0F                          ; mask lower 4 bits
 099  1D101                        COMPARE s1, 01                      ; don't drop to zero!
 09A  31000                        RETURN Z
 09B  19001                        SUB s0, 01[1'd]
 09C  2F016                        STORE s0, 16[ADCgain]
 09D  2D002                        OUTPUT s0, 02[GainPD]               ; set ADC pre-amp
 09E                               ; OUTPUT       s0, CMD2KP          ; send value to LCD for display - don't bother
 09E  25000                        RETURN 
 09F  0B016       IncreaseADCgain: FETCH s0, 16[ADCgain]
 0A0  00100                        LOAD s1, s0
 0A1  0310F                        AND s1, 0F                          ; mask lower 4 bits
 0A2  1D10E                        COMPARE s1, 0E                      ; don't go past $0E!
 0A3  31000                        RETURN Z
 0A4  11001                        ADD s0, 01[1'd]
 0A5  2F016                        STORE s0, 16[ADCgain]
 0A6  2D002                        OUTPUT s0, 02[GainPD]               ; set ADC pre-amp
 0A7                               ; OUTPUT       s0, CMD2KP          ; send value to LCD for display
 0A7  25000                        RETURN 
 0A8  0B010       resetAttenuator: FETCH s0, 10[Latch7]
 0A9  03080                        AND s0, 80[TX_HIGH]
 0AA  1D080                        COMPARE s0, 80[TX_HIGH]
 0AB  320B2                        JUMP Z, 0B2[updateAttenuator]       ;if in transmit mode then leave attenuator!
 0AC  0B01D                        FETCH s0, 1D[AttenuatorState]
 0AD  03001                        AND s0, 01[1'd]
 0AE  1D000                        COMPARE s0, 00[0'd]
 0AF  31000                        RETURN Z                            ; return if already zero
 0B0  0B01D                        FETCH s0, 1D[AttenuatorState]
 0B1  030FE                        AND s0, FE
 0B2  2F01D      updateAttenuator: STORE s0, 1D[AttenuatorState]
 0B3  2D018                        OUTPUT s0, 18[AttenuatorControl]
 0B4  01553                        LOAD s5, 53                         ; gain to lowish
 0B5  2F516                        STORE s5, 16[ADCgain]               ; save initial value
 0B6  2F51C                        STORE s5, 1C[ADCGainRX]             ; save initial value for RX
 0B7  2010F                        CALL 10F[SetAnGain]                 ; set gain and calibrate to reset ADC level after attenuator jum (this affects s0)
 0B8  25000                        RETURN 
 0B9  0B010         setAttenuator: FETCH s0, 10[Latch7]
 0BA  03080                        AND s0, 80[TX_HIGH]
 0BB  1D080                        COMPARE s0, 80[TX_HIGH]
 0BC  320B2                        JUMP Z, 0B2[updateAttenuator]
 0BD  0B01D                        FETCH s0, 1D[AttenuatorState]       ; ONLY ON RECEIVE!
 0BE  05001                        OR s0, 01
 0BF  220B2                        JUMP 0B2[updateAttenuator]
 0C0  1D672             checkrqst: COMPARE s6, 72["r"]                 ;character_r
 0C1  300D3                        CALL Z, 0D3[checkRXmode]
 0C2  1D674                        COMPARE s6, 74["t"]                 ;character_t
 0C3  300DC                        CALL Z, 0DC[checkTXmode]
 0C4  1D665                        COMPARE s6, 65["e"]                 ;character_e
 0C5  300C9                        CALL Z, 0C9[setEarthAntennas]
 0C6  1D66C                        COMPARE s6, 6C["l"]                 ; character_l
 0C7  300CE                        CALL Z, 0CE[setLoopAntennas]
 0C8  25000                        RETURN 
 0C9  0B012      setEarthAntennas: FETCH s0, 12[Mode]
 0CA  030EF                        AND s0, EF[239'd]                   ; 255-16  ;reset bit 4
 0CB  2F012                        STORE s0, 12[Mode]
 0CC  200E2                        CALL 0E2[setRXmode]                 ;Make active and return to RX
 0CD  25000                        RETURN 
 0CE  0B012       setLoopAntennas: FETCH s0, 12[Mode]
 0CF  05010                        OR s0, 10[16'd]                     ;set bit 4
 0D0  2F012                        STORE s0, 12[Mode]
 0D1  200E2                        CALL 0E2[setRXmode]
 0D2  25000                        RETURN 
 0D3                  checkRXmode: 
 0D3                               ; ;; Pete added for Bluetooth (temp)
 0D3  0B043                        FETCH s0, 43[BluetoothXmit]
 0D4  11000                        ADD s0, 00
 0D5  35000                        RETURN NZ                           ; do nothing if BT transmitting
 0D6                               ; ;; end Pete added for BT
 0D6  0B012                        FETCH s0, 12[Mode]
 0D7  03002                        AND s0, 02                          ; mask bit 1
 0D8  1D002                        COMPARE s0, 02                      ; is it set ie currently in TX mode?
 0D9  35000                        RETURN NZ                           ; return if already in RX mode return
 0DA  200E2                        CALL 0E2[setRXmode]                 ; so go ahead and set up RX mode
 0DB  25000                        RETURN 
 0DC  0B012           checkTXmode: FETCH s0, 12[Mode]
 0DD  03002                        AND s0, 02                          ; mask bit 1 here 2 means TX mode 0 RX mode
 0DE  1D000                        COMPARE s0, 00                      ; is it not set ie currently in RX mode?
 0DF  35000                        RETURN NZ                           ; return if already in TX mode
 0E0  200FC                        CALL 0FC[setTXmode]                 ; so go ahead and set up TX mode
 0E1  25000                        RETURN 
 0E2                               ; need to set scratch pad mode, set RX freq to 86.95 (SRF769A or for 87kHz need 76AB), input channel with equivalent of SAI00 and send receive mode command to DSP, set analog gain to 8
 0E2  01532             setRXmode: LOAD s5, 32[50'd]                   ; Ascii code for '2' - DSP to grap the AGCvalue before the warble
 0E3  2D500                        OUTPUT s5, 00[CMD2DSP]              ; send command to DSP
 0E4  0B516                        FETCH s5, 16[ADCgain]               ; gain used during TX mode
 0E5  2F51B                        STORE s5, 1B[ADCGainTX]             ; Save for next TX mode
 0E6  20294                        CALL 294[Warble]                    ; send warble beep before returning!
 0E7  0B012                        FETCH s0, 12[Mode]
 0E8  030FC                        AND s0, FC[252'd]                   ;255 - 3         ; reset TX bit AND becon on bit
 0E9  2F012                        STORE s0, 12[Mode]
 0EA                               ; LOAD      s0, 2A             ; $75 for new demodulator   Don't need this from GV95 as keypad sets the frequency
 0EA                               ; OUTPUT       s0, RXFreqMSB
 0EA                               ; LOAD      s0, AD          ; $ N2 or Heyphone)
 0EA                               ; OUTPUT       s0, RXFreqLSB
 0EA                               ;Set ADC channel depending on whether using loop or earth wires (Mode bit 4 set for loop)
 0EA  0B012                        FETCH s0, 12[Mode]
 0EB  03010                        AND s0, 10[16'd]                    ;antenna input select bit (4)
 0EC  14006                        SL0 s0
 0ED  14006                        SL0 s0                              ;to affect bit 6
 0EE  0B113                        FETCH s1, 13[ADCstate]
 0EF  031BF                        AND s1, BF[191'd]                   ; 255 - 64        ; reset  bit 6
 0F0  04100                        OR s1, s0                           ;now affect bit 6 = Mode bit 4 setting
 0F1  2F113                        STORE s1, 13[ADCstate]              ; save
 0F2  2D113                        OUTPUT s1, 13[ADCstate_port]        ; set port to new ADC channel
 0F3  0B51C                        FETCH s5, 1C[ADCGainRX]             ; gain to last value used for RX
 0F4  2F516                        STORE s5, 16[ADCgain]               ; this value is tracked
 0F5  2010F                        CALL 10F[SetAnGain]                 ; set analogue gain to moderate
 0F6  01032                        LOAD s0, 32[AGCupperRX]
 0F7  2F019                        STORE s0, 19[ADCAGCUpperThreshold]
 0F8  01012                        LOAD s0, 12[AGClowerRX]
 0F9  2F01A                        STORE s0, 1A[ADCAGCLowerThreshold]
 0FA  2022F                        CALL 22F[RX]
 0FB  25000                        RETURN 
 0FC                               ; need to set scratch pad mode, set RX freq to 0 (SRF0155), et TX freq to 86.95 STF0E7E, input channel with equivalent of SAI01 and send transmit mode command to DSP
 0FC  0B012             setTXmode: FETCH s0, 12[Mode]
 0FD  05002                        OR s0, 02                           ; set TX bit
 0FE  030FE                        AND s0, FE                          ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 0FF  2F012                        STORE s0, 12[Mode]
 100                               ; LOAD      s0, 01      Don't need this is keypad is sorting it!
 100                               ; OUTPUT       s0, RXFreqMSB
 100                               ; LOAD      s0, 55
 100                               ; OUTPUT       s0, RXFreqLSB       ; drop detection to baseband (for when using wired mic)
 100  0B013                        FETCH s0, 13[ADCstate]
 101  05040                        OR s0, 40[AnalogueChannel]          ; set bit 6 (SAI01) - Channel 1 in Matlab GUI
 102  2F013                        STORE s0, 13[ADCstate]              ; save
 103  2D013                        OUTPUT s0, 13[ADCstate_port]        ; set port to new ADC channel
 104  0B516                        FETCH s5, 16[ADCgain]               ; get gain used for RX
 105  2F51C                        STORE s5, 1C[ADCGainRX]             ; this value is tracked
 106  0B51B                        FETCH s5, 1B[ADCGainTX]             ; gain to last value used for TX
 107  2F516                        STORE s5, 16[ADCgain]               ; and make current ADCgain value
 108  2010F                        CALL 10F[SetAnGain]                 ; set analogue gain to moderate
 109  01010                        LOAD s0, 10[AGCupperTX]
 10A  2F019                        STORE s0, 19[ADCAGCUpperThreshold]
 10B  01006                        LOAD s0, 06[AGClowerTX]
 10C  2F01A                        STORE s0, 1A[ADCAGCLowerThreshold]
 10D  20238                        CALL 238[TX]
 10E  25000                        RETURN 
 10F                               ; set gain to 32 or is it 48?, enter with gain value in s5 (ie $DA for transmit)
 10F  0350F             SetAnGain: AND s5, 0F                          ; only affect lower 4 bits
 110  0B016                        FETCH s0, 16[ADCgain]
 111  030F0                        AND s0, F0                          ; keep upper bits
 112  04500                        OR s5, s0                           ; combine
 113  2F516                        STORE s5, 16[ADCgain]               ; save new value (includes all bits)
 114  05580                        OR s5, 80                           ; set bit 7 to start calibration
 115  2D502                        OUTPUT s5, 02[GainPD]
 116  20390                        CALL 390[delay_1ms]                 ; wait for calib
 117  0357F                        AND s5, 7F[127'd]                   ; reset bit 7
 118  2D502                        OUTPUT s5, 02[GainPD]
 119  25000                        RETURN 
 11A                               ; Now interpret the command in the Scratch buffer and return to init
 11A  01900         interpcommand: LOAD s9, 00                         ; counter through scratchpad addresses.
 11B  1C9B0            interploop: COMPARE s9, sB[ScratchPointer]
 11C  32027                        JUMP Z, 027[init]                   ; break out of loop after reading final character command.
 11D  2035A                        CALL 35A[getnextscratchchar]
 11E  1D053                        COMPARE s0, 53[83'd]                ; is this a S?
 11F  32125                        JUMP Z, 125[isS]
 120  1D047                        COMPARE s0, 47[71'd]                ; is this a G?
 121  32137                        JUMP Z, 137[isG]
 122                               ;      COMPARE      s0, 77'd              ; is this a M?
 122                               ; JUMP      Z, isM
 122  1D05A                        COMPARE s0, 5A[90'd]                ; is this a Z?
 123  32001                        JUMP Z, 001[reboot]                 ; then go to reboot code (ie to reboot need to send Z<CR>, then do Prog...)
 124  2211B                        JUMP 11B[interploop]
 125  2035A                   isS: CALL 35A[getnextscratchchar]
 126  1D042                        COMPARE s0, 42[66'd]                ; is this a B?
 127  32153                        JUMP Z, 153[isSB]                   ;
 128  1D041                        COMPARE s0, 41[65'd]                ; is this a A?
 129  32149                        JUMP Z, 149[isSA]
 12A  1D052                        COMPARE s0, 52[82'd]                ; is this a R?
 12B  321FD                        JUMP Z, 1FD[isSR]
 12C  1D054                        COMPARE s0, 54[84'd]                ; is this a T?
 12D  32203                        JUMP Z, 203[isST]
 12E  1D04B                        COMPARE s0, 4B[75'd]                ; is this a K?
 12F  3215A                        JUMP Z, 15A[isSK]                   ;
 130  1D04C                        COMPARE s0, 4C[76'd]                ; is this a L?
 131  3215E                        JUMP Z, 15E[isSL]                   ; Set Loran Blanking
 132  1D04D                        COMPARE s0, 4D[77'd]                ; is this a M?
 133  3216A                        JUMP Z, 16A[isSM]                   ;
 134                               ;      COMPARE      s0, 83'd              ; is this a S?
 134                               ; JUMP      Z, isSS             ;
 134  1D055                        COMPARE s0, 55[85'd]                ; is this a U
 135  321E6                        JUMP Z, 1E6[isSU]
 136  22027                        JUMP 027[init]
 137  2035A                   isG: CALL 35A[getnextscratchchar]
 138  1D041                        COMPARE s0, 41[65'd]                ; is this a A?
 139  32281                        JUMP Z, 281[isGA]
 13A  1D042                        COMPARE s0, 42[66'd]                ; is this a B?
 13B  32252                        JUMP Z, 252[isGB]
 13C  1D043                        COMPARE s0, 43[67'd]                ; is this a C?
 13D  3225A                        JUMP Z, 25A[isGC]
 13E  1D04B                        COMPARE s0, 4B[75'd]                ; is this a K?
 13F  3225D                        JUMP Z, 25D[isGK]
 140  1D04C                        COMPARE s0, 4C[76'd]                ; is this a L?
 141  32263                        JUMP Z, 263[isGL]
 142  1D056                        COMPARE s0, 56[86'd]                ; is this a V?
 143  32283                        JUMP Z, 283[isGV]
 144  1D047                        COMPARE s0, 47[71'd]                ; is this a G?
 145  32240                        JUMP Z, 240[isGG]
 146  1D053                        COMPARE s0, 53[83'd]                ; is this a S?
 147  32249                        JUMP Z, 249[isGS]
 148  22027                        JUMP 027[init]
 149  2035A                  isSA: CALL 35A[getnextscratchchar]
 14A  1D053                        COMPARE s0, 53[83'd]                ; is this a S?
 14B  32207                        JUMP Z, 207[isSAS]                  ;
 14C  1D047                        COMPARE s0, 47[71'd]                ; is this a G?
 14D  3220B                        JUMP Z, 20B[isSAG]                  ;
 14E  1D04F                        COMPARE s0, 4F[79'd]                ; is this a O?
 14F  3221D                        JUMP Z, 21D[isSAO]                  ;
 150  1D049                        COMPARE s0, 49[73'd]                ; is this a I?
 151  32212                        JUMP Z, 212[isSAI]                  ;
 152  22027                        JUMP 027[init]
 153                               ; SB - set beacon mode (SB<xx>
 153  2035F                  isSB: CALL 35F[getnextvalue]
 154  03501                        AND s5, 01                          ; Mask bit 0
 155  0B012                        FETCH s0, 12[Mode]
 156  030FE                        AND s0, FE[254'd]                   ; reset bit 0
 157  04050                        OR s0, s5                           ; affect bit 0
 158  2F012                        STORE s0, 12[Mode]
 159  22027                        JUMP 027[init]
 15A                               ; Commands for keypad pico
 15A  2035A                  isSK: CALL 35A[getnextscratchchar]
 15B  1D053                        COMPARE s0, 53[83'd]                ; is this a S?
 15C  32169                        JUMP Z, 169[isSKS]                  ;
 15D  22027                        JUMP 027[init]
 15E  2035F                  isSL: CALL 35F[getnextvalue]
 15F  01400                        LOAD s4, 00
 160  1D501                        COMPARE s5, 01                      ; is it 1
 161  36163                        JUMP NZ, 163[setLoranBlank]
 162  01410                        LOAD s4, 10[LoranBlank]
 163  0B013         setLoranBlank: FETCH s0, 13[ADCstate]
 164  030EF                        AND s0, EF[~LoranBlank]             ; reset bit for Loran blanking
 165  04040                        OR s0, s4                           ; affect this bit
 166  2F013                        STORE s0, 13[ADCstate]              ; save
 167  2D013                        OUTPUT s0, 13[ADCstate_port]        ; set port to new ADC channel
 168  22027                        JUMP 027[init]
 169                        isSKS: ; LOAD      s0, 83              ; letter S
 169                               ; OUTPUT       s0, CMD2KP          ; send S to KP
 169                               ; CALL      getnextscratchchar
 169                               ; SUB       s0, 48
 169                               ; OUTPUT       s0, CMD2KP          ; send select value as binary value to KP
 169  22027                        JUMP 027[init]
 16A                               ; Testmemory TEMP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! -memory instructions
 16A  2035A                  isSM: CALL 35A[getnextscratchchar]
 16B  1D057                        COMPARE s0, 57[87'd]                ; is this a W?
 16C  32174                        JUMP Z, 174[isSMW]                  ;
 16D  1D052                        COMPARE s0, 52[82'd]                ; is this a R?
 16E  3219C                        JUMP Z, 19C[isSMR]                  ;
 16F  1D044                        COMPARE s0, 44[68'd]                ; is this a D?
 170  321B9                        JUMP Z, 1B9[isSMD]                  ;
 171  1D053                        COMPARE s0, 53[83'd]                ; is this a S?
 172  321CA                        JUMP Z, 1CA[isSMS]                  ;
 173  22027                        JUMP 027[init]
 174                               ; Testmemory TEMP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 174                               ; write data to flash
 174  01506                 isSMW: LOAD s5, 06[WREN]
 175  2D511                        OUTPUT s5, 11[FlashData]
 176  201F3                        CALL 1F3[nowsend2flashback]         ; write this bit already and come back here!
 177  2039F                        CALL 39F[delay_1us]                 ; wait to complete (maybe 1us enough?)
 178  015D8                        LOAD s5, D8[SER]                    ; sector erase
 179  2D511                        OUTPUT s5, 11[FlashData]
 17A  01504                        LOAD s5, 04                         ; load address to erase (part way through memory)
 17B  2D511                        OUTPUT s5, 11[FlashData]
 17C  01500                        LOAD s5, 00                         ; load address to write to
 17D  2D511                        OUTPUT s5, 11[FlashData]
 17E  01500                        LOAD s5, 00                         ; load address to write to
 17F  2D511                        OUTPUT s5, 11[FlashData]
 180  201F3                        CALL 1F3[nowsend2flashback]         ; write this bit already and come back here!
 181  2037D                        CALL 37D[delay_1s]                  ; wait to complete
 182  2037D                        CALL 37D[delay_1s]
 183  2037D                        CALL 37D[delay_1s]                  ; TO be OPTIMIZED!!!!!!!!!!!!!!!!!!!!!!!
 184  01506                        LOAD s5, 06[WREN]
 185  2D511                        OUTPUT s5, 11[FlashData]
 186  201F3                        CALL 1F3[nowsend2flashback]         ; write this bit already and come back here!
 187  2039F                        CALL 39F[delay_1us]                 ; wait to complete sending serial bits out!
 188  2039F                        CALL 39F[delay_1us]                 ; wait to complete (maybe 1us enough?)
 189  2039F                        CALL 39F[delay_1us]                 ; wait to complete sending serial bits out!
 18A  2039F                        CALL 39F[delay_1us]                 ; wait to complete (maybe 1us enough?)
 18B  2039F                        CALL 39F[delay_1us]                 ; wait to complete sending serial bits out!
 18C  2039F                        CALL 39F[delay_1us]                 ; wait to complete (maybe 1us enough?)
 18D  2039F                        CALL 39F[delay_1us]                 ; wait to complete (maybe 1us enough?)
 18E  201CC                        CALL 1CC[Status]
 18F  01502                        LOAD s5, 02[PP]                     ; write page command
 190  2D511                        OUTPUT s5, 11[FlashData]
 191  01504                        LOAD s5, 04                         ; load address to write to (part way through memory)
 192  2D511                        OUTPUT s5, 11[FlashData]
 193  01500                        LOAD s5, 00                         ; load address to write to
 194  2D511                        OUTPUT s5, 11[FlashData]
 195  01500                        LOAD s5, 00                         ; load address to write to
 196  2D511                        OUTPUT s5, 11[FlashData]
 197  1C9B0             isSMWloop: COMPARE s9, sB[ScratchPointer]      ; break out of loop after reading final character command.
 198  321FB                        JUMP Z, 1FB[nowsend2flash]          ; if so write to flash and break out
 199  2035F                        CALL 35F[getnextvalue]
 19A  2D511                        OUTPUT s5, 11[FlashData]
 19B  22197                        JUMP 197[isSMWloop]                 ; loop back to get next data value
 19C                               ; FAST_READ
 19C  0150B                 isSMR: LOAD s5, 0B[FAST_READ]
 19D  2D511                        OUTPUT s5, 11[FlashData]
 19E  2035F                        CALL 35F[getnextvalue]              ; load address to write to (about half way through memory ~10)
 19F  2D511                        OUTPUT s5, 11[FlashData]
 1A0  2035F                        CALL 35F[getnextvalue]
 1A1  2D511                        OUTPUT s5, 11[FlashData]
 1A2  2035F                        CALL 35F[getnextvalue]
 1A3  2D511                        OUTPUT s5, 11[FlashData]
 1A4                               ; now send dummy bytes to get 2 byte values
 1A4  01500                        LOAD s5, 00                         ; dummy
 1A5  2D511                        OUTPUT s5, 11[FlashData]
 1A6  01500                        LOAD s5, 00                         ; dummy byte
 1A7  2D511                        OUTPUT s5, 11[FlashData]
 1A8  01500                        LOAD s5, 00                         ; dummy byte
 1A9  2D511                        OUTPUT s5, 11[FlashData]
 1AA  01524                        LOAD s5, 24[36'd]                   ; was 16 should be 9x4=36
 1AB  2D507                        OUTPUT s5, 07[ProgramM]             ; initiates flash write - may take some time for pp command!
 1AC  01500                        LOAD s5, 00                         ; reset
 1AD  2D507                        OUTPUT s5, 07[ProgramM]             ;
 1AE  2039F                        CALL 39F[delay_1us]                 ; wait to complete sending serial bits out!
 1AF  2039F                        CALL 39F[delay_1us]                 ; wait to complete (maybe 1us enough?)
 1B0  2039F                        CALL 39F[delay_1us]                 ; wait to complete sending serial bits out!
 1B1  2039F                        CALL 39F[delay_1us]                 ; wait to complete (maybe 1us enough?)
 1B2  2039F                        CALL 39F[delay_1us]                 ; wait to complete sending serial bits out!
 1B3  2039F                        CALL 39F[delay_1us]                 ; wait to complete (maybe 1us enough?)
 1B4  09508                        INPUT s5, 08[DataReadback_1]
 1B5  20370                        CALL 370[Byte2UART]                 ; echo values as 2 ascii codes back to terminal
 1B6  09507                        INPUT s5, 07[DataReadback]
 1B7  20370                        CALL 370[Byte2UART]
 1B8  22027                        JUMP 027[init]                      ; loop back
 1B9                               ; READ DID
 1B9  0159F                 isSMD: LOAD s5, 9F[RDID]
 1BA  2D511                        OUTPUT s5, 11[FlashData]
 1BB                               ; now send dummy bytes to get 2 byte values
 1BB  01500                        LOAD s5, 00                         ; dummy
 1BC  2D511                        OUTPUT s5, 11[FlashData]
 1BD  01500                        LOAD s5, 00                         ; dummy byte
 1BE  2D511                        OUTPUT s5, 11[FlashData]
 1BF                               ; LOAD      s5, 0               ; dummy byte
 1BF                               ; OUTPUT       s5, FlashData
 1BF  01524                        LOAD s5, 24[36'd]                   ; was 16 should be 9x4=36
 1C0  2D507                        OUTPUT s5, 07[ProgramM]             ; initiates flash write
 1C1  01500                        LOAD s5, 00                         ; reset
 1C2  2D507                        OUTPUT s5, 07[ProgramM]             ;
 1C3  2039F                        CALL 39F[delay_1us]                 ; wait to complete sending serial bits out!
 1C4  2039F                        CALL 39F[delay_1us]                 ; wait to complete
 1C5  09508                        INPUT s5, 08[DataReadback_1]        ; first value
 1C6  20370                        CALL 370[Byte2UART]                 ; echo values as 2 ascii codes back to terminal
 1C7  09507                        INPUT s5, 07[DataReadback]          ; second value
 1C8  20370                        CALL 370[Byte2UART]
 1C9  22027                        JUMP 027[init]                      ; loop back
 1CA                               ; Read status register
 1CA  201CC                 isSMS: CALL 1CC[Status]
 1CB  22027                        JUMP 027[init]                      ; loop back
 1CC  01505                Status: LOAD s5, 05[RDSR]
 1CD  2D511                        OUTPUT s5, 11[FlashData]
 1CE                               ; now send dummy bytes to get 2 byte values
 1CE  01500                        LOAD s5, 00                         ; dummy
 1CF  2D511                        OUTPUT s5, 11[FlashData]
 1D0  01500                        LOAD s5, 00                         ; dummy byte
 1D1  2D511                        OUTPUT s5, 11[FlashData]
 1D2  201F3                        CALL 1F3[nowsend2flashback]
 1D3  2039F                        CALL 39F[delay_1us]                 ; wait to complete sending serial bits out!
 1D4  2039F                        CALL 39F[delay_1us]                 ; wait to complete
 1D5  20375                        CALL 375[SendCRLF]
 1D6  09508                        INPUT s5, 08[DataReadback_1]        ; first value
 1D7  20370                        CALL 370[Byte2UART]                 ; echo values as 2 ascii codes back to terminal
 1D8  09507                        INPUT s5, 07[DataReadback]          ; second value
 1D9  20370                        CALL 370[Byte2UART]
 1DA  20375                        CALL 375[SendCRLF]
 1DB  25000                        RETURN 
 1DC                               ; This streams from UART data to DSP to TX and never exits!
 1DC  2035A                  isSS: CALL 35A[getnextscratchchar]        ; get beacon offset in s0
 1DD  01533                        LOAD s5, 33[51'd]                   ; Ascii code for '3' - set stream mode -NO ESCAPE!
 1DE  2D500                        OUTPUT s5, 00[CMD2DSP]              ; send command to DSP
 1DF  2D000                        OUTPUT s0, 00[CMD2DSP]              ; send raw data byte of bit offset
 1E0  20238                        CALL 238[TX]
 1E1  0B012                        FETCH s0, 12[Mode]
 1E2  05004                        OR s0, 04                           ; set 'Streaming TX' bit
 1E3  030FE                        AND s0, FE                          ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 1E4  2F012                        STORE s0, 12[Mode]
 1E5  2203B                        JUMP 03B[loop]                      ;
 1E6                               ; Stream RX data to UART
 1E6  0B012                  isSU: FETCH s0, 12[Mode]
 1E7  05008                        OR s0, 08                           ; set 'Streaming TX' bit
 1E8  030FE                        AND s0, FE                          ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 1E9  2F012                        STORE s0, 12[Mode]
 1EA  22027                        JUMP 027[init]                      ;
 1EB                               ; Now get a raw UART byte
 1EB  20366              isSSloop: CALL 366[CheckUartRx]
 1EC  361EB                        JUMP NZ, 1EB[isSSloop]              ; loop if nothing in UART buffer
 1ED  09500                        INPUT s5, 00[Uart_rx]               ; get byte
 1EE  2031F                        CALL 31F[Byte2Chars]
 1EF  2D600                        OUTPUT s6, 00[CMD2DSP]              ; Send audio MSBbyte to DSP
 1F0  2D700                        OUTPUT s7, 00[CMD2DSP]              ; Send audio LSBbyte to DSP
 1F1  202EB                        CALL 2EB[Check4CmdfromDSP]          ; If fifo character then send to terminal !!!!!!!!!!!!!!!!!!!! reinstate this 15/5/2013
 1F2  2203B                        JUMP 03B[loop]                      ; Try making this a called routine, sending 1 value per loop
 1F3                               ; this is same as following routine except it returns rather than jumping to init
 1F3  01524     nowsend2flashback: LOAD s5, 24[36'd]                   ; was 16 should be 9x4=36
 1F4  2D507                        OUTPUT s5, 07[ProgramM]             ; initiates flash write - may take some time for pp command!
 1F5  20390                        CALL 390[delay_1ms]                 ; wait to complete
 1F6  20390                        CALL 390[delay_1ms]
 1F7  20390                        CALL 390[delay_1ms]                 ; TO be OPTIMIZED!!!!!!!!!!!!!!!!!!!!!!!
 1F8  01500                        LOAD s5, 00                         ; reset send2flash
 1F9  2D507                        OUTPUT s5, 07[ProgramM]             ; initiates flash write - may take some time for pp command!
 1FA  25000                        RETURN 
 1FB  201F3         nowsend2flash: CALL 1F3[nowsend2flashback]
 1FC  22027                        JUMP 027[init]
 1FD  2035A                  isSR: CALL 35A[getnextscratchchar]
 1FE  1D046                        COMPARE s0, 46[70'd]                ; is this a F?
 1FF  32228                        JUMP Z, 228[isSRF]                  ;
 200  1D04D                        COMPARE s0, 4D[77'd]                ; is this a M?
 201  3222D                        JUMP Z, 22D[isSRM]                  ;
 202  22027                        JUMP 027[init]
 203                               ; Testmemory TEMP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END
 203  2035A                  isST: CALL 35A[getnextscratchchar]
 204                               ;                    COMPARE      s0, 70'd              ; is this a F?
 204                               ;                   JUMP      Z, isSTF            ;
 204  1D04D                        COMPARE s0, 4D[77'd]                ; is this a M?
 205  32236                        JUMP Z, 236[isSTM]                  ;
 206  22027                        JUMP 027[init]
 207                               ; SAS - set archive source
 207  2035F                 isSAS: CALL 35F[getnextvalue]
 208  00150                        LOAD s1, s5
 209  20345                        CALL 345[ArchiveSource]
 20A  22027                        JUMP 027[init]
 20B                               ; SAG   Set analogue gain
 20B  2035F                 isSAG: CALL 35F[getnextvalue]
 20C  05580                        OR s5, 80[128'd]                    ; set bit 7
 20D  2D502                        OUTPUT s5, 02[GainPD]
 20E  20390                        CALL 390[delay_1ms]                 ; wait for calib
 20F  0357F                        AND s5, 7F[127'd]                   ; reset bit 7
 210  2D502                        OUTPUT s5, 02[GainPD]
 211  22027                        JUMP 027[init]
 212  2035F                 isSAI: CALL 35F[getnextvalue]
 213  01400                        LOAD s4, 00
 214  1D501                        COMPARE s5, 01                      ; is it 1
 215  36217                        JUMP NZ, 217[setADC]
 216  01440                        LOAD s4, 40[64'd]
 217  0B013                setADC: FETCH s0, 13[ADCstate]
 218  030BF                        AND s0, BF[191'd]                   ; reset bit 6
 219  04040                        OR s0, s4                           ; affect bit 6
 21A  2F013                        STORE s0, 13[ADCstate]              ; save
 21B  2D013                        OUTPUT s0, 13[ADCstate_port]        ; set port to new ADC channel
 21C  22027                        JUMP 027[init]
 21D  2035F                 isSAO: CALL 35F[getnextvalue]
 21E  01400                        LOAD s4, 00
 21F  1D501                        COMPARE s5, 01                      ; is it 1
 220  36222                        JUMP NZ, 222[setAudioOut]
 221  01420                        LOAD s4, 20[32'd]
 222  0B013           setAudioOut: FETCH s0, 13[ADCstate]
 223  030DF                        AND s0, DF[223'd]                   ; 255 - 32        ; reset bit5
 224  04040                        OR s0, s4                           ; affect bit 5
 225  2F013                        STORE s0, 13[ADCstate]              ; save
 226  2D013                        OUTPUT s0, 13[ADCstate_port]        ; set port to new audio channel
 227  22027                        JUMP 027[init]
 228                               ; SRF - set receive frequency (gets 4 hex digits
 228  2035F                 isSRF: CALL 35F[getnextvalue]              ; get byte represented by 2 digits
 229  2D50A                        OUTPUT s5, 0A[RXFreqMSB]
 22A  2035F                        CALL 35F[getnextvalue]
 22B  2D50B                        OUTPUT s5, 0B[RXFreqLSB]
 22C  22027                        JUMP 027[init]
 22D                               ; set receive mode
 22D  200E2                 isSRM: CALL 0E2[setRXmode]                 ; used to be RX, but that doesn't change mode and frequency etc.
 22E  22027                        JUMP 027[init]
 22F                               ; Routine to set receive mode - just basic function ie doesn't set mode etc.
 22F  01548                    RX: LOAD s5, 48                         ; Ascii code for '0' - set receive mode
 230  2D500                        OUTPUT s5, 00[CMD2DSP]              ; send command to DSP
 231  0B510                        FETCH s5, 10[Latch7]
 232  0357F                        AND s5, 7F[~TX_HIGH]                ; reset bit 7
 233  2F510                        STORE s5, 10[Latch7]
 234  2D507                        OUTPUT s5, 07[ProgramM]
 235  25000                        RETURN 
 236                               ; set Tranmit mode
 236  200FC                 isSTM: CALL 0FC[setTXmode]                 ; used to be TX 20/5/2013
 237  22027                        JUMP 027[init]
 238                               ; routine to set transmit mode
 238  01531                    TX: LOAD s5, 31[49'd]                   ; Ascii code for '1' - set transmit mode
 239  2D500                        OUTPUT s5, 00[CMD2DSP]              ; send command to DSP
 23A  0B510                        FETCH s5, 10[Latch7]
 23B  05580                        OR s5, 80[TX_HIGH]                  ; set bit 7
 23C  2F510                        STORE s5, 10[Latch7]
 23D  2D507                        OUTPUT s5, 07[ProgramM]
 23E  20287                        CALL 287[Twotone]                   ; added to give start of message beep
 23F  25000                        RETURN 
 240                               ; STF - set transmit frequency (gets 4 hex digits -Frequency now set by Keypad
 240                               ;isSTF:              CALL      getnextvalue        ; get byte represented by 2 digits
 240                               ;                   OUTPUT       s5, TXFreqMSB
 240                               ;                  CALL      getnextvalue
 240                               ;                 OUTPUT       s5, TXFreqLSB
 240                               ;                JUMP      init
 240                               ; GET AGC value from DSP
 240  01071                  isGG: LOAD s0, 71                         ; letter G
 241  2D000                        OUTPUT s0, 00[CMD2DSP]              ; send G to DSP
 242  20375                        CALL 375[SendCRLF]
 243  20390                        CALL 390[delay_1ms]
 244  202EB                        CALL 2EB[Check4CmdfromDSP]          ; if character send to terminal
 245  202EB                        CALL 2EB[Check4CmdfromDSP]          ; if character send to terminal
 246  202EB                        CALL 2EB[Check4CmdfromDSP]          ; if character send to terminal
 247  202EB                        CALL 2EB[Check4CmdfromDSP]          ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 248                               ;      CALL      SendCRLF
 248  22027                        JUMP 027[init]
 249                               ; Get AVEsignal level from DSP
 249  01083                  isGS: LOAD s0, 83                         ; letter S
 24A  2D000                        OUTPUT s0, 00[CMD2DSP]              ; send S to DSP
 24B  20375                        CALL 375[SendCRLF]
 24C  20390                        CALL 390[delay_1ms]
 24D  202EB                        CALL 2EB[Check4CmdfromDSP]          ; if character send to terminal
 24E  202EB                        CALL 2EB[Check4CmdfromDSP]          ; if character send to terminal
 24F  202EB                        CALL 2EB[Check4CmdfromDSP]          ; if character send to terminal
 250  202EB                        CALL 2EB[Check4CmdfromDSP]          ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 251                               ;      CALL      SendCRLF
 251  22027                        JUMP 027[init]
 252                               ; send test command to BT pico
 252  01071                  isGB: LOAD s0, 71                         ; letter G
 253  2D014                        OUTPUT s0, 14[CMD2BT]               ; send G to BT
 254                               ;      CALL      SendCRLF
 254  20390                        CALL 390[delay_1ms]
 255  202F0                        CALL 2F0[Check4CmdfromBT]           ; if character send to terminal
 256  202F0                        CALL 2F0[Check4CmdfromBT]           ; if character send to terminal
 257  202F0                        CALL 2F0[Check4CmdfromBT]           ; if character send to terminal
 258  202F0                        CALL 2F0[Check4CmdfromBT]           ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 259                               ;      CALL      SendCRLF
 259  22027                        JUMP 027[init]
 25A                               ; Return Loran inhibit rate
 25A  09508                  isGC: INPUT s5, 08
 25B  20370                        CALL 370[Byte2UART]
 25C  25000                        RETURN 
 25D                               ; Request from keypad pico
 25D  2035A                  isGK: CALL 35A[getnextscratchchar]
 25E  1D054                        COMPARE s0, 54[84'd]                ; is this a T?
 25F  3226F                        JUMP Z, 26F[isGKT]
 260  1D056                        COMPARE s0, 56[86'd]                ; is this a V?
 261  32278                        JUMP Z, 278[isGKV]
 262  22027                        JUMP 027[init]
 263                               ; report signal level from the ADC
 263  0B515                  isGL: FETCH s5, 15[ADCLevel]
 264  20370                        CALL 370[Byte2UART]
 265  01620                        LOAD s6, 20                         ; space
 266  2036A                        CALL 36A[Send2UartTX]
 267  0950F                        INPUT s5, 0F[ADCSignalLevel]
 268  20370                        CALL 370[Byte2UART]
 269  01620                        LOAD s6, 20                         ; space
 26A  2036A                        CALL 36A[Send2UartTX]
 26B  0B516                        FETCH s5, 16[ADCgain]
 26C  20370                        CALL 370[Byte2UART]
 26D  20375                        CALL 375[SendCRLF]
 26E  22027                        JUMP 027[init]
 26F                               ; send test command to KP pico
 26F  01054                 isGKT: LOAD s0, 54[84'd]                   ; letter T
 270  2D015                        OUTPUT s0, 15[CMD2KP]               ; send T to KP
 271  20375                        CALL 375[SendCRLF]
 272  20390                        CALL 390[delay_1ms]
 273  202F5                        CALL 2F5[Check4CmdfromKP]           ; if character send to terminal
 274  202F5                        CALL 2F5[Check4CmdfromKP]           ; if character send to terminal
 275  202F5                        CALL 2F5[Check4CmdfromKP]           ; if character send to terminal
 276  202F5                        CALL 2F5[Check4CmdfromKP]           ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 277                               ;      CALL      SendCRLF
 277  22027                        JUMP 027[init]
 278  01056                 isGKV: LOAD s0, 56[86'd]                   ; letter V
 279  2D015                        OUTPUT s0, 15[CMD2KP]               ; send V to KP
 27A  20375                        CALL 375[SendCRLF]
 27B  20390                        CALL 390[delay_1ms]
 27C  202F5                        CALL 2F5[Check4CmdfromKP]           ; if character send to terminal
 27D  202F5                        CALL 2F5[Check4CmdfromKP]           ; if character send to terminal
 27E  202F5                        CALL 2F5[Check4CmdfromKP]           ; if character send to terminal
 27F  202F5                        CALL 2F5[Check4CmdfromKP]           ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 280                               ;      CALL      SendCRLF
 280  22027                        JUMP 027[init]
 281  20332                  isGA: CALL 332[SendArchive]
 282  22027                        JUMP 027[init]
 283  015A5                  isGV: LOAD s5, A5[Versionno]
 284  20370                        CALL 370[Byte2UART]
 285  20375                        CALL 375[SendCRLF]                  ; added to allow get line to read OK
 286  22027                        JUMP 027[init]
 287  01042               Twotone: LOAD s0, 42[66'd]                   ; Block DSPpico
 288  2D000                        OUTPUT s0, 00[CMD2DSP]              ; send B to DSP to block it
 289                               ; need to output TX freq carrier plus 30 then 40 and then return to carrier - now simply as an increment
 289  01035                        LOAD s0, 35[53'd]
 28A  2D00D                        OUTPUT s0, 0D[TXFreqLSB]
 28B  2038B                        CALL 38B[delay_100ms]
 28C  01023                        LOAD s0, 23[35'd]
 28D  2D00D                        OUTPUT s0, 0D[TXFreqLSB]
 28E  2038B                        CALL 38B[delay_100ms]
 28F  01000                        LOAD s0, 00
 290  2D00D                        OUTPUT s0, 0D[TXFreqLSB]            ; and send value to SSB modulatorto reset to normal frequency
 291  01052                        LOAD s0, 52[82'd]                   ; Un Block DSPpico
 292  2D000                        OUTPUT s0, 00[CMD2DSP]              ; send R to DSP (release)
 293  25000                        RETURN 
 294  01500                Warble: LOAD s5, 00
 295  01042            Warbleloop: LOAD s0, 42[66'd]                   ; Block DSPpico
 296  2D000                        OUTPUT s0, 00[CMD2DSP]              ; send B to DSP to block it
 297                               ; need to output TX freq carrier plus 30 then 40 and then return to carrier - now simply as an increment
 297  0101E                        LOAD s0, 1E[30'd]
 298  2D00D                        OUTPUT s0, 0D[TXFreqLSB]
 299  2038B                        CALL 38B[delay_100ms]
 29A  01028                        LOAD s0, 28[40'd]
 29B  2D00D                        OUTPUT s0, 0D[TXFreqLSB]
 29C  2038B                        CALL 38B[delay_100ms]
 29D  11501                        ADD s5, 01
 29E  1D504                        COMPARE s5, 04                      ; Do this 4 times
 29F  36295                        JUMP NZ, 295[Warbleloop]
 2A0  01000                        LOAD s0, 00
 2A1  2D00D                        OUTPUT s0, 0D[TXFreqLSB]            ; and send value to SSB modulatorto reset to normal frequency
 2A2  01052                        LOAD s0, 52[82'd]                   ; Un Block DSPpico
 2A3  2D000                        OUTPUT s0, 00[CMD2DSP]              ; send R to DSP (release)
 2A4  25000                        RETURN 
 2A5  20238            BeaconBeep: CALL 238[TX]
 2A6  01700                        LOAD s7, 00
 2A7  20294            Beaconloop: CALL 294[Warble]
 2A8                               ; Keep checking fifo for a character to keep it clear!
 2A8  202F5                        CALL 2F5[Check4CmdfromKP]
 2A9  1D674                        COMPARE s6, 74["t"]                 ; character_t
 2AA  322B8                        JUMP Z, 2B8[cancelbeacon]           ; Escape if is key pressed - changed this 2/5/13 to speed up beacon cancel
 2AB  11701                        ADD s7, 01
 2AC  1D703                        COMPARE s7, 03
 2AD  362A7                        JUMP NZ, 2A7[Beaconloop]            ; do warble 3 times
 2AE  2022F                        CALL 22F[RX]
 2AF  2037D                        CALL 37D[delay_1s]
 2B0                               ; Keep checking fifo for a character to keep it clear!
 2B0  202F5                        CALL 2F5[Check4CmdfromKP]
 2B1  1D674                        COMPARE s6, 74["t"]                 ; character_t
 2B2  322B8                        JUMP Z, 2B8[cancelbeacon]           ; Escape if is key pressed
 2B3  2037D                        CALL 37D[delay_1s]
 2B4                               ; Keep checking fifo for a character to keep it clear!
 2B4  202F5                        CALL 2F5[Check4CmdfromKP]
 2B5  1D674                        COMPARE s6, 74["t"]                 ; character_t
 2B6  322B8                        JUMP Z, 2B8[cancelbeacon]           ; Escape if is key pressed
 2B7                               ; 6/7/12 reduced receive period to 2s
 2B7  25000                        RETURN 
 2B8  0B012          cancelbeacon: FETCH s0, 12[Mode]
 2B9  030FE                        AND s0, FE[254'd]                   ; cancel beaon mode
 2BA  2F012                        STORE s0, 12[Mode]                  ; Hah - had forgotton to update the mode! 20/5/13
 2BB  25000                        RETURN 
 2BC                               ; ;;Pete
 2BC                               ; ;;Pete
 2BC                               ; ;;Pete
 2BC              HandleBTCommand: 
 2BC                               ; ;;LOAD      s6, 'A'             ; get character
 2BC                               ; ;;CALL      Send2UartTX         ; and echo back to terminal
 2BC  0307F                        AND s0, 7F                          ; mask off top bit
 2BD                               ; need to interpret commands from BT Here
 2BD  1D014                        COMPARE s0, 14[TRANSMIT_ON]
 2BE  322C2                        JUMP Z, 2C2[FromBT_XMIT]            ; Bluetooth Headset transmit
 2BF  1D015                        COMPARE s0, 15[TRANSMIT_OFF]
 2C0  322CC                        JUMP Z, 2CC[FromBT_RECEIVE]         ; Bluetooth Headset stop transmit
 2C1                               ; ;;COMPARE      s0, FLASH_WRITE
 2C1                               ; ;;JUMP      Z, FromBT_WRITE     ; PC has sent a WRITE to Flash request
 2C1                               ; ;;COMPARE      s0, FLASH_WRITE_PAGE
 2C1                               ; ;;JUMP      Z, FromBT_WRITE_PAGE; PC has sent a WRITE PAGE to Flash request
 2C1                               ; ;;COMPARE      s0, FLASH_ERASE
 2C1                               ; ;;JUMP      Z, FromBT_ERASE     ; PC has sent a Erase the Write message
 2C1                               ; ;;COMPARE      s0, FLASH_READ
 2C1                               ; ;;JUMP      Z, FromBT_READ      ; PC has sent a Read request
 2C1                               ; ;;COMPARE      s0, FLASH_READ_PAGE
 2C1                               ; ;;JUMP      Z, FromBT_READ_PAGE ; PC has sent a Read Page request
 2C1                               ; ;;COMPARE      s0, FLASH_WRITE_TEXT
 2C1                               ; ;;JUMP      Z, FromBT_WRITE_TEXT; PC has sent a WRITE TEXT to Flash request
 2C1                               ; LOAD      s0, 2F             ; send message back
 2C1                               ; OUTPUT       s0, CMD2BT          ; send Go to BT
 2C1                               ; CALL      SendCharToBT
 2C1  2204D                        JUMP 04D[HandleBTCommand_Done]
 2C2                  FromBT_XMIT: 
 2C2  20375                        CALL 375[SendCRLF]
 2C3  01654                        LOAD s6, 54["T"]
 2C4  2036A                        CALL 36A[Send2UartTX]               ; and echo back to terminal. Message mode
 2C5  01678                        LOAD s6, 78["x"]
 2C6  2036A                        CALL 36A[Send2UartTX]               ; and echo back to terminal. Message mode
 2C7  200FC                        CALL 0FC[setTXmode]
 2C8  20375                        CALL 375[SendCRLF]
 2C9  01001                        LOAD s0, 01
 2CA  2F043                        STORE s0, 43[BluetoothXmit]
 2CB  2204D                        JUMP 04D[HandleBTCommand_Done]
 2CC               FromBT_RECEIVE: 
 2CC  20375                        CALL 375[SendCRLF]
 2CD  01652                        LOAD s6, 52["R"]
 2CE  2036A                        CALL 36A[Send2UartTX]               ; and echo back to terminal. Message mode
 2CF  01663                        LOAD s6, 63["c"]
 2D0  2036A                        CALL 36A[Send2UartTX]               ; and echo back to terminal. Message mode
 2D1  200E2                        CALL 0E2[setRXmode]
 2D2  20375                        CALL 375[SendCRLF]
 2D3  01000                        LOAD s0, 00
 2D4  2F043                        STORE s0, 43[BluetoothXmit]
 2D5  2204D                        JUMP 04D[HandleBTCommand_Done]
 2D6                               ; ;; end Pete
 2D6                               ; ;; end Pete
 2D6                               ; ;; end Pete
 2D6  016FF           getUARTchar: LOAD s6, FF                         ; Return FF if no character
 2D7  20366                        CALL 366[CheckUartRx]
 2D8  35000                        RETURN NZ                           ; Return if no character with s6=$FF
 2D9  09600                        INPUT s6, 00[Uart_rx]               ; get character
 2DA  0367F                        AND s6, 7F
 2DB                               ; CALL      Send2UartTX         ; and echo back to terminal. - SHOULD USE Send2UartTX (not in message mode)
 2DB  25000                        RETURN 
 2DC                               ; returns fifo character in s6 assuming present
 2DC  202FA      sendDSP2Terminal: CALL 2FA[GetDSPFifoChar]
 2DD  01600                        LOAD s6, 00                         ; get character
 2DE  0367F                        AND s6, 7F                          ; top bit is for empty fifo flag!
 2DF                               ;Send to keypad pico (LCD) instead
 2DF                               ;                    CALL      Send2UartTX         ; and echo back to terminal.
 2DF  2D615                        OUTPUT s6, 15[CMD2KP]               ; send code 0-7F (normally ascii, but $7F would tell it to expect a value to display at a particular place)
 2E0  25000                        RETURN 
 2E1                               ; returns BT fifo character in s6 assuming present
 2E1  20300       sendBT2Terminal: CALL 300[GetBTFifoChar]
 2E2  00600                        LOAD s6, s0                         ; get character
 2E3  0367F                        AND s6, 7F
 2E4  2036A                        CALL 36A[Send2UartTX]               ; and echo back to terminal.
 2E5  25000                        RETURN 
 2E6                               ; returns KP fifo character in s6 assuming present
 2E6  20306       sendKP2Terminal: CALL 306[GetKPFifoChar]
 2E7  00600                        LOAD s6, s0                         ; get character
 2E8  0367F                        AND s6, 7F
 2E9  2036A                        CALL 36A[Send2UartTX]               ; and echo back to terminal.
 2EA  25000                        RETURN 
 2EB                               ; checks for command from DSP pico, if present in s6 and echo to terminal - otherwise s6>127
 2EB  09104      Check4CmdfromDSP: INPUT s1, 04[DSPcmd]                ; Get character from DSP picoblaze (if present should be less than 128)
 2EC  00610                        LOAD s6, s1
 2ED  1D180                        COMPARE s1, 80[128'd]               ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 2EE  382DC                        CALL C, 2DC[sendDSP2Terminal]       ; If less than 128 there is a value to give back and display.
 2EF  25000                        RETURN 
 2F0                               ; checks for command from BTpico, if present in s6 and echo to terminal - otherwise s6>127
 2F0  09105       Check4CmdfromBT: INPUT s1, 05[BTcmd]                 ; Get character from BT picoblaze (if present should be less than 128)
 2F1  00610                        LOAD s6, s1
 2F2  1D180                        COMPARE s1, 80[128'd]               ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 2F3  382E1                        CALL C, 2E1[sendBT2Terminal]        ; If less than 128 there is a value to give back and display.
 2F4  25000                        RETURN 
 2F5                               ; checks for command from KPpico, if present in s6  - otherwise s6>127
 2F5  09106       Check4CmdfromKP: INPUT s1, 06[KPcmd]                 ; Get character from BT picoblaze (if present should be less than 128)
 2F6  00610                        LOAD s6, s1
 2F7  1D180                        COMPARE s1, 80[128'd]               ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 2F8  38306                        CALL C, 306[GetKPFifoChar]
 2F9  25000                        RETURN 
 2FA                               ; Routine to recover a byte, (character?) from the FIFO in s0
 2FA  01010        GetDSPFifoChar: LOAD s0, 10[DSPFifo]
 2FB  2D00E                        OUTPUT s0, 0E[Acknowledge]          ; read next fifo character - this sends a read pulse to the FIFO
 2FC  01010                        LOAD s0, 10[DSPFifo]                ; dummy, wait a bit longer for character to present itself
 2FD  09004                        INPUT s0, 04[DSPcmd]                ; now get my character
 2FE  0307F                        AND s0, 7F                          ; mask off top bit
 2FF  25000                        RETURN 
 300                               ; Routine to recover a character from the BTFIFO in s0
 300  01020         GetBTFifoChar: LOAD s0, 20[BTFifo]
 301  2D00E                        OUTPUT s0, 0E[Acknowledge]          ; read next fifo character - this sends a read pulse to the FIFO
 302  01020                        LOAD s0, 20[BTFifo]                 ; dummy, wait a bit longer for character to present itself
 303  09005                        INPUT s0, 05[BTcmd]                 ; now get my character
 304  0307F                        AND s0, 7F                          ; mask off top bit
 305  25000                        RETURN 
 306                               ; Routine to recover a character from the KPFIFO in s6
 306  01040         GetKPFifoChar: LOAD s0, 40[KPFifo]
 307  2D00E                        OUTPUT s0, 0E[Acknowledge]          ; read next fifo character - this sends a read pulse to the FIFO
 308  01040                        LOAD s0, 40[KPFifo]                 ; dummy, wait a bit longer for character to present itself
 309  09606                        INPUT s6, 06[KPcmd]                 ; now get my character
 30A  0367F                        AND s6, 7F                          ; mask off top bit
 30B  25000                        RETURN 
 30C                               ; sayOK:              CALL      SendCRLF
 30C                               ; LOAD      s6, 79
 30C                               ; CALL      Send2UartTX
 30C                               ; LOAD      s6, 75
 30C                               ; CALL      Send2UartTX
 30C                               ; CALL      SendCRLF
 30C                               ; RETURN
 30C                               ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 30C  00860            Chars2Byte: LOAD s8, s6
 30D  20317                        CALL 317[Get4bits]
 30E  00580                        LOAD s5, s8
 30F  14506                        SL0 s5
 310  14506                        SL0 s5
 311  14506                        SL0 s5
 312  14506                        SL0 s5                              ; put these 4 bits to MSBs
 313  00870                        LOAD s8, s7
 314  20317                        CALL 317[Get4bits]
 315  10580                        ADD s5, s8
 316  25000                        RETURN 
 317                               ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 317  1D860              Get4bits: COMPARE s8, 60                      ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 318  3A31C                        JUMP C, 31C[char0_9]
 319  19855                        SUB s8, 55                          ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 31A  0380F                        AND s8, 0F                          ; make sure only return 4 bits
 31B  25000                        RETURN 
 31C  19830               char0_9: SUB s8, 30[48'd]
 31D  0380F                        AND s8, 0F                          ; make sure only return 4 bits
 31E  25000                        RETURN 
 31F                               ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 31F  00850            Byte2Chars: LOAD s8, s5                         ; assumes 8 bit data is in s5
 320  1450E                        SR0 s5
 321  1450E                        SR0 s5
 322  1450E                        SR0 s5
 323  1450E                        SR0 s5                              ; get first hex character
 324  2032B                        CALL 32B[GetChar]
 325  00650                        LOAD s6, s5                         ; first ascii char
 326  00580                        LOAD s5, s8
 327  0350F                        AND s5, 0F
 328  2032B                        CALL 32B[GetChar]                   ;
 329  00750                        LOAD s7, s5                         ; second ascii char
 32A  25000                        RETURN 
 32B                               ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 32B  1950A               GetChar: SUB s5, 0A[10'd]                    ; Test if s5 greater than 9
 32C  3A32F                        JUMP C, 32F[is_0_9]                 ; Hex character is 0_9
 32D  11541                        ADD s5, 41[65'd]                    ; offset for Ascii code 'A'
 32E  25000                        RETURN 
 32F  1150A                is_0_9: ADD s5, 0A[10'd]                    ; return to range 0-9
 330  11548                        ADD s5, 48                          ; offset to Ascii code for '0'
 331  25000                        RETURN 
 332                               ; To send to Uart, simply use: OUTPUT       s3, UART_TX         ; Sends value in s3 to Uart Tx
 332                               ; Dump archive RAM to RS232 port as 4 Ascii codes per data value followed by carriage return and line feed.
 332  20351           SendArchive: CALL 351[DisableArchive]            ; Stop archiving
 333  01000                        LOAD s0, 00
 334  01100                        LOAD s1, 00
 335  0B410             SendAloop: FETCH s4, 10[Latch7]
 336  034FC                        AND s4, FC[252'd]                   ; set top 2 address bits to zero
 337  2D006                        OUTPUT s0, 06[ProgramL]
 338  04410                        OR s4, s1                           ; patch in top 2 address bits
 339  2D407                        OUTPUT s4, 07[ProgramM]             ; and send to the output port
 33A  09503                        INPUT s5, 03[ArchiveDataMSB]
 33B  20370                        CALL 370[Byte2UART]
 33C  09502                        INPUT s5, 02[ArchiveDataLSB]        ; grab bottom byte
 33D  20370                        CALL 370[Byte2UART]
 33E  11001                        ADD s0, 01
 33F  13100                        ADDCY s1, 00
 340  20375                        CALL 375[SendCRLF]
 341  1D104                        COMPARE s1, 04
 342  36335                        JUMP NZ, 335[SendAloop]
 343  2034C                        CALL 34C[EnableArchive]             ; Restart archiving
 344  25000                        RETURN 
 345                               ; Select Archiving source, if s1 is 0 then raw 16bit ADC data is archived, or if s1=1 then 16bit data from the DSP picoblaze (DATA2Archve) is archived at 6kHz
 345  03103         ArchiveSource: AND s1, 03
 346  0B014                        FETCH s0, 14[SelectScratch]         ; get current value of selections
 347  030FC                        AND s0, FC[252'd]                   ; first reset first 2 bits
 348  04010                        OR s0, s1                           ; affect bits 0-1
 349  2D008                        OUTPUT s0, 08[SelectArchiveSource]  ; update archive control port
 34A  2F014                        STORE s0, 14[SelectScratch]         ; Update scratchpad
 34B                               ;      LOAD   s5,s0
 34B                               ;      CALL   Byte2Chars
 34B  25000                        RETURN 
 34C                               ; Enable Archiving
 34C  0B010         EnableArchive: FETCH s0, 10[Latch7]                ; get current value of control port
 34D  05040                        OR s0, 40[EnArchive]                ; set bit 5
 34E  2D007                        OUTPUT s0, 07[ProgramM]
 34F  2F010                        STORE s0, 10[Latch7]                ; get current value of control port
 350  25000                        RETURN 
 351                               ; Disable Archiving
 351  00600        DisableArchive: LOAD s6, s0
 352  2039A                        CALL 39A[delay_50us]                ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 353  20390                        CALL 390[delay_1ms]                 ; wait for a bit more archiving first!
 354  0B010                        FETCH s0, 10[Latch7]                ; get current value of control port
 355  030BF                        AND s0, BF[~EnArchive]              ; reset bit 5
 356  2D007                        OUTPUT s0, 07[ProgramM]
 357  2F010                        STORE s0, 10[Latch7]                ; get current value of control port
 358  00060                        LOAD s0, s6                         ; restore s0 value
 359  25000                        RETURN 
 35A                               ; Character parsing:
 35A                               ; returns next command character in s0
 35A  0A090    getnextscratchchar: FETCH s0, (s9)
 35B  11901                        ADD s9, 01                          ; increment pointer
 35C  00600                        LOAD s6, s0
 35D  2036A                        CALL 36A[Send2UartTX]               ; and echo back to terminal. Message mode
 35E  25000                        RETURN 
 35F                               ; Reads 2 ascii codes and returns the byte represented in hex as binary value in s5
 35F  2035A          getnextvalue: CALL 35A[getnextscratchchar]
 360  00400                        LOAD s4, s0
 361  2035A                        CALL 35A[getnextscratchchar]
 362  00700                        LOAD s7, s0
 363  00640                        LOAD s6, s4
 364  2030C                        CALL 30C[Chars2Byte]                ; return byte in s5
 365  25000                        RETURN 
 366                               ; UART control
 366  09001           CheckUartRx: INPUT s0, 01[Uart_status]           ; Check if there is RX data
 367  03001                        AND s0, 01
 368  1D001                        COMPARE s0, 01
 369  25000                        RETURN 
 36A                               ; send character in s6 to Uart - also uses s8!
 36A  09801           Send2UartTX: INPUT s8, 01[Uart_status]           ; Check if TX buffer is full
 36B  03802                        AND s8, 02
 36C  1D802                        COMPARE s8, 02                      ; if 2 then wait
 36D  3236A                        JUMP Z, 36A[Send2UartTX]
 36E  2D601                        OUTPUT s6, 01[UART_TX]
 36F  25000                        RETURN 
 370                               ; Convert byte in s5 into 2 ascii codes in hexadecimal and send to the serial port.
 370  2031F             Byte2UART: CALL 31F[Byte2Chars]
 371  2036A                        CALL 36A[Send2UartTX]
 372  00670                        LOAD s6, s7
 373  2036A                        CALL 36A[Send2UartTX]
 374  25000                        RETURN 
 375  0160D              SendCRLF: LOAD s6, 0D
 376  2036A                        CALL 36A[Send2UartTX]
 377  0160A                        LOAD s6, 0A
 378  2036A                        CALL 36A[Send2UartTX]
 379  25000                        RETURN 
 37A  01620             SendSPACE: LOAD s6, 20
 37B  2036A                        CALL 36A[Send2UartTX]
 37C  25000                        RETURN 
 37D                               CONSTANT count_1000_lsb, E8         ; lower 8-bits of 1000 count value
 37D                               CONSTANT count_1000_msb, 03         ; upper 8-bits of 1000 count value
 37D                               ; Registers used s0, s1, s2, s3, s4 and s5.
 37D                               ;
 37D  01500              delay_1s: LOAD s5, 00                         ; clear cycle counter
 37E  01400                        LOAD s4, 00
 37F  20390               wait_1s: CALL 390[delay_1ms]
 380  11401                        ADD s4, 01                          ; increment cycle counter
 381  13500                        ADDCY s5, 00
 382  1D4E8                        COMPARE s4, E8[count_1000_lsb]      ; test for 1000ms
 383  3637F                        JUMP NZ, 37F[wait_1s]
 384  1D503                        COMPARE s5, 03[count_1000_msb]
 385  3637F                        JUMP NZ, 37F[wait_1s]
 386  25000                        RETURN 
 387                               ;
 387                               ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 387                               ;
 387                               ;
 387                               ; Registers used s0, s1, s2, s3 and s4.
 387                               ;
 387  2038B           delay_300ms: CALL 38B[delay_100ms]
 388  2038B           delay_200ms: CALL 38B[delay_100ms]
 389  2038B                        CALL 38B[delay_100ms]
 38A  25000                        RETURN 
 38B                               ;
 38B                               ; Delay of approximately 100ms used for switch debounce
 38B                               ;
 38B                               ; Registers used s0, s1, s2, s3 and s4.
 38B                               ;
 38B  01464           delay_100ms: LOAD s4, 64                         ; repeat 1ms delay 100 times
 38C  20390            wait_100ms: CALL 390[delay_1ms]
 38D  19401                        SUB s4, 01
 38E  3638C                        JUMP NZ, 38C[wait_100ms]
 38F  25000                        RETURN 
 390                               ;
 390                               ; Registers used s0, s1, s2 and s3.
 390                               ;
 390  01300             delay_1ms: LOAD s3, 00                         ; clear cycle counter
 391  01200                        LOAD s2, 00
 392  2039F              wait_1ms: CALL 39F[delay_1us]
 393  11201                        ADD s2, 01                          ; increment cycle counter
 394  13300                        ADDCY s3, 00
 395  1D2E8                        COMPARE s2, E8[count_1000_lsb]      ; test for 1000us
 396  36392                        JUMP NZ, 392[wait_1ms]
 397  1D303                        COMPARE s3, 03[count_1000_msb]
 398  36392                        JUMP NZ, 392[wait_1ms]
 399  25000                        RETURN 
 39A                               ;
 39A                               ; Delay of approximately 50us required by LCD display
 39A                               ;
 39A                               ; Registers used s0 and s1.
 39A                               ;
 39A  01132            delay_50us: LOAD s1, 32[50'd]                   ; repeat 1us delay 50 times
 39B  2039F             wait_50us: CALL 39F[delay_1us]
 39C  19101                        SUB s1, 01
 39D  3639B                        JUMP NZ, 39B[wait_50us]
 39E  25000                        RETURN 
 39F                               ; Delay of approximately 1us used to provide timing reference for
 39F                               ; LCD operations. This must be adjusted to reflect the clock
 39F                               ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 39F                               ;
 39F                               ; The software delay loop is formed using register s0. This register
 39F                               ; must be loaded with an integer value close to the result of....
 39F                               ;
 39F                               ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 39F                               ;
 39F                               ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 39F                               ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 39F                               ; operation will become lower than the 100KHz target intended.
 39F                               ;
 39F                               ; Register used s0.
 39F                               ;
 39F  0100C             delay_1us: LOAD s0, 0C[delay_1us_constant]     ; delay value of 12 decimal for a 50MHz clock
 3A0  19001              wait_1us: SUB s0, 01
 3A1  363A0                        JUMP NZ, 3A0[wait_1us]
 3A2  25000                        RETURN 
 3A3                               ;
 3A3                               ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\Users\gnaylor.CCFEPC\Dropbox\N3workingG\TE0722Rebuild\SP3eUserN3_GVA5.psm



List of defined constants

 CONSTANT name        Value        Source PSM File

 timestamp_hours      16'd         
 timestamp_minutes    17'd         
 timestamp_seconds    30'd         
 datestamp_year       15'd         
 datestamp_month      12'd         
 datestamp_day        15'd         
 NUL                  00           
 BEL                  07           
 BS                   08           
 HT                   09           
 LF                   0A           
 VT                   0B           
 CR                   0D           
 ESC                  1B           
 DEL                  7F           
 DCS                  90           
 ST                   9C           
 Versionno            A5           SP3eUserN3_GVA5.psm
 MinorVersionno       EE           SP3eUserN3_GVA5.psm
 Bmode                00           SP3eUserN3_GVA5.psm
 AGCupperRX           32           SP3eUserN3_GVA5.psm
 AGClowerRX           12           SP3eUserN3_GVA5.psm
 AGCupperTX           10           SP3eUserN3_GVA5.psm
 AGClowerTX           06           SP3eUserN3_GVA5.psm
 delay_1us_constant   12'd         SP3eUserN3_GVA5.psm
 WREN                 06           SP3eUserN3_GVA5.psm
 FAST_READ            0B           SP3eUserN3_GVA5.psm
 BERASE               C7           SP3eUserN3_GVA5.psm
 SER                  D8           SP3eUserN3_GVA5.psm
 RDID                 9F           SP3eUserN3_GVA5.psm
 PP                   02           SP3eUserN3_GVA5.psm
 RDSR                 05           SP3eUserN3_GVA5.psm
 Latch7               16'd         SP3eUserN3_GVA5.psm
 LastDSPbyte          17'd         SP3eUserN3_GVA5.psm
 Mode                 18'd         SP3eUserN3_GVA5.psm
 ADCstate             19'd         SP3eUserN3_GVA5.psm
 SelectScratch        20'd         SP3eUserN3_GVA5.psm
 ADCLevel             21'd         SP3eUserN3_GVA5.psm
 ADCgain              22'd         SP3eUserN3_GVA5.psm
 TX_F_MSB             23'd         SP3eUserN3_GVA5.psm
 TX_F_LSB             24'd         SP3eUserN3_GVA5.psm
 ADCAGCUpperThreshold 25'd         SP3eUserN3_GVA5.psm
 ADCAGCLowerThreshold 26'd         SP3eUserN3_GVA5.psm
 ADCGainTX            27'd         SP3eUserN3_GVA5.psm
 ADCGainRX            28'd         SP3eUserN3_GVA5.psm
 AttenuatorState      29'd         SP3eUserN3_GVA5.psm
 BluetoothXmit        43           SP3eUserN3_GVA5.psm
 Uart_rx              00           SP3eUserN3_GVA5.psm
 Uart_status          01           SP3eUserN3_GVA5.psm
 BattMon              4'd          SP3eUserN3_GVA5.psm
 ArchiveDataLSB       2'd          SP3eUserN3_GVA5.psm
 ArchiveDataMSB       3'd          SP3eUserN3_GVA5.psm
 DSPcmd               4'd          SP3eUserN3_GVA5.psm
 BTcmd                5'd          SP3eUserN3_GVA5.psm
 KPcmd                6'd          SP3eUserN3_GVA5.psm
 DataReadback         7'd          SP3eUserN3_GVA5.psm
 DataReadback_1       8'd          SP3eUserN3_GVA5.psm
 DSPRAMrdbkMSB        9'd          SP3eUserN3_GVA5.psm
 DSPRAMrdbkLSB        10'd         SP3eUserN3_GVA5.psm
 BTRAMrdbkMSB         11'd         SP3eUserN3_GVA5.psm
 BTRAMrdbkLSB         12'd         SP3eUserN3_GVA5.psm
 KPRAMrdbkMSB         13'd         SP3eUserN3_GVA5.psm
 KPRAMrdbkLSB         14'd         SP3eUserN3_GVA5.psm
 ADCSignalLevel       15'd         SP3eUserN3_GVA5.psm
 CMD2DSP              00           SP3eUserN3_GVA5.psm
 UART_TX              01           SP3eUserN3_GVA5.psm
 GainPD               02           SP3eUserN3_GVA5.psm
 Instructiona         03           SP3eUserN3_GVA5.psm
 Instructionb         04           SP3eUserN3_GVA5.psm
 Instructionc         05           SP3eUserN3_GVA5.psm
 ProgramL             06           SP3eUserN3_GVA5.psm
 ProgramM             07           SP3eUserN3_GVA5.psm
 EnArchive            64'd         SP3eUserN3_GVA5.psm
 TX_HIGH              128'd        SP3eUserN3_GVA5.psm
 SelectArchiveSource  8'd          SP3eUserN3_GVA5.psm
 RXFreqMSB            10'd         SP3eUserN3_GVA5.psm
 RXFreqLSB            11'd         SP3eUserN3_GVA5.psm
 TXFreqMSB            12'd         SP3eUserN3_GVA5.psm
 TXFreqLSB            13'd         SP3eUserN3_GVA5.psm
 Acknowledge          14'd         SP3eUserN3_GVA5.psm
 DSPFifo              16'd         SP3eUserN3_GVA5.psm
 BTFifo               32'd         SP3eUserN3_GVA5.psm
 KPFifo               64'd         SP3eUserN3_GVA5.psm
 FlashData            17'd         SP3eUserN3_GVA5.psm
 ADCstate_port        19'd         SP3eUserN3_GVA5.psm
 LoranBlank           16'd         SP3eUserN3_GVA5.psm
 AudioOutSelect       32'd         SP3eUserN3_GVA5.psm
 AnalogueChannel      64'd         SP3eUserN3_GVA5.psm
 CMD2BT               20'd         SP3eUserN3_GVA5.psm
 CMD2KP               21'd         SP3eUserN3_GVA5.psm
 RAMDataMSB           22'd         SP3eUserN3_GVA5.psm
 RAMDataLSB           23'd         SP3eUserN3_GVA5.psm
 AttenuatorControl    24'd         SP3eUserN3_GVA5.psm
 TRANSMIT_ON          14           SP3eUserN3_GVA5.psm
 TRANSMIT_OFF         15           SP3eUserN3_GVA5.psm
 count_1000_lsb       E8           SP3eUserN3_GVA5.psm
 count_1000_msb       03           SP3eUserN3_GVA5.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "15 Dec 2015"  
 timestamp$        "16:17:30"     



List of line labels

   Label                  Addr  Source PSM File

 * boot                   000   SP3eUserN3_GVA5.psm
   reboot                 001   SP3eUserN3_GVA5.psm
   DoUserProg             007   SP3eUserN3_GVA5.psm
   GetProg                00A   SP3eUserN3_GVA5.psm
   GetByte                01B   SP3eUserN3_GVA5.psm
   cold_start             021   SP3eUserN3_GVA5.psm
   ProgDSP                022   SP3eUserN3_GVA5.psm
   ScratchClear           023   SP3eUserN3_GVA5.psm
   init                   027   SP3eUserN3_GVA5.psm
   loop                   03B   SP3eUserN3_GVA5.psm
   HandleBTCommand_Done   04D   SP3eUserN3_GVA5.psm
   CheckADClevel          05B   SP3eUserN3_GVA5.psm
   nofive                 06A   SP3eUserN3_GVA5.psm
   First                  06D   SP3eUserN3_GVA5.psm
   Second                 070   SP3eUserN3_GVA5.psm
   Third                  073   SP3eUserN3_GVA5.psm
   Fourth                 076   SP3eUserN3_GVA5.psm
   Fifth                  079   SP3eUserN3_GVA5.psm
   Below10                07D   SP3eUserN3_GVA5.psm
   continue               083   SP3eUserN3_GVA5.psm
   ToLCD                  08C   SP3eUserN3_GVA5.psm
 * Tempskip               08E   SP3eUserN3_GVA5.psm
   ReduceADCgain          096   SP3eUserN3_GVA5.psm
   IncreaseADCgain        09F   SP3eUserN3_GVA5.psm
   resetAttenuator        0A8   SP3eUserN3_GVA5.psm
   updateAttenuator       0B2   SP3eUserN3_GVA5.psm
   setAttenuator          0B9   SP3eUserN3_GVA5.psm
   checkrqst              0C0   SP3eUserN3_GVA5.psm
   setEarthAntennas       0C9   SP3eUserN3_GVA5.psm
   setLoopAntennas        0CE   SP3eUserN3_GVA5.psm
   checkRXmode            0D3   SP3eUserN3_GVA5.psm
   checkTXmode            0DC   SP3eUserN3_GVA5.psm
   setRXmode              0E2   SP3eUserN3_GVA5.psm
   setTXmode              0FC   SP3eUserN3_GVA5.psm
   SetAnGain              10F   SP3eUserN3_GVA5.psm
   interpcommand          11A   SP3eUserN3_GVA5.psm
   interploop             11B   SP3eUserN3_GVA5.psm
   isS                    125   SP3eUserN3_GVA5.psm
   isG                    137   SP3eUserN3_GVA5.psm
   isSA                   149   SP3eUserN3_GVA5.psm
   isSB                   153   SP3eUserN3_GVA5.psm
   isSK                   15A   SP3eUserN3_GVA5.psm
   isSL                   15E   SP3eUserN3_GVA5.psm
   setLoranBlank          163   SP3eUserN3_GVA5.psm
   isSKS                  169   SP3eUserN3_GVA5.psm
   isSM                   16A   SP3eUserN3_GVA5.psm
   isSMW                  174   SP3eUserN3_GVA5.psm
   isSMWloop              197   SP3eUserN3_GVA5.psm
   isSMR                  19C   SP3eUserN3_GVA5.psm
   isSMD                  1B9   SP3eUserN3_GVA5.psm
   isSMS                  1CA   SP3eUserN3_GVA5.psm
   Status                 1CC   SP3eUserN3_GVA5.psm
 * isSS                   1DC   SP3eUserN3_GVA5.psm
   isSU                   1E6   SP3eUserN3_GVA5.psm
   isSSloop               1EB   SP3eUserN3_GVA5.psm
   nowsend2flashback      1F3   SP3eUserN3_GVA5.psm
   nowsend2flash          1FB   SP3eUserN3_GVA5.psm
   isSR                   1FD   SP3eUserN3_GVA5.psm
   isST                   203   SP3eUserN3_GVA5.psm
   isSAS                  207   SP3eUserN3_GVA5.psm
   isSAG                  20B   SP3eUserN3_GVA5.psm
   isSAI                  212   SP3eUserN3_GVA5.psm
   setADC                 217   SP3eUserN3_GVA5.psm
   isSAO                  21D   SP3eUserN3_GVA5.psm
   setAudioOut            222   SP3eUserN3_GVA5.psm
   isSRF                  228   SP3eUserN3_GVA5.psm
   isSRM                  22D   SP3eUserN3_GVA5.psm
   RX                     22F   SP3eUserN3_GVA5.psm
   isSTM                  236   SP3eUserN3_GVA5.psm
   TX                     238   SP3eUserN3_GVA5.psm
   isGG                   240   SP3eUserN3_GVA5.psm
   isGS                   249   SP3eUserN3_GVA5.psm
   isGB                   252   SP3eUserN3_GVA5.psm
   isGC                   25A   SP3eUserN3_GVA5.psm
   isGK                   25D   SP3eUserN3_GVA5.psm
   isGL                   263   SP3eUserN3_GVA5.psm
   isGKT                  26F   SP3eUserN3_GVA5.psm
   isGKV                  278   SP3eUserN3_GVA5.psm
   isGA                   281   SP3eUserN3_GVA5.psm
   isGV                   283   SP3eUserN3_GVA5.psm
   Twotone                287   SP3eUserN3_GVA5.psm
   Warble                 294   SP3eUserN3_GVA5.psm
   Warbleloop             295   SP3eUserN3_GVA5.psm
   BeaconBeep             2A5   SP3eUserN3_GVA5.psm
   Beaconloop             2A7   SP3eUserN3_GVA5.psm
   cancelbeacon           2B8   SP3eUserN3_GVA5.psm
   HandleBTCommand        2BC   SP3eUserN3_GVA5.psm
   FromBT_XMIT            2C2   SP3eUserN3_GVA5.psm
   FromBT_RECEIVE         2CC   SP3eUserN3_GVA5.psm
   getUARTchar            2D6   SP3eUserN3_GVA5.psm
   sendDSP2Terminal       2DC   SP3eUserN3_GVA5.psm
   sendBT2Terminal        2E1   SP3eUserN3_GVA5.psm
 * sendKP2Terminal        2E6   SP3eUserN3_GVA5.psm
   Check4CmdfromDSP       2EB   SP3eUserN3_GVA5.psm
   Check4CmdfromBT        2F0   SP3eUserN3_GVA5.psm
   Check4CmdfromKP        2F5   SP3eUserN3_GVA5.psm
   GetDSPFifoChar         2FA   SP3eUserN3_GVA5.psm
   GetBTFifoChar          300   SP3eUserN3_GVA5.psm
   GetKPFifoChar          306   SP3eUserN3_GVA5.psm
   Chars2Byte             30C   SP3eUserN3_GVA5.psm
   Get4bits               317   SP3eUserN3_GVA5.psm
   char0_9                31C   SP3eUserN3_GVA5.psm
   Byte2Chars             31F   SP3eUserN3_GVA5.psm
   GetChar                32B   SP3eUserN3_GVA5.psm
   is_0_9                 32F   SP3eUserN3_GVA5.psm
   SendArchive            332   SP3eUserN3_GVA5.psm
   SendAloop              335   SP3eUserN3_GVA5.psm
   ArchiveSource          345   SP3eUserN3_GVA5.psm
   EnableArchive          34C   SP3eUserN3_GVA5.psm
   DisableArchive         351   SP3eUserN3_GVA5.psm
   getnextscratchchar     35A   SP3eUserN3_GVA5.psm
   getnextvalue           35F   SP3eUserN3_GVA5.psm
   CheckUartRx            366   SP3eUserN3_GVA5.psm
   Send2UartTX            36A   SP3eUserN3_GVA5.psm
   Byte2UART              370   SP3eUserN3_GVA5.psm
   SendCRLF               375   SP3eUserN3_GVA5.psm
 * SendSPACE              37A   SP3eUserN3_GVA5.psm
   delay_1s               37D   SP3eUserN3_GVA5.psm
   wait_1s                37F   SP3eUserN3_GVA5.psm
 * delay_300ms            387   SP3eUserN3_GVA5.psm
 * delay_200ms            388   SP3eUserN3_GVA5.psm
   delay_100ms            38B   SP3eUserN3_GVA5.psm
   wait_100ms             38C   SP3eUserN3_GVA5.psm
   delay_1ms              390   SP3eUserN3_GVA5.psm
   wait_1ms               392   SP3eUserN3_GVA5.psm
   delay_50us             39A   SP3eUserN3_GVA5.psm
   wait_50us              39B   SP3eUserN3_GVA5.psm
   delay_1us              39F   SP3eUserN3_GVA5.psm
   wait_1us               3A0   SP3eUserN3_GVA5.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            127
 STAR              -

 AND              50
 OR               19
 XOR               -

 ADD              22
 ADDCY             4
 SUB               9
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          95
 COMPARECY         -

 SL0               6
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               5
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT            23
 OUTPUT           89
 OUTPUTK           -

 STORE            48
 FETCH            48

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP            124
 JUMP@             -
 CALL            203
 CALL@             -
 RETURN           63
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
