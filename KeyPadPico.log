KCPSM6 Assembler log file for program 'Z:\home\graham\Dropbox\N3workingG\TE0722Rebuild\N3SysGen\KeyPadPico.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 10 Jul 2016
Assembly timestamp: 18:09:23

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 1A4 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 421
Memory locations available: 3675


Assembly listing

 Addr Code                        Instruction

 000                              ;Modified for 49.162MHz clock
 000                              ;A0 is version to get start and stop tone levels for speaker switching.
 000                              ;
 000                              ;99 - add latch on button facility so don't need handset plugged in.
 000                              ;Now display signal level and gain setting
 000                              ;Switch off key pad oscillation and
 000                              ;Mod to read key pad and display
 000                              ;Version using CoutA
 000                              ;Need to mod to send TX request to User when touchdown active
 000                              ;May 10
 000                              ;
 000                              ; KeyPad routine for SSB picoblaze
 000                              ;
 000                              CONSTANT LCD_RS, 1'd                         ; bit0 - Register Select - command(0) or data(1)
 000                              CONSTANT LCD_RW, 2'd                         ; bit1 - read(1) or write(0)
 000                              CONSTANT LCD_E, 4'd                          ; bit2 - Enable(1)
 000                              ; Registers
 000                              NAMEREG sF, LCD_data                         ;            EQU       sF                  ; registers used for data and control of LCD
 000                              NAMEREG sE, LCD_control                      ;         EQU       sE                  ; E=bit2,  R/W=bit1,  RS=bit0
 000                              NAMEREG sD, cursor_position                  ;     EQU       sD                  ; register to define cursor position on LCD display
 000                              ;sB and sC also used for temporary character storage
 000                              CONSTANT delay_1us_constant, 06              ; Value (13)19 or 12? decimal suitable for 50MHz clock – about 6 for 33MHz?
 000                              CONSTANT count_1000_lsb, E8                  ; hex lower 8-bits of 1000 count value
 000                              CONSTANT count_1000_msb, 03                  ; hex upper 8-bits of 1000 count value
 000                              ; Input port - port numbering changed June 11
 000                              CONSTANT Command, 0'd                        ; From main pico
 000                              CONSTANT PTT, 1'd                            ;This is PTT
 000                              CONSTANT RAMdataInLSB, 2'd
 000                              CONSTANT RAMdataInMSB, 3'd
 000                              CONSTANT KP2userbufferFull, 4'd              ;Bit 0 KP2User buffer full, Bit 1 Touch counter running
 000                              CONSTANT TouchSignal2, 5'd                   ;This is keypad Bit 0 On, Bit 1 Select, Bit 2 Down, Bit 3 Up
 000                              ;TouchSignal2=0E is On, 0D = Select, 0B = Down, 07= Up
 000                              CONSTANT ADCpeak, 6'd
 000                              CONSTANT DemodPeak, 7'd
 000                              ;CONSTANT SignalLevel,   8'd
 000                              CONSTANT StartToneA, 8'd
 000                              CONSTANT StartToneALong, 9'd
 000                              CONSTANT StartToneB, 10'd
 000                              CONSTANT StartToneBLong, 11'd
 000                              CONSTANT StopToneA, 12'd
 000                              CONSTANT StopToneALong, 13'd
 000                              CONSTANT StopToneB, 14'd
 000                              CONSTANT StopToneBLong, 15'd
 000                              ; Output ports
 000                              CONSTANT CmdToUser, 0'd
 000                              CONSTANT LCD_data_port, 1'd
 000                              CONSTANT LCD_control_port, 2'd
 000                              CONSTANT LCDcontrast, 3'd
 000                              CONSTANT Data2ArchiveMSB, 4'd
 000                              CONSTANT Data2ArchiveLSB, 5'd
 000                              CONSTANT Controlbits, 6'd
 000                              ;Bit offsets:
 000                              CONSTANT AckFIFO, 32'd                       ;   bit 5 Acknowledge FIFO (present character)
 000                              CONSTANT RAM_ADD_MSB, 7'd                    ;Bits 0 and 1 top too address bits, bit 2 write RAM
 000                              ;Bit offsets:
 000                              CONSTANT WriteKPRAM, 4'd
 000                              CONSTANT RAM_ADD_LSB, 8'd
 000                              CONSTANT LatchOn, 9'd
 000                              CONSTANT RXFreqMSB, 10'd                     ; 7546 for 87.956kHz ie 86.956kHz carrier and allow range up to 154kHz 7555 Heyphone
 000                              CONSTANT RXFreqLSB, 11'd
 000                              CONSTANT TXFreqMSB, 12'd                     ; 3710  with 49.152MHz clock, with 49.162MHz - need 3709 for N2 and 3711 for Heyphone
 000                              CONSTANT TXFreqLSB, 13'd
 000                              ;TX frequencies:
 000                              ;For 49.152MHz!
 000                              ;Heyphone - 0e80
 000                              ;N2 -       0e7e
 000                              ;N3_31 -    052b
 000                              ;RX frequencies:
 000                              ;Heyphone  - $7555
 000                              ;N2  -       $7546
 000                              ;N3_31  -    $2aad
 000                              ;But for 49.162MHz:
 000                              ;Heyphone - 0e7F
 000                              ;N2 -       0e7d
 000                              ;N3_31 -    052a
 000                              ;RX frequencies:
 000                              ;Heyphone  - $754F
 000                              ;N2  -       $753E
 000                              ;N3_31  -    $2953
 000                              ; Scratchpad registers
 000                              CONSTANT TouchUpLevel, 0'd
 000                              CONSTANT TouchDownLevel, 1'd
 000                              CONSTANT TouchSelectLevel, 2'd
 000                              CONSTANT TX_F_MSB, 3'd
 000                              CONSTANT TX_F_LSB, 4'd
 000                              CONSTANT RX_F_MSB, 5'd
 000                              CONSTANT RX_F_LSB, 6'd
 000                              CONSTANT Freq2Set, 7'd                       ; values 0 nothing to set, 1>Hy, 2>N2, 3>N3 (31kHz)
 000                              ;;;GenerateCode        MEM       "KeyPadProg.mem"
 000  2013D           cold_start: CALL 13D[LCD_setup]
 001  20155      welcome_message: CALL 155[LCD_home]                           ; left hand of display
 002  01F4E                       LOAD sF[LCD_data], 4E[78'd]                  ; character_N
 003  20173                       CALL 173[LCD_character_write]
 004                              ;                    LOAD      LCD_data, character_i
 004                              ;                   CALL      LCD_character_write
 004                              ;                  LOAD      LCD_data, character_c
 004                              ;                 CALL      LCD_character_write
 004                              ;                LOAD      LCD_data, character_o
 004                              ;               CALL      LCD_character_write
 004                              ;              LOAD      LCD_data, character_l
 004                              ;             CALL      LCD_character_write
 004                              ;            LOAD      LCD_data, character_a
 004                              ;           CALL      LCD_character_write
 004                              ;               LOAD      LCD_data, character_space
 004                              ;              CALL      LCD_character_write
 004  01F33                       LOAD sF[LCD_data], 33["3"]
 005  20173                       CALL 173[LCD_character_write]
 006  01F20                       LOAD sF[LCD_data], 20[" "]
 007  20173                       CALL 173[LCD_character_write]
 008  01000           initialise: LOAD s0, 00                                  ;This is now used to drive LatchOn which latches the device on!!
 009  2D009                       OUTPUT s0, 09[LatchOn]                       ;Latch On if 1
 00A                              ;set values for Hey by default
 00A  09001                       INPUT s0, 01[PTT]                            ;This is PTT but also has set default frequency bits
 00B  1400E                       SR0 s0
 00C  03003                       AND s0, 03
 00D                              ;     LOAD    s0,01   ;use 1 for Hey, 2 for N2 freq, 3 for 37kHz
 00D  2F007                       STORE s0, 07[Freq2Set]
 00E  2008F                       CALL 08F[UpdateFreqRegisters]
 00F                              ;Wait and check if ON still pressed
 00F  2017F                       CALL 17F[delay_1s]
 010  09505                       INPUT s5, 05[TouchSignal2]
 011  0350F                       AND s5, 0F
 012  1D50E                       COMPARE s5, 0E                               ;is 'ON' pressed
 013  36018                       JUMP NZ, 018[loop]                           ;if not ON button, skip
 014  01001                       LOAD s0, 01                                  ;This is now used to drive PMOD1 which latches the device on!!
 015  2D009                       OUTPUT s0, 09[LatchOn]                       ;Latch On
 016  2017F                       CALL 17F[delay_1s]                           ;Wait so it doesn't detect as turn off!
 017  2017F                       CALL 17F[delay_1s]                           ;Wait so it doesn't detect as turn off!
 018  09000                 loop: INPUT s0, 00[Command]                        ;Check if FIFO character present
 019  1D080                       COMPARE s0, 80[128'd]                        ; is there a character?
 01A  380B9                       CALL C, 0B9[Respond2Fifo]                    ;this should now receive value of mode from user pico and display on LCD
 01B  09105                       INPUT s1, 05[TouchSignal2]
 01C  0310F                       AND s1, 0F
 01D  1D10F                       COMPARE s1, 0F                               ;bits go to zero if pressed
 01E  3403B                       CALL NZ, 03B[KeyPressed]
 01F                              ;;;;;;;;;;;;;Bit added to check touch switch - re-enable June 2013
 01F                              ;     LOAD   s1,02
 01F                              ;     OUTPUT    s1,ChooseTouchKey
 01F                              ;     LOAD   s5,00
 01F                              ;StayWaiting:  INPUT    s0,KP2userbufferFull
 01F                              ;     ADD      s5,01
 01F                              ;     AND      s0,02
 01F                              ;     COMPARE  s0,02
 01F                              ;     JUMP     Z,StayWaiting
 01F                              ;                    LOAD   cursor_position,14'd ;position cursor at end of line   -Add this to get keypad level
 01F                              ;                   CALL   LCD_position_cursor
 01F                              ;                    INPUT   s5,Touchsignal2
 01F                              ;                   CALL   Displays5
 01F                              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 01F  09101                       INPUT s1, 01[PTT]                            ;This is PTT
 020  03101                       AND s1, 01                                   ;Mask lowest bit
 021  1D100                       COMPARE s1, 00                               ;0 if pressed - logic on proto2 is inverted
 022  3202F                       JUMP Z, 02F[TouchDown]
 023                              ;think touch is not pressed
 023  2018D         NotTouchDown: CALL 18D[delay_100ms]
 024  09101                       INPUT s1, 01[PTT]
 025  03101                       AND s1, 01                                   ;Mask lowest bit
 026  1D100                       COMPARE s1, 00                               ;check if pressed logic on proto2 is inverted
 027  32018                       JUMP Z, 018[loop]                            ;so is in fact pressed so escape
 028  01D04                       LOAD sD[cursor_position], 04                 ;position cursor just after 'Nicola 3'
 029  2016B                       CALL 16B[LCD_position_cursor]
 02A  01572                       LOAD s5, 72["r"]                             ; character_r      ;temp - shoulr be r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 02B  00F50                       LOAD sF[LCD_data], s5                        ;
 02C  2D500                       OUTPUT s5, 00[CmdToUser]
 02D  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 02E  22018                       JUMP 018[loop]
 02F                              ;believe touch to be pressed
 02F  2018D            TouchDown: CALL 18D[delay_100ms]
 030  09101                       INPUT s1, 01[PTT]
 031  03101                       AND s1, 01                                   ;Mask lowest bit
 032  1D100                       COMPARE s1, 00                               ;logic on proto2 is inverted
 033  36018                       JUMP NZ, 018[loop]                           ;so is not in fact pressed - escape
 034  01D04                       LOAD sD[cursor_position], 04                 ;position cursor just after 'Nicola 3'
 035  2016B                       CALL 16B[LCD_position_cursor]
 036  01574                       LOAD s5, 74["t"]                             ; character_t
 037  00F50                       LOAD sF[LCD_data], s5                        ;
 038  2D500                       OUTPUT s5, 00[CmdToUser]
 039  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 03A  22018                       JUMP 018[loop]
 03B  2017F           KeyPressed: CALL 17F[delay_1s]
 03C  09505                       INPUT s5, 05[TouchSignal2]
 03D  0350F                       AND s5, 0F
 03E  1D50F                       COMPARE s5, 0F                               ;not $F if pressed
 03F  31000                       RETURN Z                                     ;return if key not still pressed
 040  01DC3                       LOAD sD[cursor_position], C3                 ;position cursor
 041  2016B                       CALL 16B[LCD_position_cursor]
 042  01B20                       LOAD sB, 20[" "]                             ; character_space
 043  01C20                       LOAD sC, 20[" "]                             ; character_space
 044                              ;TouchSignal2=0E is On, 0D = Select, 0B = Down, 07= Up
 044  1D507                       COMPARE s5, 07
 045  30054                       CALL Z, 054[upFreq]
 046  1D50B                       COMPARE s5, 0B
 047  30059                       CALL Z, 059[DownFreq]                        ;These should reload LCD_data and sC with characters representing code of Freq, N3 etc
 048                              ;     LOAD   LCD_data,sB
 048                              ;     CALL      LCD_character_write  ;then write 1st char to LCD
 048                              ;     LOAD   LCD_data,sC
 048                              ;     CALL      LCD_character_write  ;then write 2nd to LCD
 048  1D50D                       COMPARE s5, 0D
 049  3008F                       CALL Z, 08F[UpdateFreqRegisters]
 04A  1D50E                       COMPARE s5, 0E
 04B  30051                       CALL Z, 051[TurnOff]
 04C                              ;and use DispAntennaInput for setting antenna input
 04C  1D505                       COMPARE s5, 05                               ;Up+select
 04D  3009A                       CALL Z, 09A[SetLoop]
 04E  1D509                       COMPARE s5, 09                               ;Down+select
 04F  300A0                       CALL Z, 0A0[SetEarth]
 050  25000                       RETURN 
 051                              ;Note key pad bits are: bit3 = On, bit 2 = up, bit 1 = select, bit 0 = down
 051  01000              TurnOff: LOAD s0, 00                                  ;This is now used to drive PMOD1 which latches the device on!!
 052  2D009                       OUTPUT s0, 09[LatchOn]                       ;Latch On if 1
 053  25000                       RETURN 
 054  0B007               upFreq: FETCH s0, 07[Freq2Set]
 055  11001                       ADD s0, 01
 056  03003                       AND s0, 03
 057  2F007                       STORE s0, 07[Freq2Set]
 058  2205E                       JUMP 05E[CheckWhichFreq]
 059  0B007             DownFreq: FETCH s0, 07[Freq2Set]
 05A  19001                       SUB s0, 01
 05B  03003                       AND s0, 03
 05C  2F007                       STORE s0, 07[Freq2Set]
 05D  2205E                       JUMP 05E[CheckWhichFreq]
 05E  1D000       CheckWhichFreq: COMPARE s0, 00
 05F  3006B                       CALL Z, 06B[ClearFreq]                       ;clear set display
 060  1D001                       COMPARE s0, 01
 061  3006E                       CALL Z, 06E[SetHeyphoneFreq]                 ;set Hy freq and return
 062  1D002                       COMPARE s0, 02
 063  30079                       CALL Z, 079[SetN2Freq]
 064  1D003                       COMPARE s0, 03
 065  30084                       CALL Z, 084[SetN3_31Freq]
 066  00FB0                       LOAD sF[LCD_data], sB
 067  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 068  00FC0                       LOAD sF[LCD_data], sC
 069  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 06A  25000                       RETURN 
 06B  01B20            ClearFreq: LOAD sB, 20[" "]                             ; character_space
 06C  01C20                       LOAD sC, 20[" "]                             ; character_space
 06D  25000                       RETURN 
 06E                              ;TX frequencies:
 06E                              ;for 49.162MHz!:
 06E                              ;Heyphone - 0e7F
 06E                              ;N2 -       0e7d
 06E                              ;N3_31 -    052a
 06E                              ;RX frequencies:
 06E                              ;Heyphone  - $754F
 06E                              ;N2  -       $753E
 06E                              ;N3_31  -    $2953
 06E                              ; with 49.162MHzMHz!
 06E  0110E      SetHeyphoneFreq: LOAD s1, 0E
 06F  2F103                       STORE s1, 03[TX_F_MSB]
 070  0117F                       LOAD s1, 7F
 071  2F104                       STORE s1, 04[TX_F_LSB]
 072  01175                       LOAD s1, 75
 073  2F105                       STORE s1, 05[RX_F_MSB]
 074  0114F                       LOAD s1, 4F
 075  2F106                       STORE s1, 06[RX_F_LSB]
 076  01B68                       LOAD sB, 68["h"]                             ; character_h
 077  01C79                       LOAD sC, 79["y"]                             ; character_y
 078  25000                       RETURN 
 079                              ;For N3 5565 (15BD) TX and  45032 (AFE8) RX with 32.768MHz!
 079  0110E            SetN2Freq: LOAD s1, 0E
 07A  2F103                       STORE s1, 03[TX_F_MSB]
 07B  0117D                       LOAD s1, 7D
 07C  2F104                       STORE s1, 04[TX_F_LSB]
 07D  01175                       LOAD s1, 75
 07E  2F105                       STORE s1, 05[RX_F_MSB]
 07F  0113E                       LOAD s1, 3E
 080  2F106                       STORE s1, 06[RX_F_LSB]
 081  01B6E                       LOAD sB, 6E["n"]                             ; character_n
 082  01C32                       LOAD sC, 32["2"]                             ; character_2
 083  25000                       RETURN 
 084                              ;For 31kH 1984 TX (07C0)    16384 for RX (4000 hex) with 32.768MHz!
 084  01105         SetN3_31Freq: LOAD s1, 05
 085  2F103                       STORE s1, 03[TX_F_MSB]
 086  0112A                       LOAD s1, 2A
 087  2F104                       STORE s1, 04[TX_F_LSB]
 088  01129                       LOAD s1, 29
 089  2F105                       STORE s1, 05[RX_F_MSB]
 08A  01153                       LOAD s1, 53
 08B  2F106                       STORE s1, 06[RX_F_LSB]
 08C  01B33                       LOAD sB, 33["3"]                             ; character_3
 08D  01C31                       LOAD sC, 31["1"]                             ; character_1
 08E  25000                       RETURN 
 08F  01DC6  UpdateFreqRegisters: LOAD sD[cursor_position], C6                 ;position cursor
 090  2016B                       CALL 16B[LCD_position_cursor]
 091  01F66                       LOAD sF[LCD_data], 66["f"]                   ; character_f   ;
 092  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 093  01F3D                       LOAD sF[LCD_data], 3D["="]                   ; character_equals
 094  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 095  0B007                       FETCH s0, 07[Freq2Set]
 096  2005E                       CALL 05E[CheckWhichFreq]
 097  200EE                       CALL 0EE[SetTxFreq]
 098  200F3                       CALL 0F3[SetRxFreq]
 099  25000                       RETURN 
 09A  0186C              SetLoop: LOAD s8, 6C["l"]                             ; character_l
 09B  0196F                       LOAD s9, 6F["o"]                             ; character_o
 09C  01A6F                       LOAD sA, 6F["o"]                             ; character_o
 09D  01B70                       LOAD sB, 70["p"]                             ; character_p
 09E  01C20                       LOAD sC, 20[" "]                             ; character_space
 09F  220A5                       JUMP 0A5[DispAntennaInput]
 0A0  01865             SetEarth: LOAD s8, 65["e"]                             ; character_e
 0A1  01961                       LOAD s9, 61["a"]                             ; character_a
 0A2  01A72                       LOAD sA, 72["r"]                             ; character_r
 0A3  01B74                       LOAD sB, 74["t"]                             ; character_t
 0A4  01C68                       LOAD sC, 68["h"]                             ; character_h
 0A5                              ;To use
 0A5  01DCB     DispAntennaInput: LOAD sD[cursor_position], CB                 ;position cursor near end of second line
 0A6  2016B                       CALL 16B[LCD_position_cursor]
 0A7  00F80                       LOAD sF[LCD_data], s8
 0A8  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0A9  2D800                       OUTPUT s8, 00[CmdToUser]                     ;First letter is used to inform userpico whether loop or earth
 0AA  00F90                       LOAD sF[LCD_data], s9
 0AB  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0AC  00FA0                       LOAD sF[LCD_data], sA
 0AD  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0AE  00FB0                       LOAD sF[LCD_data], sB
 0AF  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0B0  00FC0                       LOAD sF[LCD_data], sC
 0B1  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0B2  25000                       RETURN 
 0B3                              ;displays s5
 0B3  20127            Displays5: CALL 127[Byte2Chars]
 0B4  00F60                       LOAD sF[LCD_data], s6                        ;
 0B5  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0B6  00F70                       LOAD sF[LCD_data], s7                        ;
 0B7  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0B8  25000                       RETURN 
 0B9                              ;Get fifo command and act on it. Echo ascii value to LCD
 0B9                Respond2Fifo: ;CALL LCD_cursor_back
 0B9  200FB                       CALL 0FB[GetFifoChar]
 0BA  1D004                       COMPARE s0, 04                               ;character T (request for info from userpico) ->LESS TOP BIT WHICH IS NOT SENT!
 0BB  300F8                       CALL Z, 0F8[SendParamBack]
 0BC                              ;     COMPARE s0,03    ;character S (request for info from userpico)
 0BC                              ;     CALL Z,Select
 0BC  1D07F                       COMPARE s0, 7F                               ;Is this the start of a signal readout (ie another 2 values expected) -LESS TOP BIT WHICH IS NOT SENT!
 0BD  320DA                       JUMP Z, 0DA[Display2]                        ; No revert to original!! ----move cursor and return
 0BE  25000                       RETURN 
 0BF                              ;Display character in s0
 0BF                              ;Display_s0:     LOAD s5,s0         ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!temporary to check beacon mode
 0BF                              ;     CALL   Byte2Chars
 0BF                              ;       LOAD      LCD_data, s6   ;This should display at the end of the line ie characters 12,13
 0BF                              ;     CALL      LCD_character_write  ;then write to LCD
 0BF                              ;     LOAD      LCD_data, s7   ;
 0BF                              ;     CALL      LCD_character_write  ;then write to LCD
 0BF                              ;     RETURN
 0BF                              ;This is not currently called
 0BF  01D07             Display8: LOAD sD[cursor_position], 07                 ;position cursor just after touch value
 0C0  2016B                       CALL 16B[LCD_position_cursor]
 0C1  200FB                       CALL 0FB[GetFifoChar]
 0C2  00F00                       LOAD sF[LCD_data], s0                        ; Write character from GetFfoChar
 0C3  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0C4  200FB                       CALL 0FB[GetFifoChar]
 0C5  00F00                       LOAD sF[LCD_data], s0                        ; Write character from GetFfoChar
 0C6  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0C7  200FB                       CALL 0FB[GetFifoChar]
 0C8  00F00                       LOAD sF[LCD_data], s0                        ; Write character from GetFfoChar
 0C9  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0CA  200FB                       CALL 0FB[GetFifoChar]
 0CB  00F00                       LOAD sF[LCD_data], s0                        ; Write character from GetFfoChar
 0CC  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0CD  200FB                       CALL 0FB[GetFifoChar]
 0CE  00F00                       LOAD sF[LCD_data], s0                        ; Write character from GetFfoChar
 0CF  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0D0  200FB                       CALL 0FB[GetFifoChar]
 0D1  00F00                       LOAD sF[LCD_data], s0                        ; Write character from GetFfoChar
 0D2  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0D3  200FB                       CALL 0FB[GetFifoChar]
 0D4  00F00                       LOAD sF[LCD_data], s0                        ; Write character from GetFfoChar
 0D5  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0D6  200FB                       CALL 0FB[GetFifoChar]
 0D7  00F00                       LOAD sF[LCD_data], s0                        ; Write character from GetFfoChar
 0D8  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0D9  25000                       RETURN 
 0DA                              ;Set cursor position back to 7 and display 2 decimal values from fifo followed by locally available values
 0DA  01D07             Display2: LOAD sD[cursor_position], 07                 ;position cursor just after touch value
 0DB  2016B                       CALL 16B[LCD_position_cursor]
 0DC  200FB                       CALL 0FB[GetFifoChar]
 0DD  00500                       LOAD s5, s0
 0DE  20133                       CALL 133[GetChar]                            ;Added this Sep 2014 to extend display of first digit
 0DF                              ;                    ADD       s0, 48              ; offset to Ascii code for '0'
 0DF  00F50                       LOAD sF[LCD_data], s5                        ; Write character from GetChar
 0E0  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0E1  200FB                       CALL 0FB[GetFifoChar]
 0E2  11030                       ADD s0, 30[48'd]                             ; offset to Ascii code for '0'
 0E3  00F00                       LOAD sF[LCD_data], s0                        ;
 0E4  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0E5                              ; Added code to display ADC and demod peak values
 0E5  01D0A                       LOAD sD[cursor_position], 0A[10'd]           ;position cursor
 0E6  2016B                       CALL 16B[LCD_position_cursor]
 0E7  09506                       INPUT s5, 06[ADCpeak]
 0E8  200B3                       CALL 0B3[Displays5]
 0E9  01F20                       LOAD sF[LCD_data], 20[" "]                   ;character_space   ;
 0EA  20173                       CALL 173[LCD_character_write]                ;then write to LCD
 0EB  09507                       INPUT s5, 07[DemodPeak]                      ;will also reset the peak value
 0EC  200B3                       CALL 0B3[Displays5]
 0ED                              ;This is the part that displays the signal amplitudes - disable for th emoment (Jan 2016) to allow normal display...
 0ED                              ;     LOAD    cursor_position, C0 ;position cursor
 0ED                              ;                   CALL    LCD_position_cursor
 0ED                              ;    INPUT    s5,StartToneA
 0ED                              ;    CALL   Displays5
 0ED                              ;    INPUT   s5,StartToneALong
 0ED                              ;    CALL   Displays5
 0ED                              ;    INPUT   s5,StartToneB
 0ED                              ;    CALL   Displays5
 0ED                              ;    INPUT   s5,StartToneBLong
 0ED                              ;    CALL   Displays5
 0ED                              ;    INPUT   s5,StopToneA
 0ED                              ;    CALL   Displays5
 0ED                              ;    INPUT   s5,StopToneALong
 0ED                              ;    CALL   Displays5
 0ED                              ;    INPUT   s5,StopToneB
 0ED                              ;    CALL   Displays5
 0ED                              ;    INPUT   s5,StopToneBLong
 0ED                              ;    CALL   Displays5
 0ED  25000                       RETURN 
 0EE                              ;Enter with s0 - LSB, s1 - MSB
 0EE  0B003            SetTxFreq: FETCH s0, 03[TX_F_MSB]                       ; Value for TX frequency being used
 0EF  2D00C                       OUTPUT s0, 0C[TXFreqMSB]
 0F0  0B004                       FETCH s0, 04[TX_F_LSB]
 0F1  2D00D                       OUTPUT s0, 0D[TXFreqLSB]                     ; and send value to SSB modulator
 0F2  25000                       RETURN 
 0F3  0B005            SetRxFreq: FETCH s0, 05[RX_F_MSB]                       ; Value for RX frequency being used
 0F4  2D00A                       OUTPUT s0, 0A[RXFreqMSB]
 0F5  0B006                       FETCH s0, 06[RX_F_LSB]
 0F6  2D00B                       OUTPUT s0, 0B[RXFreqLSB]                     ; and send value to SSB demodulator
 0F7  25000                       RETURN 
 0F8                              ;Select:   CALL GetFifoChar
 0F8                              ;     OUT  s0,ChooseTouchKey
 0F8                              ;     RETURN
 0F8  09501        SendParamBack: INPUT s5, 01[PTT]                            ;********************TEST reading touch***********************************
 0F9  20101                       CALL 101[Export2User]
 0FA  25000                       RETURN 
 0FB                              ; Routine to recover a character from the FIFO in s0
 0FB  01020          GetFifoChar: LOAD s0, 20[AckFIFO]
 0FC  2D006                       OUTPUT s0, 06[Controlbits]
 0FD  01020                       LOAD s0, 20[AckFIFO]                         ;Wait
 0FE  09000                       INPUT s0, 00[Command]                        ; now get my character
 0FF  0307F                       AND s0, 7F                                   ; mask of top bit
 100  25000                       RETURN 
 101                              ; Takes value in s5 and converts to 2 ascii codes which are sent to the user picoblaze.
 101  20127          Export2User: CALL 127[Byte2Chars]
 102  2D600                       OUTPUT s6, 00[CmdToUser]
 103  2D700                       OUTPUT s7, 00[CmdToUser]
 104  0100D                       LOAD s0, 0D[13'd]                            ;terminate with CR
 105  2D000                       OUTPUT s0, 00[CmdToUser]
 106  0100A                       LOAD s0, 0A[10'd]                            ;and with LF
 107  2D000                       OUTPUT s0, 00[CmdToUser]
 108  25000                       RETURN 
 109                              ; routine to look at command input and recover 2 characters and return the byte they represent in s5.
 109  09600            Get2Chars: INPUT s6, 00[Command]
 10A  1D680                       COMPARE s6, 80[128'd]                        ; if greater than 128, then no character
 10B  3E109                       JUMP NC, 109[Get2Chars]
 10C  200FB                       CALL 0FB[GetFifoChar]
 10D  00600                       LOAD s6, s0
 10E  09700           Get2ndChar: INPUT s7, 00[Command]
 10F  1D780                       COMPARE s7, 80[128'd]                        ; if greater than 128, then no character
 110  3E10E                       JUMP NC, 10E[Get2ndChar]
 111  200FB                       CALL 0FB[GetFifoChar]
 112  00700                       LOAD s7, s0
 113  22114                       JUMP 114[Chars2Byte]
 114                              ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 114  00860           Chars2Byte: LOAD s8, s6
 115  2011F                       CALL 11F[Get4bits]
 116  00580                       LOAD s5, s8
 117  14506                       SL0 s5
 118  14506                       SL0 s5
 119  14506                       SL0 s5
 11A  14506                       SL0 s5                                       ; put these 4 bits to MSBs
 11B  00870                       LOAD s8, s7
 11C  2011F                       CALL 11F[Get4bits]
 11D  10580                       ADD s5, s8
 11E  25000                       RETURN 
 11F                              ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 11F  1D83C             Get4bits: COMPARE s8, 3C[60'd]                         ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 120  3A124                       JUMP C, 124[char0_9]
 121  19837                       SUB s8, 37[55'd]                             ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 122  0380F                       AND s8, 0F                                   ; make sure only return 4 bits
 123  25000                       RETURN 
 124  19830              char0_9: SUB s8, 30[48'd]
 125  0380F                       AND s8, 0F                                   ; make sure only return 4 bits
 126  25000                       RETURN 
 127                              ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 127  00850           Byte2Chars: LOAD s8, s5                                  ; assumes 8 bit data is in s5
 128  1450E                       SR0 s5
 129  1450E                       SR0 s5
 12A  1450E                       SR0 s5
 12B  1450E                       SR0 s5                                       ; get first hex character
 12C  20133                       CALL 133[GetChar]
 12D  00650                       LOAD s6, s5                                  ; first ascii char
 12E  00580                       LOAD s5, s8
 12F  0350F                       AND s5, 0F
 130  20133                       CALL 133[GetChar]                            ; send to LCD or UART
 131  00750                       LOAD s7, s5                                  ; second ascii char
 132  25000                       RETURN 
 133                              ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 133  1950A              GetChar: SUB s5, 0A[10'd]                             ; Test if s5 greater than 9
 134  3A137                       JUMP C, 137[is_0_9]                          ; Hex character is 0_9
 135  11541                       ADD s5, 41[65'd]                             ; offset for Ascii code 'A'
 136  25000                       RETURN 
 137  1150A               is_0_9: ADD s5, 0A[10'd]                             ; return to range 0-9
 138  11530                       ADD s5, 30[48'd]                             ; offset to Ascii code for '0'
 139  25000                       RETURN 
 13A                              ; LCD driver routines courtesy Ken Chapman Xilinx.
 13A                              ; Send space to the LCD display
 13A                              ;
 13A                              ;
 13A                              ; Registers used LCD_data, LCD_control, s0 and s1.
 13A                              ;
 13A  01F20            LCD_space: LOAD sF[LCD_data], 20[" "]                   ; character_space
 13B  20173                       CALL 173[LCD_character_write]
 13C  25000                       RETURN 
 13D                              ;
 13D                              ;
 13D                              ; These are for a 20x4 character module
 13D                              ;
 13D                              ;
 13D                              ; Initialise LCD display or clear LCD display
 13D                              ;
 13D                              ;
 13D                              ; Registers used LCD_data, LCD_control, s0, s1, s2, s3, s4 and s5.
 13D                              ;
 13D  2017F            LCD_setup: CALL 17F[delay_1s]                           ; delay to allow LCD to be ready after power up
 13E  01F38                       LOAD sF[LCD_data], 38[56'd]                  ; function set, 8-bit, 2-line, 5x7 dot format
 13F  2016F                       CALL 16F[LCD_control_write]
 140  20192                       CALL 192[delay_1ms]                          ; wait >4.1ms
 141  20192                       CALL 192[delay_1ms]
 142  20192                       CALL 192[delay_1ms]
 143  20192                       CALL 192[delay_1ms]
 144  20192                       CALL 192[delay_1ms]
 145  2016F                       CALL 16F[LCD_control_write]                  ; repeat function set
 146  2017F                       CALL 17F[delay_1s]                           ; wait >100us
 147  2016F                       CALL 16F[LCD_control_write]                  ; repeat function set
 148  2016F                       CALL 16F[LCD_control_write]                  ; repeat function set
 149  01F06                       LOAD sF[LCD_data], 06[6'd]                   ; Entry mode, increment by 1, no shift
 14A  2016F                       CALL 16F[LCD_control_write]
 14B  01F0E                       LOAD sF[LCD_data], 0E[14'd]                  ; Display, on, cursur on, no blink cursor
 14C  2016F                       CALL 16F[LCD_control_write]
 14D  01F01            LCD_clear: LOAD sF[LCD_data], 01[1'd]                   ; clear display
 14E  2016F                       CALL 16F[LCD_control_write]
 14F  20192                       CALL 192[delay_1ms]                          ; wait >1.64ms
 150  20192                       CALL 192[delay_1ms]
 151  20192                       CALL 192[delay_1ms]
 152  01040                       LOAD s0, 40                                  ; hex
 153  2D003                       OUTPUT s0, 03[LCDcontrast]                   ;*************************set default contrast
 154  25000                       RETURN 
 155                              ;
 155                              ; Send cursor to ‘home’
 155  01F02             LCD_home: LOAD sF[LCD_data], 02
 156  2016F                       CALL 16F[LCD_control_write]
 157  20192                       CALL 192[delay_1ms]
 158                              ; CALL      delay_1ms
 158  25000                       RETURN 
 159                              ;
 159                              ; Turn Back-light on (assuming bit 3 of the control port is connected to the LCD
 159                              ; backlight), uses LCD_control.
 159  05E08         LCD_light_on: OR sE[LCD_control], 08
 15A  2DE02                       OUTPUT sE[LCD_control], 02[LCD_control_port]
 15B  25000                       RETURN 
 15C                              ;
 15C                              ; Turn Back-light off (assuming bit 3 of the control port is connected to the LCD
 15C                              ; backlight), uses LCD_control.
 15C  03E07        LCD_light_off: AND sE[LCD_control], 07
 15D  2DE02                       OUTPUT sE[LCD_control], 02[LCD_control_port]
 15E  25000                       RETURN 
 15F                              ;
 15F                              ; Move cursor to start of line 2
 15F                              ; Uses LCD_data, LCD_control, s0 and s1.
 15F  01FC0           LCD_line_2: LOAD sF[LCD_data], C0
 160  2016F                       CALL 16F[LCD_control_write]
 161  20192                       CALL 192[delay_1ms]
 162  25000                       RETURN 
 163                              ;
 163                              ; Advance cursur right
 163                              ; Uses LCD_data, LCD_control, s0 and s1.
 163  01F0E   LCD_cursor_advance: LOAD sF[LCD_data], 0E[14'd]
 164  2016F                       CALL 16F[LCD_control_write]
 165  20192                       CALL 192[delay_1ms]
 166  25000                       RETURN 
 167                              ;
 167                              ; Moves cursur left (back one)
 167                              ; Uses LCD_data, LCD_control, s0 and s1.
 167  01F0A      LCD_cursor_back: LOAD sF[LCD_data], 0A[10'd]
 168  2016F                       CALL 16F[LCD_control_write]
 169  20192                       CALL 192[delay_1ms]
 16A  25000                       RETURN 
 16B                              ;
 16B                              ; Set cursor on LCD display based on value in register 'cursor_position'
 16B                              ;
 16B                              ; There are 20 character positions with the following addresses on the first line
 16B                              ; position         1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
 16B                              ; cursor_position 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13
 16B                              ; address         80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f 90 91 92 93
 16B                              ; line 2 address   c0 c1 c2 .....
 16B                              ; other lines have other values…..
 16B                              ; Writing characters auto increments the address, but note that
 16B                              ;
 16B                              ;
 16B                              ; Registers used cursor_position, LCD_data, LCD_control, s0 and s1.
 16B                              ; Horinzontal position in lower 4-5 bits, line in bit 6
 16B  05D80  LCD_position_cursor: OR sD[cursor_position], 80                   ; set  MSB to address LCD memmory
 16C  00FD0                       LOAD sF[LCD_data], sD[cursor_position]
 16D  2016F                       CALL 16F[LCD_control_write]                  ; write address to LCD control
 16E  25000                       RETURN 
 16F                              ;
 16F                              ; Write to LCD with control data provided in register called LCD_data
 16F                              ; Registers used LCD_data, LCD_control, s0 and s1.
 16F                              ;
 16F  2DF01    LCD_control_write: OUTPUT sF[LCD_data], 01[LCD_data_port]       ; output data
 170  03E04                       AND sE[LCD_control], 04                      ; R/W=0,  RS=0
 171  20177                       CALL 177[LCD_enable_pulse]                   ; enable pulse
 172  25000                       RETURN 
 173                              ;
 173                              ; Write to LCD with character data provided in register called LCD_data
 173                              ;
 173                              ; Registers used LCD_data, LCD_control, s0 and s1.
 173                              ;
 173  2DF01  LCD_character_write: OUTPUT sF[LCD_data], 01[LCD_data_port]       ; output data
 174  05E01                       OR sE[LCD_control], 01                       ; R/W=0,  RS=1
 175  20177                       CALL 177[LCD_enable_pulse]                   ; enable pulse
 176  25000                       RETURN 
 177                              ;
 177                              ; Registers used LCD_control, s0 and s1.
 177                              ;
 177  05E04     LCD_enable_pulse: OR sE[LCD_control], 04[LCD_E]                ; set enable bit (E=1)
 178  2DE02                       OUTPUT sE[LCD_control], 02[LCD_control_port]
 179  201A1                       CALL 1A1[delay_1us]                          ; ensure E pulse width > 230ns
 17A  07E04                       XOR sE[LCD_control], 04[LCD_E]               ; reset enable bit (E=0)
 17B  2DE02                       OUTPUT sE[LCD_control], 02[LCD_control_port] ;
 17C  2019C                       CALL 19C[delay_50us]                         ; >40us delay
 17D  2019C                       CALL 19C[delay_50us]                         ; >40us delay - to make sure!
 17E  25000                       RETURN 
 17F                              ;
 17F                              ; Registers used s0, s1, s2, s3, s4 and s5.
 17F                              ;
 17F  01500             delay_1s: LOAD s5, 00                                  ; clear cycle counter
 180  01400                       LOAD s4, 00
 181  20192              wait_1s: CALL 192[delay_1ms]
 182  11401                       ADD s4, 01                                   ; increment cycle counter
 183  13500                       ADDCY s5, 00
 184  1D4E8                       COMPARE s4, E8[count_1000_lsb]               ; test for 1000ms
 185  36181                       JUMP NZ, 181[wait_1s]
 186  1D503                       COMPARE s5, 03[count_1000_msb]
 187  36181                       JUMP NZ, 181[wait_1s]
 188  25000                       RETURN 
 189                              ;
 189                              ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 189                              ;
 189                              ;
 189                              ; Registers used s0, s1, s2, s3 and s4.
 189                              ;
 189  2018D          delay_300ms: CALL 18D[delay_100ms]
 18A  2018D          delay_200ms: CALL 18D[delay_100ms]
 18B  2018D                       CALL 18D[delay_100ms]
 18C  25000                       RETURN 
 18D                              ;
 18D                              ; Delay of approximately 100ms used for switch debounce
 18D                              ;
 18D                              ; Registers used s0, s1, s2, s3 and s4.
 18D                              ;
 18D  01464          delay_100ms: LOAD s4, 64                                  ; repeat 1ms delay 100 times
 18E  20192           wait_100ms: CALL 192[delay_1ms]
 18F  19401                       SUB s4, 01
 190  3618E                       JUMP NZ, 18E[wait_100ms]
 191  25000                       RETURN 
 192                              ;
 192                              ; Delay of approximately 1ms required by LCD display
 192                              ;
 192                              ; Registers used s0, s1, s2 and s3.
 192                              ;
 192  01300            delay_1ms: LOAD s3, 00                                  ; clear cycle counter
 193  01200                       LOAD s2, 00
 194  201A1             wait_1ms: CALL 1A1[delay_1us]
 195  11201                       ADD s2, 01                                   ; increment cycle counter
 196  13300                       ADDCY s3, 00
 197  1D2E8                       COMPARE s2, E8[count_1000_lsb]               ; test for 1000us
 198  36194                       JUMP NZ, 194[wait_1ms]
 199  1D303                       COMPARE s3, 03[count_1000_msb]
 19A  36194                       JUMP NZ, 194[wait_1ms]
 19B  25000                       RETURN 
 19C                              ;
 19C                              ; Delay of approximately 50us required by LCD display
 19C                              ;
 19C                              ; Registers used s0 and s1.
 19C                              ;
 19C  01132           delay_50us: LOAD s1, 32[50'd]                            ; repeat 1us delay 50 times
 19D  201A1            wait_50us: CALL 1A1[delay_1us]
 19E  19101                       SUB s1, 01
 19F  3619D                       JUMP NZ, 19D[wait_50us]
 1A0  25000                       RETURN 
 1A1                              ; Delay of approximately 1us used to provide timing reference for
 1A1                              ; LCD operations. This must be adjusted to reflect the clock
 1A1                              ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 1A1                              ;
 1A1                              ; The software delay loop is formed using register s0. This register
 1A1                              ; must be loaded with an integer value close to the result of....
 1A1                              ;
 1A1                              ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 1A1                              ;
 1A1                              ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 1A1                              ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 1A1                              ; operation will become lower than the 100KHz target intended.
 1A1                              ;
 1A1                              ; Register used s0.
 1A1                              ;
 1A1  01006            delay_1us: LOAD s0, 06[delay_1us_constant]              ; delay value of 12 decimal for a 50MHz clock
 1A2  19001             wait_1us: SUB s0, 01
 1A3  361A2                       JUMP NZ, 1A2[wait_1us]
 1A4  25000                       RETURN 
 1A5                              ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\home\graham\Dropbox\N3workingG\TE0722Rebuild\N3SysGen\KeyPadPico.psm



List of defined constants

 CONSTANT name      Value        Source PSM File

 timestamp_hours    18'd         
 timestamp_minutes  09'd         
 timestamp_seconds  23'd         
 datestamp_year     16'd         
 datestamp_month    7'd          
 datestamp_day      10'd         
 NUL                00           
 BEL                07           
 BS                 08           
 HT                 09           
 LF                 0A           
 VT                 0B           
 CR                 0D           
 ESC                1B           
 DEL                7F           
 DCS                90           
 ST                 9C           
 LCD_RS             1'd          KeyPadPico.psm
 LCD_RW             2'd          KeyPadPico.psm
 LCD_E              4'd          KeyPadPico.psm
 delay_1us_constant 06           KeyPadPico.psm
 count_1000_lsb     E8           KeyPadPico.psm
 count_1000_msb     03           KeyPadPico.psm
 Command            0'd          KeyPadPico.psm
 PTT                1'd          KeyPadPico.psm
 RAMdataInLSB       2'd          KeyPadPico.psm
 RAMdataInMSB       3'd          KeyPadPico.psm
 KP2userbufferFull  4'd          KeyPadPico.psm
 TouchSignal2       5'd          KeyPadPico.psm
 ADCpeak            6'd          KeyPadPico.psm
 DemodPeak          7'd          KeyPadPico.psm
 StartToneA         8'd          KeyPadPico.psm
 StartToneALong     9'd          KeyPadPico.psm
 StartToneB         10'd         KeyPadPico.psm
 StartToneBLong     11'd         KeyPadPico.psm
 StopToneA          12'd         KeyPadPico.psm
 StopToneALong      13'd         KeyPadPico.psm
 StopToneB          14'd         KeyPadPico.psm
 StopToneBLong      15'd         KeyPadPico.psm
 CmdToUser          0'd          KeyPadPico.psm
 LCD_data_port      1'd          KeyPadPico.psm
 LCD_control_port   2'd          KeyPadPico.psm
 LCDcontrast        3'd          KeyPadPico.psm
 Data2ArchiveMSB    4'd          KeyPadPico.psm
 Data2ArchiveLSB    5'd          KeyPadPico.psm
 Controlbits        6'd          KeyPadPico.psm
 AckFIFO            32'd         KeyPadPico.psm
 RAM_ADD_MSB        7'd          KeyPadPico.psm
 WriteKPRAM         4'd          KeyPadPico.psm
 RAM_ADD_LSB        8'd          KeyPadPico.psm
 LatchOn            9'd          KeyPadPico.psm
 RXFreqMSB          10'd         KeyPadPico.psm
 RXFreqLSB          11'd         KeyPadPico.psm
 TXFreqMSB          12'd         KeyPadPico.psm
 TXFreqLSB          13'd         KeyPadPico.psm
 TouchUpLevel       0'd          KeyPadPico.psm
 TouchDownLevel     1'd          KeyPadPico.psm
 TouchSelectLevel   2'd          KeyPadPico.psm
 TX_F_MSB           3'd          KeyPadPico.psm
 TX_F_LSB           4'd          KeyPadPico.psm
 RX_F_MSB           5'd          KeyPadPico.psm
 RX_F_LSB           6'd          KeyPadPico.psm
 Freq2Set           7'd          KeyPadPico.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "10 Jul 2016"  
 timestamp$        "18:09:23"     



List of line labels

   Label                 Addr  Source PSM File

 * cold_start            000   KeyPadPico.psm
 * welcome_message       001   KeyPadPico.psm
 * initialise            008   KeyPadPico.psm
   loop                  018   KeyPadPico.psm
 * NotTouchDown          023   KeyPadPico.psm
   TouchDown             02F   KeyPadPico.psm
   KeyPressed            03B   KeyPadPico.psm
   TurnOff               051   KeyPadPico.psm
   upFreq                054   KeyPadPico.psm
   DownFreq              059   KeyPadPico.psm
   CheckWhichFreq        05E   KeyPadPico.psm
   ClearFreq             06B   KeyPadPico.psm
   SetHeyphoneFreq       06E   KeyPadPico.psm
   SetN2Freq             079   KeyPadPico.psm
   SetN3_31Freq          084   KeyPadPico.psm
   UpdateFreqRegisters   08F   KeyPadPico.psm
   SetLoop               09A   KeyPadPico.psm
   SetEarth              0A0   KeyPadPico.psm
   DispAntennaInput      0A5   KeyPadPico.psm
   Displays5             0B3   KeyPadPico.psm
   Respond2Fifo          0B9   KeyPadPico.psm
 * Display8              0BF   KeyPadPico.psm
   Display2              0DA   KeyPadPico.psm
   SetTxFreq             0EE   KeyPadPico.psm
   SetRxFreq             0F3   KeyPadPico.psm
   SendParamBack         0F8   KeyPadPico.psm
   GetFifoChar           0FB   KeyPadPico.psm
   Export2User           101   KeyPadPico.psm
   Get2Chars             109   KeyPadPico.psm
   Get2ndChar            10E   KeyPadPico.psm
   Chars2Byte            114   KeyPadPico.psm
   Get4bits              11F   KeyPadPico.psm
   char0_9               124   KeyPadPico.psm
   Byte2Chars            127   KeyPadPico.psm
   GetChar               133   KeyPadPico.psm
   is_0_9                137   KeyPadPico.psm
 * LCD_space             13A   KeyPadPico.psm
   LCD_setup             13D   KeyPadPico.psm
 * LCD_clear             14D   KeyPadPico.psm
   LCD_home              155   KeyPadPico.psm
 * LCD_light_on          159   KeyPadPico.psm
 * LCD_light_off         15C   KeyPadPico.psm
 * LCD_line_2            15F   KeyPadPico.psm
 * LCD_cursor_advance    163   KeyPadPico.psm
 * LCD_cursor_back       167   KeyPadPico.psm
   LCD_position_cursor   16B   KeyPadPico.psm
   LCD_control_write     16F   KeyPadPico.psm
   LCD_character_write   173   KeyPadPico.psm
   LCD_enable_pulse      177   KeyPadPico.psm
   delay_1s              17F   KeyPadPico.psm
   wait_1s               181   KeyPadPico.psm
 * delay_300ms           189   KeyPadPico.psm
 * delay_200ms           18A   KeyPadPico.psm
   delay_100ms           18D   KeyPadPico.psm
   wait_100ms            18E   KeyPadPico.psm
   delay_1ms             192   KeyPadPico.psm
   wait_1ms              194   KeyPadPico.psm
   delay_50us            19C   KeyPadPico.psm
   wait_50us             19D   KeyPadPico.psm
   delay_1us             1A1   KeyPadPico.psm
   wait_1us              1A2   KeyPadPico.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            104
 STAR              -

 AND              15
 OR                4
 XOR               1

 ADD               8
 ADDCY             2
 SUB               7
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          26
 COMPARECY         -

 SL0               4
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               5
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT            14
 OUTPUT           22
 OUTPUTK           -

 STORE             7
 FETCH             7

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             22
 JUMP@             -
 CALL            122
 CALL@             -
 RETURN           43
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
