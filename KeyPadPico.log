KCPSM6 Assembler log file for program 'Z:\home\gnaylor\Dropbox\N3SysGen\KeyPadPico.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 06 Sep 2017
Assembly timestamp: 19:57:43

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 143 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 324
Memory locations available: 3772


Assembly listing

 Addr Code                        Instruction

 000                              ;Modified for 49.162MHz clock
 000                              ;A0 is version to get start and stop tone levels for speaker switching.
 000                              ;
 000                              ;99 - add latch on button facility so don't need handset plugged in.
 000                              ;Now display signal level and gain setting
 000                              ;Switch off key pad oscillation and
 000                              ;Mod to read key pad and display
 000                              ;Version using CoutA
 000                              ;Need to mod to send TX request to User when touchdown active
 000                              ;May 10
 000                              ;
 000                              ; KeyPad routine for SSB picoblaze
 000                              ;
 000                              CONSTANT delay_1us_constant, 06   ; Value (13)19 or 12? decimal suitable for 50MHz clock – about 6 for 33MHz?
 000                              CONSTANT count_1000_lsb, E8       ; hex lower 8-bits of 1000 count value
 000                              CONSTANT count_1000_msb, 03       ; hex upper 8-bits of 1000 count value
 000                              ; Input port - port numbering changed June 11
 000                              CONSTANT Command, 0'd             ; From main pico
 000                              CONSTANT PTT, 1'd                 ;This is PTT and default frequency in bits 1 and 2
 000                              CONSTANT RAMdataInLSB, 2'd
 000                              CONSTANT RAMdataInMSB, 3'd
 000                              CONSTANT KP2userbufferFull, 4'd   ;Bit 0 KP2User buffer full, Bit 1 Touch counter running
 000                              CONSTANT TouchSignal2, 5'd        ;This is keypad Bit 0 On, Bit 1 Select, Bit 2 Down, Bit 3 Up
 000                              ;TouchSignal2=0E is On, 0D = Select, 0B = Down, 07= Up
 000                              CONSTANT ADCpeak, 6'd
 000                              CONSTANT DemodPeak, 7'd
 000                              ;CONSTANT SignalLevel,   8'd
 000                              CONSTANT StartToneA, 8'd
 000                              CONSTANT StartToneALong, 9'd
 000                              CONSTANT StartToneB, 10'd
 000                              CONSTANT StartToneBLong, 11'd
 000                              CONSTANT StopToneA, 12'd
 000                              CONSTANT StopToneALong, 13'd
 000                              CONSTANT StopToneB, 14'd
 000                              CONSTANT StopToneBLong, 15'd
 000                              ; Output ports
 000                              CONSTANT CmdToUser, 0'd
 000                              CONSTANT LCD_data_port, 1'd
 000                              CONSTANT LCD_control_port, 2'd
 000                              CONSTANT LCDcontrast, 3'd
 000                              CONSTANT Data2ArchiveMSB, 4'd
 000                              CONSTANT Data2ArchiveLSB, 5'd
 000                              CONSTANT Controlbits, 6'd
 000                              ;Bit offsets:
 000                              CONSTANT AckFIFO, 32'd            ;   bit 5 Acknowledge FIFO (present character)
 000                              CONSTANT RAM_ADD_MSB, 7'd         ;Bits 0 and 1 top too address bits, bit 2 write RAM
 000                              ;Bit offsets:
 000                              CONSTANT WriteKPRAM, 4'd
 000                              CONSTANT RAM_ADD_LSB, 8'd
 000                              CONSTANT LatchOn, 9'd
 000                              CONSTANT RXFreqMSB, 10'd          ; 7546 for 87.956kHz ie 86.956kHz carrier and allow range up to 154kHz 7555 Heyphone
 000                              CONSTANT RXFreqLSB, 11'd
 000                              CONSTANT TXFreqMSB, 12'd          ; 3710  with 49.152MHz clock, with 49.162MHz - need 3709 for N2 and 3711 for Heyphone
 000                              CONSTANT TXFreqLSB, 13'd
 000                              ;TX frequencies:
 000                              ;For 49.152MHz!
 000                              ;Heyphone - 0e80
 000                              ;N2 -       0e7e
 000                              ;N3_31 -    052b
 000                              ;RX frequencies:
 000                              ;Heyphone  - $7555
 000                              ;N2  -       $7546
 000                              ;N3_31  -    $2aad
 000                              ;But for 49.162MHz:
 000                              ;Heyphone - 0e7F
 000                              ;N2 -       0e7d
 000                              ;N3_31 -    052a
 000                              ;RX frequencies:
 000                              ;Heyphone  - $754F
 000                              ;N2  -       $753E
 000                              ;N3_31  -    $2953
 000                              ; Scratchpad registers
 000                              CONSTANT TouchUpLevel, 0'd
 000                              CONSTANT TouchDownLevel, 1'd
 000                              CONSTANT TouchSelectLevel, 2'd
 000                              CONSTANT TX_F_MSB, 3'd
 000                              CONSTANT TX_F_LSB, 4'd
 000                              CONSTANT RX_F_MSB, 5'd
 000                              CONSTANT RX_F_LSB, 6'd
 000                              CONSTANT Freq2Set, 7'd            ; values 0 nothing to set, 1>Hy, 2>N2, 3>N3 (31kHz)
 000                              CONSTANT PreviousKeyState, 10     ; 16d
 000                              CONSTANT PreviousPTTState, 11     ; 17d
 000                              CONSTANT PreviousFrequency, 12    ; 18d
 000                              CONSTANT KEYS_PRESSED, 13         ; 19d
 000                              CONSTANT KeyPressTimer, 14        ; 20d
 000                              CONSTANT KeyPressFast, 15         ; 21d
 000                              CONSTANT KeyPressFastLeadIn, 16   ; 22d
 000                              CONSTANT KeypadCheckingState, 17  ; 23d
 000                              ;;;GenerateCode        MEM       "KeyPadProg.mem"
 000                  cold_start: 
 000             welcome_message: 
 000  01000           initialise: LOAD s0, 00                       ;This is now used to drive LatchOn which latches the device on!!
 001  2D009                       OUTPUT s0, 09[LatchOn]            ;Latch On if 1
 002  2F010                       STORE s0, 10[PreviousKeyState]    ; initial state
 003  2F011                       STORE s0, 11[PreviousPTTState]    ; initial state
 004  2F012                       STORE s0, 12[PreviousFrequency]
 005  2F013                       STORE s0, 13[KEYS_PRESSED]
 006  2F014                       STORE s0, 14[KeyPressTimer]
 007  2F015                       STORE s0, 15[KeyPressFast]
 008  2F017                       STORE s0, 17[KeypadCheckingState]
 009  2011C                       CALL 11C[delay_1s]                ;Wait so it doesn't detect as turn off
 00A                              ;LOAD      s5, "&"   ; key event flag
 00A                              ;OUTPUT    s5, CmdToUser  ; write to user pico and onto ARM
 00A                              ;FETCH   s5, KEYS_PRESSED ; get the keys pressed mask
 00A                              ;ADD     s5, "P"   ; convert to appropriate character for key on
 00A                              ;OUTPUT    s5, CmdToUser  ; write to user pico and onto ARM
 00A                              ;set values for Hey by default
 00A  09001                       INPUT s0, 01[PTT]                 ;This is PTT but also has set default frequency bits in bits 1 and 2
 00B  1400E                       SR0 s0
 00C  03003                       AND s0, 03
 00D                              ;LOAD    s0,01   ;use 1 for Hey, 2 for N2 freq, 3 for 37kHz
 00D  2F007                       STORE s0, 07[Freq2Set]
 00E  200A6                       CALL 0A6[UpdateFreqRegisters]
 00F                              ;Wait and check if ON still pressed
 00F  2011C                       CALL 11C[delay_1s]
 010  09505                       INPUT s5, 05[TouchSignal2]
 011  0350F                       AND s5, 0F
 012  1D50E                       COMPARE s5, 0E                    ;is 'ON' pressed
 013  36018                       JUMP NZ, 018[loop]                ;if not ON button, skip
 014  01001                       LOAD s0, 01                       ;This is now used to drive PMOD1 which latches the device on!!
 015  2D009                       OUTPUT s0, 09[LatchOn]            ;Latch On
 016  2011C                       CALL 11C[delay_1s]                ;Wait so it doesn't detect as turn off!
 017  2011C                       CALL 11C[delay_1s]                ;Wait so it doesn't detect as turn off!
 018                        loop: 
 018  2012A                       CALL 12A[delay_50msecs]           ; period between checks
 019                              ;CALL   delay_1s    ;Wait so it doesn't detect as turn off!
 019  09000                       INPUT s0, 00[Command]             ;Check if FIFO character present
 01A  1D080                       COMPARE s0, 80[128'd]             ; is there a character?
 01B  380AC                       CALL C, 0AC[Respond2Fifo]         ;this should now receive value of mode from user pico and display on LCD
 01C  09105                       INPUT s1, 05[TouchSignal2]        ; read the keys touched register
 01D  071FF                       XOR s1, FF                        ; invert so ON is a 1
 01E  0310F                       AND s1, 0F                        ; mask to the key press bits
 01F                              ;LOAD      s5, "&"   ; key event flag
 01F                              ;OUTPUT    s5, CmdToUser  ; write to user pico and onto ARM
 01F                              ;LOAD      s5, s1
 01F                              ;ADD     s5, "@"   ; convert to appropriate character for key on
 01F                              ;ADD     s5, 60   ; temp should get a through h
 01F                              ;OUTPUT    s5, CmdToUser  ; write to user pico and onto ARM
 01F                              ;JUMP      CheckPTT
 01F  0B510                       FETCH s5, 10[PreviousKeyState]    ; get last key pressed state
 020  1C150                       COMPARE s1, s5
 021                              ;JUMP      Z, CheckPTT      ; skip if input state not changed
 021  3203A                       JUMP Z, 03A[KeyNotChanged]        ; skip if input state not changed
 022  2F110                       STORE s1, 10[PreviousKeyState]    ; remember new state
 023  0B513                       FETCH s5, 13[KEYS_PRESSED]        ; get the keys pressed mask
 024  04510                       OR s5, s1                         ; remember which keys have been pressed
 025  2F513                       STORE s5, 13[KEYS_PRESSED]        ; remember new state
 026                              ;;; exceptional problem - force turn off
 026  1D51F                       COMPARE s5, 1F                    ; all keys have been pressed then force turn off
 027  3006A                       CALL Z, 06A[TurnOff]              ; call the turn off routine
 028  1D50F                       COMPARE s5, 0F                    ; all keys have been pressed then force turn off
 029  3006A                       CALL Z, 06A[TurnOff]              ; call the turn off routine
 02A  0B917                       FETCH s9, 17[KeypadCheckingState] ; are we checking the keypad operation?
 02B  1D900                       COMPARE s9, 00                    ;
 02C  3602F                       JUMP NZ, 02F[SendKeychangeAnyway] ; send key operation if we are
 02D  1D100                       COMPARE s1, 00                    ; are there any keys pressed now?
 02E  3603A                       JUMP NZ, 03A[KeyNotChanged]       ; skip if keys still pressed
 02F                              ;JUMP      nz, CheckPTT          ; skip if keys still pressed
 02F         SendKeychangeAnyway: 
 02F  01526                       LOAD s5, 26["&"]                  ; key event flag
 030  2D500                       OUTPUT s5, 00[CmdToUser]          ; write to user pico and onto ARM
 031  0B513                       FETCH s5, 13[KEYS_PRESSED]        ; get the keys pressed mask
 032  11540                       ADD s5, 40["@"]                   ; convert to appropriate character
 033  2D500                       OUTPUT s5, 00[CmdToUser]          ; write to user pico and onto ARM
 034                              ;#define KEY_UP  'H'  // up = 08
 034                              ;#define KEY_DOWN 'D'  // down = 04
 034                              ;#define KEY_RIGHT 'B'  // right = 02
 034                              ;#define KEY_LEFT 'A'  // left = 01
 034                              ;#define KEY_UPLEFT 'I'  // 08 + 01
 034                              ;#define KEY_LEFTRIGHT 'C'  // 02 + 01
 034                              ;#define KEY_PTT_ON  '0'
 034                              ;#define KEY_PTT_OFF '1'
 034  01000                       LOAD s0, 00                       ; reset the keys pressed
 035  2F013                       STORE s0, 13[KEYS_PRESSED]
 036  2F014                       STORE s0, 14[KeyPressTimer]
 037  2F015                       STORE s0, 15[KeyPressFast]
 038  2F016                       STORE s0, 16[KeyPressFastLeadIn]
 039  22056                       JUMP 056[CheckPTT]
 03A                              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 03A               KeyNotChanged: 
 03A                              ;;; check for key pressed for a period and tell ARM if so
 03A  0B113                       FETCH s1, 13[KEYS_PRESSED]        ; get the keys pressed mask
 03B  1D100                       COMPARE s1, 00                    ; any keys pressed
 03C  32056                       JUMP Z, 056[CheckPTT]             ; if not then do not time
 03D  0B215                       FETCH s2, 15[KeyPressFast]        ; has key been pressed a while?
 03E  1D200                       COMPARE s2, 00                    ;
 03F  32046                       JUMP Z, 046[SlowPress]            ; skip if slow presses
 040                   FastPress: 
 040  0B214                       FETCH s2, 14[KeyPressTimer]
 041  11201                       ADD s2, 01                        ; increment by approx loop time (50 milli sec?)
 042  2F214                       STORE s2, 14[KeyPressTimer]
 043  03207                       AND s2, 07                        ; if key pressed for .3 secs approx (32 ticks)
 044  36056                       JUMP NZ, 056[CheckPTT]            ; if not then no message
 045  2204B                       JUMP 04B[SlowPressSend]
 046                   SlowPress: 
 046  0B214                       FETCH s2, 14[KeyPressTimer]
 047  11201                       ADD s2, 01                        ; increment by approx loop time (50 milli sec?)
 048  2F214                       STORE s2, 14[KeyPressTimer]
 049  0320F                       AND s2, 0F                        ; if key pressed for 1.5 secs approx (32 ticks)
 04A  36056                       JUMP NZ, 056[CheckPTT]            ; if not then no message
 04B               SlowPressSend: 
 04B  01526                       LOAD s5, 26["&"]                  ; key event flag
 04C  2D500                       OUTPUT s5, 00[CmdToUser]          ; write to user pico and onto ARM
 04D  0B513                       FETCH s5, 13[KEYS_PRESSED]        ; get the keys pressed mask
 04E  11550                       ADD s5, 50["P"]                   ; convert to appropriate character for key on
 04F  2D500                       OUTPUT s5, 00[CmdToUser]          ; write to user pico and onto ARM
 050  0B216                       FETCH s2, 16[KeyPressFastLeadIn]
 051  11201                       ADD s2, 01                        ; increment by approx loop time (50 milli sec?)
 052  2F216                       STORE s2, 16[KeyPressFastLeadIn]
 053  1D204                       COMPARE s2, 04                    ; approx 2 seconds?
 054  36056                       JUMP NZ, 056[CheckPTT]            ; keep slow presses till then
 055  2F215                       STORE s2, 15[KeyPressFast]        ; start fast key press
 056                              ;;; now check PTT
 056                    CheckPTT: 
 056  09101                       INPUT s1, 01[PTT]                 ;Read PTT register
 057  03101                       AND s1, 01                        ;Mask lowest bit
 058  0B511                       FETCH s5, 11[PreviousPTTState]
 059  1C150                       COMPARE s1, s5                    ; has it changed
 05A  32060                       JUMP Z, 060[CheckPTTFrequency]    ; loop back if not
 05B  2F111                       STORE s1, 11[PreviousPTTState]
 05C                              ; send PTT state -
 05C                              ;  0 = PTT pressed   1 = PTT released
 05C  01526                       LOAD s5, 26["&"]
 05D  2D500                       OUTPUT s5, 00[CmdToUser]
 05E  11130                       ADD s1, 30["0"]                   ; PTT pressed = '0'; PTT released = '1'
 05F  2D100                       OUTPUT s1, 00[CmdToUser]
 060                              ;   loop  drop through to check frequency
 060           CheckPTTFrequency: 
 060  09101                       INPUT s1, 01[PTT]                 ;Read PTT register
 061  1410E                       SR0 s1
 062  03103                       AND s1, 03                        ;Mask frequency bits
 063  0B507                       FETCH s5, 07[Freq2Set]
 064  1C150                       COMPARE s1, s5                    ; has it changed
 065  32018                       JUMP Z, 018[loop]                 ; loop back if not
 066  2F107                       STORE s1, 07[Freq2Set]
 067  00010                       LOAD s0, s1
 068  200A6                       CALL 0A6[UpdateFreqRegisters]
 069  22018                       JUMP 018[loop]
 06A                              ;Note key pad bits are: bit3 = On, bit 2 = up, bit 1 = select, bit 0 = down
 06A  01000              TurnOff: LOAD s0, 00                       ;This is now used to drive PMOD1 which latches the device on!!
 06B  2D009                       OUTPUT s0, 09[LatchOn]            ;Latch On if 1
 06C  25000                       RETURN 
 06D              CheckWhichFreq: 
 06D  1D000                       COMPARE s0, 00
 06E  30076                       CALL Z, 076[ClearFreq]            ;clear set display
 06F  1D001                       COMPARE s0, 01
 070  30079                       CALL Z, 079[SetHeyphoneFreq]      ;set Hy freq and return
 071  1D002                       COMPARE s0, 02
 072  30088                       CALL Z, 088[SetN2Freq]
 073  1D003                       COMPARE s0, 03
 074  30097                       CALL Z, 097[SetN3_31Freq]
 075  25000                       RETURN 
 076  01B20            ClearFreq: LOAD sB, 20[" "]                  ; character_space
 077  01C20                       LOAD sC, 20[" "]                  ; character_space
 078  25000                       RETURN 
 079                              ;TX frequencies:
 079                              ;for 49.162MHz!:
 079                              ;Heyphone - 0e7F
 079                              ;N2 -       0e7d
 079                              ;N3_31 -    052a
 079                              ;RX frequencies:
 079                              ;Heyphone  - $754F
 079                              ;N2  -       $753E
 079                              ;N3_31  -    $2953
 079                              ; with 49.162MHzMHz!
 079  0110E      SetHeyphoneFreq: LOAD s1, 0E
 07A  2F103                       STORE s1, 03[TX_F_MSB]
 07B  0117F                       LOAD s1, 7F
 07C  2F104                       STORE s1, 04[TX_F_LSB]
 07D  01175                       LOAD s1, 75
 07E  2F105                       STORE s1, 05[RX_F_MSB]
 07F  0114F                       LOAD s1, 4F
 080  2F106                       STORE s1, 06[RX_F_LSB]
 081                              ;LOAD   sB,"h"  ; character_h
 081                              ;LOAD   sC,"y"  ; character_y
 081  200D0                       CALL 0D0[SetTxFreq]
 082  200D5                       CALL 0D5[SetRxFreq]
 083  01526                       LOAD s5, 26["&"]                  ; key event flag
 084  2D500                       OUTPUT s5, 00[CmdToUser]          ; write to user pico and onto ARM
 085  01577                       LOAD s5, 77["w"]                  ; key event flag
 086  2D500                       OUTPUT s5, 00[CmdToUser]          ; write to user pico and onto ARM
 087  25000                       RETURN 
 088                              ;For N3 5565 (15BD) TX and  45032 (AFE8) RX with 32.768MHz!
 088  0110E            SetN2Freq: LOAD s1, 0E
 089  2F103                       STORE s1, 03[TX_F_MSB]
 08A  0117D                       LOAD s1, 7D
 08B  2F104                       STORE s1, 04[TX_F_LSB]
 08C  01175                       LOAD s1, 75
 08D  2F105                       STORE s1, 05[RX_F_MSB]
 08E  0113E                       LOAD s1, 3E
 08F  2F106                       STORE s1, 06[RX_F_LSB]
 090                              ;LOAD   sB,"n"  ; character_n
 090                              ;LOAD   sC,"2"  ; character_2
 090  200D0                       CALL 0D0[SetTxFreq]
 091  200D5                       CALL 0D5[SetRxFreq]
 092  01526                       LOAD s5, 26["&"]                  ; key event flag
 093  2D500                       OUTPUT s5, 00[CmdToUser]          ; write to user pico and onto ARM
 094  01578                       LOAD s5, 78["x"]                  ; key event flag
 095  2D500                       OUTPUT s5, 00[CmdToUser]          ; write to user pico and onto ARM
 096  25000                       RETURN 
 097                              ;For 31kH 1984 TX (07C0)    16384 for RX (4000 hex) with 32.768MHz!
 097  01105         SetN3_31Freq: LOAD s1, 05
 098  2F103                       STORE s1, 03[TX_F_MSB]
 099  0112A                       LOAD s1, 2A
 09A  2F104                       STORE s1, 04[TX_F_LSB]
 09B  01129                       LOAD s1, 29
 09C  2F105                       STORE s1, 05[RX_F_MSB]
 09D  01153                       LOAD s1, 53
 09E  2F106                       STORE s1, 06[RX_F_LSB]
 09F                              ;LOAD   sB,"3"  ; character_3
 09F                              ;LOAD   sC,"1"  ; character_1
 09F  200D0                       CALL 0D0[SetTxFreq]
 0A0  200D5                       CALL 0D5[SetRxFreq]
 0A1  01526                       LOAD s5, 26["&"]                  ; key event flag
 0A2  2D500                       OUTPUT s5, 00[CmdToUser]          ; write to user pico and onto ARM
 0A3  01579                       LOAD s5, 79["y"]                  ; key event flag
 0A4  2D500                       OUTPUT s5, 00[CmdToUser]          ; write to user pico and onto ARM
 0A5  25000                       RETURN 
 0A6         UpdateFreqRegisters: 
 0A6                              ;CALL    SetHeyphoneFreq    ;set Hy freq and return
 0A6  0B007                       FETCH s0, 07[Freq2Set]
 0A7  2006D                       CALL 06D[CheckWhichFreq]
 0A8  25000                       RETURN 
 0A9                              ;  flag that we are checking the keypad operation
 0A9              SetKeypadCheck: 
 0A9  01001                       LOAD s0, 01
 0AA  2F017                       STORE s0, 17[KeypadCheckingState]
 0AB  25000                       RETURN 
 0AC                              ;Get fifo command and act on it. Echo ascii value to LCD
 0AC                Respond2Fifo: ;CALL LCD_cursor_back
 0AC  200DD                       CALL 0DD[GetFifoChar]
 0AD               Respond2FifoW: 
 0AD  09000                       INPUT s0, 00[Command]             ;Check if FIFO character present
 0AE  1D080                       COMPARE s0, 80[128'd]             ; is there a character?
 0AF  3E0AD                       JUMP NC, 0AD[Respond2FifoW]       ;this should now receive value of mode from user pico and display on LCD
 0B0  200DD                       CALL 0DD[GetFifoChar]
 0B1  1D044                       COMPARE s0, 44["D"]               ;#define SEND_FREQUENCY_HEYPHONE ('D')
 0B2  30079                       CALL Z, 079[SetHeyphoneFreq]
 0B3  1D045                       COMPARE s0, 45["E"]               ;#define SEND_FREQUENCY_NICOLA2 ('E')
 0B4  30088                       CALL Z, 088[SetN2Freq]
 0B5  1D046                       COMPARE s0, 46["F"]               ;#define SEND_FREQUENCY_31KHZ ('F')
 0B6  30097                       CALL Z, 097[SetN3_31Freq]
 0B7  1D07E                       COMPARE s0, 7E                    ;#define SEND_KEYPAD_CHK_MODE (0x7E)
 0B8  300A9                       CALL Z, 0A9[SetKeypadCheck]
 0B9  1D057                       COMPARE s0, 57["W"]               ; Z = turn off
 0BA  300C4                       CALL Z, 0C4[SendWatchdogReply]
 0BB  1D05A                       COMPARE s0, 5A["Z"]               ; Z = turn off
 0BC  3006A                       CALL Z, 06A[TurnOff]
 0BD  1D079                       COMPARE s0, 79["y"]               ; y - turn on LCD
 0BE  300C9                       CALL Z, 0C9[TurnLCDOn]
 0BF  1D059                       COMPARE s0, 59["Y"]               ; Y - turn off LCD
 0C0  300CC                       CALL Z, 0CC[TurnLCDOff]
 0C1  1D004                       COMPARE s0, 04                    ;character T (request for info from userpico) ->LESS TOP BIT WHICH IS NOT SENT!
 0C2  300DA                       CALL Z, 0DA[SendParamBack]
 0C3  25000                       RETURN 
 0C4           SendWatchdogReply: 
 0C4  01526                       LOAD s5, 26["&"]                  ;
 0C5  2D500                       OUTPUT s5, 00[CmdToUser]          ; write to user pico and onto ARM
 0C6  01571                       LOAD s5, 71["q"]                  ; key pico watchdog reply
 0C7  2D500                       OUTPUT s5, 00[CmdToUser]          ; write to user pico and onto ARM
 0C8  25000                       RETURN 
 0C9                   TurnLCDOn: 
 0C9  01001                       LOAD s0, 01
 0CA  2D003                       OUTPUT s0, 03[LCDcontrast]        ;
 0CB  25000                       RETURN 
 0CC                  TurnLCDOff: 
 0CC  01000                       LOAD s0, 00
 0CD  2D003                       OUTPUT s0, 03[LCDcontrast]        ;
 0CE  25000                       RETURN 
 0CF                              ; Added code to display ADC and demod peak values
 0CF  25000                       RETURN 
 0D0                              ;Enter with s0 - LSB, s1 - MSB
 0D0  0B003            SetTxFreq: FETCH s0, 03[TX_F_MSB]            ; Value for TX frequency being used
 0D1  2D00C                       OUTPUT s0, 0C[TXFreqMSB]
 0D2  0B004                       FETCH s0, 04[TX_F_LSB]
 0D3  2D00D                       OUTPUT s0, 0D[TXFreqLSB]          ; and send value to SSB modulator
 0D4  25000                       RETURN 
 0D5  0B005            SetRxFreq: FETCH s0, 05[RX_F_MSB]            ; Value for RX frequency being used
 0D6  2D00A                       OUTPUT s0, 0A[RXFreqMSB]
 0D7  0B006                       FETCH s0, 06[RX_F_LSB]
 0D8  2D00B                       OUTPUT s0, 0B[RXFreqLSB]          ; and send value to SSB demodulator
 0D9  25000                       RETURN 
 0DA                              ;Select:   CALL GetFifoChar
 0DA                              ;     OUT  s0,ChooseTouchKey
 0DA                              ;     RETURN
 0DA  09501        SendParamBack: INPUT s5, 01[PTT]                 ;********************TEST reading touch***********************************
 0DB  200E3                       CALL 0E3[Export2User]
 0DC  25000                       RETURN 
 0DD                              ; Routine to recover a character from the FIFO in s0
 0DD  01020          GetFifoChar: LOAD s0, 20[AckFIFO]
 0DE  2D006                       OUTPUT s0, 06[Controlbits]
 0DF  01020                       LOAD s0, 20[AckFIFO]              ;Wait
 0E0  09000                       INPUT s0, 00[Command]             ; now get my character
 0E1  0307F                       AND s0, 7F                        ; mask of top bit
 0E2  25000                       RETURN 
 0E3                              ; Takes value in s5 and converts to 2 ascii codes which are sent to the user picoblaze.
 0E3  20109          Export2User: CALL 109[Byte2Chars]
 0E4  2D600                       OUTPUT s6, 00[CmdToUser]
 0E5  2D700                       OUTPUT s7, 00[CmdToUser]
 0E6  0100D                       LOAD s0, 0D[13'd]                 ;terminate with CR
 0E7  2D000                       OUTPUT s0, 00[CmdToUser]
 0E8  0100A                       LOAD s0, 0A[10'd]                 ;and with LF
 0E9  2D000                       OUTPUT s0, 00[CmdToUser]
 0EA  25000                       RETURN 
 0EB                              ; routine to look at command input and recover 2 characters and return the byte they represent in s5.
 0EB  09600            Get2Chars: INPUT s6, 00[Command]
 0EC  1D680                       COMPARE s6, 80[128'd]             ; if greater than 128, then no character
 0ED  3E0EB                       JUMP NC, 0EB[Get2Chars]
 0EE  200DD                       CALL 0DD[GetFifoChar]
 0EF  00600                       LOAD s6, s0
 0F0  09700           Get2ndChar: INPUT s7, 00[Command]
 0F1  1D780                       COMPARE s7, 80[128'd]             ; if greater than 128, then no character
 0F2  3E0F0                       JUMP NC, 0F0[Get2ndChar]
 0F3  200DD                       CALL 0DD[GetFifoChar]
 0F4  00700                       LOAD s7, s0
 0F5  220F6                       JUMP 0F6[Chars2Byte]
 0F6                              ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 0F6  00860           Chars2Byte: LOAD s8, s6
 0F7  20101                       CALL 101[Get4bits]
 0F8  00580                       LOAD s5, s8
 0F9  14506                       SL0 s5
 0FA  14506                       SL0 s5
 0FB  14506                       SL0 s5
 0FC  14506                       SL0 s5                            ; put these 4 bits to MSBs
 0FD  00870                       LOAD s8, s7
 0FE  20101                       CALL 101[Get4bits]
 0FF  10580                       ADD s5, s8
 100  25000                       RETURN 
 101                              ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 101  1D83C             Get4bits: COMPARE s8, 3C[60'd]              ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 102  3A106                       JUMP C, 106[char0_9]
 103  19837                       SUB s8, 37[55'd]                  ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 104  0380F                       AND s8, 0F                        ; make sure only return 4 bits
 105  25000                       RETURN 
 106  19830              char0_9: SUB s8, 30[48'd]
 107  0380F                       AND s8, 0F                        ; make sure only return 4 bits
 108  25000                       RETURN 
 109                              ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 109  00850           Byte2Chars: LOAD s8, s5                       ; assumes 8 bit data is in s5
 10A  1450E                       SR0 s5
 10B  1450E                       SR0 s5
 10C  1450E                       SR0 s5
 10D  1450E                       SR0 s5                            ; get first hex character
 10E  20115                       CALL 115[GetChar]
 10F  00650                       LOAD s6, s5                       ; first ascii char
 110  00580                       LOAD s5, s8
 111  0350F                       AND s5, 0F
 112  20115                       CALL 115[GetChar]                 ; send to LCD or UART
 113  00750                       LOAD s7, s5                       ; second ascii char
 114  25000                       RETURN 
 115                              ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 115  1950A              GetChar: SUB s5, 0A[10'd]                  ; Test if s5 greater than 9
 116  3A119                       JUMP C, 119[is_0_9]               ; Hex character is 0_9
 117  11541                       ADD s5, 41[65'd]                  ; offset for Ascii code 'A'
 118  25000                       RETURN 
 119  1150A               is_0_9: ADD s5, 0A[10'd]                  ; return to range 0-9
 11A  11530                       ADD s5, 30[48'd]                  ; offset to Ascii code for '0'
 11B  25000                       RETURN 
 11C                              ; Registers used s0, s1, s2, s3, s4 and s5.
 11C                              ;
 11C  01500             delay_1s: LOAD s5, 00                       ; clear cycle counter
 11D  01400                       LOAD s4, 00
 11E  20131              wait_1s: CALL 131[delay_1ms]
 11F  11401                       ADD s4, 01                        ; increment cycle counter
 120  13500                       ADDCY s5, 00
 121  1D4E8                       COMPARE s4, E8[count_1000_lsb]    ; test for 1000ms
 122  3611E                       JUMP NZ, 11E[wait_1s]
 123  1D503                       COMPARE s5, 03[count_1000_msb]
 124  3611E                       JUMP NZ, 11E[wait_1s]
 125  25000                       RETURN 
 126                              ;
 126                              ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 126                              ;
 126                              ;
 126                              ; Registers used s0, s1, s2, s3 and s4.
 126                              ;
 126  2012C          delay_300ms: CALL 12C[delay_100ms]
 127  2012C          delay_200ms: CALL 12C[delay_100ms]
 128  2012C                       CALL 12C[delay_100ms]
 129  25000                       RETURN 
 12A                              ;
 12A                              ; Delay of approximately 100ms used for switch debounce
 12A                              ;
 12A                              ; Registers used s0, s1, s2, s3 and s4.
 12A                              ;
 12A  01432        delay_50msecs: LOAD s4, 32                       ; repeat 1ms delay 100 times
 12B  2212D                       JUMP 12D[wait_100ms]
 12C  01464          delay_100ms: LOAD s4, 64                       ; repeat 1ms delay 100 times
 12D  20131           wait_100ms: CALL 131[delay_1ms]
 12E  19401                       SUB s4, 01
 12F  3612D                       JUMP NZ, 12D[wait_100ms]
 130  25000                       RETURN 
 131                              ;
 131                              ; Delay of approximately 1ms required by LCD display
 131                              ;
 131                              ; Registers used s0, s1, s2 and s3.
 131                              ;
 131  01300            delay_1ms: LOAD s3, 00                       ; clear cycle counter
 132  01200                       LOAD s2, 00
 133  20140             wait_1ms: CALL 140[delay_1us]
 134  11201                       ADD s2, 01                        ; increment cycle counter
 135  13300                       ADDCY s3, 00
 136  1D2E8                       COMPARE s2, E8[count_1000_lsb]    ; test for 1000us
 137  36133                       JUMP NZ, 133[wait_1ms]
 138  1D303                       COMPARE s3, 03[count_1000_msb]
 139  36133                       JUMP NZ, 133[wait_1ms]
 13A  25000                       RETURN 
 13B                              ;
 13B                              ; Delay of approximately 50us required by LCD display
 13B                              ;
 13B                              ; Registers used s0 and s1.
 13B                              ;
 13B  01132           delay_50us: LOAD s1, 32[50'd]                 ; repeat 1us delay 50 times
 13C  20140            wait_50us: CALL 140[delay_1us]
 13D  19101                       SUB s1, 01
 13E  3613C                       JUMP NZ, 13C[wait_50us]
 13F  25000                       RETURN 
 140                              ; Delay of approximately 1us used to provide timing reference for
 140                              ; LCD operations. This must be adjusted to reflect the clock
 140                              ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 140                              ;
 140                              ; The software delay loop is formed using register s0. This register
 140                              ; must be loaded with an integer value close to the result of....
 140                              ;
 140                              ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 140                              ;
 140                              ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 140                              ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 140                              ; operation will become lower than the 100KHz target intended.
 140                              ;
 140                              ; Register used s0.
 140                              ;
 140  01006            delay_1us: LOAD s0, 06[delay_1us_constant]   ; delay value of 12 decimal for a 50MHz clock
 141  19001             wait_1us: SUB s0, 01
 142  36141                       JUMP NZ, 141[wait_1us]
 143  25000                       RETURN 
 144                              ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\home\gnaylor\Dropbox\N3SysGen\KeyPadPico.psm



List of defined constants

 CONSTANT name       Value        Source PSM File

 timestamp_hours     19'd         
 timestamp_minutes   57'd         
 timestamp_seconds   43'd         
 datestamp_year      17'd         
 datestamp_month     9'd          
 datestamp_day       06'd         
 NUL                 00           
 BEL                 07           
 BS                  08           
 HT                  09           
 LF                  0A           
 VT                  0B           
 CR                  0D           
 ESC                 1B           
 DEL                 7F           
 DCS                 90           
 ST                  9C           
 delay_1us_constant  06           KeyPadPico.psm
 count_1000_lsb      E8           KeyPadPico.psm
 count_1000_msb      03           KeyPadPico.psm
 Command             0'd          KeyPadPico.psm
 PTT                 1'd          KeyPadPico.psm
 RAMdataInLSB        2'd          KeyPadPico.psm
 RAMdataInMSB        3'd          KeyPadPico.psm
 KP2userbufferFull   4'd          KeyPadPico.psm
 TouchSignal2        5'd          KeyPadPico.psm
 ADCpeak             6'd          KeyPadPico.psm
 DemodPeak           7'd          KeyPadPico.psm
 StartToneA          8'd          KeyPadPico.psm
 StartToneALong      9'd          KeyPadPico.psm
 StartToneB          10'd         KeyPadPico.psm
 StartToneBLong      11'd         KeyPadPico.psm
 StopToneA           12'd         KeyPadPico.psm
 StopToneALong       13'd         KeyPadPico.psm
 StopToneB           14'd         KeyPadPico.psm
 StopToneBLong       15'd         KeyPadPico.psm
 CmdToUser           0'd          KeyPadPico.psm
 LCD_data_port       1'd          KeyPadPico.psm
 LCD_control_port    2'd          KeyPadPico.psm
 LCDcontrast         3'd          KeyPadPico.psm
 Data2ArchiveMSB     4'd          KeyPadPico.psm
 Data2ArchiveLSB     5'd          KeyPadPico.psm
 Controlbits         6'd          KeyPadPico.psm
 AckFIFO             32'd         KeyPadPico.psm
 RAM_ADD_MSB         7'd          KeyPadPico.psm
 WriteKPRAM          4'd          KeyPadPico.psm
 RAM_ADD_LSB         8'd          KeyPadPico.psm
 LatchOn             9'd          KeyPadPico.psm
 RXFreqMSB           10'd         KeyPadPico.psm
 RXFreqLSB           11'd         KeyPadPico.psm
 TXFreqMSB           12'd         KeyPadPico.psm
 TXFreqLSB           13'd         KeyPadPico.psm
 TouchUpLevel        0'd          KeyPadPico.psm
 TouchDownLevel      1'd          KeyPadPico.psm
 TouchSelectLevel    2'd          KeyPadPico.psm
 TX_F_MSB            3'd          KeyPadPico.psm
 TX_F_LSB            4'd          KeyPadPico.psm
 RX_F_MSB            5'd          KeyPadPico.psm
 RX_F_LSB            6'd          KeyPadPico.psm
 Freq2Set            7'd          KeyPadPico.psm
 PreviousKeyState    10           KeyPadPico.psm
 PreviousPTTState    11           KeyPadPico.psm
 PreviousFrequency   12           KeyPadPico.psm
 KEYS_PRESSED        13           KeyPadPico.psm
 KeyPressTimer       14           KeyPadPico.psm
 KeyPressFast        15           KeyPadPico.psm
 KeyPressFastLeadIn  16           KeyPadPico.psm
 KeypadCheckingState 17           KeyPadPico.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "06 Sep 2017"  
 timestamp$        "19:57:43"     



List of line labels

   Label                 Addr  Source PSM File

 * cold_start            000   KeyPadPico.psm
 * welcome_message       000   KeyPadPico.psm
 * initialise            000   KeyPadPico.psm
   loop                  018   KeyPadPico.psm
   SendKeychangeAnyway   02F   KeyPadPico.psm
   KeyNotChanged         03A   KeyPadPico.psm
 * FastPress             040   KeyPadPico.psm
   SlowPress             046   KeyPadPico.psm
   SlowPressSend         04B   KeyPadPico.psm
   CheckPTT              056   KeyPadPico.psm
   CheckPTTFrequency     060   KeyPadPico.psm
   TurnOff               06A   KeyPadPico.psm
   CheckWhichFreq        06D   KeyPadPico.psm
   ClearFreq             076   KeyPadPico.psm
   SetHeyphoneFreq       079   KeyPadPico.psm
   SetN2Freq             088   KeyPadPico.psm
   SetN3_31Freq          097   KeyPadPico.psm
   UpdateFreqRegisters   0A6   KeyPadPico.psm
   SetKeypadCheck        0A9   KeyPadPico.psm
   Respond2Fifo          0AC   KeyPadPico.psm
   Respond2FifoW         0AD   KeyPadPico.psm
   SendWatchdogReply     0C4   KeyPadPico.psm
   TurnLCDOn             0C9   KeyPadPico.psm
   TurnLCDOff            0CC   KeyPadPico.psm
   SetTxFreq             0D0   KeyPadPico.psm
   SetRxFreq             0D5   KeyPadPico.psm
   SendParamBack         0DA   KeyPadPico.psm
   GetFifoChar           0DD   KeyPadPico.psm
   Export2User           0E3   KeyPadPico.psm
   Get2Chars             0EB   KeyPadPico.psm
   Get2ndChar            0F0   KeyPadPico.psm
   Chars2Byte            0F6   KeyPadPico.psm
   Get4bits              101   KeyPadPico.psm
   char0_9               106   KeyPadPico.psm
   Byte2Chars            109   KeyPadPico.psm
   GetChar               115   KeyPadPico.psm
   is_0_9                119   KeyPadPico.psm
   delay_1s              11C   KeyPadPico.psm
   wait_1s               11E   KeyPadPico.psm
 * delay_300ms           126   KeyPadPico.psm
 * delay_200ms           127   KeyPadPico.psm
   delay_50msecs         12A   KeyPadPico.psm
   delay_100ms           12C   KeyPadPico.psm
   wait_100ms            12D   KeyPadPico.psm
   delay_1ms             131   KeyPadPico.psm
   wait_1ms              133   KeyPadPico.psm
 * delay_50us            13B   KeyPadPico.psm
   wait_50us             13C   KeyPadPico.psm
   delay_1us             140   KeyPadPico.psm
   wait_1us              141   KeyPadPico.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             54
 STAR              -

 AND              11
 OR                1
 XOR               1

 ADD              12
 ADDCY             2
 SUB               6
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          33
 COMPARECY         -

 SL0               4
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               6
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT            11
 OUTPUT           28
 OUTPUTK           -

 STORE            17
 FETCH            17

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             28
 JUMP@             -
 CALL             47
 CALL@             -
 RETURN           30
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
