KCPSM6 Assembler log file for program 'Z:\home\gnaylor\Dropbox\N3SysGen\ToneDetectpicoBitDodgy.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 15 May 2017
Assembly timestamp: 20:00:58

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 211 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 530
Memory locations available: 3566


Assembly listing

 Addr Code                           Instruction

 000                                 ;Start working on detecting digital phase tones
 000                                 ;GV0B Tone detect working - getting AGC adjust to work thrugh DSP
 000                                 ;GV?? first tone detect
 000                                 CONSTANT delay_1us_constant, 06                        ; Value (13)19 or 12? decimal suitable for 50MHz clock – about 6 for 33MHz?
 000                                 CONSTANT m, 8'd                                        ; No. of iterations for cordic
 000                                 CONSTANT m_plus_1, 9'd                                 ; No. of iterations for cordic
 000                                 CONSTANT count_1000_lsb, E8                            ; lower 8-bits of 1000 count value
 000                                 CONSTANT count_1000_msb, 03                            ; upper 8-bits of 1000 count value
 000                                 CONSTANT half_pi_LSB, 00                               ;
 000                                 CONSTANT half_pi_MSB, 40                               ; 360 degrees = $10000
 000                                 CONSTANT phase_threshold, 30'd                         ;test for phase fairly constant
 000                                 CONSTANT count_value_to_trig, 9'd                      ;if low phase 12 succesive times, then this is significant! - try to increase sensitivity (was 10 - worth trying 6!)
 000                                 ;not sure about these (Aug2016)
 000                                 CONSTANT audioTest, 2'd                                ; Frequency 2=800Hz, 3=1200Hz, 4=1.6kHz 7=2.8kHz
 000                                 ;Frequency values for start and stop tones (decrease all by 1 29/1/17)
 000                                 CONSTANT StrtToneAInc, 9E
 000                                 CONSTANT StrtToneBInc, 68
 000                                 CONSTANT StopToneAInc, 59
 000                                 CONSTANT StopToneBInc, 77
 000                                 ;Digital tone increments here
 000                                 CONSTANT DigToneAinc, 61'd
 000                                 CONSTANT DigToneBinc, 82'd
 000                                 CONSTANT DigToneCinc, 213'd
 000                                 CONSTANT DigToneDinc, 234'd
 000                                 ; Registers
 000                                 NAMEREG sF, SampleCounter                              ;
 000                                 NAMEREG sE, TempScratchPointer
 000                                 NAMEREG sD, Mode                                       ;stores the operating mode: 0=idle, 1=Starting, 2=Receiving, 3=stopping, 4=TX
 000                                 NAMEREG sC, SampleTimer                                ;This counter does not stop!
 000                                 ; registers sA-sB are used for longish term storage...!
 000                                 ; sA used for cordic calcs
 000                                 ; Scratch pad
 000                                 ; registers 0-8 used for cordic table:
 000                                 ; reg 0=45degrees
 000                                 ; ..
 000                                 ; reg 7=0.44761degrees
 000                                 ; Input port
 000                                 CONSTANT AudioMSB, 0'd                                 ;Not used?
 000                                 CONSTANT AudioLSB, 1'd
 000                                 CONSTANT Strobe, 2'd                                   ;     bit0=8kHz square wave - Bit 1 is TX_High, bit 2 is ToneDetectOff
 000                                 CONSTANT DemodMSB, 3'd                                 ; Top significant byte of multiplier output
 000                                 CONSTANT DemodLSB, 4'd                                 ; (only 16 bits retained)
 000                                 CONSTANT TBD0, 5'd                                     ;
 000                                 CONSTANT TBD1, 6'd                                     ;
 000                                 CONSTANT TBD2, 7'd                                     ;TBdefined
 000                                 ; Output ports
 000                                 CONSTANT CmdToUser, 0'd
 000                                 CONSTANT LOMSB, 1'd
 000                                 CONSTANT BRAMaddrMSB, 2'd                              ;Not currently used (Feb '17)
 000                                 CONSTANT BRAMaddrLSB, 3'd
 000                                 ;also used:8,9,13,14,18,19,23,24 -  8 STRTA,13  STRTB ,18 STPA or 23  STPB, and 9 STRTA,14  STRTB ,19 STPA or 24  STPB
 000                                 ; 6,11,16,21 used for running Itone values and 7,12,17,22 for Qtone values
 000                                 CONSTANT StartAmpOut, 25'd                             ;goes to DSP pico to calibrate AGC
 000                                 CONSTANT State, 26'd                                   ;Bit 0 enables speaker, Bit 1 is green light
 000                                 ; Scratchpad registers
 000                                 ; 0-8 used for Cordic Table!
 000                                 ;Now various pointers to create start and stop tones
 000                                 CONSTANT AVEtoneAmp, 9'd                               ;Is this needed?
 000                                 CONSTANT STRTAinc, 10'd                                ;This is the base address loaded into s0 before calling 'TreatTone'
 000                                 CONSTANT STRTAptrMSB, 11'd                             ;16 bit value used to generate the LUT ptr - won't use these names, just documented for reference
 000                                 CONSTANT STRTAptrLSB, 12'd                             ;fine resolution
 000                                 CONSTANT STRTAAccuDemodIMSB, 13'd                      ;This is the 16 bit value returned from the mulitplier
 000                                 CONSTANT STRTAAccuDemodILSB, 14'd                      ;Will this byte be used?
 000                                 CONSTANT STRTAAccuDemodQMSB, 15'd                      ;This is th e 16 bit value of the demod component accumulated
 000                                 CONSTANT STRTAAccuDemodQLSB, 16'd
 000                                 CONSTANT STRTAcurrentPhase, 17'd                       ;8 bit value of the current phase determined by the cordic
 000                                 CONSTANT STRTApreviousPhase, 18'd                      ;8 bit value of the previous phase determined by the cordic
 000                                 CONSTANT STRTAcounter, 19'd                            ;counts number of cycles of constant phase..
 000                                 CONSTANT STRTBinc, 20'd
 000                                 ;etc
 000                                 CONSTANT STPAinc, 30'd
 000                                 CONSTANT STPBinc, 40'd
 000                                 ;then second space at +40 from above numbers for another 4 tones
 000                                 ;uses up to Scratch register 89'd
 000                                 CONSTANT DigitalAinc, 50'd
 000                                 CONSTANT DigitalBinc, 60'd
 000                                 CONSTANT DigitalCinc, 70'd
 000                                 CONSTANT DigitalDinc, 80'd
 000                                 CONSTANT SampleCounterMSB, 90'd                        ;So as to have a 16 bit sample counter
 000                                 CONSTANT StartAmpA, 91'd                               ;Store the amplitude of the startA tone continuosly and output when whoopie.
 000  010FF              cold_start: LOAD s0, FF[255'd]                                     ; phase for 45 degrees- actually a bit less!
 001  2F000                          STORE s0, 00
 002  01097                          LOAD s0, 97[151'd]                                     ; phase for 26.565 degrees
 003  2F001                          STORE s0, 01
 004  01050                          LOAD s0, 50[80'd]                                      ; phase for 14.036 degrees
 005  2F002                          STORE s0, 02
 006  01029                          LOAD s0, 29[41'd]                                      ; phase for 7.125 degrees
 007  2F003                          STORE s0, 03
 008  01014                          LOAD s0, 14[20'd]                                      ; phase for 3.576 degrees
 009  2F004                          STORE s0, 04
 00A  0100A                          LOAD s0, 0A[10'd]                                      ; phase for 1.79 degrees
 00B  2F005                          STORE s0, 05
 00C  01005                          LOAD s0, 05[5'd]                                       ; phase for 0.895 degrees
 00D  2F006                          STORE s0, 06
 00E  01003                          LOAD s0, 03[3'd]                                       ; phase for 0.448 degrees
 00F  2F007                          STORE s0, 07
 010  01001                          LOAD s0, 01[1'd]                                       ; phase for 0.224 degrees
 011  2F008                          STORE s0, 08
 012  0109E                          LOAD s0, 9E[StrtToneAInc]                              ; Tone increments to detect
 013  2F00A                          STORE s0, 0A[STRTAinc]
 014  01068                          LOAD s0, 68[StrtToneBInc]                              ; Tone increments to detect
 015  2F014                          STORE s0, 14[STRTBinc]
 016  01059                          LOAD s0, 59[StopToneAInc]                              ; Tone increments to detect
 017  2F01E                          STORE s0, 1E[STPAinc]
 018  01077                          LOAD s0, 77[StopToneBInc]                              ; Tone increments to detect
 019  2F028                          STORE s0, 28[STPBinc]
 01A  0103D                          LOAD s0, 3D[DigToneAinc]                               ; Tone increments to detect
 01B  2F032                          STORE s0, 32[DigitalAinc]
 01C  01052                          LOAD s0, 52[DigToneBinc]                               ; Tone increments to detect
 01D  2F03C                          STORE s0, 3C[DigitalBinc]
 01E  010D5                          LOAD s0, D5[DigToneCinc]                               ; Tone increments to detect
 01F  2F046                          STORE s0, 46[DigitalCinc]
 020  010EA                          LOAD s0, EA[DigToneDinc]                               ; Tone increments to detect
 021  2F050                          STORE s0, 50[DigitalDinc]
 022  2012C                          CALL 12C[SpeakerOn]                                    ;Start with speaker ON !!!!!!!!!!!!!!!!!!!!!!
 023                                 ;?But currently Speaker off is immediately being activated!
 023                                 ; Routine to look at lowest bit of Strobe to detect rising edge.
 023  09002           AwaitAudioVal: INPUT s0, 02[Strobe]
 024  03001                          AND s0, 01                                             ; look only at lowest bit
 025  1D001                          COMPARE s0, 01
 026  32023                          JUMP Z, 023[AwaitAudioVal]                             ; if 1 wait...
 027  09002               AwaitRise: INPUT s0, 02[Strobe]
 028  03001                          AND s0, 01                                             ; look only at lowest bit
 029  1D000                          COMPARE s0, 00
 02A  32027                          JUMP Z, 027[AwaitRise]                                 ; if 0 still, wait a bit more...
 02B                                 ;Demod signal is not stable till ~6 clock cycles after rising edge, so should maybe use falling edge??
 02B                                 ;so will be stable after ~3 instructions!
 02B  09002                          INPUT s0, 02[Strobe]                                   ;To check if in TX mode
 02C  03002                          AND s0, 02                                             ;look at bit 1
 02D  1D000                          COMPARE s0, 00
 02E  32031                          JUMP Z, 031[isReceiving]                               ;TX_High not set
 02F  01D04                          LOAD sD[Mode], 04                                      ;keep in TX mode
 030  32027                          JUMP Z, 027[AwaitRise]                                 ; keep looping
 031                    isReceiving: 
 031  11C01                          ADD sC[SampleTimer], 01                                ;Always increment timer in receive mode
 032  1DD04                          COMPARE sD[Mode], 04
 033  36035                          JUMP NZ, 035[StartDemod]                               ;has not just come out of TX
 034  01D00                          LOAD sD[Mode], 00                                      ;has just come out of TX, so reset mode to idle
 035                                 ;start treating StrtToneA
 035  0100A              StartDemod: LOAD s0, 0A[STRTAinc]                                  ;Note s0 is being used to point to the location of the values in scratch memory!
 036  01100                          LOAD s1, 00[00'd]                                      ;(counter value when mature)
 037  2004E                          CALL 04E[DemodulateTone]                               ;and checks if the accumulation has matured (from s1) and if so do cordic
 038                                 ;start treating StrtToneB
 038  01014                          LOAD s0, 14[STRTBinc]
 039  01110                          LOAD s1, 10[16'd]                                      ;(counter value when mature)
 03A  2004E                          CALL 04E[DemodulateTone]
 03B                                 ;start treating StpToneA
 03B  0101E                          LOAD s0, 1E[STPAinc]
 03C  01120                          LOAD s1, 20[32'd]                                      ;(counter value when mature)
 03D  2004E                          CALL 04E[DemodulateTone]
 03E                                 ;start treating StpToneB
 03E  01028                          LOAD s0, 28[STPBinc]
 03F  01130                          LOAD s1, 30[48'd]                                      ;(counter value when mature)
 040  2004E                          CALL 04E[DemodulateTone]
 041                                 ;add more tones to demodulate here for digital modes.
 041                                 ;start treating DigitalAinc
 041  01032                          LOAD s0, 32[DigitalAinc]
 042  01108                          LOAD s1, 08[8'd]                                       ;(counter value when mature)
 043  2004E                          CALL 04E[DemodulateTone]
 044                                 ;start treating DigitalBinc
 044  0103C                          LOAD s0, 3C[DigitalBinc]
 045  01118                          LOAD s1, 18[24'd]                                      ;(counter value when mature)
 046  2004E                          CALL 04E[DemodulateTone]
 047                                 ;start treating DigitalCinc
 047  01046                          LOAD s0, 46[DigitalCinc]
 048  01128                          LOAD s1, 28[40'd]                                      ;(counter value when mature)
 049  2004E                          CALL 04E[DemodulateTone]
 04A                                 ;start treating DigitalDinc
 04A  01050                          LOAD s0, 50[DigitalDinc]
 04B  01138                          LOAD s1, 38[56'd]                                      ;(counter value when mature)
 04C  2004E                          CALL 04E[DemodulateTone]
 04D  22023                          JUMP 023[AwaitAudioVal]
 04E                                 ; -------------This is end of main loop--------------------------------
 04E                                 ;Accumulate and demodulate routine
 04E                                 ;Enter with mature index in s1 (0-63 to stagger output to the UART) and the scratch base address to treat in s0 - this is the scratch
 04E                                 ;address for the toneinc
 04E  0A200          DemodulateTone: FETCH s2, (s0)                                         ;Tone increment (pointed to in scratch by s0, to increment through sine wave LUT)
 04F  01300                          LOAD s3, 00
 050                                 ;Need to right shift into s3 to scale correctly (as they are 4 times too big)
 050  1420E                          SR0 s2                                                 ;The increment is a positive value (0-255 when x4) so should be kept positive!
 051  14308                          SRA s3                                                 ;and carry containing lowest bit
 052  1420E                          SR0 s2
 053  14308                          SRA s3                                                 ;and carry containing lowest bit (doing this twice limits highest frequency to about 2kHz)
 054  11001                          ADD s0, 01
 055  0A400                          FETCH s4, (s0)                                         ;MSB of LUTptr
 056  11001                          ADD s0, 01
 057  0A500                          FETCH s5, (s0)                                         ;LSB of LUTptr
 058  10530                          ADD s5, s3                                             ;increment LUTptr
 059  12420                          ADDCY s4, s2                                           ;increment LUTptr
 05A  2E500                          STORE s5, (s0)                                         ;update LSB LUTptr
 05B  19001                          SUB s0, 01                                             ;decrement scratch pointer s0
 05C  2E400                          STORE s4, (s0)                                         ;update MSB LUTptr
 05D                                 ;           OUTPUT s5,LOLSB ;Send next sinewave address to LUT
 05D  2D401                          OUTPUT s4, 01[LOMSB]                                   ;Actually only need to output MSB  - use write of MSB to delay trigger latch of multiplier
 05E  20159                          CALL 159[waitabit]
 05F                                 ;NEED To wait for multiplication otherwise cordic will be out of step
 05F  09203                          INPUT s2, 03[DemodMSB]                                 ;input previous LO tone multiplied by the signal (for accumulation)
 060  09304                          INPUT s3, 04[DemodLSB]
 061                                 ;This value may be too big as it stands to accumulate so need to scale down so as not to overflow
 061                                 ;   SRX s2
 061                                 ;   SRA s3
 061                                 ;   SRX s2
 061                                 ;   SRA s3
 061                                 ;   SRX s2
 061                                 ;   SRA s3
 061  11002                          ADD s0, 02                                             ;move back up to scratch pointer location for MSB of I accumulating signal (of previous tone!)
 062  0A600                          FETCH s6, (s0)                                         ;MSB of Accumulated I demod value
 063                                 ;added this bit to get debug info again !!!!!!!!!!!!!!!!!!!!!!
 063  19001                          SUB s0, 01                                             ;to get an even value!
 064  14008                          SRA s0                                                 ;divide by 2 to get 6,11,16 or 21
 065  2C600                          OUTPUT s6, (s0)                                        ;Export intermediate I value accumulated
 066  14000                          SLA s0                                                 ;now get s0 back on track
 067  11001                          ADD s0, 01                                             ;add one to get back and another to advance to I LSB accu
 068                                 ;Would be ADD s0,01 instead of the above debug
 068  11001                          ADD s0, 01                                             ;add one to get back and another to advance to I LSB accu
 069  0A700                          FETCH s7, (s0)                                         ;LSB of Accumulated I demod value (base + 4)
 06A  10730                          ADD s7, s3                                             ;signed accumulate into Accumulated value
 06B  12620                          ADDCY s6, s2                                           ;accumulate into Accumulated value
 06C  200D4                          CALL 0D4[CheckNotTooBigI]                              ;Check s6(MSB),s7 not to big (ie bigger than 40)
 06D  2E700                          STORE s7, (s0)                                         ;update LSB Accumulated value
 06E  19001                          SUB s0, 01                                             ;decrement scratch pointer s0
 06F  2E600                          STORE s6, (s0)                                         ;update MSB Accumulated value
 070  00E00                          LOAD sE[TempScratchPointer], s0                        ;temporarily store pointer to MSB of accumulated I value
 071                                 ;s4 and s5 still have LUTptr to add pi/2
 071  11440                          ADD s4, 40[64'd]
 072                                 ;    OUTPUT s5,LOLSB ;Send next sinewave address to LUT -  already done!
 072  2D401                          OUTPUT s4, 01[LOMSB]                                   ;Actually only need to output MSB  - use write of MSB to delay trigger latch of multiplier
 073  20159                          CALL 159[waitabit]
 074                                 ;NEED To wait for multiplication otherwise cordic will be out of step
 074  09203                          INPUT s2, 03[DemodMSB]                                 ;input previous LO tone multiplied by the signal (for accumulation)
 075  09304                          INPUT s3, 04[DemodLSB]
 076                                 ;This value may be too big as it stands to accumulate so need to scale down so as not to overflow?
 076                                 ;   SRX s2
 076                                 ;   SRA s3
 076                                 ;   SRX s2
 076                                 ;   SRA s3
 076                                 ;   SRX s2
 076                                 ;   SRA s3
 076  11002                          ADD s0, 02                                             ;move back up to scratch pointer location for Q MSB of accumulating signal (of previous tone!)
 077  0A600                          FETCH s6, (s0)                                         ;MSB of Accumulated Q demod value
 078                                 ;added this bit to get debug info renable !!!!!!!!!!!!!!!!!!!!!!!!!!
 078  19001                          SUB s0, 01                                             ;to get an even value!
 079  14008                          SRA s0                                                 ;divide by 2 to get 7,12,17 or 22
 07A  2C600                          OUTPUT s6, (s0)                                        ;Export MSB of  Q value accumulated
 07B  14000                          SLA s0                                                 ;now get s0 back on track
 07C  11001                          ADD s0, 01                                             ;add one to get back and another to advance to I LSB accu
 07D                                 ;Would be ADD s0,01 instead of the above debug
 07D  11001                          ADD s0, 01                                             ;add one to get back and another to advance to I LSB accu
 07E  0A700                          FETCH s7, (s0)                                         ;LSB of Accumulated Q demod value (base + 6)
 07F  10730                          ADD s7, s3                                             ;signed accumulate into Accumulated value
 080  12620                          ADDCY s6, s2                                           ;accumulate into Accumulated value
 081  200E7                          CALL 0E7[CheckNotTooBigQ]                              ;Check s6(MSB),s7 not to0 big (ie bigger than 48)
 082  2E700                          STORE s7, (s0)                                         ;update LSB Accumulated value
 083  19001                          SUB s0, 01                                             ;decrement scratch pointer s0 (s0 now at base + 5)
 084  2E600                          STORE s6, (s0)                                         ;update MSB Accumulated value
 085  20087                          CALL 087[CheckMatureAndOutput]
 086  25000                          RETURN 
 087                                 ;Checks s1 is mature
 087  003C0    CheckMatureAndOutput: LOAD s3, sC[SampleTimer]                               ;Use the always incremented timer!
 088  0333F                          AND s3, 3F                                             ;mod 64
 089  1C310                          COMPARE s3, s1
 08A  3008C                          CALL Z, 08C[Matured]                                   ;OK to do cordic and output - this will happen every 2ms (or every 1ms with 8 tones being decoded)
 08B  25000                          RETURN 
 08C                                 ;Cordic takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
 08C                                 ; Useable range is for I and Q up to about +/-$3000
 08C                                 ;normally get I and Q values from scratch. Scratch pointer
 08C                                 ;need to use TempScratchPointer as s0 value which had pointed to the scratch area has been lost
 08C  0A1E0                 Matured: FETCH s1, (sE[TempScratchPointer])                     ;pointer at MSB of I accumulated
 08D  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to LSB of I accumulated
 08E  0A0E0                          FETCH s0, (sE[TempScratchPointer])
 08F  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to MSB of Q accumulated
 090  0A3E0                          FETCH s3, (sE[TempScratchPointer])
 091  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to LSB of Q accumulated
 092  0A2E0                          FETCH s2, (sE[TempScratchPointer])                     ;TempScratchPointer has now increased by 3
 093  2015D                          CALL 15D[cordic]
 094                                 ;now have amplitude and phase in s0/s1(MSB AMP)...s4,s5(MSB Phase) - need to calculate phase change and output the MSBs
 094                                 ;Use MSB amp in s1 - only interested in SartAmpA value - put in fixed scratch location if TempScratchPointer is +6,for this tone, ie is STRTAAccuDemodQLSB
 094  1DE10                          COMPARE sE[TempScratchPointer], 10[STRTAAccuDemodQLSB] ; are we treating StartToneA
 095  36097                          JUMP NZ, 097[CarryOn]                                  ;if not do not store in scratch
 096  2F15B                          STORE s1, 5B[StartAmpA]                                ;Save the current amplitude of the A tone (as we happen to be doing start A tone)
 097                                 ;have phase in s5
 097  11E02                 CarryOn: ADD sE[TempScratchPointer], 02
 098  0A4E0                          FETCH s4, (sE[TempScratchPointer])                     ;get last phase (inc+8)
 099  2E5E0                          STORE s5, (sE[TempScratchPointer])                     ;update current phase
 09A  19E01                          SUB sE[TempScratchPointer], 01
 09B  2E4E0                          STORE s4, (sE[TempScratchPointer])                     ;update previous phase (inc+7)
 09C  19E01                          SUB sE[TempScratchPointer], 01
 09D                                 ;Send to ARM
 09D  20154                          CALL 154[StreamPhase]                                  ; This does not affect s5! - but does kill s0
 09E  00510                          LOAD s5, s1
 09F  20150                          CALL 150[StreamAmp]
 0A0                                 ;Need to reset accumulators to zero! (Tempscratch (originally inc+3) is now inc+6 but need to reseet addresses of original! TempScratchPointer, TempScratchPointer+1,+2 +3)
 0A0                                 ;This is executed every 2ms if 4 tones are treated as executed 4 times per cycle - if more tones added, this will run more frequently and so counter timeouts will need adjusting!
 0A0  000E0                          LOAD s0, sE[TempScratchPointer]
 0A1  01100                          LOAD s1, 00
 0A2  2E100                          STORE s1, (s0)
 0A3  19001                          SUB s0, 01
 0A4  2E100                          STORE s1, (s0)
 0A5  19001                          SUB s0, 01
 0A6  2E100                          STORE s1, (s0)
 0A7  19001                          SUB s0, 01
 0A8  2E100                          STORE s1, (s0)
 0A9  20116                          CALL 116[CheckforTimeOuts]
 0AA  1DD00                          COMPARE sD[Mode], 00
 0AB  340CE                          CALL NZ, 0CE[IncrementCounter]                         ;Unless Idle!
 0AC                                 ;This last part to be corrected to check magnitude of phase shift
 0AC                                 ;OK ready to do now using software multiply
 0AC  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to previous phase (inc+7)
 0AD  0A2E0                          FETCH s2, (sE[TempScratchPointer])                     ;s2 now has msb of previous phase
 0AE  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to current phase (inc+8)
 0AF  0A3E0                          FETCH s3, (sE[TempScratchPointer])                     ;s3 now has msb of current phase
 0B0  18230                          SUB s2, s3                                             ;delta phase (signed)
 0B1  201AA                          CALL 1AA[absval]                                       ;gets absolute value of s2 (abs phase shift)
 0B2  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to counter (inc+9)
 0B3  0A1E0                          FETCH s1, (sE[TempScratchPointer])                     ;s1 has the counter
 0B4  000E0                          LOAD s0, sE[TempScratchPointer]
 0B5  19005                          SUB s0, 05                                             ;to get inc+4
 0B6  14008                          SRA s0                                                 ;divide by 2 to get 7,12,17 or 22
 0B7                                 ;
 0B7                                 ;Debug output Counter value and Phase difference
 0B7                                 ;   OUTPUT s1,(s0) ;Export Counter value come out on 'IQ stoptones', when value '5' is selected
 0B7                                 ;   SUB s0,01 ;to get 6,11,16,21 to align with 'IQStarttones' read by selecting '4' value
 0B7                                 ;   OUTPUT s2,(s0) ;Export phase difference value come out on 'IQ starttones', when value '4' is selected
 0B7  1D21E                          COMPARE s2, 1E[phase_threshold]                        ;is it less than threshold, then set carry
 0B8  3E0C9                          JUMP NC, 0C9[dropcounter]                              ; if failed then drop the counter and return
 0B9  11101                          ADD s1, 01                                             ;otherwise is small phase shift so advance counter
 0BA  2E1E0                          STORE s1, (sE[TempScratchPointer])                     ;now save the counter
 0BB  1D109                          COMPARE s1, 09[count_value_to_trig]                    ;s1 has phase constant counter, carry not set if count is high enough.
 0BC  3C0BE                          CALL NC, 0BE[Whoopie]                                  ;seem to have a tone here!
 0BD  25000                          RETURN 
 0BE                                 ;Ultimately will use TempScratchPointer to work out which tone was detected
 0BE                                 ;need to reset counter to Zero!!
 0BE  01000                 Whoopie: LOAD s0, 00
 0BF  2E0E0                          STORE s0, (sE[TempScratchPointer])                     ;reset counter to zero
 0C0  1DE13                          COMPARE sE[TempScratchPointer], 13[19'd]               ;if start tone A counter
 0C1  300FA                          CALL Z, 0FA[isStrtToneA]
 0C2  1DE1D                          COMPARE sE[TempScratchPointer], 1D[29'd]               ;if start tone B counter
 0C3  30102                          CALL Z, 102[isStrtToneB]
 0C4  1DE27                          COMPARE sE[TempScratchPointer], 27[39'd]               ;if start tone A counter
 0C5  30109                          CALL Z, 109[isStopToneA]
 0C6  1DE31                          COMPARE sE[TempScratchPointer], 31[49'd]               ;if start tone A counter
 0C7  3010F                          CALL Z, 10F[isStopToneB]
 0C8  25000                          RETURN 
 0C9  1D102             dropcounter: COMPARE s1, 02
 0CA  39000                          RETURN C                                               ;return if counter 1 or zero
 0CB  19102                          SUB s1, 02                                             ;drop counter by 2
 0CC  2E1E0                          STORE s1, (sE[TempScratchPointer])                     ;now set counter to new value
 0CD  25000                          RETURN 
 0CE                                 ;Update sample counter (increments every 2ms if treating all 4 tones simultaneously, would be 1ms if treating 8 tones)
 0CE                                 ;This only advances in modes 1,2 and 3
 0CE  0B05A        IncrementCounter: FETCH s0, 5A[SampleCounterMSB]
 0CF  11F01                          ADD sF[SampleCounter], 01                              ;increment counter
 0D0  13000                          ADDCY s0, 00
 0D1  2F05A                          STORE s0, 5A[SampleCounterMSB]                         ;increment MSB on rollover
 0D2                                 ;Check if any of the time outs are passed
 0D2  20116                          CALL 116[CheckforTimeOuts]
 0D3  25000                          RETURN 
 0D4                                 ;This is to drop the value of the accumulated I and Q values so that don't end up getting too big for the Cordic
 0D4  00260         CheckNotTooBigI: LOAD s2, s6
 0D5  00360                          LOAD s3, s6                                            ;also have to save s6 as absval kills s6
 0D6  201AA                          CALL 1AA[absval]                                       ;return absval in s2
 0D7  00630                          LOAD s6, s3                                            ;put value back in s6
 0D8  1D230                          COMPARE s2, 30                                         ;is absolute value bigger than or equal 30 (then NC)
 0D9  39000                          RETURN C                                               ;if not return
 0DA  1460A                          SRX s6
 0DB  14708                          SRA s7                                                 ;half value in s6/s7
 0DC                                 ;now need to drop value in accummulated Q
 0DC  11002                          ADD s0, 02                                             ;increase scratch pointer to Q accumulation values
 0DD  0A300                          FETCH s3, (s0)                                         ;LSB of Q accumulated
 0DE  19001                          SUB s0, 01
 0DF  0A200                          FETCH s2, (s0)                                         ;MSB of Q accumulated
 0E0  1420A                          SRX s2
 0E1  14308                          SRA s3                                                 ;half Q accumulated value
 0E2  2E200                          STORE s2, (s0)
 0E3  11001                          ADD s0, 01
 0E4  2E300                          STORE s3, (s0)
 0E5  19002                          SUB s0, 02                                             ;Get s0 back to its original value
 0E6  25000                          RETURN 
 0E7  00260         CheckNotTooBigQ: LOAD s2, s6
 0E8  00360                          LOAD s3, s6                                            ;also have to save s6 as absval kills s6
 0E9  201AA                          CALL 1AA[absval]                                       ;return absval in s2
 0EA  00630                          LOAD s6, s3                                            ;put value back in s6
 0EB  1D230                          COMPARE s2, 30                                         ;is absolute value bigger than or equal 30 (then NC)
 0EC  39000                          RETURN C                                               ;if not return
 0ED  1460A                          SRX s6
 0EE  14708                          SRA s7                                                 ;half value in s6/s7
 0EF                                 ;now need to drop value in accummulated Q
 0EF  19002                          SUB s0, 02                                             ;reduce scratch pointer to I accumulation values
 0F0  0A300                          FETCH s3, (s0)                                         ;LSB of I accumulated
 0F1  19001                          SUB s0, 01
 0F2  0A200                          FETCH s2, (s0)                                         ;MSB of I accumulated
 0F3  1420A                          SRX s2
 0F4  14308                          SRA s3                                                 ;half I accumulated value
 0F5  2E200                          STORE s2, (s0)
 0F6  11001                          ADD s0, 01
 0F7  2E300                          STORE s3, (s0)
 0F8  11002                          ADD s0, 02                                             ;Get s0 back to its original value
 0F9  25000                          RETURN 
 0FA                                 ;Treat different mode cases
 0FA                                 ;Mode 0 Idle
 0FA                                 ;Mode 1 Starting  (Start tone A detected)
 0FA                                 ;Mode 2 Recieving Voice
 0FA                                 ;Mode 3 Stopping
 0FA                                 ;Mode 4 TX
 0FA  1DD00             isStrtToneA: COMPARE sD[Mode], 00                                   ;Check if currently idle
 0FB  35000                          RETURN NZ                                              ;Don't do anything if not currently idle
 0FC  0B05B                          FETCH s0, 5B[StartAmpA]                                ;Get thepreviously stored amplitude
 0FD  2D019                          OUTPUT s0, 19[StartAmpOut]                             ;and output to be read by the DSP Pico
 0FE  01D01                          LOAD sD[Mode], 01                                      ;Move in to starting mode
 0FF  01F00                          LOAD sF[SampleCounter], 00
 100  2FF5A                          STORE sF[SampleCounter], 5A[SampleCounterMSB]          ;Reset counter and allow about 160ms to receive tone B
 101  25000                          RETURN 
 102  1DD01             isStrtToneB: COMPARE sD[Mode], 01                                   ;Check if in starting mode
 103  35000                          RETURN NZ                                              ;Don't do anything if not starting
 104  01D02                          LOAD sD[Mode], 02                                      ;go ahead in to receive
 105  2012C                          CALL 12C[SpeakerOn]                                    ;Turn on speaker
 106  01F00                          LOAD sF[SampleCounter], 00
 107  2FF5A                          STORE sF[SampleCounter], 5A[SampleCounterMSB]          ;Reset counter and allow about 160ms to receive tone B
 108  25000                          RETURN 
 109  1DD02             isStopToneA: COMPARE sD[Mode], 02                                   ;Check if in RX mode
 10A  35000                          RETURN NZ                                              ;Don't do anything if not in RX
 10B  01D03                          LOAD sD[Mode], 03                                      ;Move in to stopping mode
 10C  01F00                          LOAD sF[SampleCounter], 00
 10D  2FF5A                          STORE sF[SampleCounter], 5A[SampleCounterMSB]          ;Reset counter and allow about 512ms to receive tone B
 10E  25000                          RETURN 
 10F  1DD03             isStopToneB: COMPARE sD[Mode], 03                                   ;Check if in stopping mode
 110  35000                          RETURN NZ                                              ;Don't do anything if not stopping
 111  01D00                          LOAD sD[Mode], 00                                      ;go back to idle
 112  2012F                          CALL 12F[SpeakerOff]                                   ;Turn speaker off
 113  01F00                          LOAD sF[SampleCounter], 00
 114  2FF5A                          STORE sF[SampleCounter], 5A[SampleCounterMSB]          ;Reset counter (not really needed, but just for tidiness)
 115  25000                          RETURN 
 116                                 ;timeout values in units of 2ms - this will drop to 1ms if more tones added, so timeout values will need re-adjusting
 116  1DD01        CheckforTimeOuts: COMPARE sD[Mode], 01
 117  3011D                          CALL Z, 11D[checkStarttoneAtimeout]
 118  1DD02                          COMPARE sD[Mode], 02
 119  30121                          CALL Z, 121[checkRXtimeout]
 11A  1DD03                          COMPARE sD[Mode], 03
 11B  30127                          CALL Z, 127[checkStoptoneAtimeout]
 11C  25000                          RETURN 
 11D  1DF50  checkStarttoneAtimeout: COMPARE sF[SampleCounter], 50[80'd]                    ;This will need to be 160'd with 8 tones
 11E  39000                          RETURN C                                               ;Counter<80 (160ms) so OK
 11F  01D00                          LOAD sD[Mode], 00                                      ;Set mode back to idle - tone B was not received in time
 120  25000                          RETURN 
 121  0B05A          checkRXtimeout: FETCH s0, 5A[SampleCounterMSB]                         ;Get counter
 122  1D03D                          COMPARE s0, 3D[61'd]                                   ;-about 30 secs - COmpare with 122'd if using 8 tones
 123  39000                          RETURN C                                               ;Can carry on listening (not timed out)
 124  01D00                          LOAD sD[Mode], 00                                      ;Set mode back to idle - seems to have been transmitting too long
 125  2012F                          CALL 12F[SpeakerOff]                                   ;on stop speaker again
 126  25000                          RETURN 
 127  0B05A   checkStoptoneAtimeout: FETCH s0, 5A[SampleCounterMSB]                         ;Get counter
 128  1D001                          COMPARE s0, 01                                         ;-about 512ms - need to compare with 02 if using 8 tones
 129  39000                          RETURN C                                               ;Counter MSB still 0 so within 512ms of receiving StoptoneB
 12A  01D02                          LOAD sD[Mode], 02                                      ;Set mode back to RX - tone B was not received in time so must have been a chance tone
 12B  25000                          RETURN 
 12C  01001               SpeakerOn: LOAD s0, 01
 12D  2D01A                          OUTPUT s0, 1A[State]
 12E  25000                          RETURN 
 12F  01002              SpeakerOff: LOAD s0, 02                                            ;Turns Green LED off (bit 1)? and stops speaker (currently driven directly off not speaker enable)
 130  2D01A                          OUTPUT s0, 1A[State]
 131  01D00                          LOAD sD[Mode], 00                                      ;return to idle state
 132  25000                          RETURN 
 133                                 ;Does 16 bit signed accumulation of 8 bit signed value in s1 into s4/s5 which are recoverred from scratch pad pointed to by s2 (loading here the offset to the actual tone
 133                                 ;dependent on how many times round the loop we are)
 133  10260            DoAccumulate: ADD s2, s6
 134  0A420                          FETCH s4, (s2)                                         ;Now Get AveSToneLSB_Is in s4 etc...
 135  19201                          SUB s2, 01                                             ;step back to MSB
 136  0A520                          FETCH s5, (s2)                                         ;Get AveSToneMSB_Is in s5
 137  013FF                          LOAD s3, FF                                            ;Assume s1 is negative and use s3 for sign extension
 138  1D180                          COMPARE s1, 80[128'd]                                  ;if s1 is 128 or bigger, then it is negative (carry not set)
 139  3E13B                          JUMP NC, 13B[negaccum]
 13A  01300                          LOAD s3, 00                                            ;sign extend with zeros
 13B  10410                negaccum: ADD s4, s1                                             ;Accumulate into averageLsB
 13C  12530                          ADDCY s5, s3                                           ;do carry to add into upper byte (keeping carry from previous add!!)
 13D  00050                          LOAD s0, s5
 13E  1400A                          SRX s0
 13F  1400A                          SRX s0                                                 ;reduce value to subtract by factor 4 to increase integration time constant and gain.
 140  13000                          ADDCY s0, 00                                           ;round up if necessary
 141  18400                          SUB s4, s0
 142  013FF                          LOAD s3, FF                                            ;Assume s5 is negative and use s3 for sign extension
 143  1D580                          COMPARE s5, 80[128'd]                                  ;is this a negative number?
 144  3E146                          JUMP NC, 146[negdecrmnt]
 145  01300                          LOAD s3, 00                                            ;do this if s5 is positive (sign extension)
 146  18400              negdecrmnt: SUB s4, s0
 147  1A530                          SUBCY s5, s3                                           ;subtract 1/256
 148  2E520                          STORE s5, (s2)
 149  11201                          ADD s2, 01                                             ;move down to LSB again
 14A  2E420                          STORE s4, (s2)                                         ;update scratchpad values
 14B  25000                          RETURN 
 14C                                 ; This TBD, should output 16 bit value, that goes through a sinewave LUT and multiplies by the signal and recover
 14C  2D101          LUTandMultiply: OUTPUT s1, 01[LOMSB]
 14D  09903                          INPUT s9, 03[DemodMSB]                                 ;actually gets previously latched multiply corresponding to previous tone!
 14E  09804                          INPUT s8, 04[DemodLSB]
 14F  25000                          RETURN 
 150  000E0               StreamAmp: LOAD s0, sE[TempScratchPointer]                        ;possible values are 16,26,36 and 46
 151  1400E                          SR0 s0                                                 ;Divide by 0 to get 8 STRTA,13  STRTB ,18 STPA or 23  STPB
 152  2C500                          OUTPUT s5, (s0)                                        ;direct amplitude MSB to the appropriate port
 153  25000                          RETURN 
 154  000E0             StreamPhase: LOAD s0, sE[TempScratchPointer]
 155  1400E                          SR0 s0
 156  11001                          ADD s0, 01                                             ;Offset to output phase values get 9 STRTA,14  STRTB ,19 STPA or 24  STPB
 157  2C500                          OUTPUT s5, (s0)                                        ;direct phase MSB to the appropriate port
 158  25000                          RETURN 
 159  00220                waitabit: LOAD s2, s2
 15A  00220                          LOAD s2, s2
 15B  00220                          LOAD s2, s2                                            ;is this long enough?
 15C  25000                          RETURN 
 15D                                 ; CORDIC  Takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
 15D                                 ; Useable range is for I and Q up to about +/-$3000
 15D  01400                  cordic: LOAD s4, 00
 15E  01500                          LOAD s5, 00
 15F  1D180                          COMPARE s1, 80[128'd]
 160  3C194                          CALL NC, 194[rotate90]                                 ; if I negative then need to bring back into RH 2 quadrants.
 161                                 ; now enter loop
 161  01800                          LOAD s8, 00                                            ; counter of times to iterate.
 162  00710              cordicloop: LOAD s7, s1                                            ; temporary store for I
 163  00600                          LOAD s6, s0                                            ; temp store
 164  1D380                          COMPARE s3, 80[128'd]                                  ; is Q negative?
 165  3E174                          JUMP NC, 174[posrotate]                                ; if negative rotate positive
 166  00A20               negrotate: LOAD sA, s2
 167  00B30                          LOAD sB, s3                                            ; put Q into working registers
 168  2018D                          CALL 18D[shift]                                        ; shift Q by the amount in s8
 169  100A0                          ADD s0, sA                                             ; add shifted Q to I
 16A  121B0                          ADDCY s1, sB
 16B  00A60                          LOAD sA, s6                                            ; prepare working registers (sA,sB) with original value of I
 16C  00B70                          LOAD sB, s7
 16D  2018D                          CALL 18D[shift]
 16E  182A0                          SUB s2, sA
 16F  1A3B0                          SUBCY s3, sB
 170  20185                          CALL 185[GetPhaseIncrement]
 171  184A0                          SUB s4, sA
 172  1A5B0                          SUBCY s5, sB
 173  22181                          JUMP 181[testcordicend]
 174  00A20               posrotate: LOAD sA, s2
 175  00B30                          LOAD sB, s3                                            ; put Q into working registers
 176  2018D                          CALL 18D[shift]                                        ; shift Q by the amount in s8
 177  180A0                          SUB s0, sA                                             ; add shifted Q to I
 178  1A1B0                          SUBCY s1, sB
 179  00A60                          LOAD sA, s6                                            ; prepare working registers with original value of I
 17A  00B70                          LOAD sB, s7
 17B  2018D                          CALL 18D[shift]
 17C  102A0                          ADD s2, sA
 17D  123B0                          ADDCY s3, sB
 17E  20185                          CALL 185[GetPhaseIncrement]
 17F  104A0                          ADD s4, sA
 180  125B0                          ADDCY s5, sB
 181  11801           testcordicend: ADD s8, 01
 182  1D809                          COMPARE s8, 09[m_plus_1]                               ;m + 1
 183  3A162                          JUMP C, 162[cordicloop]
 184  25000                          RETURN 
 185                                 ; routine to lookup from the cordic look up table (scratchpad), the phase increment - stored as 8 bits at the location pointed to be s8, returned as 16 bits in sA and sB
 185                                 ; sB is MSB
 185  0AB80       GetPhaseIncrement: FETCH sB, (s8)
 186  14B0E                          SR0 sB
 187  14A08                          SRA sA
 188  14B0E                          SR0 sB
 189  14A08                          SRA sA
 18A  14B0E                          SR0 sB
 18B  14A08                          SRA sA                                                 ; This multiplies the 8 bit stored value by 32 so that max scratchpad value 255->255*32 equivalent to 44.82degrees
 18C  25000                          RETURN 
 18D  00980                   shift: LOAD s9, s8
 18E  1D900               shiftloop: COMPARE s9, 00
 18F  31000                          RETURN Z
 190  19901                          SUB s9, 01
 191  14B0A                          SRX sB
 192  14A08                          SRA sA
 193  2218E                          JUMP 18E[shiftloop]
 194  00710                rotate90: LOAD s7, s1                                            ; temporary store for I
 195  00600                          LOAD s6, s0                                            ; temp store
 196  1D380                          COMPARE s3, 80[128'd]                                  ; is Q negative?
 197  3E1A1                          JUMP NC, 1A1[add90]                                    ; if negative add 90
 198  00130                   sub90: LOAD s1, s3
 199  00020                          LOAD s0, s2                                            ; I=Q
 19A  01200                          LOAD s2, 00
 19B  01300                          LOAD s3, 00
 19C  18260                          SUB s2, s6
 19D  1A370                          SUBCY s3, s7                                           ; Q=-I
 19E  19400                          SUB s4, 00[half_pi_LSB]
 19F  1B540                          SUBCY s5, 40[half_pi_MSB]
 1A0  25000                          RETURN 
 1A1  01100                   add90: LOAD s1, 00
 1A2  01000                          LOAD s0, 00
 1A3  18020                          SUB s0, s2
 1A4  1A130                          SUBCY s1, s3                                           ; I=-Q
 1A5  00260                          LOAD s2, s6
 1A6  00370                          LOAD s3, s7                                            ; Q=I
 1A7  01400                          LOAD s4, 00[half_pi_LSB]
 1A8  01540                          LOAD s5, 40[half_pi_MSB]
 1A9  25000                          RETURN 
 1AA                                 ;takes s2 and returns in s2 the absolute value of s2 (uses s6)
 1AA  1D280                  absval: COMPARE s2, 80[128'd]
 1AB  3C1AD                          CALL NC, 1AD[makeposval]
 1AC  25000                          RETURN 
 1AD                                 ; Turn negative value in s2 into a positive one (well will actualy make a positive value negative as well).
 1AD  01600              makeposval: LOAD s6, 00
 1AE  18620                          SUB s6, s2
 1AF  00260                          LOAD s2, s6
 1B0  25000                          RETURN 
 1B1                                 ; Takes value in s5 and converts to 2 ascii codes which are sent to the user picoblaze.
 1B1  201CF             Export2User: CALL 1CF[Byte2Chars]
 1B2  2D600                          OUTPUT s6, 00[CmdToUser]
 1B3  2D700                          OUTPUT s7, 00[CmdToUser]
 1B4  01614                          LOAD s6, 14[20'd]                                      ; terminate with space character
 1B5  2D600                          OUTPUT s6, 00[CmdToUser]
 1B6  25000                          RETURN 
 1B7  0160D                 AddCRLF: LOAD s6, 0D[13'd]                                      ; terminate with CR
 1B8  2D600                          OUTPUT s6, 00[CmdToUser]
 1B9  0160A                          LOAD s6, 0A[10'd]                                      ; and with LF
 1BA  2D600                          OUTPUT s6, 00[CmdToUser]
 1BB  25000                          RETURN 
 1BC                                 ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 1BC  00860              Chars2Byte: LOAD s8, s6
 1BD  201C7                          CALL 1C7[Get4bits]
 1BE  00580                          LOAD s5, s8
 1BF  14506                          SL0 s5
 1C0  14506                          SL0 s5
 1C1  14506                          SL0 s5
 1C2  14506                          SL0 s5                                                 ; put these 4 bits to MSBs
 1C3  00870                          LOAD s8, s7
 1C4  201C7                          CALL 1C7[Get4bits]
 1C5  10580                          ADD s5, s8
 1C6  25000                          RETURN 
 1C7                                 ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 1C7  1D83C                Get4bits: COMPARE s8, 3C[60'd]                                   ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 1C8  3A1CC                          JUMP C, 1CC[char0_9]
 1C9  19837                          SUB s8, 37[55'd]                                       ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 1CA  0380F                          AND s8, 0F                                             ; make sure only return 4 bits
 1CB  25000                          RETURN 
 1CC  19830                 char0_9: SUB s8, 30[48'd]
 1CD  0380F                          AND s8, 0F                                             ; make sure only return 4 bits
 1CE  25000                          RETURN 
 1CF                                 ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 1CF  00850              Byte2Chars: LOAD s8, s5                                            ; assumes 8 bit data is in s5
 1D0  1450E                          SR0 s5
 1D1  1450E                          SR0 s5
 1D2  1450E                          SR0 s5
 1D3  1450E                          SR0 s5                                                 ; get first hex character
 1D4  201DB                          CALL 1DB[GetChar]
 1D5  00650                          LOAD s6, s5                                            ; first ascii char
 1D6  00580                          LOAD s5, s8
 1D7  0350F                          AND s5, 0F
 1D8  201DB                          CALL 1DB[GetChar]                                      ; send to LCD or UART
 1D9  00750                          LOAD s7, s5                                            ; second ascii char
 1DA  25000                          RETURN 
 1DB                                 ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 1DB  1950A                 GetChar: SUB s5, 0A[10'd]                                       ; Test if s5 greater than 9
 1DC  3A1DF                          JUMP C, 1DF[is_0_9]                                    ; Hex character is 0_9
 1DD  11541                          ADD s5, 41[65'd]                                       ; offset for Ascii code 'A'
 1DE  25000                          RETURN 
 1DF  1150A                  is_0_9: ADD s5, 0A[10'd]                                       ; return to range 0-9
 1E0  11530                          ADD s5, 30[48'd]                                       ; offset to Ascii code for '0'
 1E1  25000                          RETURN 
 1E2                                 ; Registers used s0, s1, s2, s3, s4 and s5.
 1E2                                 ;
 1E2  01500                delay_1s: LOAD s5, 00                                            ; clear cycle counter
 1E3  01400                          LOAD s4, 00
 1E4  201F5                 wait_1s: CALL 1F5[delay_1ms]
 1E5  11401                          ADD s4, 01                                             ; increment cycle counter
 1E6  13500                          ADDCY s5, 00
 1E7  1D4E8                          COMPARE s4, E8[count_1000_lsb]                         ; test for 1000ms
 1E8  361E4                          JUMP NZ, 1E4[wait_1s]
 1E9  1D503                          COMPARE s5, 03[count_1000_msb]
 1EA  361E4                          JUMP NZ, 1E4[wait_1s]
 1EB  25000                          RETURN 
 1EC                                 ;
 1EC                                 ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 1EC                                 ;
 1EC                                 ;
 1EC                                 ; Registers used s0, s1, s2, s3 and s4.
 1EC                                 ;
 1EC  201F0             delay_300ms: CALL 1F0[delay_100ms]
 1ED  201F0             delay_200ms: CALL 1F0[delay_100ms]
 1EE  201F0                          CALL 1F0[delay_100ms]
 1EF  25000                          RETURN 
 1F0                                 ;
 1F0                                 ; Delay of approximately 100ms used for switch debounce
 1F0                                 ;
 1F0                                 ; Registers used s0, s1, s2, s3 and s4.
 1F0                                 ;
 1F0  01464             delay_100ms: LOAD s4, 64                                            ; repeat 1ms delay 100 times
 1F1  201F5              wait_100ms: CALL 1F5[delay_1ms]
 1F2  19401                          SUB s4, 01
 1F3  361F1                          JUMP NZ, 1F1[wait_100ms]
 1F4  25000                          RETURN 
 1F5                                 ;
 1F5                                 ; Delay of approximately 1ms required by LCD display
 1F5                                 ;
 1F5                                 ; Registers used s0, s1, s2 and s3.
 1F5                                 ;
 1F5  01300               delay_1ms: LOAD s3, 00                                            ; clear cycle counter
 1F6  01200                          LOAD s2, 00
 1F7  20204                wait_1ms: CALL 204[delay_1us]
 1F8  11201                          ADD s2, 01                                             ; increment cycle counter
 1F9  13300                          ADDCY s3, 00
 1FA  1D2E8                          COMPARE s2, E8[count_1000_lsb]                         ; test for 1000us
 1FB  361F7                          JUMP NZ, 1F7[wait_1ms]
 1FC  1D303                          COMPARE s3, 03[count_1000_msb]
 1FD  361F7                          JUMP NZ, 1F7[wait_1ms]
 1FE  25000                          RETURN 
 1FF                                 ;
 1FF                                 ; Delay of approximately 50us required by LCD display
 1FF                                 ;
 1FF                                 ; Registers used s0 and s1.
 1FF                                 ;
 1FF  01132              delay_50us: LOAD s1, 32[50'd]                                      ; repeat 1us delay 50 times
 200  20204               wait_50us: CALL 204[delay_1us]
 201  19101                          SUB s1, 01
 202  36200                          JUMP NZ, 200[wait_50us]
 203  25000                          RETURN 
 204                                 ; Delay of approximately 1us used to provide timing reference for
 204                                 ; LCD operations. This must be adjusted to reflect the clock
 204                                 ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 204                                 ;
 204                                 ; The software delay loop is formed using register s0. This register
 204                                 ; must be loaded with an integer value close to the result of....
 204                                 ;
 204                                 ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 204                                 ;
 204                                 ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 204                                 ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 204                                 ; operation will become lower than the 100KHz target intended.
 204                                 ;
 204                                 ; Register used s0.
 204                                 ;
 204  01006               delay_1us: LOAD s0, 06[delay_1us_constant]                        ; delay value of 12 decimal for a 50MHz clock
 205  19001                wait_1us: SUB s0, 01
 206  36205                          JUMP NZ, 205[wait_1us]
 207  25000                          RETURN 
 208                                 ;
 208                                 ;
 208                                 ; Multiplier Routine (8-bit x 8-bit = 16-bit product) - Ken Chapman
 208                                 ; ==================================================
 208                                 ; Shift and add algorithm
 208                                 ;
 208                       mult_8x8: 
 208                                 NAMEREG s0, multiplicand                               ; preserved
 208                                 NAMEREG s1, multiplier                                 ; preserved
 208                                 NAMEREG s2, bit_mask                                   ; modified
 208                                 NAMEREG s3, result_msb                                 ; most-significant byte (MSB) of result,
 208                                 ; modified
 208                                 NAMEREG s4, result_lsb                                 ; least-significant byte (LSB) of result,
 208                                 ; modified
 208                                 ;
 208  01201                          LOAD s2[bit_mask], 01                                  ; start with least-significant bit (lsb)
 209  01300                          LOAD s3[result_msb], 00                                ; clear product MSB
 20A  01400                          LOAD s4[result_lsb], 00                                ; clear product LSB (not required)
 20B                                 ;
 20B                                 ; loop through all bits in multiplier
 20B  0C120               mult_loop: TEST s1[multiplier], s2[bit_mask]                      ; check if bit is set
 20C  3220E                          JUMP Z, 20E[no_add]                                    ; if bit is not set, skip addition
 20D                                 ;
 20D  10300                          ADD s3[result_msb], s0[multiplicand]                   ; addition only occurs in MSB
 20E                                 ;
 20E  14308                  no_add: SRA s3[result_msb]                                     ; shift MSB right, CARRY into bit 7,
 20F                                 ; lsb into CARRY
 20F  14408                          SRA s4[result_lsb]                                     ; shift LSB right,
 210                                 ; lsb from result_msb into bit 7
 210                                 ;
 210  14206                          SL0 s2[bit_mask]                                       ; shift bit_mask left to examine
 211                                 ; next bit in multiplier
 211                                 ;
 211  3620B                          JUMP NZ, 20B[mult_loop]                                ; if all bit examined, then bit_mask = 0


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\home\gnaylor\Dropbox\N3SysGen\ToneDetectpicoBitDodgy.psm



List of defined constants

 CONSTANT name       Value        Source PSM File

 timestamp_hours     20'd         
 timestamp_minutes   00'd         
 timestamp_seconds   58'd         
 datestamp_year      17'd         
 datestamp_month     5'd          
 datestamp_day       15'd         
 NUL                 00           
 BEL                 07           
 BS                  08           
 HT                  09           
 LF                  0A           
 VT                  0B           
 CR                  0D           
 ESC                 1B           
 DEL                 7F           
 DCS                 90           
 ST                  9C           
 delay_1us_constant  06           ToneDetectpicoBitDodgy.psm
 m                   8'd          ToneDetectpicoBitDodgy.psm
 m_plus_1            9'd          ToneDetectpicoBitDodgy.psm
 count_1000_lsb      E8           ToneDetectpicoBitDodgy.psm
 count_1000_msb      03           ToneDetectpicoBitDodgy.psm
 half_pi_LSB         00           ToneDetectpicoBitDodgy.psm
 half_pi_MSB         40           ToneDetectpicoBitDodgy.psm
 phase_threshold     30'd         ToneDetectpicoBitDodgy.psm
 count_value_to_trig 9'd          ToneDetectpicoBitDodgy.psm
 audioTest           2'd          ToneDetectpicoBitDodgy.psm
 StrtToneAInc        9E           ToneDetectpicoBitDodgy.psm
 StrtToneBInc        68           ToneDetectpicoBitDodgy.psm
 StopToneAInc        59           ToneDetectpicoBitDodgy.psm
 StopToneBInc        77           ToneDetectpicoBitDodgy.psm
 DigToneAinc         61'd         ToneDetectpicoBitDodgy.psm
 DigToneBinc         82'd         ToneDetectpicoBitDodgy.psm
 DigToneCinc         213'd        ToneDetectpicoBitDodgy.psm
 DigToneDinc         234'd        ToneDetectpicoBitDodgy.psm
 AudioMSB            0'd          ToneDetectpicoBitDodgy.psm
 AudioLSB            1'd          ToneDetectpicoBitDodgy.psm
 Strobe              2'd          ToneDetectpicoBitDodgy.psm
 DemodMSB            3'd          ToneDetectpicoBitDodgy.psm
 DemodLSB            4'd          ToneDetectpicoBitDodgy.psm
 TBD0                5'd          ToneDetectpicoBitDodgy.psm
 TBD1                6'd          ToneDetectpicoBitDodgy.psm
 TBD2                7'd          ToneDetectpicoBitDodgy.psm
 CmdToUser           0'd          ToneDetectpicoBitDodgy.psm
 LOMSB               1'd          ToneDetectpicoBitDodgy.psm
 BRAMaddrMSB         2'd          ToneDetectpicoBitDodgy.psm
 BRAMaddrLSB         3'd          ToneDetectpicoBitDodgy.psm
 StartAmpOut         25'd         ToneDetectpicoBitDodgy.psm
 State               26'd         ToneDetectpicoBitDodgy.psm
 AVEtoneAmp          9'd          ToneDetectpicoBitDodgy.psm
 STRTAinc            10'd         ToneDetectpicoBitDodgy.psm
 STRTAptrMSB         11'd         ToneDetectpicoBitDodgy.psm
 STRTAptrLSB         12'd         ToneDetectpicoBitDodgy.psm
 STRTAAccuDemodIMSB  13'd         ToneDetectpicoBitDodgy.psm
 STRTAAccuDemodILSB  14'd         ToneDetectpicoBitDodgy.psm
 STRTAAccuDemodQMSB  15'd         ToneDetectpicoBitDodgy.psm
 STRTAAccuDemodQLSB  16'd         ToneDetectpicoBitDodgy.psm
 STRTAcurrentPhase   17'd         ToneDetectpicoBitDodgy.psm
 STRTApreviousPhase  18'd         ToneDetectpicoBitDodgy.psm
 STRTAcounter        19'd         ToneDetectpicoBitDodgy.psm
 STRTBinc            20'd         ToneDetectpicoBitDodgy.psm
 STPAinc             30'd         ToneDetectpicoBitDodgy.psm
 STPBinc             40'd         ToneDetectpicoBitDodgy.psm
 DigitalAinc         50'd         ToneDetectpicoBitDodgy.psm
 DigitalBinc         60'd         ToneDetectpicoBitDodgy.psm
 DigitalCinc         70'd         ToneDetectpicoBitDodgy.psm
 DigitalDinc         80'd         ToneDetectpicoBitDodgy.psm
 SampleCounterMSB    90'd         ToneDetectpicoBitDodgy.psm
 StartAmpA           91'd         ToneDetectpicoBitDodgy.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "15 May 2017"  
 timestamp$        "20:00:58"     



List of line labels

   Label                    Addr  Source PSM File

 * cold_start               000   ToneDetectpicoBitDodgy.psm
   AwaitAudioVal            023   ToneDetectpicoBitDodgy.psm
   AwaitRise                027   ToneDetectpicoBitDodgy.psm
   isReceiving              031   ToneDetectpicoBitDodgy.psm
   StartDemod               035   ToneDetectpicoBitDodgy.psm
   DemodulateTone           04E   ToneDetectpicoBitDodgy.psm
   CheckMatureAndOutput     087   ToneDetectpicoBitDodgy.psm
   Matured                  08C   ToneDetectpicoBitDodgy.psm
   CarryOn                  097   ToneDetectpicoBitDodgy.psm
   Whoopie                  0BE   ToneDetectpicoBitDodgy.psm
   dropcounter              0C9   ToneDetectpicoBitDodgy.psm
   IncrementCounter         0CE   ToneDetectpicoBitDodgy.psm
   CheckNotTooBigI          0D4   ToneDetectpicoBitDodgy.psm
   CheckNotTooBigQ          0E7   ToneDetectpicoBitDodgy.psm
   isStrtToneA              0FA   ToneDetectpicoBitDodgy.psm
   isStrtToneB              102   ToneDetectpicoBitDodgy.psm
   isStopToneA              109   ToneDetectpicoBitDodgy.psm
   isStopToneB              10F   ToneDetectpicoBitDodgy.psm
   CheckforTimeOuts         116   ToneDetectpicoBitDodgy.psm
   checkStarttoneAtimeout   11D   ToneDetectpicoBitDodgy.psm
   checkRXtimeout           121   ToneDetectpicoBitDodgy.psm
   checkStoptoneAtimeout    127   ToneDetectpicoBitDodgy.psm
   SpeakerOn                12C   ToneDetectpicoBitDodgy.psm
   SpeakerOff               12F   ToneDetectpicoBitDodgy.psm
 * DoAccumulate             133   ToneDetectpicoBitDodgy.psm
   negaccum                 13B   ToneDetectpicoBitDodgy.psm
   negdecrmnt               146   ToneDetectpicoBitDodgy.psm
 * LUTandMultiply           14C   ToneDetectpicoBitDodgy.psm
   StreamAmp                150   ToneDetectpicoBitDodgy.psm
   StreamPhase              154   ToneDetectpicoBitDodgy.psm
   waitabit                 159   ToneDetectpicoBitDodgy.psm
   cordic                   15D   ToneDetectpicoBitDodgy.psm
   cordicloop               162   ToneDetectpicoBitDodgy.psm
 * negrotate                166   ToneDetectpicoBitDodgy.psm
   posrotate                174   ToneDetectpicoBitDodgy.psm
   testcordicend            181   ToneDetectpicoBitDodgy.psm
   GetPhaseIncrement        185   ToneDetectpicoBitDodgy.psm
   shift                    18D   ToneDetectpicoBitDodgy.psm
   shiftloop                18E   ToneDetectpicoBitDodgy.psm
   rotate90                 194   ToneDetectpicoBitDodgy.psm
 * sub90                    198   ToneDetectpicoBitDodgy.psm
   add90                    1A1   ToneDetectpicoBitDodgy.psm
   absval                   1AA   ToneDetectpicoBitDodgy.psm
   makeposval               1AD   ToneDetectpicoBitDodgy.psm
 * Export2User              1B1   ToneDetectpicoBitDodgy.psm
 * AddCRLF                  1B7   ToneDetectpicoBitDodgy.psm
 * Chars2Byte               1BC   ToneDetectpicoBitDodgy.psm
   Get4bits                 1C7   ToneDetectpicoBitDodgy.psm
   char0_9                  1CC   ToneDetectpicoBitDodgy.psm
   Byte2Chars               1CF   ToneDetectpicoBitDodgy.psm
   GetChar                  1DB   ToneDetectpicoBitDodgy.psm
   is_0_9                   1DF   ToneDetectpicoBitDodgy.psm
 * delay_1s                 1E2   ToneDetectpicoBitDodgy.psm
   wait_1s                  1E4   ToneDetectpicoBitDodgy.psm
 * delay_300ms              1EC   ToneDetectpicoBitDodgy.psm
 * delay_200ms              1ED   ToneDetectpicoBitDodgy.psm
   delay_100ms              1F0   ToneDetectpicoBitDodgy.psm
   wait_100ms               1F1   ToneDetectpicoBitDodgy.psm
   delay_1ms                1F5   ToneDetectpicoBitDodgy.psm
   wait_1ms                 1F7   ToneDetectpicoBitDodgy.psm
 * delay_50us               1FF   ToneDetectpicoBitDodgy.psm
   wait_50us                200   ToneDetectpicoBitDodgy.psm
   delay_1us                204   ToneDetectpicoBitDodgy.psm
   wait_1us                 205   ToneDetectpicoBitDodgy.psm
 * mult_8x8                 208   ToneDetectpicoBitDodgy.psm
   mult_loop                20B   ToneDetectpicoBitDodgy.psm
   no_add                   20E   ToneDetectpicoBitDodgy.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            121
 STAR              -

 AND               7
 OR                -
 XOR               -

 ADD              41
 ADDCY            11
 SUB              34
 SUBCY             7

 TEST              1
 TESTCY            -
 COMPARE          39
 COMPARECY         -

 SL0               5
 SL1               -
 SLX               -
 SLA               2
 RL                -
 SR0              11
 SR1               -
 SRX               7
 SRA              15
 RR                -

 REGBANK           -

 INPUT             9
 OUTPUT           15
 OUTPUTK           -

 STORE            26
 FETCH            26

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             26
 JUMP@             -
 CALL             55
 CALL@             -
 RETURN           54
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
