KCPSM6 Assembler log file for program 'C:\Users\gnaylor\Dropbox\N3workingG\TE0722Rebuild\KeyPadProgPTTModADCgainDisplayGVA5.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 13 Dec 2015
Assembly timestamp: 17:42:21

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 1B0 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 433
Memory locations available: 3663


Assembly listing

 Addr Code                        Instruction

 000                              ;A0 is version to get start and stop tone levels for speaker switching.
 000                              ;
 000                              ;99 - add latch on button facility so don't need handset plugged in.
 000                              ;Now display signal level and gain setting
 000                              ;Switch off key pad oscillation and
 000                              ;Mod to read key pad and display
 000                              ;Version using CoutA
 000                              ;Need to mod to send TX request to User when touchdown active
 000                              ;May 10
 000                              ;
 000                              ; KeyPad routine for SSB picoblaze
 000                              ;
 000                              CONSTANT LCD_RS, 1'd                         ; bit0 - Register Select - command(0) or data(1)
 000                              CONSTANT LCD_RW, 2'd                         ; bit1 - read(1) or write(0)
 000                              CONSTANT LCD_E, 4'd                          ; bit2 - Enable(1)
 000                              ; Registers
 000                              NAMEREG sF, LCD_data                         ;            EQU       sF                  ; registers used for data and control of LCD
 000                              NAMEREG sE, LCD_control                      ;         EQU       sE                  ; E=bit2,  R/W=bit1,  RS=bit0
 000                              NAMEREG sD, cursor_position                  ;     EQU       sD                  ; register to define cursor position on LCD display
 000                              ;sB and sC also used for temporary character storage
 000                              CONSTANT delay_1us_constant, 12'd            ; Value (13)19 or 12? decimal suitable for 50MHz clock – about 8 for 20MHz
 000                              CONSTANT count_1000_lsb, E8                  ; hex lower 8-bits of 1000 count value
 000                              CONSTANT count_1000_msb, 03                  ; hex upper 8-bits of 1000 count value
 000                              ; Input port - port numbering changed June 11
 000                              CONSTANT Command, 0'd                        ; From main pico
 000                              CONSTANT TouchSignal, 1'd                    ;This is PTT
 000                              CONSTANT RAMdataInLSB, 2'd
 000                              CONSTANT RAMdataInMSB, 3'd
 000                              CONSTANT KP2userbufferFull, 4'd              ;Bit 0 KP2User buffer full, Bit 1 Touch counter running
 000                              CONSTANT TouchSignal2, 5'd                   ;This is keypad
 000                              CONSTANT ADCpeak, 6'd
 000                              CONSTANT DemodPeak, 7'd
 000                              ;CONSTANT SignalLevel,   8'd
 000                              CONSTANT StartToneA, 8'd
 000                              CONSTANT StartToneALong, 9'd
 000                              CONSTANT StartToneB, 10'd
 000                              CONSTANT StartToneBLong, 11'd
 000                              CONSTANT StopToneA, 12'd
 000                              CONSTANT StopToneALong, 13'd
 000                              CONSTANT StopToneB, 14'd
 000                              CONSTANT StopToneBLong, 15'd
 000                              ; Output ports
 000                              CONSTANT CmdToUser, 0'd
 000                              CONSTANT LCD_data_port, 1'd
 000                              CONSTANT LCD_control_port, 2'd
 000                              CONSTANT LCDcontrast, 3'd
 000                              CONSTANT Data2ArchiveMSB, 4'd
 000                              CONSTANT Data2ArchiveLSB, 5'd
 000                              CONSTANT Controlbits, 6'd
 000                              ;Bit offsets:
 000                              CONSTANT AckFIFO, 32'd                       ;   bit 5 Acknowledge FIFO (present character)
 000                              CONSTANT RAM_ADD_MSB, 7'd                    ;Bits 0 and 1 top too address bits, bit 2 write RAM
 000                              ;Bit offsets:
 000                              CONSTANT WriteKPRAM, 4'd
 000                              CONSTANT RAM_ADD_LSB, 8'd
 000                              CONSTANT LatchOn, 9'd
 000                              CONSTANT RXFreqMSB, 10'd                     ; 7546 for 87.956kHz ie 86.956kHz carrier and allow range up to 154kHz 7555 Heyphone
 000                              CONSTANT RXFreqLSB, 11'd
 000                              CONSTANT TXFreqMSB, 12'd                     ; 3710  with 49MHz clock
 000                              CONSTANT TXFreqLSB, 13'd
 000                              ;TX frequencies:
 000                              ;Heyphone - 0e80
 000                              ;N2 -       0e7e
 000                              ;N3_31 -    052b
 000                              ;RX frequencies:
 000                              ;Heyphone  - $7555
 000                              ;N2  -       $7546
 000                              ;N3_31  -    $2aad
 000                              ; Scratchpad registers
 000                              CONSTANT TouchUpLevel, 0'd
 000                              CONSTANT TouchDownLevel, 1'd
 000                              CONSTANT TouchSelectLevel, 2'd
 000                              CONSTANT TX_F_MSB, 3'd
 000                              CONSTANT TX_F_LSB, 4'd
 000                              CONSTANT RX_F_MSB, 5'd
 000                              CONSTANT RX_F_LSB, 6'd
 000                              CONSTANT Freq2Set, 7'd                       ; values 0 nothing to set, 1>Hy, 2>N2, 3>N3 (31kHz)
 000                              ;;;GenerateCode        MEM       "KeyPadProg.mem"
 000  2014A           cold_start: CALL 14A[LCD_setup]
 001  20162      welcome_message: CALL 162[LCD_home]                           ; left hand of display
 002  01F4E                       LOAD sF[LCD_data], 4E[78'd]                  ; character_N
 003  20180                       CALL 180[LCD_character_write]
 004                              ;                    LOAD      LCD_data, character_i
 004                              ;                   CALL      LCD_character_write
 004                              ;                  LOAD      LCD_data, character_c
 004                              ;                 CALL      LCD_character_write
 004                              ;                LOAD      LCD_data, character_o
 004                              ;               CALL      LCD_character_write
 004                              ;              LOAD      LCD_data, character_l
 004                              ;             CALL      LCD_character_write
 004                              ;            LOAD      LCD_data, character_a
 004                              ;           CALL      LCD_character_write
 004                              ;               LOAD      LCD_data, character_space
 004                              ;              CALL      LCD_character_write
 004  01F33                       LOAD sF[LCD_data], 33["3"]
 005  20180                       CALL 180[LCD_character_write]
 006  01F20                       LOAD sF[LCD_data], 20[" "]
 007  20180                       CALL 180[LCD_character_write]
 008  01000           initialise: LOAD s0, 00                                  ;This is now used to drive LatchOn which latches the device on!!
 009  2D009                       OUTPUT s0, 09[LatchOn]                       ;Latch On if 1
 00A                              ;set values for Heyphone by default
 00A  01001                       LOAD s0, 01                                  ;use \Heyphone
 00B  2F007                       STORE s0, 07[Freq2Set]
 00C  2008A                       CALL 08A[UpdateFreqRegisters]
 00D                              ;Wait and check if ON still pressed
 00D  2018B                       CALL 18B[delay_1s]
 00E  09505                       INPUT s5, 05[TouchSignal2]
 00F  0350F                       AND s5, 0F
 010  1D507                       COMPARE s5, 07                               ;is 'ON' pressed
 011  36016                       JUMP NZ, 016[loop]                           ;if not ON button, skip
 012  01001                       LOAD s0, 01                                  ;This is now used to drive PMOD1 which latches the device on!!
 013  2D009                       OUTPUT s0, 09[LatchOn]                       ;Latch On
 014  2018B                       CALL 18B[delay_1s]                           ;Wait so it doesn't detect as turn off!
 015  2018B                       CALL 18B[delay_1s]                           ;Wait so it doesn't detect as turn off!
 016  09000                 loop: INPUT s0, 00[Command]                        ;Check if FIFO character present
 017  1D080                       COMPARE s0, 80[128'd]                        ; is there a character?
 018  380B4                       CALL C, 0B4[Respond2Fifo]                    ;this should now receive value of mode from user pico and display on LCD
 019  09105                       INPUT s1, 05[TouchSignal2]
 01A  0310F                       AND s1, 0F
 01B  1D10F                       COMPARE s1, 0F                               ;0 if pressed - logic on proto2 is inverted
 01C  34036                       CALL NZ, 036[KeyPressed]
 01D                              ;;;;;;;;;;;;;Bit added to check touch switch - re-enable June 2013
 01D                              ;     LOAD   s1,02
 01D                              ;     OUTPUT    s1,ChooseTouchKey
 01D                              ;     LOAD   s5,00
 01D                              ;StayWaiting:  INPUT    s0,KP2userbufferFull
 01D                              ;     ADD      s5,01
 01D                              ;     AND      s0,02
 01D                              ;     COMPARE  s0,02
 01D                              ;     JUMP     Z,StayWaiting
 01D                              ;                    LOAD   cursor_position,14'd ;position cursor at end of line   -Add this to get keypad level
 01D                              ;                   CALL   LCD_position_cursor
 01D                              ;                    INPUT   s5,Touchsignal2
 01D                              ;                   CALL   Displays5
 01D                              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 01D  09101                       INPUT s1, 01[TouchSignal]                    ;This is PTT
 01E  1D100                       COMPARE s1, 00                               ;0 if pressed - logic on proto2 is inverted
 01F  3202B                       JUMP Z, 02B[TouchDown]
 020                              ;think touch is not pressed
 020  20199         NotTouchDown: CALL 199[delay_100ms]
 021  09101                       INPUT s1, 01[TouchSignal]
 022  1D100                       COMPARE s1, 00                               ;check if pressed logic on proto2 is inverted
 023  32016                       JUMP Z, 016[loop]                            ;so is in fact pressed so escape
 024  01D04                       LOAD sD[cursor_position], 04                 ;position cursor just after 'Nicola 3'
 025  20178                       CALL 178[LCD_position_cursor]
 026  01572                       LOAD s5, 72["r"]                             ; character_r      ;temp - shoulr be r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 027  00F50                       LOAD sF[LCD_data], s5                        ;
 028  2D500                       OUTPUT s5, 00[CmdToUser]
 029  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 02A  22016                       JUMP 016[loop]
 02B                              ;believe touch to be pressed
 02B  20199            TouchDown: CALL 199[delay_100ms]
 02C  09101                       INPUT s1, 01[TouchSignal]
 02D  1D100                       COMPARE s1, 00                               ;logic on proto2 is inverted
 02E  36016                       JUMP NZ, 016[loop]                           ;so is not in fact pressed - escape
 02F  01D04                       LOAD sD[cursor_position], 04                 ;position cursor just after 'Nicola 3'
 030  20178                       CALL 178[LCD_position_cursor]
 031  01574                       LOAD s5, 74["t"]                             ; character_t
 032  00F50                       LOAD sF[LCD_data], s5                        ;
 033  2D500                       OUTPUT s5, 00[CmdToUser]
 034  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 035  22016                       JUMP 016[loop]
 036  2018B           KeyPressed: CALL 18B[delay_1s]
 037  09505                       INPUT s5, 05[TouchSignal2]
 038  0350F                       AND s5, 0F
 039  1D50F                       COMPARE s5, 0F                               ;not $F if pressed
 03A  31000                       RETURN Z                                     ;return if key not still pressed
 03B  01DC3                       LOAD sD[cursor_position], C3                 ;position cursor
 03C  20178                       CALL 178[LCD_position_cursor]
 03D  01B20                       LOAD sB, 20[" "]                             ; character_space
 03E  01C20                       LOAD sC, 20[" "]                             ; character_space
 03F  1D50B                       COMPARE s5, 0B
 040  3004F                       CALL Z, 04F[upFreq]
 041  1D50E                       COMPARE s5, 0E
 042  30054                       CALL Z, 054[DownFreq]                        ;These should reload LCD_data and sC with characters representing code of Freq, N3 etc
 043                              ;     LOAD   LCD_data,sB
 043                              ;     CALL      LCD_character_write  ;then write 1st char to LCD
 043                              ;     LOAD   LCD_data,sC
 043                              ;     CALL      LCD_character_write  ;then write 2nd to LCD
 043  1D50D                       COMPARE s5, 0D
 044  3008A                       CALL Z, 08A[UpdateFreqRegisters]
 045  1D507                       COMPARE s5, 07
 046  3004C                       CALL Z, 04C[TurnOff]
 047                              ;and use DispAntennaInput for setting antenna input
 047  1D509                       COMPARE s5, 09                               ;Up+select
 048  30095                       CALL Z, 095[SetLoop]
 049  1D50C                       COMPARE s5, 0C                               ;Down+select
 04A  3009B                       CALL Z, 09B[SetEarth]
 04B  25000                       RETURN 
 04C                              ;Note key pad bits are: bit3 = On, bit 2 = up, bit 1 = select, bit 0 = down
 04C  01000              TurnOff: LOAD s0, 00                                  ;This is now used to drive PMOD1 which latches the device on!!
 04D  2D009                       OUTPUT s0, 09[LatchOn]                       ;Latch On if 1
 04E  25000                       RETURN 
 04F  0B007               upFreq: FETCH s0, 07[Freq2Set]
 050  11001                       ADD s0, 01
 051  03003                       AND s0, 03
 052  2F007                       STORE s0, 07[Freq2Set]
 053  22059                       JUMP 059[CheckWhichFreq]
 054  0B007             DownFreq: FETCH s0, 07[Freq2Set]
 055  19001                       SUB s0, 01
 056  03003                       AND s0, 03
 057  2F007                       STORE s0, 07[Freq2Set]
 058  22059                       JUMP 059[CheckWhichFreq]
 059  1D000       CheckWhichFreq: COMPARE s0, 00
 05A  30066                       CALL Z, 066[ClearFreq]                       ;clear set display
 05B  1D001                       COMPARE s0, 01
 05C  30069                       CALL Z, 069[SetHeyphoneFreq]                 ;set Hy freq and return
 05D  1D002                       COMPARE s0, 02
 05E  30074                       CALL Z, 074[SetN2Freq]
 05F  1D003                       COMPARE s0, 03
 060  3007F                       CALL Z, 07F[SetN3_31Freq]
 061  00FB0                       LOAD sF[LCD_data], sB
 062  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 063  00FC0                       LOAD sF[LCD_data], sC
 064  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 065  25000                       RETURN 
 066  01B20            ClearFreq: LOAD sB, 20[" "]                             ; character_space
 067  01C20                       LOAD sC, 20[" "]                             ; character_space
 068  25000                       RETURN 
 069                              ;5568 (15C0) for Heyphone TX and 45056 (B000) for RX
 069  01115      SetHeyphoneFreq: LOAD s1, 15
 06A  2F103                       STORE s1, 03[TX_F_MSB]
 06B  011C0                       LOAD s1, C0
 06C  2F104                       STORE s1, 04[TX_F_LSB]
 06D  011B0                       LOAD s1, B0
 06E  2F105                       STORE s1, 05[RX_F_MSB]
 06F  01100                       LOAD s1, 00
 070  2F106                       STORE s1, 06[RX_F_LSB]
 071  01B68                       LOAD sB, 68["h"]                             ; character_h
 072  01C79                       LOAD sC, 79["y"]                             ; character_y
 073  25000                       RETURN 
 074                              ;For N3 5565 (15BD) TX and  45032 (AFE8) RX
 074  01115            SetN2Freq: LOAD s1, 15
 075  2F103                       STORE s1, 03[TX_F_MSB]
 076  011BD                       LOAD s1, BD
 077  2F104                       STORE s1, 04[TX_F_LSB]
 078  011AF                       LOAD s1, AF
 079  2F105                       STORE s1, 05[RX_F_MSB]
 07A  011E8                       LOAD s1, E8
 07B  2F106                       STORE s1, 06[RX_F_LSB]
 07C  01B6E                       LOAD sB, 6E["n"]                             ; character_n
 07D  01C32                       LOAD sC, 32["2"]                             ; character_2
 07E  25000                       RETURN 
 07F                              ;For 31kH 1984 TX (07C0)    16384 for RX (4000 hex)
 07F  01107         SetN3_31Freq: LOAD s1, 07
 080  2F103                       STORE s1, 03[TX_F_MSB]
 081  011C0                       LOAD s1, C0
 082  2F104                       STORE s1, 04[TX_F_LSB]
 083  01140                       LOAD s1, 40
 084  2F105                       STORE s1, 05[RX_F_MSB]
 085  01100                       LOAD s1, 00
 086  2F106                       STORE s1, 06[RX_F_LSB]
 087  01B6E                       LOAD sB, 6E["n"]                             ; character_n
 088  01C33                       LOAD sC, 33["3"]                             ; character_3
 089  25000                       RETURN 
 08A  01DC6  UpdateFreqRegisters: LOAD sD[cursor_position], C6                 ;position cursor
 08B  20178                       CALL 178[LCD_position_cursor]
 08C  01F66                       LOAD sF[LCD_data], 66["f"]                   ; character_f   ;
 08D  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 08E  01F3D                       LOAD sF[LCD_data], 3D["="]                   ; character_equals
 08F  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 090  0B007                       FETCH s0, 07[Freq2Set]
 091  20059                       CALL 059[CheckWhichFreq]
 092  200FB                       CALL 0FB[SetTxFreq]
 093  20100                       CALL 100[SetRxFreq]
 094  25000                       RETURN 
 095  0186C              SetLoop: LOAD s8, 6C["l"]                             ; character_l
 096  0196F                       LOAD s9, 6F["o"]                             ; character_o
 097  01A6F                       LOAD sA, 6F["o"]                             ; character_o
 098  01B70                       LOAD sB, 70["p"]                             ; character_p
 099  01C20                       LOAD sC, 20[" "]                             ; character_space
 09A  220A0                       JUMP 0A0[DispAntennaInput]
 09B  01865             SetEarth: LOAD s8, 65["e"]                             ; character_e
 09C  01961                       LOAD s9, 61["a"]                             ; character_a
 09D  01A72                       LOAD sA, 72["r"]                             ; character_r
 09E  01B74                       LOAD sB, 74["t"]                             ; character_t
 09F  01C68                       LOAD sC, 68["h"]                             ; character_h
 0A0                              ;To use
 0A0  01DCB     DispAntennaInput: LOAD sD[cursor_position], CB                 ;position cursor near end of second line
 0A1  20178                       CALL 178[LCD_position_cursor]
 0A2  00F80                       LOAD sF[LCD_data], s8
 0A3  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0A4  2D800                       OUTPUT s8, 00[CmdToUser]                     ;First letter is used to inform userpico whether loop or earth
 0A5  00F90                       LOAD sF[LCD_data], s9
 0A6  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0A7  00FA0                       LOAD sF[LCD_data], sA
 0A8  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0A9  00FB0                       LOAD sF[LCD_data], sB
 0AA  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0AB  00FC0                       LOAD sF[LCD_data], sC
 0AC  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0AD  25000                       RETURN 
 0AE                              ;displays s5
 0AE  20134            Displays5: CALL 134[Byte2Chars]
 0AF  00F60                       LOAD sF[LCD_data], s6                        ;
 0B0  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0B1  00F70                       LOAD sF[LCD_data], s7                        ;
 0B2  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0B3  25000                       RETURN 
 0B4                              ;initialise scratchpad values for touch levels
 0B4                              ;GetTouchLevels:    LOAD   s0,00      ;!!!!!!!!!!!!!! 1 for touch down, 0 for up - changed to up 23/6/11 only worry about touch down for the moment! (This is the touch nearest the middle of the lid)
 0B4                              ;     OUTPUT    s0,ChooseTouchKey  ;Select which pad to read
 0B4                              ;     INPUT     s6,TouchSignal
 0B4                              ;     CALL   delay_100ms
 0B4                              ;     INPUT   s1,TouchSignal
 0B4                              ;     ADD    s1,s6
 0B4                              ;     SRA    s1      ;Devide by 2 taking ito account carry so average 2 values
 0B4                              ;     SUB    s1,20   ;set threshold at a lower value (assuming doesn't wrap around!!) -or add???????
 0B4                              ;     STORE   s1,TouchDownLevel
 0B4                              ;     RETURN
 0B4                              ;Get fifo command and act on it. Echo ascii value to LCD
 0B4                Respond2Fifo: ;CALL LCD_cursor_back
 0B4  20108                       CALL 108[GetFifoChar]
 0B5  1D004                       COMPARE s0, 04                               ;character T (request for info from userpico) ->LESS TOP BIT WHICH IS NOT SENT!
 0B6  30105                       CALL Z, 105[SendParamBack]
 0B7                              ;     COMPARE s0,03    ;character S (request for info from userpico)
 0B7                              ;     CALL Z,Select
 0B7  1D07F                       COMPARE s0, 7F                               ;Is this the start of a signal readout (ie another 2 values expected) -LESS TOP BIT WHICH IS NOT SENT!
 0B8  320D5                       JUMP Z, 0D5[Display2]                        ; No revert to original!! ----move cursor and return
 0B9  25000                       RETURN 
 0BA                              ;Display character in s0
 0BA                              ;Display_s0:     LOAD s5,s0         ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!temporary to check beacon mode
 0BA                              ;     CALL   Byte2Chars
 0BA                              ;       LOAD      LCD_data, s6   ;This should display at the end of the line ie characters 12,13
 0BA                              ;     CALL      LCD_character_write  ;then write to LCD
 0BA                              ;     LOAD      LCD_data, s7   ;
 0BA                              ;     CALL      LCD_character_write  ;then write to LCD
 0BA                              ;     RETURN
 0BA  01D07             Display8: LOAD sD[cursor_position], 07                 ;position cursor just after touch value
 0BB  20178                       CALL 178[LCD_position_cursor]
 0BC  20108                       CALL 108[GetFifoChar]
 0BD  00F00                       LOAD sF[LCD_data], s0                        ; Write character from GetFfoChar
 0BE  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0BF  20108                       CALL 108[GetFifoChar]
 0C0  00F00                       LOAD sF[LCD_data], s0                        ; Write character from GetFfoChar
 0C1  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0C2  20108                       CALL 108[GetFifoChar]
 0C3  00F00                       LOAD sF[LCD_data], s0                        ; Write character from GetFfoChar
 0C4  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0C5  20108                       CALL 108[GetFifoChar]
 0C6  00F00                       LOAD sF[LCD_data], s0                        ; Write character from GetFfoChar
 0C7  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0C8  20108                       CALL 108[GetFifoChar]
 0C9  00F00                       LOAD sF[LCD_data], s0                        ; Write character from GetFfoChar
 0CA  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0CB  20108                       CALL 108[GetFifoChar]
 0CC  00F00                       LOAD sF[LCD_data], s0                        ; Write character from GetFfoChar
 0CD  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0CE  20108                       CALL 108[GetFifoChar]
 0CF  00F00                       LOAD sF[LCD_data], s0                        ; Write character from GetFfoChar
 0D0  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0D1  20108                       CALL 108[GetFifoChar]
 0D2  00F00                       LOAD sF[LCD_data], s0                        ; Write character from GetFfoChar
 0D3  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0D4  25000                       RETURN 
 0D5                              ;Set cursor position back to 7 and display 2 decimal values from fifo followed by locally available values
 0D5  01D07             Display2: LOAD sD[cursor_position], 07                 ;position cursor just after touch value
 0D6  20178                       CALL 178[LCD_position_cursor]
 0D7  20108                       CALL 108[GetFifoChar]
 0D8  00500                       LOAD s5, s0
 0D9  20140                       CALL 140[GetChar]                            ;Added this Sep 2014 to extend display of first digit
 0DA                              ;                    ADD       s0, 48              ; offset to Ascii code for '0'
 0DA  00F50                       LOAD sF[LCD_data], s5                        ; Write character from GetChar
 0DB  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0DC  20108                       CALL 108[GetFifoChar]
 0DD  11030                       ADD s0, 30[48'd]                             ; offset to Ascii code for '0'
 0DE  00F00                       LOAD sF[LCD_data], s0                        ;
 0DF  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0E0                              ; Added code to display ADC and demod peak values
 0E0  01D0A                       LOAD sD[cursor_position], 0A[10'd]           ;position cursor
 0E1  20178                       CALL 178[LCD_position_cursor]
 0E2  09506                       INPUT s5, 06[ADCpeak]
 0E3  200AE                       CALL 0AE[Displays5]
 0E4  01F20                       LOAD sF[LCD_data], 20[" "]                   ;character_space   ;
 0E5  20180                       CALL 180[LCD_character_write]                ;then write to LCD
 0E6  09507                       INPUT s5, 07[DemodPeak]                      ;will also reset the peak value
 0E7  200AE                       CALL 0AE[Displays5]
 0E8  01DC0                       LOAD sD[cursor_position], C0                 ;position cursor
 0E9  20178                       CALL 178[LCD_position_cursor]
 0EA  09508                       INPUT s5, 08[StartToneA]
 0EB  200AE                       CALL 0AE[Displays5]
 0EC  09509                       INPUT s5, 09[StartToneALong]
 0ED  200AE                       CALL 0AE[Displays5]
 0EE  0950A                       INPUT s5, 0A[StartToneB]
 0EF  200AE                       CALL 0AE[Displays5]
 0F0  0950B                       INPUT s5, 0B[StartToneBLong]
 0F1  200AE                       CALL 0AE[Displays5]
 0F2  0950C                       INPUT s5, 0C[StopToneA]
 0F3  200AE                       CALL 0AE[Displays5]
 0F4  0950D                       INPUT s5, 0D[StopToneALong]
 0F5  200AE                       CALL 0AE[Displays5]
 0F6  0950E                       INPUT s5, 0E[StopToneB]
 0F7  200AE                       CALL 0AE[Displays5]
 0F8  0950F                       INPUT s5, 0F[StopToneBLong]
 0F9  200AE                       CALL 0AE[Displays5]
 0FA  25000                       RETURN 
 0FB                              ;Enter with s0 - LSB, s1 - MSB
 0FB  0B003            SetTxFreq: FETCH s0, 03[TX_F_MSB]                       ; store value for 86.95kHz
 0FC  2D00C                       OUTPUT s0, 0C[TXFreqMSB]
 0FD  0B004                       FETCH s0, 04[TX_F_LSB]
 0FE  2D00D                       OUTPUT s0, 0D[TXFreqLSB]                     ; and send value to SSB modulator
 0FF  25000                       RETURN 
 100  0B005            SetRxFreq: FETCH s0, 05[RX_F_MSB]                       ; store value for 86.95kHz
 101  2D00A                       OUTPUT s0, 0A[RXFreqMSB]
 102  0B006                       FETCH s0, 06[RX_F_LSB]
 103  2D00B                       OUTPUT s0, 0B[RXFreqLSB]                     ; and send value to SSB modulator
 104  25000                       RETURN 
 105                              ;Select:   CALL GetFifoChar
 105                              ;     OUT  s0,ChooseTouchKey
 105                              ;     RETURN
 105  09501        SendParamBack: INPUT s5, 01[TouchSignal]                    ;********************TEST reading touch***********************************
 106  2010E                       CALL 10E[Export2User]
 107  25000                       RETURN 
 108                              ; Routine to recover a character from the FIFO in s0
 108  01020          GetFifoChar: LOAD s0, 20[AckFIFO]
 109  2D006                       OUTPUT s0, 06[Controlbits]
 10A  01020                       LOAD s0, 20[AckFIFO]                         ;Wait
 10B  09000                       INPUT s0, 00[Command]                        ; now get my character
 10C  0307F                       AND s0, 7F                                   ; mask of top bit
 10D  25000                       RETURN 
 10E                              ; Takes value in s5 and converts to 2 ascii codes which are sent to the user picoblaze.
 10E  20134          Export2User: CALL 134[Byte2Chars]
 10F  2D600                       OUTPUT s6, 00[CmdToUser]
 110  2D700                       OUTPUT s7, 00[CmdToUser]
 111  0100D                       LOAD s0, 0D[13'd]                            ;terminate with CR
 112  2D000                       OUTPUT s0, 00[CmdToUser]
 113  0100A                       LOAD s0, 0A[10'd]                            ;and with LF
 114  2D000                       OUTPUT s0, 00[CmdToUser]
 115  25000                       RETURN 
 116                              ; routine to look at command input and recover 2 characters and return the byte they represent in s5.
 116  09600            Get2Chars: INPUT s6, 00[Command]
 117  1D680                       COMPARE s6, 80[128'd]                        ; if greater than 128, then no character
 118  3E116                       JUMP NC, 116[Get2Chars]
 119  20108                       CALL 108[GetFifoChar]
 11A  00600                       LOAD s6, s0
 11B  09700           Get2ndChar: INPUT s7, 00[Command]
 11C  1D780                       COMPARE s7, 80[128'd]                        ; if greater than 128, then no character
 11D  3E11B                       JUMP NC, 11B[Get2ndChar]
 11E  20108                       CALL 108[GetFifoChar]
 11F  00700                       LOAD s7, s0
 120  22121                       JUMP 121[Chars2Byte]
 121                              ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 121  00860           Chars2Byte: LOAD s8, s6
 122  2012C                       CALL 12C[Get4bits]
 123  00580                       LOAD s5, s8
 124  14506                       SL0 s5
 125  14506                       SL0 s5
 126  14506                       SL0 s5
 127  14506                       SL0 s5                                       ; put these 4 bits to MSBs
 128  00870                       LOAD s8, s7
 129  2012C                       CALL 12C[Get4bits]
 12A  10580                       ADD s5, s8
 12B  25000                       RETURN 
 12C                              ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 12C  1D83C             Get4bits: COMPARE s8, 3C[60'd]                         ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 12D  3A131                       JUMP C, 131[char0_9]
 12E  19837                       SUB s8, 37[55'd]                             ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 12F  0380F                       AND s8, 0F                                   ; make sure only return 4 bits
 130  25000                       RETURN 
 131  19830              char0_9: SUB s8, 30[48'd]
 132  0380F                       AND s8, 0F                                   ; make sure only return 4 bits
 133  25000                       RETURN 
 134                              ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 134  00850           Byte2Chars: LOAD s8, s5                                  ; assumes 8 bit data is in s5
 135  1450E                       SR0 s5
 136  1450E                       SR0 s5
 137  1450E                       SR0 s5
 138  1450E                       SR0 s5                                       ; get first hex character
 139  20140                       CALL 140[GetChar]
 13A  00650                       LOAD s6, s5                                  ; first ascii char
 13B  00580                       LOAD s5, s8
 13C  0350F                       AND s5, 0F
 13D  20140                       CALL 140[GetChar]                            ; send to LCD or UART
 13E  00750                       LOAD s7, s5                                  ; second ascii char
 13F  25000                       RETURN 
 140                              ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 140  1950A              GetChar: SUB s5, 0A[10'd]                             ; Test if s5 greater than 9
 141  3A144                       JUMP C, 144[is_0_9]                          ; Hex character is 0_9
 142  11541                       ADD s5, 41[65'd]                             ; offset for Ascii code 'A'
 143  25000                       RETURN 
 144  1150A               is_0_9: ADD s5, 0A[10'd]                             ; return to range 0-9
 145  11530                       ADD s5, 30[48'd]                             ; offset to Ascii code for '0'
 146  25000                       RETURN 
 147                              ; LCD driver routines courtesy Ken Chapman Xilinx.
 147                              ; Send space to the LCD display
 147                              ;
 147                              ;
 147                              ; Registers used LCD_data, LCD_control, s0 and s1.
 147                              ;
 147  01F20            LCD_space: LOAD sF[LCD_data], 20[" "]                   ; character_space
 148  20180                       CALL 180[LCD_character_write]
 149  25000                       RETURN 
 14A                              ;
 14A                              ;
 14A                              ; These are for a 20x4 character module
 14A                              ;
 14A                              ;
 14A                              ; Initialise LCD display or clear LCD display
 14A                              ;
 14A                              ;
 14A                              ; Registers used LCD_data, LCD_control, s0, s1, s2, s3, s4 and s5.
 14A                              ;
 14A  2018B            LCD_setup: CALL 18B[delay_1s]                           ; delay to allow LCD to be ready after power up
 14B  01F38                       LOAD sF[LCD_data], 38[56'd]                  ; function set, 8-bit, 2-line, 5x7 dot format
 14C  2017C                       CALL 17C[LCD_control_write]
 14D  2019E                       CALL 19E[delay_1ms]                          ; wait >4.1ms
 14E  2019E                       CALL 19E[delay_1ms]
 14F  2019E                       CALL 19E[delay_1ms]
 150  2019E                       CALL 19E[delay_1ms]
 151  2019E                       CALL 19E[delay_1ms]
 152  2017C                       CALL 17C[LCD_control_write]                  ; repeat function set
 153  2018B                       CALL 18B[delay_1s]                           ; wait >100us
 154  2017C                       CALL 17C[LCD_control_write]                  ; repeat function set
 155  2017C                       CALL 17C[LCD_control_write]                  ; repeat function set
 156  01F06                       LOAD sF[LCD_data], 06[6'd]                   ; Entry mode, increment by 1, no shift
 157  2017C                       CALL 17C[LCD_control_write]
 158  01F0E                       LOAD sF[LCD_data], 0E[14'd]                  ; Display, on, cursur on, no blink cursor
 159  2017C                       CALL 17C[LCD_control_write]
 15A  01F01            LCD_clear: LOAD sF[LCD_data], 01[1'd]                   ; clear display
 15B  2017C                       CALL 17C[LCD_control_write]
 15C  2019E                       CALL 19E[delay_1ms]                          ; wait >1.64ms
 15D  2019E                       CALL 19E[delay_1ms]
 15E  2019E                       CALL 19E[delay_1ms]
 15F  01040                       LOAD s0, 40                                  ; hex
 160  2D003                       OUTPUT s0, 03[LCDcontrast]                   ;*************************set default contrast
 161  25000                       RETURN 
 162                              ;
 162                              ; Send cursor to ‘home’
 162  01F02             LCD_home: LOAD sF[LCD_data], 02
 163  2017C                       CALL 17C[LCD_control_write]
 164  2019E                       CALL 19E[delay_1ms]
 165                              ; CALL      delay_1ms
 165  25000                       RETURN 
 166                              ;
 166                              ; Turn Back-light on (assuming bit 3 of the control port is connected to the LCD
 166                              ; backlight), uses LCD_control.
 166  05E08         LCD_light_on: OR sE[LCD_control], 08
 167  2DE02                       OUTPUT sE[LCD_control], 02[LCD_control_port]
 168  25000                       RETURN 
 169                              ;
 169                              ; Turn Back-light off (assuming bit 3 of the control port is connected to the LCD
 169                              ; backlight), uses LCD_control.
 169  03E07        LCD_light_off: AND sE[LCD_control], 07
 16A  2DE02                       OUTPUT sE[LCD_control], 02[LCD_control_port]
 16B  25000                       RETURN 
 16C                              ;
 16C                              ; Move cursor to start of line 2
 16C                              ; Uses LCD_data, LCD_control, s0 and s1.
 16C  01FC0           LCD_line_2: LOAD sF[LCD_data], C0
 16D  2017C                       CALL 17C[LCD_control_write]
 16E  2019E                       CALL 19E[delay_1ms]
 16F  25000                       RETURN 
 170                              ;
 170                              ; Advance cursur right
 170                              ; Uses LCD_data, LCD_control, s0 and s1.
 170  01F0E   LCD_cursor_advance: LOAD sF[LCD_data], 0E[14'd]
 171  2017C                       CALL 17C[LCD_control_write]
 172  2019E                       CALL 19E[delay_1ms]
 173  25000                       RETURN 
 174                              ;
 174                              ; Moves cursur left (back one)
 174                              ; Uses LCD_data, LCD_control, s0 and s1.
 174  01F0A      LCD_cursor_back: LOAD sF[LCD_data], 0A[10'd]
 175  2017C                       CALL 17C[LCD_control_write]
 176  2019E                       CALL 19E[delay_1ms]
 177  25000                       RETURN 
 178                              ;
 178                              ; Set cursor on LCD display based on value in register 'cursor_position'
 178                              ;
 178                              ; There are 20 character positions with the following addresses on the first line
 178                              ; position         1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
 178                              ; cursor_position 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13
 178                              ; address         80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f 90 91 92 93
 178                              ; line 2 address   c0 c1 c2 .....
 178                              ; other lines have other values…..
 178                              ; Writing characters auto increments the address, but note that
 178                              ;
 178                              ;
 178                              ; Registers used cursor_position, LCD_data, LCD_control, s0 and s1.
 178                              ; Horinzontal position in lower 4-5 bits, line in bit 6
 178  05D80  LCD_position_cursor: OR sD[cursor_position], 80                   ; set  MSB to address LCD memmory
 179  00FD0                       LOAD sF[LCD_data], sD[cursor_position]
 17A  2017C                       CALL 17C[LCD_control_write]                  ; write address to LCD control
 17B  25000                       RETURN 
 17C                              ;
 17C                              ; Write to LCD with control data provided in register called LCD_data
 17C                              ; Registers used LCD_data, LCD_control, s0 and s1.
 17C                              ;
 17C  2DF01    LCD_control_write: OUTPUT sF[LCD_data], 01[LCD_data_port]       ; output data
 17D  03E04                       AND sE[LCD_control], 04                      ; R/W=0,  RS=0
 17E  20184                       CALL 184[LCD_enable_pulse]                   ; enable pulse
 17F  25000                       RETURN 
 180                              ;
 180                              ; Write to LCD with character data provided in register called LCD_data
 180                              ;
 180                              ; Registers used LCD_data, LCD_control, s0 and s1.
 180                              ;
 180  2DF01  LCD_character_write: OUTPUT sF[LCD_data], 01[LCD_data_port]       ; output data
 181  05E01                       OR sE[LCD_control], 01                       ; R/W=0,  RS=1
 182  20184                       CALL 184[LCD_enable_pulse]                   ; enable pulse
 183  25000                       RETURN 
 184                              ;
 184                              ; Registers used LCD_control, s0 and s1.
 184                              ;
 184  05E04     LCD_enable_pulse: OR sE[LCD_control], 04[LCD_E]                ; set enable bit (E=1)
 185  2DE02                       OUTPUT sE[LCD_control], 02[LCD_control_port]
 186  201AD                       CALL 1AD[delay_1us]                          ; ensure E pulse width > 230ns
 187  07E04                       XOR sE[LCD_control], 04[LCD_E]               ; reset enable bit (E=0)
 188  2DE02                       OUTPUT sE[LCD_control], 02[LCD_control_port] ;
 189  201A8                       CALL 1A8[delay_50us]                         ; >40us delay
 18A  25000                       RETURN 
 18B                              ;
 18B                              ; Registers used s0, s1, s2, s3, s4 and s5.
 18B                              ;
 18B  01500             delay_1s: LOAD s5, 00                                  ; clear cycle counter
 18C  01400                       LOAD s4, 00
 18D  2019E              wait_1s: CALL 19E[delay_1ms]
 18E  11401                       ADD s4, 01                                   ; increment cycle counter
 18F  13500                       ADDCY s5, 00
 190  1D4E8                       COMPARE s4, E8[count_1000_lsb]               ; test for 1000ms
 191  3618D                       JUMP NZ, 18D[wait_1s]
 192  1D503                       COMPARE s5, 03[count_1000_msb]
 193  3618D                       JUMP NZ, 18D[wait_1s]
 194  25000                       RETURN 
 195                              ;
 195                              ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 195                              ;
 195                              ;
 195                              ; Registers used s0, s1, s2, s3 and s4.
 195                              ;
 195  20199          delay_300ms: CALL 199[delay_100ms]
 196  20199          delay_200ms: CALL 199[delay_100ms]
 197  20199                       CALL 199[delay_100ms]
 198  25000                       RETURN 
 199                              ;
 199                              ; Delay of approximately 100ms used for switch debounce
 199                              ;
 199                              ; Registers used s0, s1, s2, s3 and s4.
 199                              ;
 199  01464          delay_100ms: LOAD s4, 64                                  ; repeat 1ms delay 100 times
 19A  2019E           wait_100ms: CALL 19E[delay_1ms]
 19B  19401                       SUB s4, 01
 19C  3619A                       JUMP NZ, 19A[wait_100ms]
 19D  25000                       RETURN 
 19E                              ;
 19E                              ; Delay of approximately 1ms required by LCD display
 19E                              ;
 19E                              ; Registers used s0, s1, s2 and s3.
 19E                              ;
 19E  01300            delay_1ms: LOAD s3, 00                                  ; clear cycle counter
 19F  01200                       LOAD s2, 00
 1A0  201AD             wait_1ms: CALL 1AD[delay_1us]
 1A1  11201                       ADD s2, 01                                   ; increment cycle counter
 1A2  13300                       ADDCY s3, 00
 1A3  1D2E8                       COMPARE s2, E8[count_1000_lsb]               ; test for 1000us
 1A4  361A0                       JUMP NZ, 1A0[wait_1ms]
 1A5  1D303                       COMPARE s3, 03[count_1000_msb]
 1A6  361A0                       JUMP NZ, 1A0[wait_1ms]
 1A7  25000                       RETURN 
 1A8                              ;
 1A8                              ; Delay of approximately 50us required by LCD display
 1A8                              ;
 1A8                              ; Registers used s0 and s1.
 1A8                              ;
 1A8  01132           delay_50us: LOAD s1, 32[50'd]                            ; repeat 1us delay 50 times
 1A9  201AD            wait_50us: CALL 1AD[delay_1us]
 1AA  19101                       SUB s1, 01
 1AB  361A9                       JUMP NZ, 1A9[wait_50us]
 1AC  25000                       RETURN 
 1AD                              ; Delay of approximately 1us used to provide timing reference for
 1AD                              ; LCD operations. This must be adjusted to reflect the clock
 1AD                              ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 1AD                              ;
 1AD                              ; The software delay loop is formed using register s0. This register
 1AD                              ; must be loaded with an integer value close to the result of....
 1AD                              ;
 1AD                              ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 1AD                              ;
 1AD                              ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 1AD                              ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 1AD                              ; operation will become lower than the 100KHz target intended.
 1AD                              ;
 1AD                              ; Register used s0.
 1AD                              ;
 1AD  0100C            delay_1us: LOAD s0, 0C[delay_1us_constant]              ; delay value of 12 decimal for a 50MHz clock
 1AE  19001             wait_1us: SUB s0, 01
 1AF  361AE                       JUMP NZ, 1AE[wait_1us]
 1B0  25000                       RETURN 
 1B1                              ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\Users\gnaylor\Dropbox\N3workingG\TE0722Rebuild\KeyPadProgPTTModADCgainDisplayGVA5.psm



List of defined constants

 CONSTANT name      Value        Source PSM File

 timestamp_hours    17'd         
 timestamp_minutes  42'd         
 timestamp_seconds  21'd         
 datestamp_year     15'd         
 datestamp_month    12'd         
 datestamp_day      13'd         
 NUL                00           
 BEL                07           
 BS                 08           
 HT                 09           
 LF                 0A           
 VT                 0B           
 CR                 0D           
 ESC                1B           
 DEL                7F           
 DCS                90           
 ST                 9C           
 LCD_RS             1'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 LCD_RW             2'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 LCD_E              4'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 delay_1us_constant 12'd         KeyPadProgPTTModADCgainDisplayGVA5.psm
 count_1000_lsb     E8           KeyPadProgPTTModADCgainDisplayGVA5.psm
 count_1000_msb     03           KeyPadProgPTTModADCgainDisplayGVA5.psm
 Command            0'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 TouchSignal        1'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 RAMdataInLSB       2'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 RAMdataInMSB       3'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 KP2userbufferFull  4'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 TouchSignal2       5'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 ADCpeak            6'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 DemodPeak          7'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 StartToneA         8'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 StartToneALong     9'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 StartToneB         10'd         KeyPadProgPTTModADCgainDisplayGVA5.psm
 StartToneBLong     11'd         KeyPadProgPTTModADCgainDisplayGVA5.psm
 StopToneA          12'd         KeyPadProgPTTModADCgainDisplayGVA5.psm
 StopToneALong      13'd         KeyPadProgPTTModADCgainDisplayGVA5.psm
 StopToneB          14'd         KeyPadProgPTTModADCgainDisplayGVA5.psm
 StopToneBLong      15'd         KeyPadProgPTTModADCgainDisplayGVA5.psm
 CmdToUser          0'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 LCD_data_port      1'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 LCD_control_port   2'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 LCDcontrast        3'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 Data2ArchiveMSB    4'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 Data2ArchiveLSB    5'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 Controlbits        6'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 AckFIFO            32'd         KeyPadProgPTTModADCgainDisplayGVA5.psm
 RAM_ADD_MSB        7'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 WriteKPRAM         4'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 RAM_ADD_LSB        8'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 LatchOn            9'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 RXFreqMSB          10'd         KeyPadProgPTTModADCgainDisplayGVA5.psm
 RXFreqLSB          11'd         KeyPadProgPTTModADCgainDisplayGVA5.psm
 TXFreqMSB          12'd         KeyPadProgPTTModADCgainDisplayGVA5.psm
 TXFreqLSB          13'd         KeyPadProgPTTModADCgainDisplayGVA5.psm
 TouchUpLevel       0'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 TouchDownLevel     1'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 TouchSelectLevel   2'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 TX_F_MSB           3'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 TX_F_LSB           4'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 RX_F_MSB           5'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 RX_F_LSB           6'd          KeyPadProgPTTModADCgainDisplayGVA5.psm
 Freq2Set           7'd          KeyPadProgPTTModADCgainDisplayGVA5.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "13 Dec 2015"  
 timestamp$        "17:42:21"     



List of line labels

   Label                 Addr  Source PSM File

 * cold_start            000   KeyPadProgPTTModADCgainDisplayGVA5.psm
 * welcome_message       001   KeyPadProgPTTModADCgainDisplayGVA5.psm
 * initialise            008   KeyPadProgPTTModADCgainDisplayGVA5.psm
   loop                  016   KeyPadProgPTTModADCgainDisplayGVA5.psm
 * NotTouchDown          020   KeyPadProgPTTModADCgainDisplayGVA5.psm
   TouchDown             02B   KeyPadProgPTTModADCgainDisplayGVA5.psm
   KeyPressed            036   KeyPadProgPTTModADCgainDisplayGVA5.psm
   TurnOff               04C   KeyPadProgPTTModADCgainDisplayGVA5.psm
   upFreq                04F   KeyPadProgPTTModADCgainDisplayGVA5.psm
   DownFreq              054   KeyPadProgPTTModADCgainDisplayGVA5.psm
   CheckWhichFreq        059   KeyPadProgPTTModADCgainDisplayGVA5.psm
   ClearFreq             066   KeyPadProgPTTModADCgainDisplayGVA5.psm
   SetHeyphoneFreq       069   KeyPadProgPTTModADCgainDisplayGVA5.psm
   SetN2Freq             074   KeyPadProgPTTModADCgainDisplayGVA5.psm
   SetN3_31Freq          07F   KeyPadProgPTTModADCgainDisplayGVA5.psm
   UpdateFreqRegisters   08A   KeyPadProgPTTModADCgainDisplayGVA5.psm
   SetLoop               095   KeyPadProgPTTModADCgainDisplayGVA5.psm
   SetEarth              09B   KeyPadProgPTTModADCgainDisplayGVA5.psm
   DispAntennaInput      0A0   KeyPadProgPTTModADCgainDisplayGVA5.psm
   Displays5             0AE   KeyPadProgPTTModADCgainDisplayGVA5.psm
   Respond2Fifo          0B4   KeyPadProgPTTModADCgainDisplayGVA5.psm
 * Display8              0BA   KeyPadProgPTTModADCgainDisplayGVA5.psm
   Display2              0D5   KeyPadProgPTTModADCgainDisplayGVA5.psm
   SetTxFreq             0FB   KeyPadProgPTTModADCgainDisplayGVA5.psm
   SetRxFreq             100   KeyPadProgPTTModADCgainDisplayGVA5.psm
   SendParamBack         105   KeyPadProgPTTModADCgainDisplayGVA5.psm
   GetFifoChar           108   KeyPadProgPTTModADCgainDisplayGVA5.psm
   Export2User           10E   KeyPadProgPTTModADCgainDisplayGVA5.psm
   Get2Chars             116   KeyPadProgPTTModADCgainDisplayGVA5.psm
   Get2ndChar            11B   KeyPadProgPTTModADCgainDisplayGVA5.psm
   Chars2Byte            121   KeyPadProgPTTModADCgainDisplayGVA5.psm
   Get4bits              12C   KeyPadProgPTTModADCgainDisplayGVA5.psm
   char0_9               131   KeyPadProgPTTModADCgainDisplayGVA5.psm
   Byte2Chars            134   KeyPadProgPTTModADCgainDisplayGVA5.psm
   GetChar               140   KeyPadProgPTTModADCgainDisplayGVA5.psm
   is_0_9                144   KeyPadProgPTTModADCgainDisplayGVA5.psm
 * LCD_space             147   KeyPadProgPTTModADCgainDisplayGVA5.psm
   LCD_setup             14A   KeyPadProgPTTModADCgainDisplayGVA5.psm
 * LCD_clear             15A   KeyPadProgPTTModADCgainDisplayGVA5.psm
   LCD_home              162   KeyPadProgPTTModADCgainDisplayGVA5.psm
 * LCD_light_on          166   KeyPadProgPTTModADCgainDisplayGVA5.psm
 * LCD_light_off         169   KeyPadProgPTTModADCgainDisplayGVA5.psm
 * LCD_line_2            16C   KeyPadProgPTTModADCgainDisplayGVA5.psm
 * LCD_cursor_advance    170   KeyPadProgPTTModADCgainDisplayGVA5.psm
 * LCD_cursor_back       174   KeyPadProgPTTModADCgainDisplayGVA5.psm
   LCD_position_cursor   178   KeyPadProgPTTModADCgainDisplayGVA5.psm
   LCD_control_write     17C   KeyPadProgPTTModADCgainDisplayGVA5.psm
   LCD_character_write   180   KeyPadProgPTTModADCgainDisplayGVA5.psm
   LCD_enable_pulse      184   KeyPadProgPTTModADCgainDisplayGVA5.psm
   delay_1s              18B   KeyPadProgPTTModADCgainDisplayGVA5.psm
   wait_1s               18D   KeyPadProgPTTModADCgainDisplayGVA5.psm
 * delay_300ms           195   KeyPadProgPTTModADCgainDisplayGVA5.psm
 * delay_200ms           196   KeyPadProgPTTModADCgainDisplayGVA5.psm
   delay_100ms           199   KeyPadProgPTTModADCgainDisplayGVA5.psm
   wait_100ms            19A   KeyPadProgPTTModADCgainDisplayGVA5.psm
   delay_1ms             19E   KeyPadProgPTTModADCgainDisplayGVA5.psm
   wait_1ms              1A0   KeyPadProgPTTModADCgainDisplayGVA5.psm
   delay_50us            1A8   KeyPadProgPTTModADCgainDisplayGVA5.psm
   wait_50us             1A9   KeyPadProgPTTModADCgainDisplayGVA5.psm
   delay_1us             1AD   KeyPadProgPTTModADCgainDisplayGVA5.psm
   wait_1us              1AE   KeyPadProgPTTModADCgainDisplayGVA5.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            106
 STAR              -

 AND              11
 OR                4
 XOR               1

 ADD               8
 ADDCY             2
 SUB               7
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          26
 COMPARECY         -

 SL0               4
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               4
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT            21
 OUTPUT           22
 OUTPUTK           -

 STORE             7
 FETCH             7

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             22
 JUMP@             -
 CALL            130
 CALL@             -
 RETURN           43
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
