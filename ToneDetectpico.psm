;GV?? first tone detect





CONSTANT    delay_1us_constant,       06                  ; Value (13)19 or 12? decimal suitable for 50MHz clock – about 6 for 33MHz?
CONSTANT	m,						8'd                   ; No. of iterations for cordic
CONSTANT	m_plus_1,				9'd                   ; No. of iterations for cordic
CONSTANT	count_1000_lsb,			E8                 	  ; lower 8-bits of 1000 count value
CONSTANT	count_1000_msb,			03                    ; upper 8-bits of 1000 count value
CONSTANT	half_pi_LSB,			00                     ; 
CONSTANT	half_pi_MSB,		 	40                    ; 360 degrees = $10000


;not sure about these (Aug2016)
CONSTANT	audioTest,				2'd                   ; Frequency 2=800Hz, 3=1200Hz, 4=1.6kHz 7=2.8kHz

;Frequency values for start and stop tones
CONSTANT	StrtToneAInc,			9F
CONSTANT	StrtToneBInc,			69
CONSTANT	StopToneAInc,			5A
CONSTANT	StopToneBInc,			78



; Registers
NAMEREG		sF, SampleCounter            ;
NAMEREG		sE, TempScratchPointer

; registers sA-sD are used for longish term storage...!
; sA used for cordic calcs 

; Scratch pad
; registers 0-8 used for cordic table:
; reg 0=45degrees
; ..
; reg 7=0.44761degrees

; Input port
CONSTANT	AudioMSB,		0'd		;Not used?
CONSTANT	AudioLSB,		1'd
CONSTANT	Strobe,			2'd                   ; 	   bit0=8kHz square wave - the rest are now zeros
CONSTANT	Not used,		3'd                   ; TBD
CONSTANT	DemodMSB,		4'd                   ; Top significant byte of multiplier output
CONSTANT	DemodLSB,		5'd                   ; (only 16 bits retained)

CONSTANT	Status,			6'd				  ;TBdefined
CONSTANT	TBD,			7'd				  ;TBdefined



; Output ports

CONSTANT	CMD2USER,		0'd
CONSTANT	LOMSB,			1'd
CONSTANT	LOLSB,			2'd



; Scratchpad registers
; 0-8 used for Cordic Table!

;Now various pointers to create start and stop tones

CONSTANT	AVEtoneAmp,	9'd	;Is this needed?

CONSTANT	STRTAinc,	10'd	;This is the base address loaded into s0 before calling 'TreatTone'
CONSTANT	STRTAptrMSB,	11'd	;16 bit value used to generate the LUT ptr - won't use these names, just documented for reference
CONSTANT	STRTAptrLSB,	12'd	
CONSTANT	STRTAAccuDemodIMSB,	13'd	;This is the 16 bit value returned from the mulitplier
CONSTANT	STRTAAccuDemodILSB,	14'd	;Will this byte be used?
CONSTANT	STRTAAccuDemodQMSB,	15'd	;This is th e 16 bit value of the demod component accumulated
CONSTANT	STRTAAccuDemodQLSB,	16'd
CONSTANT	STRTApreviousPhase	17'd	;8 bit value of the previous phase determined by the cordic
CONSTANT	STRTAcounter,	18'd		;Counter to determine number of succesive 8ms periods that delta phase is less than phasethreshold (reset to zero if not)	

CONSTANT	STRTBinc,	20'd
;etc
CONSTANT	STPAinc,	30'd	

CONSTANT	STPBinc,	40'd
;uses up to Scratch register 49'd





cold_start:         LOAD      s0, 255'd             ; phase for 45 degrees- actually a bit less!
                    STORE     s0, 00
                    LOAD      s0, 151'd             ; phase for 26.565 degrees
                    STORE     s0, 01
                    LOAD      s0, 80'd              ; phase for 14.036 degrees
                    STORE     s0, 02
                    LOAD      s0, 41'd              ; phase for 7.125 degrees
                    STORE     s0, 03
                    LOAD      s0, 20'd              ; phase for 3.576 degrees
                    STORE     s0, 04
                    LOAD      s0, 10'd              ; phase for 1.79 degrees
                    STORE     s0, 05
                    LOAD      s0, 5'd               ; phase for 0.895 degrees
                    STORE     s0, 06
                    LOAD      s0, 3'd               ; phase for 0.448 degrees
                    STORE     s0, 07
                    LOAD      s0, 1'd               ; phase for 0.224 degrees
                    STORE     s0, 08
                    
		    LOAD      s0, StrtToneAInc               ; Tone increments to detect
                    STORE     s0, STRTAinc
		    LOAD      s0, StrtToneBInc               ; Tone increments to detect
                    STORE     s0, STRTBinc
		    LOAD      s0, StopToneAInc               ; Tone increments to detect
                    STORE     s0, STPAinc
		    LOAD      s0, StopToneBInc               ; Tone increments to detect
                    STORE     s0, STPBinc
                    



; Routine to look at lowest bit of Strobe to detect rising edge.
AwaitAudioVal:	  	INPUT     s0, Strobe
                    AND       s0, 01               ; look only at lowest bit
                    COMPARE   s0, 01
                    JUMP      Z, AwaitAudioVal    ; if 1 wait...
AwaitRise:          INPUT     s0, Strobe
                    AND       s0, 01               ; look only at lowest bit
                    COMPARE   s0, 00
                    JUMP      Z, AwaitRise        ; if 0 still, wait a bit more...



 					
 		ADD  SampleCounter,1	;increment counter		
 ;start treating StrtToneA
		LOAD s0,STRTAinc
		LOAD s1,0	(counter value when mature)
		CALL DemodulateTone

;now check if the accumulation has matured and then do cordic
			


 ;start treating StrtToneB

 ;start treating StpToneA

 ;start treating StpToneB



                JUMP      AwaitAudioVal

; -------------This is end of main loop--------------------------------


;Accumulate and demodulate routine
;Enter with mature index in s1 (0-63 to stagger output to the UART) and the scratch base address to treat in s0 - this is the scratch
;address for the toneinc

DemodulateTone:		FETCH s2,s0	;Tone increment (pointed to in scratch by s0, to increment through sine wave LUT)
			LOAD s3,00
;Need to right shift into s3 to scale correctly
			SRX  s2
			SRA  s3		;and carry containing lowest bit
			SRX  s2
			SRA  s3		;and carry containing lowest bit (doing this twice limits highest frequency to about 2kHz)
			
			ADD  s0,01
			FETCH s4,s0	;MSB of LUTptr
			ADD  s0,01
			FETCH s5,s0	;LSB of LUTptr
			ADD  s5,s3	;increment LUTptr
			ADDC s4,s2	;increment LUTptr
			STORE s5,s0	;update LSB LUTptr
			SUB s0,01	;decrement scratch pointer s0
			STORE s4,s0	;update MSB LUTptr
			OUTPUT s4,LOMSB
			OUTPUT s5,LOLSB ;Send next sinewave address to LUT - use write of LSB to delay trigger latch of multiplier
			INPUT	s2,DemodMSB	;input previous LO tone multiplied by the signal (for accumulation)
			INPUT	s3,DemodLSB
			ADD s0,02	;move back up to scratch pointer location for MSB of I accumulating signal (of previous tone!)
			FETCH s6,s0	;MSB of Accumulated I demod value
			ADD  s0,01
			FETCH s7,s0	;LSB of Accumulated I demod value (base + 4)
			ADD  s7,s3	;signed accumulate into Accumulated value
			ADDC s6,s2	;accumulate into Accumulated value
			STORE s7,s0	;update LSB Accumulated value
			SUB s0,01	;decrement scratch pointer s0
			STORE s6,s0	;update MSB Accumulated value
			STORE s0,TempScratchPointer	;temporarily store pointer to MSB of accumulated I value
;s4 and s5 still have LUTptr to add pi/2
			ADD s4,64'd
			OUTPUT s4,LOMSB
			OUTPUT s5,LOLSB ;Send next sinewave address to LUT - use write of LSB to delay trigger latch of multiplier
			INPUT	s2,DemodMSB	;input previous LO tone multiplied by the signal (for accumulation)
			INPUT	s3,DemodLSB
			ADD s0,02	;move back up to scratch pointer location for Q MSB of accumulating signal (of previous tone!)
			FETCH s6,s0	;MSB of Accumulated Q demod value
			ADD  s0,01
			FETCH s7,s0	;LSB of Accumulated Q demod value (base + 6)
			ADD  s7,s3	;signed accumulate into Accumulated value
			ADDC s6,s2	;accumulate into Accumulated value
			STORE s7,s0	;update LSB Accumulated value
			SUB s0,01	;decrement scratch pointer s0 (s0 now at base + 5)
			STORE s6,s0	;update MSB Accumulated value
			CALL CheckMatureAndOuput
			RETURN

;Checks s1 is mature
CheckMatureAndOutput:	LOAD	s3,SampleCounter
			AND	s3,3f	;mod 64
			COMPARE s3,s1
			CALL Z,Matured	;OK to do cordic and output

			RETURN

;Cordic takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
; Useable range is for I and Q up to about +/-$3000
;normally get I and Q values from scratch. Scratch pointer
Matured:		FETCH s1,TempScratchPointer	;pointer at MSB of I accumulated
			ADD  TempScratchPointer,1 	;move pointer on to LSB of I accumulated
			FETCH s0,TempScratchPointer
			ADD  TempScratchPointer,1 	;move pointer on to MSB of Q accumulated
			FETCH s3,TempScratchPointer
			ADD  TempScratchPointer,1 	;move pointer on to LSB of Q accumulated
			FETCH s2,TempScratchPointer
			CALL CORDIC
;now have amplitude and phase in s0/s1...s4,s5.
			

			RETURN		

;Takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
; Useable range is for I and Q up to about +/-$3000	
;Get registers loaded with I & Q values for cordic




;Does 16 bit signed accumulation of 8 bit signed value in s1 into s4/s5 which are recoverred from scratch pad pointed to by s2 (loading here the offset to the actual tone
;dependent on how many times round the loop we are)
DoAccumulate:	 ADD   s2,s6
				 FETCH s4,(s2)			;Now Get AveSToneLSB_Is in s4 etc...
				 SUB   s2,01				;step back to MSB
				 FETCH s5,(s2)			;Get AveSToneMSB_Is in s5
				 LOAD  s3,FF			;Assume s1 is negative and use s3 for sign extension
				 COMPARE  s1,128'd			;if s1 is 128 or bigger, then it is negative (carry not set)
				 JUMP  NC,negaccum
				 LOAD  s3,00		  		;sign extend with zeros
negaccum:		 ADD   s4,s1			;Accumulate into averageLsB
				 ADDCY s5,s3				;do carry to add into upper byte (keeping carry from previous add!!)
				 LOAD  s0,s5
				 SRX   s0
				 SRX   s0					;reduce value to subtract by factor 4 to increase integration time constant and gain.	
				 ADDCY s0,00					;round up if necessary 		   	  		
				 SUB   s4,s0
				 LOAD  s3,FF			;Assume s5 is negative and use s3 for sign extension				
				 COMPARE  s5,128'd				;is this a negative number?
				 JUMP  NC,negdecrmnt
				 LOAD  s3,00					;do this if s5 is positive (sign extension)
negdecrmnt:		 SUB   s4,s0
				 SUBCY s5,s3				;subtract 1/256						
				 STORE s5,(s2)
				 ADD   s2,01				;move down to LSB again
				 STORE s4,(s2)			;update scratchpad values   	
				 RETURN





; This TBD, should output 16 bit value, that goes through a sinewave LUT and multiplies by the signal and recover
LUTandMultiply:             OUTPUT    s1, LOMSB
                    OUTPUT    s0, LOLSB       ; Historical signal sent to multiplier

                    INPUT     s9, DemodMSB		;actually gets previously latched multiply corresponding to previous tone!
                    INPUT     s8, DemodLSB
                    RETURN       






; CORDIC  Takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
; Useable range is for I and Q up to about +/-$3000

cordic:	  	    LOAD      s4, 00
                    LOAD      s5, 00

                    COMPARE   s1, 128'd
                    CALL      NC, rotate90        ; if I negative then need to bring back into RH 2 quadrants.
; now enter loop

                    LOAD      s8, 00              ; counter of times to iterate.
cordicloop:         LOAD      s7, s1              ; temporary store for I
                    LOAD      s6, s0              ; temp store

                    COMPARE   s3, 128'd           ; is Q negative?
                    JUMP      NC, posrotate       ; if negative rotate positive
negrotate:          LOAD      sA, s2
                    LOAD      sB, s3              ; put Q into working registers
                    CALL      shift               ; shift Q by the amount in s8
                    ADD       s0, sA              ; add shifted Q to I
                    ADDCY     s1, sB
                    LOAD      sA, s6              ; prepare working registers (sA,sB) with original value of I
                    LOAD      sB, s7
                    CALL      shift
                    SUB       s2, sA
                    SUBCY     s3, sB
                    CALL      GetPhaseIncrement
                    SUB       s4, sA
                    SUBCY     s5, sB
                    JUMP      testcordicend
posrotate:          LOAD      sA, s2
                    LOAD      sB, s3              ; put Q into working registers
                    CALL      shift               ; shift Q by the amount in s8
                    SUB       s0, sA              ; add shifted Q to I
                    SUBCY     s1, sB
                    LOAD      sA, s6              ; prepare working registers with original value of I
                    LOAD      sB, s7
                    CALL      shift
                    ADD       s2, sA
                    ADDCY     s3, sB
                    CALL      GetPhaseIncrement
                    ADD       s4, sA
                    ADDCY     s5, sB
testcordicend:      ADD       s8, 01
                    COMPARE   s8, m_plus_1 		;m + 1
                    JUMP      C, cordicloop
                    RETURN       

; routine to lookup from the cordic look up table (scratchpad), the phase increment - stored as 8 bits at the location pointed to be s8, returned as 16 bits in sA and sB
; sB is MSB
GetPhaseIncrement:  FETCH     sB, (s8)
                    SR0       sB
                    SRA       sA
                    SR0       sB
                    SRA       sA
                    SR0       sB
                    SRA       sA                  ; This multiplies the 8 bit stored value by 32 so that max scratchpad value 255->255*32 equivalent to 44.82degrees
                    RETURN       

shift:              LOAD      s9, s8
shiftloop:          COMPARE   s9, 00
                    RETURN    Z
                    SUB       s9, 01
                    SRX       sB
                    SRA       sA
                    JUMP      shiftloop



rotate90:           LOAD      s7, s1              ; temporary store for I
                    LOAD      s6, s0              ; temp store

                    COMPARE   s3, 128'd           ; is Q negative?
                    JUMP      NC, add90           ; if negative add 90
sub90:              LOAD      s1, s3
                    LOAD      s0, s2              ; I=Q
                    LOAD      s2, 00
                    LOAD      s3, 00

                    SUB       s2, s6
                    SUBCY     s3, s7              ; Q=-I
                    SUB       s4, half_pi_LSB
                    SUBCY     s5, half_pi_MSB
                    RETURN       

add90:              LOAD      s1, 00
                    LOAD      s0, 00
                    SUB       s0, s2
                    SUBCY     s1, s3              ; I=-Q

                    LOAD      s2, s6
                    LOAD      s3, s7              ; Q=I
                    LOAD      s4, half_pi_LSB
                    LOAD      s5, half_pi_MSB
                    RETURN       

Transmitmode:       FETCH     s1, State
                    OR        s1, 02
                    STORE     s1, State           ; set bit 1
                    
                    FETCH      s1,AGCvalue
                    STORE	  s1,AGCvalueRX
                    FETCH	  s1,AGCvalueTX		  ;recovers last used value for AGCvalur in this mode
                    STORE      s1,AGCvalue
                    RETURN       

					



; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
Chars2Byte:         LOAD      s8, s6
                    CALL      Get4bits
                    LOAD      s5, s8
                    SL0       s5
                    SL0       s5
                    SL0       s5
                    SL0       s5                  ; put these 4 bits to MSBs
                    LOAD      s8, s7
                    CALL      Get4bits
                    ADD       s5, s8
                    RETURN       

; This routine takes an ascii code in s8 and returns a 4 bit value in s8
Get4bits:           COMPARE   s8, 60'd           ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
                    JUMP      C, char0_9
                    SUB       s8, 55'd            ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
                    AND       s8, 0F             ; make sure only return 4 bits
                    RETURN       

char0_9:            SUB       s8, 48'd
                    AND       s8, 0F             ; make sure only return 4 bits
                    RETURN      


; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
Byte2Chars:         LOAD      s8, s5              ; assumes 8 bit data is in s5

                    SR0       s5
                    SR0       s5
                    SR0       s5
                    SR0       s5                  ; get first hex character
                    CALL      GetChar
                    LOAD      s6, s5              ; first ascii char
                    LOAD      s5, s8
                    AND       s5, 0F
                    CALL      GetChar             ; send to LCD or UART
                    LOAD      s7, s5              ; second ascii char
                    RETURN       

; routine to convert 4bit value in s5 to an ascii code, returned in s5
GetChar:            SUB       s5, 10'd            ; Test if s5 greater than 9
                    JUMP      C, is_0_9           ; Hex character is 0_9
                    ADD       s5, 65'd            ; offset for Ascii code 'A'
                    RETURN       
is_0_9:             ADD       s5, 10'd            ; return to range 0-9
                    ADD       s5, 48'd            ; offset to Ascii code for '0'
                    RETURN       






; Registers used s0, s1, s2, s3, s4 and s5.
; 
delay_1s:           LOAD      s5, 00               ; clear cycle counter
                    LOAD      s4, 00
wait_1s:            CALL      delay_1ms
                    ADD       s4, 01               ; increment cycle counter
                    ADDCY     s5, 00
                    COMPARE   s4, count_1000_lsb  ; test for 1000ms
                    JUMP      NZ, wait_1s
                    COMPARE   s5, count_1000_msb
                    JUMP      NZ, wait_1s
                    RETURN       
; 
; Delays of approximately 200ms and 300ms used for LCD display scrolling
; 
; 
; Registers used s0, s1, s2, s3 and s4.
; 
delay_300ms:        CALL      delay_100ms
delay_200ms:        CALL      delay_100ms
                    CALL      delay_100ms
                    RETURN       
; 
; Delay of approximately 100ms used for switch debounce
; 
; Registers used s0, s1, s2, s3 and s4.
; 
delay_100ms:        LOAD      s4, 64             ; repeat 1ms delay 100 times
wait_100ms:         CALL      delay_1ms
                    SUB       s4, 01
                    JUMP      NZ, wait_100ms
                    RETURN       
; 
; Delay of approximately 1ms required by LCD display
; 
; Registers used s0, s1, s2 and s3.
; 
delay_1ms:          LOAD      s3, 00               ; clear cycle counter
                    LOAD      s2, 00
wait_1ms:           CALL      delay_1us
                    ADD       s2, 01               ; increment cycle counter
                    ADDCY     s3, 00
                    COMPARE   s2, count_1000_lsb  ; test for 1000us
                    JUMP      NZ, wait_1ms
                    COMPARE   s3, count_1000_msb
                    JUMP      NZ, wait_1ms
                    RETURN       
; 
; Delay of approximately 50us required by LCD display
; 
; Registers used s0 and s1.
; 
delay_50us:         LOAD      s1, 50'd            ; repeat 1us delay 50 times
wait_50us:          CALL      delay_1us
                    SUB       s1, 01
                    JUMP      NZ, wait_50us
                    RETURN       

; Delay of approximately 1us used to provide timing reference for
; LCD operations. This must be adjusted to reflect the clock
; applied to KCPSM3. The provided code is for a 50MHz clock rate.
; 
; The software delay loop is formed using register s0. This register
; must be loaded with an integer value close to the result of....
; 
; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
; 
; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
; For clock rates below 8MHz the value of 1 must be used and the I2C bus
; operation will become lower than the 100KHz target intended.
; 
; Register used s0.
; 

delay_1us:          LOAD      s0, delay_1us_constant; delay value of 12 decimal for a 50MHz clock
wait_1us:           SUB       s0, 01
                    JUMP      NZ, wait_1us
                    RETURN       
; 
; 


