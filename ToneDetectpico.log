KCPSM6 Assembler log file for program 'C:\Users\gnaylor.CCFEPC\Dropbox\N3workingG\TE0722Rebuild\N3SysGen\ToneDetectpico.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 18 Nov 2016
Assembly timestamp: 09:45:28

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 166 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 359
Memory locations available: 3737


Assembly listing

 Addr Code                         Instruction

 000                               ;GV?? first tone detect
 000                               CONSTANT delay_1us_constant, 06           ; Value (13)19 or 12? decimal suitable for 50MHz clock – about 6 for 33MHz?
 000                               CONSTANT m, 8'd                           ; No. of iterations for cordic
 000                               CONSTANT m_plus_1, 9'd                    ; No. of iterations for cordic
 000                               CONSTANT count_1000_lsb, E8               ; lower 8-bits of 1000 count value
 000                               CONSTANT count_1000_msb, 03               ; upper 8-bits of 1000 count value
 000                               CONSTANT half_pi_LSB, 00                  ;
 000                               CONSTANT half_pi_MSB, 40                  ; 360 degrees = $10000
 000                               CONSTANT phase_threshold, 30'd            ;test for phase fairly constant
 000                               CONSTANT count_value_to_trig, 08'd        ;if low phase 8 succesive times, then this is significant!
 000                               ;not sure about these (Aug2016)
 000                               CONSTANT audioTest, 2'd                   ; Frequency 2=800Hz, 3=1200Hz, 4=1.6kHz 7=2.8kHz
 000                               ;Frequency values for start and stop tones
 000                               CONSTANT StrtToneAInc, 9F
 000                               CONSTANT StrtToneBInc, 69
 000                               CONSTANT StopToneAInc, 5A
 000                               CONSTANT StopToneBInc, 78
 000                               ; Registers
 000                               NAMEREG sF, SampleCounter                 ;
 000                               NAMEREG sE, TempScratchPointer
 000                               ; registers sA-sD are used for longish term storage...!
 000                               ; sA used for cordic calcs
 000                               ; Scratch pad
 000                               ; registers 0-8 used for cordic table:
 000                               ; reg 0=45degrees
 000                               ; ..
 000                               ; reg 7=0.44761degrees
 000                               ; Input port
 000                               CONSTANT AudioMSB, 0'd                    ;Not used?
 000                               CONSTANT AudioLSB, 1'd
 000                               CONSTANT Strobe, 2'd                      ;     bit0=8kHz square wave - the rest are now zeros
 000                               CONSTANT DemodMSB, 3'd                    ; Top significant byte of multiplier output
 000                               CONSTANT DemodLSB, 4'd                    ; (only 16 bits retained)
 000                               CONSTANT Status, 6'd                      ;TBdefined
 000                               CONSTANT TBD, 7'd                         ;TBdefined
 000                               ; Output ports
 000                               CONSTANT CmdToUser, 0'd
 000                               CONSTANT LOMSB, 1'd
 000                               CONSTANT BRAMaddrMSB, 2'd
 000                               CONSTANT BRAMaddrLSB, 3'd
 000                               ;also used:8,9,13,14,18,19,23,24 -  8 STRTA,13  STRTB ,18 STPA or 23  STPB, and 9 STRTA,14  STRTB ,19 STPA or 24  STPB
 000                               ; Scratchpad registers
 000                               ; 0-8 used for Cordic Table!
 000                               ;Now various pointers to create start and stop tones
 000                               CONSTANT AVEtoneAmp, 9'd                  ;Is this needed?
 000                               CONSTANT STRTAinc, 10'd                   ;This is the base address loaded into s0 before calling 'TreatTone'
 000                               CONSTANT STRTAptrMSB, 11'd                ;16 bit value used to generate the LUT ptr - won't use these names, just documented for reference
 000                               CONSTANT STRTAptrLSB, 12'd
 000                               CONSTANT STRTAAccuDemodIMSB, 13'd         ;This is the 16 bit value returned from the mulitplier
 000                               CONSTANT STRTAAccuDemodILSB, 14'd         ;Will this byte be used?
 000                               CONSTANT STRTAAccuDemodQMSB, 15'd         ;This is th e 16 bit value of the demod component accumulated
 000                               CONSTANT STRTAAccuDemodQLSB, 16'd
 000                               CONSTANT STRTApreviousPhase, 17'd         ;8 bit value of the previous phase determined by the cordic
 000                               CONSTANT STRTAcounter, 18'd               ;Counter to determine number of succesive 8ms periods that delta phase is less than phasethreshold (reset to zero if not)
 000                               CONSTANT STRTBinc, 20'd
 000                               ;etc
 000                               CONSTANT STPAinc, 30'd
 000                               CONSTANT STPBinc, 40'd
 000                               ;uses up to Scratch register 49'd
 000                               CONSTANT SampleCounterMSB, 50'd           ;So as to have a 16 bit sample counter
 000  010FF            cold_start: LOAD s0, FF[255'd]                        ; phase for 45 degrees- actually a bit less!
 001  2F000                        STORE s0, 00
 002  01097                        LOAD s0, 97[151'd]                        ; phase for 26.565 degrees
 003  2F001                        STORE s0, 01
 004  01050                        LOAD s0, 50[80'd]                         ; phase for 14.036 degrees
 005  2F002                        STORE s0, 02
 006  01029                        LOAD s0, 29[41'd]                         ; phase for 7.125 degrees
 007  2F003                        STORE s0, 03
 008  01014                        LOAD s0, 14[20'd]                         ; phase for 3.576 degrees
 009  2F004                        STORE s0, 04
 00A  0100A                        LOAD s0, 0A[10'd]                         ; phase for 1.79 degrees
 00B  2F005                        STORE s0, 05
 00C  01005                        LOAD s0, 05[5'd]                          ; phase for 0.895 degrees
 00D  2F006                        STORE s0, 06
 00E  01003                        LOAD s0, 03[3'd]                          ; phase for 0.448 degrees
 00F  2F007                        STORE s0, 07
 010  01001                        LOAD s0, 01[1'd]                          ; phase for 0.224 degrees
 011  2F008                        STORE s0, 08
 012  0109F                        LOAD s0, 9F[StrtToneAInc]                 ; Tone increments to detect
 013  2F00A                        STORE s0, 0A[STRTAinc]
 014  01069                        LOAD s0, 69[StrtToneBInc]                 ; Tone increments to detect
 015  2F014                        STORE s0, 14[STRTBinc]
 016  0105A                        LOAD s0, 5A[StopToneAInc]                 ; Tone increments to detect
 017  2F01E                        STORE s0, 1E[STPAinc]
 018  01078                        LOAD s0, 78[StopToneBInc]                 ; Tone increments to detect
 019  2F028                        STORE s0, 28[STPBinc]
 01A                               ; Routine to look at lowest bit of Strobe to detect rising edge.
 01A  09002         AwaitAudioVal: INPUT s0, 02[Strobe]
 01B  03001                        AND s0, 01                                ; look only at lowest bit
 01C  1D001                        COMPARE s0, 01
 01D  3201A                        JUMP Z, 01A[AwaitAudioVal]                ; if 1 wait...
 01E  09002             AwaitRise: INPUT s0, 02[Strobe]
 01F  03001                        AND s0, 01                                ; look only at lowest bit
 020  1D000                        COMPARE s0, 00
 021  3201E                        JUMP Z, 01E[AwaitRise]                    ; if 0 still, wait a bit more...
 022  2DF03                        OUTPUT sF[SampleCounter], 03[BRAMaddrLSB] ;send to BRAM address and initiate write
 023  0B032                        FETCH s0, 32[SampleCounterMSB]
 024  11F01                        ADD sF[SampleCounter], 01                 ;increment counter
 025  13000                        ADDCY s0, 00
 026  2F032                        STORE s0, 32[SampleCounterMSB]            ;increment MSB
 027  2D002                        OUTPUT s0, 02[BRAMaddrMSB]                ;And send to BRAM address ready for LSB to be sent and initiate write
 028                               ;start treating StrtToneA
 028  0100A            StartDemod: LOAD s0, 0A[STRTAinc]
 029  01100                        LOAD s1, 00                               ;(counter value when mature)
 02A  20035                        CALL 035[DemodulateTone]                  ;and checks if the accumulation has matured (from s1) and if so do cordic
 02B                               ;start treating StrtToneB
 02B  01014                        LOAD s0, 14[STRTBinc]
 02C  01116                        LOAD s1, 16                               ;(counter value when mature)
 02D  20035                        CALL 035[DemodulateTone]
 02E                               ;start treating StpToneA
 02E  0101E                        LOAD s0, 1E[STPAinc]
 02F  01132                        LOAD s1, 32                               ;(counter value when mature)
 030  20035                        CALL 035[DemodulateTone]
 031                               ;start treating StpToneB
 031  01028                        LOAD s0, 28[STPBinc]
 032  01148                        LOAD s1, 48                               ;(counter value when mature)
 033  20035                        CALL 035[DemodulateTone]
 034  2201A                        JUMP 01A[AwaitAudioVal]
 035                               ; -------------This is end of main loop--------------------------------
 035                               ;Accumulate and demodulate routine
 035                               ;Enter with mature index in s1 (0-63 to stagger output to the UART) and the scratch base address to treat in s0 - this is the scratch
 035                               ;address for the toneinc
 035  0A200        DemodulateTone: FETCH s2, (s0)                            ;Tone increment (pointed to in scratch by s0, to increment through sine wave LUT)
 036  01300                        LOAD s3, 00
 037                               ;Need to right shift into s3 to scale correctly (as they are 4 times too big)
 037  1420A                        SRX s2
 038  14308                        SRA s3                                    ;and carry containing lowest bit
 039  1420A                        SRX s2
 03A  14308                        SRA s3                                    ;and carry containing lowest bit (doing this twice limits highest frequency to about 2kHz)
 03B  11001                        ADD s0, 01
 03C  0A400                        FETCH s4, (s0)                            ;MSB of LUTptr
 03D  11001                        ADD s0, 01
 03E  0A500                        FETCH s5, (s0)                            ;LSB of LUTptr
 03F  10530                        ADD s5, s3                                ;increment LUTptr
 040  12420                        ADDCY s4, s2                              ;increment LUTptr
 041  2E500                        STORE s5, (s0)                            ;update LSB LUTptr
 042  19001                        SUB s0, 01                                ;decrement scratch pointer s0
 043  2E400                        STORE s4, (s0)                            ;update MSB LUTptr
 044                               ;           OUTPUT s5,LOLSB ;Send next sinewave address to LUT
 044  2D401                        OUTPUT s4, 01[LOMSB]                      ;Actually only need to output MSB  - use write of MSB to delay trigger latch of multiplier
 045  200B8                        CALL 0B8[waitabit]
 046                               ;NEED To wait for multiplication otherwise cordic will be out of step
 046  09203                        INPUT s2, 03[DemodMSB]                    ;input previous LO tone multiplied by the signal (for accumulation)
 047  09304                        INPUT s3, 04[DemodLSB]
 048  11002                        ADD s0, 02                                ;move back up to scratch pointer location for MSB of I accumulating signal (of previous tone!)
 049  0A600                        FETCH s6, (s0)                            ;MSB of Accumulated I demod value
 04A  11001                        ADD s0, 01
 04B  0A700                        FETCH s7, (s0)                            ;LSB of Accumulated I demod value (base + 4)
 04C  10730                        ADD s7, s3                                ;signed accumulate into Accumulated value
 04D  12620                        ADDCY s6, s2                              ;accumulate into Accumulated value
 04E  2E700                        STORE s7, (s0)                            ;update LSB Accumulated value
 04F  19001                        SUB s0, 01                                ;decrement scratch pointer s0
 050  2E600                        STORE s6, (s0)                            ;update MSB Accumulated value
 051  00E00                        LOAD sE[TempScratchPointer], s0           ;temporarily store pointer to MSB of accumulated I value
 052                               ;s4 and s5 still have LUTptr to add pi/2
 052  11440                        ADD s4, 40[64'd]
 053                               ;    OUTPUT s5,LOLSB ;Send next sinewave address to LUT -  already done!
 053  2D401                        OUTPUT s4, 01[LOMSB]                      ;Actually only need to output MSB  - use write of MSB to delay trigger latch of multiplier
 054  200B8                        CALL 0B8[waitabit]
 055                               ;NEED To wait for multiplication otherwise cordic will be out of step
 055  09203                        INPUT s2, 03[DemodMSB]                    ;input previous LO tone multiplied by the signal (for accumulation)
 056  09304                        INPUT s3, 04[DemodLSB]
 057  11002                        ADD s0, 02                                ;move back up to scratch pointer location for Q MSB of accumulating signal (of previous tone!)
 058  0A600                        FETCH s6, (s0)                            ;MSB of Accumulated Q demod value
 059  11001                        ADD s0, 01
 05A  0A700                        FETCH s7, (s0)                            ;LSB of Accumulated Q demod value (base + 6)
 05B  10730                        ADD s7, s3                                ;signed accumulate into Accumulated value
 05C  12620                        ADDCY s6, s2                              ;accumulate into Accumulated value
 05D  2E700                        STORE s7, (s0)                            ;update LSB Accumulated value
 05E  19001                        SUB s0, 01                                ;decrement scratch pointer s0 (s0 now at base + 5)
 05F  2E600                        STORE s6, (s0)                            ;update MSB Accumulated value
 060  20062                        CALL 062[CheckMatureAndOutput]
 061  25000                        RETURN 
 062                               ;Checks s1 is mature
 062  003F0  CheckMatureAndOutput: LOAD s3, sF[SampleCounter]
 063  0333F                        AND s3, 3F                                ;mod 64
 064  1C310                        COMPARE s3, s1
 065  30067                        CALL Z, 067[Matured]                      ;OK to do cordic and output
 066  25000                        RETURN 
 067                               ;Cordic takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
 067                               ; Useable range is for I and Q up to about +/-$3000
 067                               ;normally get I and Q values from scratch. Scratch pointer
 067                               ;need to use TempScratchPointer as s0 value which had pointed to the scratch area has been lost
 067  0A1E0               Matured: FETCH s1, (sE[TempScratchPointer])        ;pointer at MSB of I accumulated
 068  11E01                        ADD sE[TempScratchPointer], 01            ;move pointer on to LSB of I accumulated
 069  0A0E0                        FETCH s0, (sE[TempScratchPointer])
 06A  11E01                        ADD sE[TempScratchPointer], 01            ;move pointer on to MSB of Q accumulated
 06B  0A3E0                        FETCH s3, (sE[TempScratchPointer])
 06C  11E01                        ADD sE[TempScratchPointer], 01            ;move pointer on to LSB of Q accumulated
 06D  0A2E0                        FETCH s2, (sE[TempScratchPointer])
 06E  200BC                        CALL 0BC[cordic]
 06F                               ;now have amplitude and phase in s0/s1...s4,s5 - need to calculate phase change and output the MSBs
 06F  00500                        LOAD s5, s0
 070  20110                        CALL 110[Export2User]                     ;send 2 ascii codes for the amplitude MSB to the user
 071  200AF                        CALL 0AF[StreamAmp]
 072  00540                        LOAD s5, s4
 073  20110                        CALL 110[Export2User]                     ;send ascii codes for the phase MSB to the user
 074  200B3                        CALL 0B3[StreamPhase]
 075  1DE46                        COMPARE sE[TempScratchPointer], 46        ;STPBinc+6=46 is the pointer to the LSB of the Q accumulated value that of the stopB tone (ie the last one)
 076  30116                        CALL Z, 116[AddCRLF]                      ;send end of line characters if treating last tone
 077  11E01                        ADD sE[TempScratchPointer], 01            ;move pointer on to previous phase
 078  0A2E0                        FETCH s2, (sE[TempScratchPointer])        ;s2 now has msb of previous phase
 079  18240                        SUB s2, s4                                ;delta phase (signed)
 07A  20109                        CALL 109[absval]                          ;gets absolute value of s2 (phase shift)
 07B  11E01                        ADD sE[TempScratchPointer], 01            ;move pointer on to counter
 07C  0A1E0                        FETCH s1, (sE[TempScratchPointer])        ;s1 has the counter
 07D  11101                        ADD s1, 01
 07E  2E1E0                        STORE s1, (sE[TempScratchPointer])        ;now increment the counter
 07F  1D21E                        COMPARE s2, 1E[phase_threshold]           ;is it less than threshold, then set carry
 080  3C08F                        CALL NC, 08F[resetcounter]                ; if failed then reset the counter
 081  1D108                        COMPARE s1, 08[count_value_to_trig]       ;s1 has phase constant counter, carry not set if count is high enough.
 082  20084                        CALL 084[Whoopie]                         ;seem to have a tone here!
 083  25000                        RETURN 
 084                               ;Ultimately will use TempScratchPointer to work out which tone was detected
 084  20116               Whoopie: CALL 116[AddCRLF]
 085  01659                        LOAD s6, 59["Y"]
 086  2D600                        OUTPUT s6, 00[CmdToUser]
 087  01645                        LOAD s6, 45["E"]
 088  2D600                        OUTPUT s6, 00[CmdToUser]
 089  01653                        LOAD s6, 53["S"]
 08A  2D600                        OUTPUT s6, 00[CmdToUser]
 08B  01621                        LOAD s6, 21["!"]
 08C  2D600                        OUTPUT s6, 00[CmdToUser]
 08D  20116                        CALL 116[AddCRLF]
 08E  25000                        RETURN 
 08F  01100          resetcounter: LOAD s1, 00
 090  2E1E0                        STORE s1, (sE[TempScratchPointer])        ;now set counter to zero
 091  25000                        RETURN 
 092                               ;Takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
 092                               ; Useable range is for I and Q up to about +/-$3000
 092                               ;Get registers loaded with I & Q values for cordic
 092                               ;Does 16 bit signed accumulation of 8 bit signed value in s1 into s4/s5 which are recoverred from scratch pad pointed to by s2 (loading here the offset to the actual tone
 092                               ;dependent on how many times round the loop we are)
 092  10260          DoAccumulate: ADD s2, s6
 093  0A420                        FETCH s4, (s2)                            ;Now Get AveSToneLSB_Is in s4 etc...
 094  19201                        SUB s2, 01                                ;step back to MSB
 095  0A520                        FETCH s5, (s2)                            ;Get AveSToneMSB_Is in s5
 096  013FF                        LOAD s3, FF                               ;Assume s1 is negative and use s3 for sign extension
 097  1D180                        COMPARE s1, 80[128'd]                     ;if s1 is 128 or bigger, then it is negative (carry not set)
 098  3E09A                        JUMP NC, 09A[negaccum]
 099  01300                        LOAD s3, 00                               ;sign extend with zeros
 09A  10410              negaccum: ADD s4, s1                                ;Accumulate into averageLsB
 09B  12530                        ADDCY s5, s3                              ;do carry to add into upper byte (keeping carry from previous add!!)
 09C  00050                        LOAD s0, s5
 09D  1400A                        SRX s0
 09E  1400A                        SRX s0                                    ;reduce value to subtract by factor 4 to increase integration time constant and gain.
 09F  13000                        ADDCY s0, 00                              ;round up if necessary
 0A0  18400                        SUB s4, s0
 0A1  013FF                        LOAD s3, FF                               ;Assume s5 is negative and use s3 for sign extension
 0A2  1D580                        COMPARE s5, 80[128'd]                     ;is this a negative number?
 0A3  3E0A5                        JUMP NC, 0A5[negdecrmnt]
 0A4  01300                        LOAD s3, 00                               ;do this if s5 is positive (sign extension)
 0A5  18400            negdecrmnt: SUB s4, s0
 0A6  1A530                        SUBCY s5, s3                              ;subtract 1/256
 0A7  2E520                        STORE s5, (s2)
 0A8  11201                        ADD s2, 01                                ;move down to LSB again
 0A9  2E420                        STORE s4, (s2)                            ;update scratchpad values
 0AA  25000                        RETURN 
 0AB                               ; This TBD, should output 16 bit value, that goes through a sinewave LUT and multiplies by the signal and recover
 0AB  2D101        LUTandMultiply: OUTPUT s1, 01[LOMSB]
 0AC  09903                        INPUT s9, 03[DemodMSB]                    ;actually gets previously latched multiply corresponding to previous tone!
 0AD  09804                        INPUT s8, 04[DemodLSB]
 0AE  25000                        RETURN 
 0AF  000E0             StreamAmp: LOAD s0, sE[TempScratchPointer]           ;possible values are 16,26,36 and 46
 0B0  1400E                        SR0 s0                                    ;Divide by 0 to get 8 STRTA,13  STRTB ,18 STPA or 23  STPB
 0B1  2C500                        OUTPUT s5, (s0)                           ;direct amplitude MSB to the appropriate port
 0B2  25000                        RETURN 
 0B3  000E0           StreamPhase: LOAD s0, sE[TempScratchPointer]
 0B4  1400E                        SR0 s0
 0B5  11001                        ADD s0, 01                                ;Offset to output phase values get 9 STRTA,14  STRTB ,19 STPA or 24  STPB
 0B6  2C500                        OUTPUT s5, (s0)                           ;direct phase MSB to the appropriate port
 0B7  25000                        RETURN 
 0B8  00220              waitabit: LOAD s2, s2
 0B9  00220                        LOAD s2, s2
 0BA  00220                        LOAD s2, s2                               ;is this long enough?
 0BB  25000                        RETURN 
 0BC                               ; CORDIC  Takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
 0BC                               ; Useable range is for I and Q up to about +/-$3000
 0BC  01400                cordic: LOAD s4, 00
 0BD  01500                        LOAD s5, 00
 0BE  1D180                        COMPARE s1, 80[128'd]
 0BF  3C0F3                        CALL NC, 0F3[rotate90]                    ; if I negative then need to bring back into RH 2 quadrants.
 0C0                               ; now enter loop
 0C0  01800                        LOAD s8, 00                               ; counter of times to iterate.
 0C1  00710            cordicloop: LOAD s7, s1                               ; temporary store for I
 0C2  00600                        LOAD s6, s0                               ; temp store
 0C3  1D380                        COMPARE s3, 80[128'd]                     ; is Q negative?
 0C4  3E0D3                        JUMP NC, 0D3[posrotate]                   ; if negative rotate positive
 0C5  00A20             negrotate: LOAD sA, s2
 0C6  00B30                        LOAD sB, s3                               ; put Q into working registers
 0C7  200EC                        CALL 0EC[shift]                           ; shift Q by the amount in s8
 0C8  100A0                        ADD s0, sA                                ; add shifted Q to I
 0C9  121B0                        ADDCY s1, sB
 0CA  00A60                        LOAD sA, s6                               ; prepare working registers (sA,sB) with original value of I
 0CB  00B70                        LOAD sB, s7
 0CC  200EC                        CALL 0EC[shift]
 0CD  182A0                        SUB s2, sA
 0CE  1A3B0                        SUBCY s3, sB
 0CF  200E4                        CALL 0E4[GetPhaseIncrement]
 0D0  184A0                        SUB s4, sA
 0D1  1A5B0                        SUBCY s5, sB
 0D2  220E0                        JUMP 0E0[testcordicend]
 0D3  00A20             posrotate: LOAD sA, s2
 0D4  00B30                        LOAD sB, s3                               ; put Q into working registers
 0D5  200EC                        CALL 0EC[shift]                           ; shift Q by the amount in s8
 0D6  180A0                        SUB s0, sA                                ; add shifted Q to I
 0D7  1A1B0                        SUBCY s1, sB
 0D8  00A60                        LOAD sA, s6                               ; prepare working registers with original value of I
 0D9  00B70                        LOAD sB, s7
 0DA  200EC                        CALL 0EC[shift]
 0DB  102A0                        ADD s2, sA
 0DC  123B0                        ADDCY s3, sB
 0DD  200E4                        CALL 0E4[GetPhaseIncrement]
 0DE  104A0                        ADD s4, sA
 0DF  125B0                        ADDCY s5, sB
 0E0  11801         testcordicend: ADD s8, 01
 0E1  1D809                        COMPARE s8, 09[m_plus_1]                  ;m + 1
 0E2  3A0C1                        JUMP C, 0C1[cordicloop]
 0E3  25000                        RETURN 
 0E4                               ; routine to lookup from the cordic look up table (scratchpad), the phase increment - stored as 8 bits at the location pointed to be s8, returned as 16 bits in sA and sB
 0E4                               ; sB is MSB
 0E4  0AB80     GetPhaseIncrement: FETCH sB, (s8)
 0E5  14B0E                        SR0 sB
 0E6  14A08                        SRA sA
 0E7  14B0E                        SR0 sB
 0E8  14A08                        SRA sA
 0E9  14B0E                        SR0 sB
 0EA  14A08                        SRA sA                                    ; This multiplies the 8 bit stored value by 32 so that max scratchpad value 255->255*32 equivalent to 44.82degrees
 0EB  25000                        RETURN 
 0EC  00980                 shift: LOAD s9, s8
 0ED  1D900             shiftloop: COMPARE s9, 00
 0EE  31000                        RETURN Z
 0EF  19901                        SUB s9, 01
 0F0  14B0A                        SRX sB
 0F1  14A08                        SRA sA
 0F2  220ED                        JUMP 0ED[shiftloop]
 0F3  00710              rotate90: LOAD s7, s1                               ; temporary store for I
 0F4  00600                        LOAD s6, s0                               ; temp store
 0F5  1D380                        COMPARE s3, 80[128'd]                     ; is Q negative?
 0F6  3E100                        JUMP NC, 100[add90]                       ; if negative add 90
 0F7  00130                 sub90: LOAD s1, s3
 0F8  00020                        LOAD s0, s2                               ; I=Q
 0F9  01200                        LOAD s2, 00
 0FA  01300                        LOAD s3, 00
 0FB  18260                        SUB s2, s6
 0FC  1A370                        SUBCY s3, s7                              ; Q=-I
 0FD  19400                        SUB s4, 00[half_pi_LSB]
 0FE  1B540                        SUBCY s5, 40[half_pi_MSB]
 0FF  25000                        RETURN 
 100  01100                 add90: LOAD s1, 00
 101  01000                        LOAD s0, 00
 102  18020                        SUB s0, s2
 103  1A130                        SUBCY s1, s3                              ; I=-Q
 104  00260                        LOAD s2, s6
 105  00370                        LOAD s3, s7                               ; Q=I
 106  01400                        LOAD s4, 00[half_pi_LSB]
 107  01540                        LOAD s5, 40[half_pi_MSB]
 108  25000                        RETURN 
 109                               ;takes s2 and returns in s2 the absolute value of s2 (uses s6)
 109  1D280                absval: COMPARE s2, 80[128'd]
 10A  3C10C                        CALL NC, 10C[makeposval]
 10B  25000                        RETURN 
 10C                               ; Turn negative value in s2 into a positive one (well will actualy make a positive value negative as well).
 10C  01600            makeposval: LOAD s6, 00
 10D  18620                        SUB s6, s2
 10E  00260                        LOAD s2, s6
 10F  25000                        RETURN 
 110                               ; Takes value in s5 and converts to 2 ascii codes which are sent to the user picoblaze.
 110  2012E           Export2User: CALL 12E[Byte2Chars]
 111  2D600                        OUTPUT s6, 00[CmdToUser]
 112  2D700                        OUTPUT s7, 00[CmdToUser]
 113  01614                        LOAD s6, 14[20'd]                         ; terminate with space character
 114  2D600                        OUTPUT s6, 00[CmdToUser]
 115  25000                        RETURN 
 116  0160D               AddCRLF: LOAD s6, 0D[13'd]                         ; terminate with CR
 117  2D600                        OUTPUT s6, 00[CmdToUser]
 118  0160A                        LOAD s6, 0A[10'd]                         ; and with LF
 119  2D600                        OUTPUT s6, 00[CmdToUser]
 11A  25000                        RETURN 
 11B                               ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 11B  00860            Chars2Byte: LOAD s8, s6
 11C  20126                        CALL 126[Get4bits]
 11D  00580                        LOAD s5, s8
 11E  14506                        SL0 s5
 11F  14506                        SL0 s5
 120  14506                        SL0 s5
 121  14506                        SL0 s5                                    ; put these 4 bits to MSBs
 122  00870                        LOAD s8, s7
 123  20126                        CALL 126[Get4bits]
 124  10580                        ADD s5, s8
 125  25000                        RETURN 
 126                               ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 126  1D83C              Get4bits: COMPARE s8, 3C[60'd]                      ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 127  3A12B                        JUMP C, 12B[char0_9]
 128  19837                        SUB s8, 37[55'd]                          ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 129  0380F                        AND s8, 0F                                ; make sure only return 4 bits
 12A  25000                        RETURN 
 12B  19830               char0_9: SUB s8, 30[48'd]
 12C  0380F                        AND s8, 0F                                ; make sure only return 4 bits
 12D  25000                        RETURN 
 12E                               ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 12E  00850            Byte2Chars: LOAD s8, s5                               ; assumes 8 bit data is in s5
 12F  1450E                        SR0 s5
 130  1450E                        SR0 s5
 131  1450E                        SR0 s5
 132  1450E                        SR0 s5                                    ; get first hex character
 133  2013A                        CALL 13A[GetChar]
 134  00650                        LOAD s6, s5                               ; first ascii char
 135  00580                        LOAD s5, s8
 136  0350F                        AND s5, 0F
 137  2013A                        CALL 13A[GetChar]                         ; send to LCD or UART
 138  00750                        LOAD s7, s5                               ; second ascii char
 139  25000                        RETURN 
 13A                               ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 13A  1950A               GetChar: SUB s5, 0A[10'd]                          ; Test if s5 greater than 9
 13B  3A13E                        JUMP C, 13E[is_0_9]                       ; Hex character is 0_9
 13C  11541                        ADD s5, 41[65'd]                          ; offset for Ascii code 'A'
 13D  25000                        RETURN 
 13E  1150A                is_0_9: ADD s5, 0A[10'd]                          ; return to range 0-9
 13F  11530                        ADD s5, 30[48'd]                          ; offset to Ascii code for '0'
 140  25000                        RETURN 
 141                               ; Registers used s0, s1, s2, s3, s4 and s5.
 141                               ;
 141  01500              delay_1s: LOAD s5, 00                               ; clear cycle counter
 142  01400                        LOAD s4, 00
 143  20154               wait_1s: CALL 154[delay_1ms]
 144  11401                        ADD s4, 01                                ; increment cycle counter
 145  13500                        ADDCY s5, 00
 146  1D4E8                        COMPARE s4, E8[count_1000_lsb]            ; test for 1000ms
 147  36143                        JUMP NZ, 143[wait_1s]
 148  1D503                        COMPARE s5, 03[count_1000_msb]
 149  36143                        JUMP NZ, 143[wait_1s]
 14A  25000                        RETURN 
 14B                               ;
 14B                               ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 14B                               ;
 14B                               ;
 14B                               ; Registers used s0, s1, s2, s3 and s4.
 14B                               ;
 14B  2014F           delay_300ms: CALL 14F[delay_100ms]
 14C  2014F           delay_200ms: CALL 14F[delay_100ms]
 14D  2014F                        CALL 14F[delay_100ms]
 14E  25000                        RETURN 
 14F                               ;
 14F                               ; Delay of approximately 100ms used for switch debounce
 14F                               ;
 14F                               ; Registers used s0, s1, s2, s3 and s4.
 14F                               ;
 14F  01464           delay_100ms: LOAD s4, 64                               ; repeat 1ms delay 100 times
 150  20154            wait_100ms: CALL 154[delay_1ms]
 151  19401                        SUB s4, 01
 152  36150                        JUMP NZ, 150[wait_100ms]
 153  25000                        RETURN 
 154                               ;
 154                               ; Delay of approximately 1ms required by LCD display
 154                               ;
 154                               ; Registers used s0, s1, s2 and s3.
 154                               ;
 154  01300             delay_1ms: LOAD s3, 00                               ; clear cycle counter
 155  01200                        LOAD s2, 00
 156  20163              wait_1ms: CALL 163[delay_1us]
 157  11201                        ADD s2, 01                                ; increment cycle counter
 158  13300                        ADDCY s3, 00
 159  1D2E8                        COMPARE s2, E8[count_1000_lsb]            ; test for 1000us
 15A  36156                        JUMP NZ, 156[wait_1ms]
 15B  1D303                        COMPARE s3, 03[count_1000_msb]
 15C  36156                        JUMP NZ, 156[wait_1ms]
 15D  25000                        RETURN 
 15E                               ;
 15E                               ; Delay of approximately 50us required by LCD display
 15E                               ;
 15E                               ; Registers used s0 and s1.
 15E                               ;
 15E  01132            delay_50us: LOAD s1, 32[50'd]                         ; repeat 1us delay 50 times
 15F  20163             wait_50us: CALL 163[delay_1us]
 160  19101                        SUB s1, 01
 161  3615F                        JUMP NZ, 15F[wait_50us]
 162  25000                        RETURN 
 163                               ; Delay of approximately 1us used to provide timing reference for
 163                               ; LCD operations. This must be adjusted to reflect the clock
 163                               ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 163                               ;
 163                               ; The software delay loop is formed using register s0. This register
 163                               ; must be loaded with an integer value close to the result of....
 163                               ;
 163                               ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 163                               ;
 163                               ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 163                               ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 163                               ; operation will become lower than the 100KHz target intended.
 163                               ;
 163                               ; Register used s0.
 163                               ;
 163  01006             delay_1us: LOAD s0, 06[delay_1us_constant]           ; delay value of 12 decimal for a 50MHz clock
 164  19001              wait_1us: SUB s0, 01
 165  36164                        JUMP NZ, 164[wait_1us]
 166  25000                        RETURN 
 167                               ;
 167                               ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\Users\gnaylor.CCFEPC\Dropbox\N3workingG\TE0722Rebuild\N3SysGen\ToneDetectpico.psm



List of defined constants

 CONSTANT name       Value        Source PSM File

 timestamp_hours     09'd         
 timestamp_minutes   45'd         
 timestamp_seconds   28'd         
 datestamp_year      16'd         
 datestamp_month     11'd         
 datestamp_day       18'd         
 NUL                 00           
 BEL                 07           
 BS                  08           
 HT                  09           
 LF                  0A           
 VT                  0B           
 CR                  0D           
 ESC                 1B           
 DEL                 7F           
 DCS                 90           
 ST                  9C           
 delay_1us_constant  06           ToneDetectpico.psm
 m                   8'd          ToneDetectpico.psm
 m_plus_1            9'd          ToneDetectpico.psm
 count_1000_lsb      E8           ToneDetectpico.psm
 count_1000_msb      03           ToneDetectpico.psm
 half_pi_LSB         00           ToneDetectpico.psm
 half_pi_MSB         40           ToneDetectpico.psm
 phase_threshold     30'd         ToneDetectpico.psm
 count_value_to_trig 08'd         ToneDetectpico.psm
 audioTest           2'd          ToneDetectpico.psm
 StrtToneAInc        9F           ToneDetectpico.psm
 StrtToneBInc        69           ToneDetectpico.psm
 StopToneAInc        5A           ToneDetectpico.psm
 StopToneBInc        78           ToneDetectpico.psm
 AudioMSB            0'd          ToneDetectpico.psm
 AudioLSB            1'd          ToneDetectpico.psm
 Strobe              2'd          ToneDetectpico.psm
 DemodMSB            3'd          ToneDetectpico.psm
 DemodLSB            4'd          ToneDetectpico.psm
 Status              6'd          ToneDetectpico.psm
 TBD                 7'd          ToneDetectpico.psm
 CmdToUser           0'd          ToneDetectpico.psm
 LOMSB               1'd          ToneDetectpico.psm
 BRAMaddrMSB         2'd          ToneDetectpico.psm
 BRAMaddrLSB         3'd          ToneDetectpico.psm
 AVEtoneAmp          9'd          ToneDetectpico.psm
 STRTAinc            10'd         ToneDetectpico.psm
 STRTAptrMSB         11'd         ToneDetectpico.psm
 STRTAptrLSB         12'd         ToneDetectpico.psm
 STRTAAccuDemodIMSB  13'd         ToneDetectpico.psm
 STRTAAccuDemodILSB  14'd         ToneDetectpico.psm
 STRTAAccuDemodQMSB  15'd         ToneDetectpico.psm
 STRTAAccuDemodQLSB  16'd         ToneDetectpico.psm
 STRTApreviousPhase  17'd         ToneDetectpico.psm
 STRTAcounter        18'd         ToneDetectpico.psm
 STRTBinc            20'd         ToneDetectpico.psm
 STPAinc             30'd         ToneDetectpico.psm
 STPBinc             40'd         ToneDetectpico.psm
 SampleCounterMSB    50'd         ToneDetectpico.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "18 Nov 2016"  
 timestamp$        "09:45:28"     



List of line labels

   Label                  Addr  Source PSM File

 * cold_start             000   ToneDetectpico.psm
   AwaitAudioVal          01A   ToneDetectpico.psm
   AwaitRise              01E   ToneDetectpico.psm
 * StartDemod             028   ToneDetectpico.psm
   DemodulateTone         035   ToneDetectpico.psm
   CheckMatureAndOutput   062   ToneDetectpico.psm
   Matured                067   ToneDetectpico.psm
   Whoopie                084   ToneDetectpico.psm
   resetcounter           08F   ToneDetectpico.psm
 * DoAccumulate           092   ToneDetectpico.psm
   negaccum               09A   ToneDetectpico.psm
   negdecrmnt             0A5   ToneDetectpico.psm
 * LUTandMultiply         0AB   ToneDetectpico.psm
   StreamAmp              0AF   ToneDetectpico.psm
   StreamPhase            0B3   ToneDetectpico.psm
   waitabit               0B8   ToneDetectpico.psm
   cordic                 0BC   ToneDetectpico.psm
   cordicloop             0C1   ToneDetectpico.psm
 * negrotate              0C5   ToneDetectpico.psm
   posrotate              0D3   ToneDetectpico.psm
   testcordicend          0E0   ToneDetectpico.psm
   GetPhaseIncrement      0E4   ToneDetectpico.psm
   shift                  0EC   ToneDetectpico.psm
   shiftloop              0ED   ToneDetectpico.psm
   rotate90               0F3   ToneDetectpico.psm
 * sub90                  0F7   ToneDetectpico.psm
   add90                  100   ToneDetectpico.psm
   absval                 109   ToneDetectpico.psm
   makeposval             10C   ToneDetectpico.psm
   Export2User            110   ToneDetectpico.psm
   AddCRLF                116   ToneDetectpico.psm
 * Chars2Byte             11B   ToneDetectpico.psm
   Get4bits               126   ToneDetectpico.psm
   char0_9                12B   ToneDetectpico.psm
   Byte2Chars             12E   ToneDetectpico.psm
   GetChar                13A   ToneDetectpico.psm
   is_0_9                 13E   ToneDetectpico.psm
 * delay_1s               141   ToneDetectpico.psm
   wait_1s                143   ToneDetectpico.psm
 * delay_300ms            14B   ToneDetectpico.psm
 * delay_200ms            14C   ToneDetectpico.psm
   delay_100ms            14F   ToneDetectpico.psm
   wait_100ms             150   ToneDetectpico.psm
   delay_1ms              154   ToneDetectpico.psm
   wait_1ms               156   ToneDetectpico.psm
 * delay_50us             15E   ToneDetectpico.psm
   wait_50us              15F   ToneDetectpico.psm
   delay_1us              163   ToneDetectpico.psm
   wait_1us               164   ToneDetectpico.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             86
 STAR              -

 AND               6
 OR                -
 XOR               -

 ADD              31
 ADDCY            11
 SUB              21
 SUBCY             7

 TEST              -
 TESTCY            -
 COMPARE          19
 COMPARECY         -

 SL0               4
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               9
 SR1               -
 SRX               5
 SRA               6
 RR                -

 REGBANK           -

 INPUT             8
 OUTPUT           16
 OUTPUTK           -

 STORE            17
 FETCH            17

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             19
 JUMP@             -
 CALL             39
 CALL@             -
 RETURN           31
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
