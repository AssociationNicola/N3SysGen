KCPSM6 Assembler log file for program 'Z:\home\gnaylor\Dropbox\N3SysGen\ToneDetectpico.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 21 Feb 2018
Assembly timestamp: 17:59:31

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 209 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 522
Memory locations available: 3574


Assembly listing

 Addr Code                           Instruction

 000                                 ;GV0B Tone detect working - getting AGC adjust to work thrugh DSP
 000                                 ;GV?? first tone detect
 000                                 CONSTANT delay_1us_constant, 06                        ; Value (13)19 or 12? decimal suitable for 50MHz clock – about 6 for 33MHz?
 000                                 CONSTANT m, 8'd                                        ; No. of iterations for cordic
 000                                 CONSTANT m_plus_1, 9'd                                 ; No. of iterations for cordic
 000                                 CONSTANT count_1000_lsb, E8                            ; lower 8-bits of 1000 count value
 000                                 CONSTANT count_1000_msb, 03                            ; upper 8-bits of 1000 count value
 000                                 CONSTANT half_pi_LSB, 00                               ;
 000                                 CONSTANT half_pi_MSB, 40                               ; 360 degrees = $10000
 000                                 CONSTANT phase_threshold, 30'd                         ;test for phase fairly constant
 000                                 CONSTANT count_value_to_trig, 9'd                      ;if low phase 12 succesive times, then this is significant! - try to increase sensitivity (was 10 - worth trying 6!)
 000                                 ;not sure about these (Aug2016)
 000                                 CONSTANT audioTest, 2'd                                ; Frequency 2=800Hz, 3=1200Hz, 4=1.6kHz 7=2.8kHz
 000                                 ;Frequency values for start and stop tones (decrease all by 1 29/1/17)
 000                                 CONSTANT StrtToneAInc, 9E
 000                                 CONSTANT StrtToneBInc, 68
 000                                 CONSTANT StopToneAInc, 59
 000                                 CONSTANT StopToneBInc, 77
 000                                 ; Registers
 000                                 NAMEREG sF, SampleCounter                              ;
 000                                 NAMEREG sE, TempScratchPointer
 000                                 NAMEREG sD, Mode                                       ;stores the operating mode: 0=idle, 1=Starting, 2=Receiving, 3=stopping, 4=TX
 000                                 NAMEREG sC, SampleTimer                                ;This counter does not stop!
 000                                 ; registers sA-sB are used for longish term storage...!
 000                                 ; sA used for cordic calcs
 000                                 ; Scratch pad
 000                                 ; registers 0-8 used for cordic table:
 000                                 ; reg 0=45degrees
 000                                 ; ..
 000                                 ; reg 7=0.44761degrees
 000                                 ; Input port
 000                                 CONSTANT AudioMSB, 0'd                                 ;Not used?
 000                                 CONSTANT AudioLSB, 1'd
 000                                 CONSTANT Strobe, 2'd                                   ;     bit0=8kHz square wave - Bit 1 is TX_High
 000                                 CONSTANT DemodMSB, 3'd                                 ; Top significant byte of multiplier output
 000                                 CONSTANT DemodLSB, 4'd                                 ; (only 16 bits retained)
 000                                 CONSTANT TBD0, 5'd                                     ;
 000                                 CONSTANT TBD1, 6'd                                     ;
 000                                 CONSTANT TBD2, 7'd                                     ;TBdefined
 000                                 ; Output ports
 000                                 CONSTANT CmdToUser, 0'd
 000                                 CONSTANT LOMSB, 1'd
 000                                 CONSTANT BRAMaddrMSB, 2'd                              ;Not currently used (Feb '17)
 000                                 CONSTANT BRAMaddrLSB, 3'd
 000                                 ;also used:8,9,13,14,18,19,23,24 -  8 STRTA,13  STRTB ,18 STPA or 23  STPB, and 9 STRTA,14  STRTB ,19 STPA or 24  STPB
 000                                 ; 6,11,16,21 used for running Itone values and 7,12,17,22 for Qtone values
 000                                 CONSTANT StartAmpOut, 25'd                             ;goes to DSP pico to calibrate AGC
 000                                 CONSTANT State, 26'd                                   ;Bit 0 N3signalReceived, Bit 1 is not used, Bit 2 Tone detect off
 000                                 ; Scratchpad registers
 000                                 ; 0-8 used for Cordic Table!
 000                                 ;Now various pointers to create start and stop tones
 000                                 CONSTANT AVEtoneAmp, 9'd                               ;Is this needed?
 000                                 CONSTANT STRTAinc, 10'd                                ;This is the base address loaded into s0 before calling 'TreatTone'
 000                                 CONSTANT STRTAptrMSB, 11'd                             ;16 bit value used to generate the LUT ptr - won't use these names, just documented for reference
 000                                 CONSTANT STRTAptrLSB, 12'd                             ;fine resolution
 000                                 CONSTANT STRTAAccuDemodIMSB, 13'd                      ;This is the 16 bit value returned from the mulitplier
 000                                 CONSTANT STRTAAccuDemodILSB, 14'd                      ;Will this byte be used?
 000                                 CONSTANT STRTAAccuDemodQMSB, 15'd                      ;This is th e 16 bit value of the demod component accumulated
 000                                 CONSTANT STRTAAccuDemodQLSB, 16'd
 000                                 CONSTANT STRTAcurrentPhase, 17'd                       ;8 bit value of the current phase determined by the cordic
 000                                 CONSTANT STRTApreviousPhase, 18'd                      ;8 bit value of the previous phase determined by the cordic
 000                                 CONSTANT STRTAcounter, 19'd                            ;counts number of cycles of constant phase..
 000                                 CONSTANT STRTBinc, 20'd
 000                                 ;etc
 000                                 CONSTANT STPAinc, 30'd
 000                                 CONSTANT STPBinc, 40'd
 000                                 ;then second space at +40 from above numbers for another 4 tones
 000                                 ;uses up to Scratch register 89'd
 000                                 CONSTANT SampleCounterMSB, 90'd                        ;So as to have a 16 bit sample counter
 000                                 CONSTANT StartAmpA, 91'd                               ;Store the amplitude of the startA tone continuosly and output when whoopie.
 000                                 ;CONSTANT     ToneDetectState, 92'd  ; tone detect enabled when 1 - NOT USED
 000  010FF              cold_start: LOAD s0, FF[255'd]                                     ; phase for 45 degrees- actually a bit less!
 001  2F000                          STORE s0, 00
 002  01097                          LOAD s0, 97[151'd]                                     ; phase for 26.565 degrees
 003  2F001                          STORE s0, 01
 004  01050                          LOAD s0, 50[80'd]                                      ; phase for 14.036 degrees
 005  2F002                          STORE s0, 02
 006  01029                          LOAD s0, 29[41'd]                                      ; phase for 7.125 degrees
 007  2F003                          STORE s0, 03
 008  01014                          LOAD s0, 14[20'd]                                      ; phase for 3.576 degrees
 009  2F004                          STORE s0, 04
 00A  0100A                          LOAD s0, 0A[10'd]                                      ; phase for 1.79 degrees
 00B  2F005                          STORE s0, 05
 00C  01005                          LOAD s0, 05[5'd]                                       ; phase for 0.895 degrees
 00D  2F006                          STORE s0, 06
 00E  01003                          LOAD s0, 03[3'd]                                       ; phase for 0.448 degrees
 00F  2F007                          STORE s0, 07
 010  01001                          LOAD s0, 01[1'd]                                       ; phase for 0.224 degrees
 011  2F008                          STORE s0, 08
 012  0109E                          LOAD s0, 9E[StrtToneAInc]                              ; Tone increments to detect
 013  2F00A                          STORE s0, 0A[STRTAinc]
 014  01068                          LOAD s0, 68[StrtToneBInc]                              ; Tone increments to detect
 015  2F014                          STORE s0, 14[STRTBinc]
 016  01059                          LOAD s0, 59[StopToneAInc]                              ; Tone increments to detect
 017  2F01E                          STORE s0, 1E[STPAinc]
 018  01077                          LOAD s0, 77[StopToneBInc]                              ; Tone increments to detect
 019  2F028                          STORE s0, 28[STPBinc]
 01A  09002                          INPUT s0, 02[Strobe]
 01B                                 ;     AND   s0, 04  ; tone detect disabled if set to 1
 01B                                 ;
 01B                                 ;     STORE     s0, ToneDetectState  ; tone detect is disabled if 04
 01B                                 ;      CALL N3ZtoneDetected ;Start with speaker ON !!!!!!!!!!!!!!!!!!!!!!
 01B                                 ; Routine to look at lowest bit of Strobe to detect rising edge.
 01B                  AwaitAudioVal: 
 01B                                 ;     INPUT     s0, Strobe
 01B                                 ;Tone detect is no longer disabled by this pico - is disabled directly in logic
 01B                                 ;                    AND       s0, 04               ; look only at lowest bit
 01B                                 ;     FETCH     s1, ToneDetectState
 01B                                 ;                    COMPARE   s0, s1
 01B                                 ;     CALL   NZ, ToneDetectStateChanged
 01B  09002                          INPUT s0, 02[Strobe]
 01C  03001                          AND s0, 01                                             ; look only at lowest bit
 01D  1D001                          COMPARE s0, 01
 01E  3201B                          JUMP Z, 01B[AwaitAudioVal]                             ; if 1 wait...
 01F  09002               AwaitRise: INPUT s0, 02[Strobe]
 020  03001                          AND s0, 01                                             ; look only at lowest bit
 021  1D000                          COMPARE s0, 00
 022  3201F                          JUMP Z, 01F[AwaitRise]                                 ; if 0 still, wait a bit more...
 023                                 ;Demod signal is not stable till ~6 clock cycles after rising edge, so should maybe use falling edge??
 023                                 ;so will be stable after ~3 instructions!
 023  09002                          INPUT s0, 02[Strobe]                                   ;To check if in TX mode
 024  03002                          AND s0, 02                                             ;look at bit 1
 025  1D000                          COMPARE s0, 00
 026  32029                          JUMP Z, 029[isReceiving]                               ;TX_High not set
 027  01D04                          LOAD sD[Mode], 04                                      ;keep in TX mode
 028  3201F                          JUMP Z, 01F[AwaitRise]                                 ; keep looping
 029                    isReceiving: 
 029  11C01                          ADD sC[SampleTimer], 01                                ;Always increment timer in receive mode
 02A  1DD04                          COMPARE sD[Mode], 04
 02B  3602F                          JUMP NZ, 02F[StartDemod]                               ;has not just come out of TX
 02C                                 ;  CALL N3ZtoneLost ;Make sure tone detect is off
 02C  201E4                          CALL 1E4[delay_300ms]                                  ;has just come out of TX so wait a bit before detecting tones GN ?????? is this needed???????
 02D  20123                          CALL 123[N3ZtoneLost]                                  ;Make sure tone detect is off
 02E  01D00                          LOAD sD[Mode], 00                                      ;has just come out of TX, so reset mode to idle
 02F                                 ;start treating StrtToneA
 02F  0100A              StartDemod: LOAD s0, 0A[STRTAinc]                                  ;Note s0 is being used to point to the location of the values in scratch memory!
 030  01100                          LOAD s1, 00[00'd]                                      ;(counter value when mature)
 031  2003C                          CALL 03C[DemodulateTone]                               ;and checks if the accumulation has matured (from s1) and if so do cordic
 032                                 ;start treating StrtToneB
 032  01014                          LOAD s0, 14[STRTBinc]
 033  01110                          LOAD s1, 10[16'd]                                      ;(counter value when mature)
 034  2003C                          CALL 03C[DemodulateTone]
 035                                 ;start treating StpToneA
 035  0101E                          LOAD s0, 1E[STPAinc]
 036  01120                          LOAD s1, 20[32'd]                                      ;(counter value when mature)
 037  2003C                          CALL 03C[DemodulateTone]
 038                                 ;start treating StpToneB
 038  01028                          LOAD s0, 28[STPBinc]
 039  01130                          LOAD s1, 30[48'd]                                      ;(counter value when mature)
 03A  2003C                          CALL 03C[DemodulateTone]
 03B                                 ;add more tones to demodulate here for digital modes.
 03B  2201B                          JUMP 01B[AwaitAudioVal]
 03C                                 ; -------------This is end of main loop--------------------------------
 03C                                 ;Accumulate and demodulate routine
 03C                                 ;Enter with mature index in s1 (0-63 to stagger output to the UART) and the scratch base address to treat in s0 - this is the scratch
 03C                                 ;address for the toneinc
 03C  0A200          DemodulateTone: FETCH s2, (s0)                                         ;Tone increment (pointed to in scratch by s0, to increment through sine wave LUT)
 03D  01300                          LOAD s3, 00
 03E                                 ;Need to right shift into s3 to scale correctly (as they are 4 times too big)
 03E  1420E                          SR0 s2                                                 ;The increment is a positive value (0-255 when x4) so should be kept positive!
 03F  14308                          SRA s3                                                 ;and carry containing lowest bit
 040  1420E                          SR0 s2
 041  14308                          SRA s3                                                 ;and carry containing lowest bit (doing this twice limits highest frequency to about 2kHz)
 042  11001                          ADD s0, 01
 043  0A400                          FETCH s4, (s0)                                         ;MSB of LUTptr
 044  11001                          ADD s0, 01
 045  0A500                          FETCH s5, (s0)                                         ;LSB of LUTptr
 046  10530                          ADD s5, s3                                             ;increment LUTptr
 047  12420                          ADDCY s4, s2                                           ;increment LUTptr
 048  2E500                          STORE s5, (s0)                                         ;update LSB LUTptr
 049  19001                          SUB s0, 01                                             ;decrement scratch pointer s0
 04A  2E400                          STORE s4, (s0)                                         ;update MSB LUTptr
 04B                                 ;           OUTPUT s5,LOLSB ;Send next sinewave address to LUT
 04B  2D401                          OUTPUT s4, 01[LOMSB]                                   ;Actually only need to output MSB  - use write of MSB to delay trigger latch of multiplier
 04C  20151                          CALL 151[waitabit]
 04D                                 ;NEED To wait for multiplication otherwise cordic will be out of step
 04D  09203                          INPUT s2, 03[DemodMSB]                                 ;input previous LO tone multiplied by the signal (for accumulation)
 04E  09304                          INPUT s3, 04[DemodLSB]
 04F                                 ;This value may be too big as it stands to accumulate so need to scale down so as not to overflow
 04F                                 ;   SRX s2
 04F                                 ;   SRA s3
 04F                                 ;   SRX s2
 04F                                 ;   SRA s3
 04F                                 ;   SRX s2
 04F                                 ;   SRA s3
 04F  11002                          ADD s0, 02                                             ;move back up to scratch pointer location for MSB of I accumulating signal (of previous tone!)
 050  0A600                          FETCH s6, (s0)                                         ;MSB of Accumulated I demod value
 051                                 ;added this bit to get debug info again !!!!!!!!!!!!!!!!!!!!!!
 051  19001                          SUB s0, 01                                             ;to get an even value!
 052  14008                          SRA s0                                                 ;divide by 2 to get 6,11,16 or 21
 053  2C600                          OUTPUT s6, (s0)                                        ;Export intermediate I value accumulated
 054  14000                          SLA s0                                                 ;now get s0 back on track
 055  11001                          ADD s0, 01                                             ;add one to get back and another to advance to I LSB accu
 056                                 ;Would be ADD s0,01 instead of the above debug
 056  11001                          ADD s0, 01                                             ;add one to get back and another to advance to I LSB accu
 057  0A700                          FETCH s7, (s0)                                         ;LSB of Accumulated I demod value (base + 4)
 058  10730                          ADD s7, s3                                             ;signed accumulate into Accumulated value
 059  12620                          ADDCY s6, s2                                           ;accumulate into Accumulated value
 05A  200C2                          CALL 0C2[CheckNotTooBigI]                              ;Check s6(MSB),s7 not to big (ie bigger than 40)
 05B  2E700                          STORE s7, (s0)                                         ;update LSB Accumulated value
 05C  19001                          SUB s0, 01                                             ;decrement scratch pointer s0
 05D  2E600                          STORE s6, (s0)                                         ;update MSB Accumulated value
 05E  00E00                          LOAD sE[TempScratchPointer], s0                        ;temporarily store pointer to MSB of accumulated I value
 05F                                 ;s4 and s5 still have LUTptr to add pi/2
 05F  11440                          ADD s4, 40[64'd]
 060                                 ;    OUTPUT s5,LOLSB ;Send next sinewave address to LUT -  already done!
 060  2D401                          OUTPUT s4, 01[LOMSB]                                   ;Actually only need to output MSB  - use write of MSB to delay trigger latch of multiplier
 061  20151                          CALL 151[waitabit]
 062                                 ;NEED To wait for multiplication otherwise cordic will be out of step
 062  09203                          INPUT s2, 03[DemodMSB]                                 ;input previous LO tone multiplied by the signal (for accumulation)
 063  09304                          INPUT s3, 04[DemodLSB]
 064                                 ;This value may be too big as it stands to accumulate so need to scale down so as not to overflow?
 064                                 ;   SRX s2
 064                                 ;   SRA s3
 064                                 ;   SRX s2
 064                                 ;   SRA s3
 064                                 ;   SRX s2
 064                                 ;   SRA s3
 064  11002                          ADD s0, 02                                             ;move back up to scratch pointer location for Q MSB of accumulating signal (of previous tone!)
 065  0A600                          FETCH s6, (s0)                                         ;MSB of Accumulated Q demod value
 066                                 ;added this bit to get debug info renable !!!!!!!!!!!!!!!!!!!!!!!!!!
 066  19001                          SUB s0, 01                                             ;to get an even value!
 067  14008                          SRA s0                                                 ;divide by 2 to get 7,12,17 or 22
 068  2C600                          OUTPUT s6, (s0)                                        ;Export MSB of  Q value accumulated
 069  14000                          SLA s0                                                 ;now get s0 back on track
 06A  11001                          ADD s0, 01                                             ;add one to get back and another to advance to I LSB accu
 06B                                 ;Would be ADD s0,01 instead of the above debug
 06B  11001                          ADD s0, 01                                             ;add one to get back and another to advance to I LSB accu
 06C  0A700                          FETCH s7, (s0)                                         ;LSB of Accumulated Q demod value (base + 6)
 06D  10730                          ADD s7, s3                                             ;signed accumulate into Accumulated value
 06E  12620                          ADDCY s6, s2                                           ;accumulate into Accumulated value
 06F  200D5                          CALL 0D5[CheckNotTooBigQ]                              ;Check s6(MSB),s7 not to0 big (ie bigger than 48)
 070  2E700                          STORE s7, (s0)                                         ;update LSB Accumulated value
 071  19001                          SUB s0, 01                                             ;decrement scratch pointer s0 (s0 now at base + 5)
 072  2E600                          STORE s6, (s0)                                         ;update MSB Accumulated value
 073  20075                          CALL 075[CheckMatureAndOutput]
 074  25000                          RETURN 
 075                                 ;Checks s1 is mature
 075  003C0    CheckMatureAndOutput: LOAD s3, sC[SampleTimer]                               ;Use the always incremented timer!
 076  0333F                          AND s3, 3F                                             ;mod 64
 077  1C310                          COMPARE s3, s1
 078  3007A                          CALL Z, 07A[Matured]                                   ;OK to do cordic and output - this will happen every 2ms (or every 1ms with 8 tones being decoded)
 079  25000                          RETURN 
 07A                                 ;Cordic takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
 07A                                 ; Useable range is for I and Q up to about +/-$3000
 07A                                 ;normally get I and Q values from scratch. Scratch pointer
 07A                                 ;need to use TempScratchPointer as s0 value which had pointed to the scratch area has been lost
 07A  0A1E0                 Matured: FETCH s1, (sE[TempScratchPointer])                     ;pointer at MSB of I accumulated
 07B  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to LSB of I accumulated
 07C  0A0E0                          FETCH s0, (sE[TempScratchPointer])
 07D  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to MSB of Q accumulated
 07E  0A3E0                          FETCH s3, (sE[TempScratchPointer])
 07F  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to LSB of Q accumulated
 080  0A2E0                          FETCH s2, (sE[TempScratchPointer])                     ;TempScratchPointer has now increased by 3
 081  20155                          CALL 155[cordic]
 082                                 ;now have amplitude and phase in s0/s1(MSB AMP)...s4,s5(MSB Phase) - need to calculate phase change and output the MSBs
 082                                 ;Use MSB amp in s1 - only interested in SartAmpA value - put in fixed scratch location if TempScratchPointer is +6,for this tone, ie is STRTAAccuDemodQLSB
 082  1DE10                          COMPARE sE[TempScratchPointer], 10[STRTAAccuDemodQLSB] ; are we treating StartToneA
 083  36085                          JUMP NZ, 085[CarryOn]                                  ;if not do not store in scratch
 084  2F15B                          STORE s1, 5B[StartAmpA]                                ;Save the current amplitude of the A tone
 085                                 ;have phase in s5
 085  11E02                 CarryOn: ADD sE[TempScratchPointer], 02
 086  0A4E0                          FETCH s4, (sE[TempScratchPointer])                     ;get last phase (inc+8)
 087  2E5E0                          STORE s5, (sE[TempScratchPointer])                     ;update current phase
 088  19E01                          SUB sE[TempScratchPointer], 01
 089  2E4E0                          STORE s4, (sE[TempScratchPointer])                     ;update previous phase (inc+7)
 08A  19E01                          SUB sE[TempScratchPointer], 01
 08B                                 ;Send to ARM
 08B  2014C                          CALL 14C[StreamPhase]                                  ; This does not affect s5! - but does kill s0
 08C  00510                          LOAD s5, s1
 08D  20148                          CALL 148[StreamAmp]
 08E                                 ;Need to reset accumulators to zero! (Tempscratch (originally inc+3) is now inc+6 but need to reseet addresses of original! TempScratchPointer, TempScratchPointer+1,+2 +3)
 08E                                 ;This is executed every 2ms if 4 tones are treated as executed 4 times per cycle - if more tones added, this will run more frequently and so counter timeouts will need adjusting!
 08E  000E0                          LOAD s0, sE[TempScratchPointer]
 08F  01100                          LOAD s1, 00
 090  2E100                          STORE s1, (s0)
 091  19001                          SUB s0, 01
 092  2E100                          STORE s1, (s0)
 093  19001                          SUB s0, 01
 094  2E100                          STORE s1, (s0)
 095  19001                          SUB s0, 01
 096  2E100                          STORE s1, (s0)
 097  20106                          CALL 106[CheckforTimeOuts]
 098  1DD00                          COMPARE sD[Mode], 00
 099  340BC                          CALL NZ, 0BC[IncrementCounter]                         ;Unless Idle!
 09A                                 ;This last part to be corrected to check magnitude of phase shift
 09A                                 ;OK ready to do now using software multiply
 09A  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to previous phase (inc+7)
 09B  0A2E0                          FETCH s2, (sE[TempScratchPointer])                     ;s2 now has msb of previous phase
 09C  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to current phase (inc+8)
 09D  0A3E0                          FETCH s3, (sE[TempScratchPointer])                     ;s3 now has msb of current phase
 09E  18230                          SUB s2, s3                                             ;delta phase (signed)
 09F  201A2                          CALL 1A2[absval]                                       ;gets absolute value of s2 (abs phase shift)
 0A0  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to counter (inc+9)
 0A1  0A1E0                          FETCH s1, (sE[TempScratchPointer])                     ;s1 has the counter
 0A2  000E0                          LOAD s0, sE[TempScratchPointer]
 0A3  19005                          SUB s0, 05                                             ;to get inc+4
 0A4  14008                          SRA s0                                                 ;divide by 2 to get 7,12,17 or 22
 0A5                                 ;
 0A5                                 ;Debug output Counter value and Phase difference
 0A5                                 ;   OUTPUT s1,(s0) ;Export Counter value come out on 'IQ stoptones', when value '5' is selected
 0A5                                 ;   SUB s0,01 ;to get 6,11,16,21 to align with 'IQStarttones' read by selecting '4' value
 0A5                                 ;   OUTPUT s2,(s0) ;Export phase difference value come out on 'IQ starttones', when value '4' is selected
 0A5  1D21E                          COMPARE s2, 1E[phase_threshold]                        ;is it less than threshold, then set carry
 0A6  3E0B7                          JUMP NC, 0B7[dropcounter]                              ; if failed then drop the counter and return
 0A7  11101                          ADD s1, 01                                             ;otherwise is small phase shift so advance counter
 0A8  2E1E0                          STORE s1, (sE[TempScratchPointer])                     ;now save the counter
 0A9  1D109                          COMPARE s1, 09[count_value_to_trig]                    ;s1 has phase constant counter, carry not set if count is high enough.
 0AA  3C0AC                          CALL NC, 0AC[Whoopie]                                  ;seem to have a tone here!
 0AB  25000                          RETURN 
 0AC                                 ;Ultimately will use TempScratchPointer to work out which tone was detected
 0AC                                 ;need to reset counter to Zero!!
 0AC  01000                 Whoopie: LOAD s0, 00
 0AD  2E0E0                          STORE s0, (sE[TempScratchPointer])                     ;reset counter to zero
 0AE  1DE13                          COMPARE sE[TempScratchPointer], 13[19'd]               ;if start tone A counter
 0AF  300E8                          CALL Z, 0E8[isStrtToneA]
 0B0  1DE1D                          COMPARE sE[TempScratchPointer], 1D[29'd]               ;if start tone B counter
 0B1  300F0                          CALL Z, 0F0[isStrtToneB]
 0B2  1DE27                          COMPARE sE[TempScratchPointer], 27[39'd]               ;if start tone A counter
 0B3  300F7                          CALL Z, 0F7[isStopToneA]
 0B4  1DE31                          COMPARE sE[TempScratchPointer], 31[49'd]               ;if start tone A counter
 0B5  300FD                          CALL Z, 0FD[isStopToneB]
 0B6  25000                          RETURN 
 0B7  1D102             dropcounter: COMPARE s1, 02
 0B8  39000                          RETURN C                                               ;return if counter 1 or zero
 0B9  19102                          SUB s1, 02                                             ;drop counter by 2
 0BA  2E1E0                          STORE s1, (sE[TempScratchPointer])                     ;now set counter to new value
 0BB  25000                          RETURN 
 0BC                                 ;Update sample counter (increments every 2ms if treating all 4 tones simultaneously, would be 1ms if treating 8 tones)
 0BC                                 ;This only advances in modes 1,2 and 3
 0BC  0B05A        IncrementCounter: FETCH s0, 5A[SampleCounterMSB]
 0BD  11F01                          ADD sF[SampleCounter], 01                              ;increment counter
 0BE  13000                          ADDCY s0, 00
 0BF  2F05A                          STORE s0, 5A[SampleCounterMSB]                         ;increment MSB on rollover
 0C0                                 ;Check if any of the time outs are passed
 0C0  20106                          CALL 106[CheckforTimeOuts]
 0C1  25000                          RETURN 
 0C2                                 ;This is to drop the value of the accumulated I and Q values so that don't end up getting too big for the Cordic
 0C2  00260         CheckNotTooBigI: LOAD s2, s6
 0C3  00360                          LOAD s3, s6                                            ;also have to save s6 as absval kills s6
 0C4  201A2                          CALL 1A2[absval]                                       ;return absval in s2
 0C5  00630                          LOAD s6, s3                                            ;put value back in s6
 0C6  1D230                          COMPARE s2, 30                                         ;is absolute value bigger than or equal 30 (then NC)
 0C7  39000                          RETURN C                                               ;if not return
 0C8  1460A                          SRX s6
 0C9  14708                          SRA s7                                                 ;half value in s6/s7
 0CA                                 ;now need to drop value in accummulated Q
 0CA  11002                          ADD s0, 02                                             ;increase scratch pointer to Q accumulation values
 0CB  0A300                          FETCH s3, (s0)                                         ;LSB of Q accumulated
 0CC  19001                          SUB s0, 01
 0CD  0A200                          FETCH s2, (s0)                                         ;MSB of Q accumulated
 0CE  1420A                          SRX s2
 0CF  14308                          SRA s3                                                 ;half Q accumulated value
 0D0  2E200                          STORE s2, (s0)
 0D1  11001                          ADD s0, 01
 0D2  2E300                          STORE s3, (s0)
 0D3  19002                          SUB s0, 02                                             ;Get s0 back to its original value
 0D4  25000                          RETURN 
 0D5  00260         CheckNotTooBigQ: LOAD s2, s6
 0D6  00360                          LOAD s3, s6                                            ;also have to save s6 as absval kills s6
 0D7  201A2                          CALL 1A2[absval]                                       ;return absval in s2
 0D8  00630                          LOAD s6, s3                                            ;put value back in s6
 0D9  1D230                          COMPARE s2, 30                                         ;is absolute value bigger than or equal 30 (then NC)
 0DA  39000                          RETURN C                                               ;if not return
 0DB  1460A                          SRX s6
 0DC  14708                          SRA s7                                                 ;half value in s6/s7
 0DD                                 ;now need to drop value in accummulated Q
 0DD  19002                          SUB s0, 02                                             ;reduce scratch pointer to I accumulation values
 0DE  0A300                          FETCH s3, (s0)                                         ;LSB of I accumulated
 0DF  19001                          SUB s0, 01
 0E0  0A200                          FETCH s2, (s0)                                         ;MSB of I accumulated
 0E1  1420A                          SRX s2
 0E2  14308                          SRA s3                                                 ;half I accumulated value
 0E3  2E200                          STORE s2, (s0)
 0E4  11001                          ADD s0, 01
 0E5  2E300                          STORE s3, (s0)
 0E6  11002                          ADD s0, 02                                             ;Get s0 back to its original value
 0E7  25000                          RETURN 
 0E8                                 ;Treat different mode cases
 0E8                                 ;Mode 0 Idle
 0E8                                 ;Mode 1 Starting  (Start tone A detected)
 0E8                                 ;Mode 2 Recieving Voice
 0E8                                 ;Mode 3 Stopping
 0E8                                 ;Mode 4 TX
 0E8  1DD00             isStrtToneA: COMPARE sD[Mode], 00                                   ;Check if currently idle
 0E9  35000                          RETURN NZ                                              ;Don't do anything if not currently idle
 0EA  0B05B                          FETCH s0, 5B[StartAmpA]                                ;Get thepreviously stored amplitude
 0EB  2D019                          OUTPUT s0, 19[StartAmpOut]                             ;and output to be read by the DSP Pico
 0EC  01D01                          LOAD sD[Mode], 01                                      ;Move in to starting mode
 0ED  01F00                          LOAD sF[SampleCounter], 00
 0EE  2FF5A                          STORE sF[SampleCounter], 5A[SampleCounterMSB]          ;Reset counter and allow about 160ms to receive tone B
 0EF  25000                          RETURN 
 0F0  1DD01             isStrtToneB: COMPARE sD[Mode], 01                                   ;Check if in starting mode
 0F1  35000                          RETURN NZ                                              ;Don't do anything if not starting
 0F2  01D02                          LOAD sD[Mode], 02                                      ;go ahead in to receive
 0F3  2011C                          CALL 11C[N3ZtoneDetected]                              ;N3Z transmission detected
 0F4  01F00                          LOAD sF[SampleCounter], 00
 0F5  2FF5A                          STORE sF[SampleCounter], 5A[SampleCounterMSB]          ;Reset counter and allow about 160ms to receive tone B
 0F6  25000                          RETURN 
 0F7  1DD02             isStopToneA: COMPARE sD[Mode], 02                                   ;Check if in RX mode
 0F8  35000                          RETURN NZ                                              ;Don't do anything if not in RX
 0F9  01D03                          LOAD sD[Mode], 03                                      ;Move in to stopping mode
 0FA  01F00                          LOAD sF[SampleCounter], 00
 0FB  2FF5A                          STORE sF[SampleCounter], 5A[SampleCounterMSB]          ;Reset counter and allow about 512ms to receive tone B
 0FC  25000                          RETURN 
 0FD  1DD03             isStopToneB: COMPARE sD[Mode], 03                                   ;Check if in stopping mode
 0FE  35000                          RETURN NZ                                              ;Don't do anything if not stopping
 0FF  01D00                          LOAD sD[Mode], 00                                      ;go back to idle
 100  201DA                          CALL 1DA[delay_1s]                                     ;dont indicate N3Z transmission detected yet
 101  201DA                          CALL 1DA[delay_1s]                                     ;in a bit...
 102  20123                          CALL 123[N3ZtoneLost]                                  ;Turn N3Z transmission detected off
 103  01F00                          LOAD sF[SampleCounter], 00
 104  2FF5A                          STORE sF[SampleCounter], 5A[SampleCounterMSB]          ;Reset counter (not really needed, but just for tidiness)
 105  25000                          RETURN 
 106                                 ;timeout values in units of 2ms - this will drop to 1ms if more tones added, so timeout values will need re-adjusting
 106  1DD01        CheckforTimeOuts: COMPARE sD[Mode], 01
 107  3010D                          CALL Z, 10D[checkStarttoneAtimeout]
 108  1DD02                          COMPARE sD[Mode], 02
 109  30111                          CALL Z, 111[checkRXtimeout]
 10A  1DD03                          COMPARE sD[Mode], 03
 10B  30117                          CALL Z, 117[checkStoptoneAtimeout]
 10C  25000                          RETURN 
 10D  1DF50  checkStarttoneAtimeout: COMPARE sF[SampleCounter], 50[80'd]                    ;This will need to be 160'd with 8 tones
 10E  39000                          RETURN C                                               ;Counter<80 (160ms) so OK
 10F  01D00                          LOAD sD[Mode], 00                                      ;Set mode back to idle - tone B was not received in time
 110  25000                          RETURN 
 111  0B05A          checkRXtimeout: FETCH s0, 5A[SampleCounterMSB]                         ;Get counter
 112  1D03D                          COMPARE s0, 3D[61'd]                                   ;-about 30 secs - COmpare with 122'd if using 8 tones
 113  39000                          RETURN C                                               ;Can carry on listening (not timed out)
 114  01D00                          LOAD sD[Mode], 00                                      ;Set mode back to idle - seems to have been transmitting too long
 115  20123                          CALL 123[N3ZtoneLost]                                  ;stop N3Z transmission detected (timeout)
 116  25000                          RETURN 
 117  0B05A   checkStoptoneAtimeout: FETCH s0, 5A[SampleCounterMSB]                         ;Get counter
 118  1D001                          COMPARE s0, 01                                         ;-about 512ms - need to compare with 02 if using 8 tones
 119  39000                          RETURN C                                               ;Counter MSB still 0 so within 512ms of receiving StoptoneA
 11A  01D02                          LOAD sD[Mode], 02                                      ;Set mode back to RX - tone B was not received in time so must have been a chance tone
 11B  25000                          RETURN 
 11C                                 ;ToneDetectStateChanged:
 11C                                 ;     STORE     s0, ToneDetectState
 11C                                 ;
 11C                                 ;     CALL N3ZtoneDetected  ; always set N3Z transmission detected on if changed
 11C                                 ;
 11C                                 ;     RETURN
 11C                N3ZtoneDetected: 
 11C                                 ;    INPUT    s0, Strobe
 11C                                 ;    AND   s0, 04  ; tone detect disabled if set to 1
 11C                                 ;    JUMP     NZ, TDIsOff   ; not control if Tone detect not enabled
 11C                                 ;FETCH    s0, ToneDetectEnabled
 11C                                 ;ADD      s0, 00
 11C                                 ;RETURN   Z
 11C  01001                          LOAD s0, 01
 11D  2D01A                          OUTPUT s0, 1A[State]                                   ;N3Z signal being received flag on
 11E  0102B                          LOAD s0, 2B[43'd]                                      ;
 11F  2D000                          OUTPUT s0, 00[CmdToUser]
 120  01031                          LOAD s0, 31[49'd]                                      ;
 121  2D000                          OUTPUT s0, 00[CmdToUser]
 122  25000                          RETURN 
 123                                 ;TDIsOff:
 123                                 ;    LOAD     s0,01   ; make sure speaker is on
 123                                 ;               OUTPUT s0,State
 123                                 ;
 123                                 ;               LOAD      s0, 43'd              ;
 123                                 ;              OUTPUT    s0, CmdToUser
 123                                 ;
 123                                 ;    LOAD      s0, 50'd              ; tell user pico
 123                                 ;               OUTPUT    s0, CmdToUser
 123                                 ;    RETURN
 123                    N3ZtoneLost: 
 123                                 ;    INPUT    s0, Strobe
 123                                 ;    AND   s0, 04  ; tone detect disabled if set to 1
 123                                 ;
 123                                 ;    JUMP     NZ, TDIsOff   ; not control if Tone detect not enabled
 123                                 ;
 123                                 ;FETCH    s0, ToneDetectEnabled
 123                                 ;ADD      s0, 00
 123                                 ;RETURN   Z
 123  01000                          LOAD s0, 00                                            ;sets signal detected state to off
 124  2D01A                          OUTPUT s0, 1A[State]
 125  01D00                          LOAD sD[Mode], 00                                      ;return to idle state
 126  0102B                          LOAD s0, 2B[43'd]                                      ; '+'
 127  2D000                          OUTPUT s0, 00[CmdToUser]
 128  01030                          LOAD s0, 30[48'd]                                      ;
 129  2D000                          OUTPUT s0, 00[CmdToUser]
 12A  25000                          RETURN 
 12B                                 ;Does 16 bit signed accumulation of 8 bit signed value in s1 into s4/s5 which are recoverred from scratch pad pointed to by s2 (loading here the offset to the actual tone
 12B                                 ;dependent on how many times round the loop we are)
 12B  10260            DoAccumulate: ADD s2, s6
 12C  0A420                          FETCH s4, (s2)                                         ;Now Get AveSToneLSB_Is in s4 etc...
 12D  19201                          SUB s2, 01                                             ;step back to MSB
 12E  0A520                          FETCH s5, (s2)                                         ;Get AveSToneMSB_Is in s5
 12F  013FF                          LOAD s3, FF                                            ;Assume s1 is negative and use s3 for sign extension
 130  1D180                          COMPARE s1, 80[128'd]                                  ;if s1 is 128 or bigger, then it is negative (carry not set)
 131  3E133                          JUMP NC, 133[negaccum]
 132  01300                          LOAD s3, 00                                            ;sign extend with zeros
 133  10410                negaccum: ADD s4, s1                                             ;Accumulate into averageLsB
 134  12530                          ADDCY s5, s3                                           ;do carry to add into upper byte (keeping carry from previous add!!)
 135  00050                          LOAD s0, s5
 136  1400A                          SRX s0
 137  1400A                          SRX s0                                                 ;reduce value to subtract by factor 4 to increase integration time constant and gain.
 138  13000                          ADDCY s0, 00                                           ;round up if necessary
 139  18400                          SUB s4, s0
 13A  013FF                          LOAD s3, FF                                            ;Assume s5 is negative and use s3 for sign extension
 13B  1D580                          COMPARE s5, 80[128'd]                                  ;is this a negative number?
 13C  3E13E                          JUMP NC, 13E[negdecrmnt]
 13D  01300                          LOAD s3, 00                                            ;do this if s5 is positive (sign extension)
 13E  18400              negdecrmnt: SUB s4, s0
 13F  1A530                          SUBCY s5, s3                                           ;subtract 1/256
 140  2E520                          STORE s5, (s2)
 141  11201                          ADD s2, 01                                             ;move down to LSB again
 142  2E420                          STORE s4, (s2)                                         ;update scratchpad values
 143  25000                          RETURN 
 144                                 ; This TBD, should output 16 bit value, that goes through a sinewave LUT and multiplies by the signal and recover
 144  2D101          LUTandMultiply: OUTPUT s1, 01[LOMSB]
 145  09903                          INPUT s9, 03[DemodMSB]                                 ;actually gets previously latched multiply corresponding to previous tone!
 146  09804                          INPUT s8, 04[DemodLSB]
 147  25000                          RETURN 
 148  000E0               StreamAmp: LOAD s0, sE[TempScratchPointer]                        ;possible values are 16,26,36 and 46
 149  1400E                          SR0 s0                                                 ;Divide by 0 to get 8 STRTA,13  STRTB ,18 STPA or 23  STPB
 14A  2C500                          OUTPUT s5, (s0)                                        ;direct amplitude MSB to the appropriate port
 14B  25000                          RETURN 
 14C  000E0             StreamPhase: LOAD s0, sE[TempScratchPointer]
 14D  1400E                          SR0 s0
 14E  11001                          ADD s0, 01                                             ;Offset to output phase values get 9 STRTA,14  STRTB ,19 STPA or 24  STPB
 14F  2C500                          OUTPUT s5, (s0)                                        ;direct phase MSB to the appropriate port
 150  25000                          RETURN 
 151  00220                waitabit: LOAD s2, s2
 152  00220                          LOAD s2, s2
 153  00220                          LOAD s2, s2                                            ;is this long enough?
 154  25000                          RETURN 
 155                                 ; CORDIC  Takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
 155                                 ; Useable range is for I and Q up to about +/-$3000
 155  01400                  cordic: LOAD s4, 00
 156  01500                          LOAD s5, 00
 157  1D180                          COMPARE s1, 80[128'd]
 158  3C18C                          CALL NC, 18C[rotate90]                                 ; if I negative then need to bring back into RH 2 quadrants.
 159                                 ; now enter loop
 159  01800                          LOAD s8, 00                                            ; counter of times to iterate.
 15A  00710              cordicloop: LOAD s7, s1                                            ; temporary store for I
 15B  00600                          LOAD s6, s0                                            ; temp store
 15C  1D380                          COMPARE s3, 80[128'd]                                  ; is Q negative?
 15D  3E16C                          JUMP NC, 16C[posrotate]                                ; if negative rotate positive
 15E  00A20               negrotate: LOAD sA, s2
 15F  00B30                          LOAD sB, s3                                            ; put Q into working registers
 160  20185                          CALL 185[shift]                                        ; shift Q by the amount in s8
 161  100A0                          ADD s0, sA                                             ; add shifted Q to I
 162  121B0                          ADDCY s1, sB
 163  00A60                          LOAD sA, s6                                            ; prepare working registers (sA,sB) with original value of I
 164  00B70                          LOAD sB, s7
 165  20185                          CALL 185[shift]
 166  182A0                          SUB s2, sA
 167  1A3B0                          SUBCY s3, sB
 168  2017D                          CALL 17D[GetPhaseIncrement]
 169  184A0                          SUB s4, sA
 16A  1A5B0                          SUBCY s5, sB
 16B  22179                          JUMP 179[testcordicend]
 16C  00A20               posrotate: LOAD sA, s2
 16D  00B30                          LOAD sB, s3                                            ; put Q into working registers
 16E  20185                          CALL 185[shift]                                        ; shift Q by the amount in s8
 16F  180A0                          SUB s0, sA                                             ; add shifted Q to I
 170  1A1B0                          SUBCY s1, sB
 171  00A60                          LOAD sA, s6                                            ; prepare working registers with original value of I
 172  00B70                          LOAD sB, s7
 173  20185                          CALL 185[shift]
 174  102A0                          ADD s2, sA
 175  123B0                          ADDCY s3, sB
 176  2017D                          CALL 17D[GetPhaseIncrement]
 177  104A0                          ADD s4, sA
 178  125B0                          ADDCY s5, sB
 179  11801           testcordicend: ADD s8, 01
 17A  1D809                          COMPARE s8, 09[m_plus_1]                               ;m + 1
 17B  3A15A                          JUMP C, 15A[cordicloop]
 17C  25000                          RETURN 
 17D                                 ; routine to lookup from the cordic look up table (scratchpad), the phase increment - stored as 8 bits at the location pointed to be s8, returned as 16 bits in sA and sB
 17D                                 ; sB is MSB
 17D  0AB80       GetPhaseIncrement: FETCH sB, (s8)
 17E  14B0E                          SR0 sB
 17F  14A08                          SRA sA
 180  14B0E                          SR0 sB
 181  14A08                          SRA sA
 182  14B0E                          SR0 sB
 183  14A08                          SRA sA                                                 ; This multiplies the 8 bit stored value by 32 so that max scratchpad value 255->255*32 equivalent to 44.82degrees
 184  25000                          RETURN 
 185  00980                   shift: LOAD s9, s8
 186  1D900               shiftloop: COMPARE s9, 00
 187  31000                          RETURN Z
 188  19901                          SUB s9, 01
 189  14B0A                          SRX sB
 18A  14A08                          SRA sA
 18B  22186                          JUMP 186[shiftloop]
 18C  00710                rotate90: LOAD s7, s1                                            ; temporary store for I
 18D  00600                          LOAD s6, s0                                            ; temp store
 18E  1D380                          COMPARE s3, 80[128'd]                                  ; is Q negative?
 18F  3E199                          JUMP NC, 199[add90]                                    ; if negative add 90
 190  00130                   sub90: LOAD s1, s3
 191  00020                          LOAD s0, s2                                            ; I=Q
 192  01200                          LOAD s2, 00
 193  01300                          LOAD s3, 00
 194  18260                          SUB s2, s6
 195  1A370                          SUBCY s3, s7                                           ; Q=-I
 196  19400                          SUB s4, 00[half_pi_LSB]
 197  1B540                          SUBCY s5, 40[half_pi_MSB]
 198  25000                          RETURN 
 199  01100                   add90: LOAD s1, 00
 19A  01000                          LOAD s0, 00
 19B  18020                          SUB s0, s2
 19C  1A130                          SUBCY s1, s3                                           ; I=-Q
 19D  00260                          LOAD s2, s6
 19E  00370                          LOAD s3, s7                                            ; Q=I
 19F  01400                          LOAD s4, 00[half_pi_LSB]
 1A0  01540                          LOAD s5, 40[half_pi_MSB]
 1A1  25000                          RETURN 
 1A2                                 ;takes s2 and returns in s2 the absolute value of s2 (uses s6)
 1A2  1D280                  absval: COMPARE s2, 80[128'd]
 1A3  3C1A5                          CALL NC, 1A5[makeposval]
 1A4  25000                          RETURN 
 1A5                                 ; Turn negative value in s2 into a positive one (well will actualy make a positive value negative as well).
 1A5  01600              makeposval: LOAD s6, 00
 1A6  18620                          SUB s6, s2
 1A7  00260                          LOAD s2, s6
 1A8  25000                          RETURN 
 1A9                                 ; Takes value in s5 and converts to 2 ascii codes which are sent to the user picoblaze.
 1A9  201C7             Export2User: CALL 1C7[Byte2Chars]
 1AA  2D600                          OUTPUT s6, 00[CmdToUser]
 1AB  2D700                          OUTPUT s7, 00[CmdToUser]
 1AC  01614                          LOAD s6, 14[20'd]                                      ; terminate with space character
 1AD  2D600                          OUTPUT s6, 00[CmdToUser]
 1AE  25000                          RETURN 
 1AF  0160D                 AddCRLF: LOAD s6, 0D[13'd]                                      ; terminate with CR
 1B0  2D600                          OUTPUT s6, 00[CmdToUser]
 1B1  0160A                          LOAD s6, 0A[10'd]                                      ; and with LF
 1B2  2D600                          OUTPUT s6, 00[CmdToUser]
 1B3  25000                          RETURN 
 1B4                                 ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 1B4  00860              Chars2Byte: LOAD s8, s6
 1B5  201BF                          CALL 1BF[Get4bits]
 1B6  00580                          LOAD s5, s8
 1B7  14506                          SL0 s5
 1B8  14506                          SL0 s5
 1B9  14506                          SL0 s5
 1BA  14506                          SL0 s5                                                 ; put these 4 bits to MSBs
 1BB  00870                          LOAD s8, s7
 1BC  201BF                          CALL 1BF[Get4bits]
 1BD  10580                          ADD s5, s8
 1BE  25000                          RETURN 
 1BF                                 ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 1BF  1D83C                Get4bits: COMPARE s8, 3C[60'd]                                   ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 1C0  3A1C4                          JUMP C, 1C4[char0_9]
 1C1  19837                          SUB s8, 37[55'd]                                       ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 1C2  0380F                          AND s8, 0F                                             ; make sure only return 4 bits
 1C3  25000                          RETURN 
 1C4  19830                 char0_9: SUB s8, 30[48'd]
 1C5  0380F                          AND s8, 0F                                             ; make sure only return 4 bits
 1C6  25000                          RETURN 
 1C7                                 ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 1C7  00850              Byte2Chars: LOAD s8, s5                                            ; assumes 8 bit data is in s5
 1C8  1450E                          SR0 s5
 1C9  1450E                          SR0 s5
 1CA  1450E                          SR0 s5
 1CB  1450E                          SR0 s5                                                 ; get first hex character
 1CC  201D3                          CALL 1D3[GetChar]
 1CD  00650                          LOAD s6, s5                                            ; first ascii char
 1CE  00580                          LOAD s5, s8
 1CF  0350F                          AND s5, 0F
 1D0  201D3                          CALL 1D3[GetChar]                                      ; send to LCD or UART
 1D1  00750                          LOAD s7, s5                                            ; second ascii char
 1D2  25000                          RETURN 
 1D3                                 ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 1D3  1950A                 GetChar: SUB s5, 0A[10'd]                                       ; Test if s5 greater than 9
 1D4  3A1D7                          JUMP C, 1D7[is_0_9]                                    ; Hex character is 0_9
 1D5  11541                          ADD s5, 41[65'd]                                       ; offset for Ascii code 'A'
 1D6  25000                          RETURN 
 1D7  1150A                  is_0_9: ADD s5, 0A[10'd]                                       ; return to range 0-9
 1D8  11530                          ADD s5, 30[48'd]                                       ; offset to Ascii code for '0'
 1D9  25000                          RETURN 
 1DA                                 ; Registers used s0, s1, s2, s3, s4 and s5.
 1DA                                 ;
 1DA  01500                delay_1s: LOAD s5, 00                                            ; clear cycle counter
 1DB  01400                          LOAD s4, 00
 1DC  201ED                 wait_1s: CALL 1ED[delay_1ms]
 1DD  11401                          ADD s4, 01                                             ; increment cycle counter
 1DE  13500                          ADDCY s5, 00
 1DF  1D4E8                          COMPARE s4, E8[count_1000_lsb]                         ; test for 1000ms
 1E0  361DC                          JUMP NZ, 1DC[wait_1s]
 1E1  1D503                          COMPARE s5, 03[count_1000_msb]
 1E2  361DC                          JUMP NZ, 1DC[wait_1s]
 1E3  25000                          RETURN 
 1E4                                 ;
 1E4                                 ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 1E4                                 ;
 1E4                                 ;
 1E4                                 ; Registers used s0, s1, s2, s3 and s4.
 1E4                                 ;
 1E4  201E8             delay_300ms: CALL 1E8[delay_100ms]
 1E5  201E8             delay_200ms: CALL 1E8[delay_100ms]
 1E6  201E8                          CALL 1E8[delay_100ms]
 1E7  25000                          RETURN 
 1E8                                 ;
 1E8                                 ; Delay of approximately 100ms used for switch debounce
 1E8                                 ;
 1E8                                 ; Registers used s0, s1, s2, s3 and s4.
 1E8                                 ;
 1E8  01464             delay_100ms: LOAD s4, 64                                            ; repeat 1ms delay 100 times
 1E9  201ED              wait_100ms: CALL 1ED[delay_1ms]
 1EA  19401                          SUB s4, 01
 1EB  361E9                          JUMP NZ, 1E9[wait_100ms]
 1EC  25000                          RETURN 
 1ED                                 ;
 1ED                                 ; Delay of approximately 1ms required by LCD display
 1ED                                 ;
 1ED                                 ; Registers used s0, s1, s2 and s3.
 1ED                                 ;
 1ED  01300               delay_1ms: LOAD s3, 00                                            ; clear cycle counter
 1EE  01200                          LOAD s2, 00
 1EF  201FC                wait_1ms: CALL 1FC[delay_1us]
 1F0  11201                          ADD s2, 01                                             ; increment cycle counter
 1F1  13300                          ADDCY s3, 00
 1F2  1D2E8                          COMPARE s2, E8[count_1000_lsb]                         ; test for 1000us
 1F3  361EF                          JUMP NZ, 1EF[wait_1ms]
 1F4  1D303                          COMPARE s3, 03[count_1000_msb]
 1F5  361EF                          JUMP NZ, 1EF[wait_1ms]
 1F6  25000                          RETURN 
 1F7                                 ;
 1F7                                 ; Delay of approximately 50us required by LCD display
 1F7                                 ;
 1F7                                 ; Registers used s0 and s1.
 1F7                                 ;
 1F7  01132              delay_50us: LOAD s1, 32[50'd]                                      ; repeat 1us delay 50 times
 1F8  201FC               wait_50us: CALL 1FC[delay_1us]
 1F9  19101                          SUB s1, 01
 1FA  361F8                          JUMP NZ, 1F8[wait_50us]
 1FB  25000                          RETURN 
 1FC                                 ; Delay of approximately 1us used to provide timing reference for
 1FC                                 ; LCD operations. This must be adjusted to reflect the clock
 1FC                                 ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 1FC                                 ;
 1FC                                 ; The software delay loop is formed using register s0. This register
 1FC                                 ; must be loaded with an integer value close to the result of....
 1FC                                 ;
 1FC                                 ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 1FC                                 ;
 1FC                                 ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 1FC                                 ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 1FC                                 ; operation will become lower than the 100KHz target intended.
 1FC                                 ;
 1FC                                 ; Register used s0.
 1FC                                 ;
 1FC  01006               delay_1us: LOAD s0, 06[delay_1us_constant]                        ; delay value of 12 decimal for a 50MHz clock
 1FD  19001                wait_1us: SUB s0, 01
 1FE  361FD                          JUMP NZ, 1FD[wait_1us]
 1FF  25000                          RETURN 
 200                                 ;
 200                                 ;
 200                                 ; Multiplier Routine (8-bit x 8-bit = 16-bit product) - Ken Chapman
 200                                 ; ==================================================
 200                                 ; Shift and add algorithm
 200                                 ;
 200                       mult_8x8: 
 200                                 NAMEREG s0, multiplicand                               ; preserved
 200                                 NAMEREG s1, multiplier                                 ; preserved
 200                                 NAMEREG s2, bit_mask                                   ; modified
 200                                 NAMEREG s3, result_msb                                 ; most-significant byte (MSB) of result,
 200                                 ; modified
 200                                 NAMEREG s4, result_lsb                                 ; least-significant byte (LSB) of result,
 200                                 ; modified
 200                                 ;
 200  01201                          LOAD s2[bit_mask], 01                                  ; start with least-significant bit (lsb)
 201  01300                          LOAD s3[result_msb], 00                                ; clear product MSB
 202  01400                          LOAD s4[result_lsb], 00                                ; clear product LSB (not required)
 203                                 ;
 203                                 ; loop through all bits in multiplier
 203  0C120               mult_loop: TEST s1[multiplier], s2[bit_mask]                      ; check if bit is set
 204  32206                          JUMP Z, 206[no_add]                                    ; if bit is not set, skip addition
 205                                 ;
 205  10300                          ADD s3[result_msb], s0[multiplicand]                   ; addition only occurs in MSB
 206                                 ;
 206  14308                  no_add: SRA s3[result_msb]                                     ; shift MSB right, CARRY into bit 7,
 207                                 ; lsb into CARRY
 207  14408                          SRA s4[result_lsb]                                     ; shift LSB right,
 208                                 ; lsb from result_msb into bit 7
 208                                 ;
 208  14206                          SL0 s2[bit_mask]                                       ; shift bit_mask left to examine
 209                                 ; next bit in multiplier
 209                                 ;
 209  36203                          JUMP NZ, 203[mult_loop]                                ; if all bit examined, then bit_mask = 0


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\home\gnaylor\Dropbox\N3SysGen\ToneDetectpico.psm



List of defined constants

 CONSTANT name       Value        Source PSM File

 timestamp_hours     17'd         
 timestamp_minutes   59'd         
 timestamp_seconds   31'd         
 datestamp_year      18'd         
 datestamp_month     2'd          
 datestamp_day       21'd         
 NUL                 00           
 BEL                 07           
 BS                  08           
 HT                  09           
 LF                  0A           
 VT                  0B           
 CR                  0D           
 ESC                 1B           
 DEL                 7F           
 DCS                 90           
 ST                  9C           
 delay_1us_constant  06           ToneDetectpico.psm
 m                   8'd          ToneDetectpico.psm
 m_plus_1            9'd          ToneDetectpico.psm
 count_1000_lsb      E8           ToneDetectpico.psm
 count_1000_msb      03           ToneDetectpico.psm
 half_pi_LSB         00           ToneDetectpico.psm
 half_pi_MSB         40           ToneDetectpico.psm
 phase_threshold     30'd         ToneDetectpico.psm
 count_value_to_trig 9'd          ToneDetectpico.psm
 audioTest           2'd          ToneDetectpico.psm
 StrtToneAInc        9E           ToneDetectpico.psm
 StrtToneBInc        68           ToneDetectpico.psm
 StopToneAInc        59           ToneDetectpico.psm
 StopToneBInc        77           ToneDetectpico.psm
 AudioMSB            0'd          ToneDetectpico.psm
 AudioLSB            1'd          ToneDetectpico.psm
 Strobe              2'd          ToneDetectpico.psm
 DemodMSB            3'd          ToneDetectpico.psm
 DemodLSB            4'd          ToneDetectpico.psm
 TBD0                5'd          ToneDetectpico.psm
 TBD1                6'd          ToneDetectpico.psm
 TBD2                7'd          ToneDetectpico.psm
 CmdToUser           0'd          ToneDetectpico.psm
 LOMSB               1'd          ToneDetectpico.psm
 BRAMaddrMSB         2'd          ToneDetectpico.psm
 BRAMaddrLSB         3'd          ToneDetectpico.psm
 StartAmpOut         25'd         ToneDetectpico.psm
 State               26'd         ToneDetectpico.psm
 AVEtoneAmp          9'd          ToneDetectpico.psm
 STRTAinc            10'd         ToneDetectpico.psm
 STRTAptrMSB         11'd         ToneDetectpico.psm
 STRTAptrLSB         12'd         ToneDetectpico.psm
 STRTAAccuDemodIMSB  13'd         ToneDetectpico.psm
 STRTAAccuDemodILSB  14'd         ToneDetectpico.psm
 STRTAAccuDemodQMSB  15'd         ToneDetectpico.psm
 STRTAAccuDemodQLSB  16'd         ToneDetectpico.psm
 STRTAcurrentPhase   17'd         ToneDetectpico.psm
 STRTApreviousPhase  18'd         ToneDetectpico.psm
 STRTAcounter        19'd         ToneDetectpico.psm
 STRTBinc            20'd         ToneDetectpico.psm
 STPAinc             30'd         ToneDetectpico.psm
 STPBinc             40'd         ToneDetectpico.psm
 SampleCounterMSB    90'd         ToneDetectpico.psm
 StartAmpA           91'd         ToneDetectpico.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "21 Feb 2018"  
 timestamp$        "17:59:31"     



List of line labels

   Label                    Addr  Source PSM File

 * cold_start               000   ToneDetectpico.psm
   AwaitAudioVal            01B   ToneDetectpico.psm
   AwaitRise                01F   ToneDetectpico.psm
   isReceiving              029   ToneDetectpico.psm
   StartDemod               02F   ToneDetectpico.psm
   DemodulateTone           03C   ToneDetectpico.psm
   CheckMatureAndOutput     075   ToneDetectpico.psm
   Matured                  07A   ToneDetectpico.psm
   CarryOn                  085   ToneDetectpico.psm
   Whoopie                  0AC   ToneDetectpico.psm
   dropcounter              0B7   ToneDetectpico.psm
   IncrementCounter         0BC   ToneDetectpico.psm
   CheckNotTooBigI          0C2   ToneDetectpico.psm
   CheckNotTooBigQ          0D5   ToneDetectpico.psm
   isStrtToneA              0E8   ToneDetectpico.psm
   isStrtToneB              0F0   ToneDetectpico.psm
   isStopToneA              0F7   ToneDetectpico.psm
   isStopToneB              0FD   ToneDetectpico.psm
   CheckforTimeOuts         106   ToneDetectpico.psm
   checkStarttoneAtimeout   10D   ToneDetectpico.psm
   checkRXtimeout           111   ToneDetectpico.psm
   checkStoptoneAtimeout    117   ToneDetectpico.psm
   N3ZtoneDetected          11C   ToneDetectpico.psm
   N3ZtoneLost              123   ToneDetectpico.psm
 * DoAccumulate             12B   ToneDetectpico.psm
   negaccum                 133   ToneDetectpico.psm
   negdecrmnt               13E   ToneDetectpico.psm
 * LUTandMultiply           144   ToneDetectpico.psm
   StreamAmp                148   ToneDetectpico.psm
   StreamPhase              14C   ToneDetectpico.psm
   waitabit                 151   ToneDetectpico.psm
   cordic                   155   ToneDetectpico.psm
   cordicloop               15A   ToneDetectpico.psm
 * negrotate                15E   ToneDetectpico.psm
   posrotate                16C   ToneDetectpico.psm
   testcordicend            179   ToneDetectpico.psm
   GetPhaseIncrement        17D   ToneDetectpico.psm
   shift                    185   ToneDetectpico.psm
   shiftloop                186   ToneDetectpico.psm
   rotate90                 18C   ToneDetectpico.psm
 * sub90                    190   ToneDetectpico.psm
   add90                    199   ToneDetectpico.psm
   absval                   1A2   ToneDetectpico.psm
   makeposval               1A5   ToneDetectpico.psm
 * Export2User              1A9   ToneDetectpico.psm
 * AddCRLF                  1AF   ToneDetectpico.psm
 * Chars2Byte               1B4   ToneDetectpico.psm
   Get4bits                 1BF   ToneDetectpico.psm
   char0_9                  1C4   ToneDetectpico.psm
   Byte2Chars               1C7   ToneDetectpico.psm
   GetChar                  1D3   ToneDetectpico.psm
   is_0_9                   1D7   ToneDetectpico.psm
   delay_1s                 1DA   ToneDetectpico.psm
   wait_1s                  1DC   ToneDetectpico.psm
   delay_300ms              1E4   ToneDetectpico.psm
 * delay_200ms              1E5   ToneDetectpico.psm
   delay_100ms              1E8   ToneDetectpico.psm
   wait_100ms               1E9   ToneDetectpico.psm
   delay_1ms                1ED   ToneDetectpico.psm
   wait_1ms                 1EF   ToneDetectpico.psm
 * delay_50us               1F7   ToneDetectpico.psm
   wait_50us                1F8   ToneDetectpico.psm
   delay_1us                1FC   ToneDetectpico.psm
   wait_1us                 1FD   ToneDetectpico.psm
 * mult_8x8                 200   ToneDetectpico.psm
   mult_loop                203   ToneDetectpico.psm
   no_add                   206   ToneDetectpico.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            113
 STAR              -

 AND               7
 OR                -
 XOR               -

 ADD              41
 ADDCY            11
 SUB              34
 SUBCY             7

 TEST              1
 TESTCY            -
 COMPARE          39
 COMPARECY         -

 SL0               5
 SL1               -
 SLX               -
 SLA               2
 RL                -
 SR0              11
 SR1               -
 SRX               7
 SRA              15
 RR                -

 REGBANK           -

 INPUT            10
 OUTPUT           19
 OUTPUTK           -

 STORE            26
 FETCH            26

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             26
 JUMP@             -
 CALL             54
 CALL@             -
 RETURN           54
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
