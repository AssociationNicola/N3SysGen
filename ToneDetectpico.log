KCPSM6 Assembler log file for program 'Z:\home\gnaylor\Dropbox\N3SysGen\ToneDetectpico.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 12 Apr 2018
Assembly timestamp: 21:38:16

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 20A hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 523
Memory locations available: 3573


Assembly listing

 Addr Code                           Instruction

 000                                 ;GV0B Tone detect working - getting AGC adjust to work thrugh DSP
 000                                 ;GV?? first tone detect
 000                                 CONSTANT delay_1us_constant, 06                        ; Value (13)19 or 12? decimal suitable for 50MHz clock – about 6 for 33MHz?
 000                                 CONSTANT m, 8'd                                        ; No. of iterations for cordic
 000                                 CONSTANT m_plus_1, 9'd                                 ; No. of iterations for cordic
 000                                 CONSTANT count_1000_lsb, E8                            ; lower 8-bits of 1000 count value
 000                                 CONSTANT count_1000_msb, 03                            ; upper 8-bits of 1000 count value
 000                                 CONSTANT half_pi_LSB, 00                               ;
 000                                 CONSTANT half_pi_MSB, 40                               ; 360 degrees = $10000
 000                                 CONSTANT phase_threshold, 30'd                         ;test for phase fairly constant
 000                                 CONSTANT count_value_to_trig, 9'd                      ;if low phase 12 succesive times, then this is significant! - try to increase sensitivity (was 10 - worth trying 6!)
 000                                 ;not sure about these (Aug2016)
 000                                 CONSTANT audioTest, 2'd                                ; Frequency 2=800Hz, 3=1200Hz, 4=1.6kHz 7=2.8kHz
 000                                 ;Frequency values for start and stop tones (decrease all by 1 29/1/17)
 000                                 CONSTANT StrtToneAInc, 9E
 000                                 CONSTANT StrtToneBInc, 68
 000                                 CONSTANT StopToneAInc, 59
 000                                 CONSTANT StopToneBInc, 77
 000                                 ; Registers
 000                                 NAMEREG sF, SampleCounter                              ;
 000                                 NAMEREG sE, TempScratchPointer
 000                                 NAMEREG sD, Mode                                       ;stores the operating mode: 0=idle, 1=Starting, 2=Receiving, 3=stopping, 4=TX
 000                                 NAMEREG sC, SampleTimer                                ;This counter does not stop!
 000                                 ; registers sA-sB are used for longish term storage...!
 000                                 ; sA used for cordic calcs
 000                                 ; Scratch pad
 000                                 ; registers 0-8 used for cordic table:
 000                                 ; reg 0=45degrees
 000                                 ; ..
 000                                 ; reg 7=0.44761degrees
 000                                 ; Input port
 000                                 CONSTANT AudioMSB, 0'd                                 ;Not used?
 000                                 CONSTANT AudioLSB, 1'd
 000                                 CONSTANT Strobe, 2'd                                   ;     bit0=8kHz square wave - Bit 1 is TX_High
 000                                 CONSTANT DemodMSB, 3'd                                 ; Top significant byte of multiplier output
 000                                 CONSTANT DemodLSB, 4'd                                 ; (only 16 bits retained)
 000                                 CONSTANT TBD0, 5'd                                     ;
 000                                 CONSTANT TBD1, 6'd                                     ;
 000                                 CONSTANT TBD2, 7'd                                     ;TBdefined
 000                                 ; Output ports
 000                                 CONSTANT CmdToUser, 0'd
 000                                 CONSTANT LOMSB, 1'd
 000                                 CONSTANT ToneMode, 2'd
 000                                 CONSTANT BRAMaddrLSB, 3'd                              ;Not currently used (Feb '17)
 000                                 ;also used:8,9,13,14,18,19,23,24 -  8 STRTA,13  STRTB ,18 STPA or 23  STPB, and 9 STRTA,14  STRTB ,19 STPA or 24  STPB
 000                                 ; 6,11,16,21 used for running Itone values and 7,12,17,22 for Qtone values
 000                                 CONSTANT StartAmpOut, 25'd                             ;goes to DSP pico to calibrate AGC
 000                                 CONSTANT State, 26'd                                   ;Bit 0 N3signalReceived, Bit 1 is not used, Bit 2 Tone detect off
 000                                 ; Scratchpad registers
 000                                 ; 0-8 used for Cordic Table!
 000                                 ;Now various pointers to create start and stop tones
 000                                 CONSTANT AVEtoneAmp, 9'd                               ;Is this needed?
 000                                 CONSTANT STRTAinc, 10'd                                ;This is the base address loaded into s0 before calling 'TreatTone'
 000                                 CONSTANT STRTAptrMSB, 11'd                             ;16 bit value used to generate the LUT ptr - won't use these names, just documented for reference
 000                                 CONSTANT STRTAptrLSB, 12'd                             ;fine resolution
 000                                 CONSTANT STRTAAccuDemodIMSB, 13'd                      ;This is the 16 bit value returned from the mulitplier
 000                                 CONSTANT STRTAAccuDemodILSB, 14'd                      ;Will this byte be used?
 000                                 CONSTANT STRTAAccuDemodQMSB, 15'd                      ;This is th e 16 bit value of the demod component accumulated
 000                                 CONSTANT STRTAAccuDemodQLSB, 16'd
 000                                 CONSTANT STRTAcurrentPhase, 17'd                       ;8 bit value of the current phase determined by the cordic
 000                                 CONSTANT STRTApreviousPhase, 18'd                      ;8 bit value of the previous phase determined by the cordic
 000                                 CONSTANT STRTAcounter, 19'd                            ;counts number of cycles of constant phase..
 000                                 CONSTANT STRTBinc, 20'd
 000                                 ;etc
 000                                 CONSTANT STPAinc, 30'd
 000                                 CONSTANT STPBinc, 40'd
 000                                 ;then second space at +40 from above numbers for another 4 tones
 000                                 ;uses up to Scratch register 89'd
 000                                 CONSTANT SampleCounterMSB, 90'd                        ;So as to have a 16 bit sample counter
 000                                 CONSTANT StartAmpA, 91'd                               ;Store the amplitude of the startA tone continuosly and output when whoopie.
 000                                 ;CONSTANT     ToneDetectState, 92'd  ; tone detect enabled when 1 - NOT USED
 000  010FF              cold_start: LOAD s0, FF[255'd]                                     ; phase for 45 degrees- actually a bit less!
 001  2F000                          STORE s0, 00
 002  01097                          LOAD s0, 97[151'd]                                     ; phase for 26.565 degrees
 003  2F001                          STORE s0, 01
 004  01050                          LOAD s0, 50[80'd]                                      ; phase for 14.036 degrees
 005  2F002                          STORE s0, 02
 006  01029                          LOAD s0, 29[41'd]                                      ; phase for 7.125 degrees
 007  2F003                          STORE s0, 03
 008  01014                          LOAD s0, 14[20'd]                                      ; phase for 3.576 degrees
 009  2F004                          STORE s0, 04
 00A  0100A                          LOAD s0, 0A[10'd]                                      ; phase for 1.79 degrees
 00B  2F005                          STORE s0, 05
 00C  01005                          LOAD s0, 05[5'd]                                       ; phase for 0.895 degrees
 00D  2F006                          STORE s0, 06
 00E  01003                          LOAD s0, 03[3'd]                                       ; phase for 0.448 degrees
 00F  2F007                          STORE s0, 07
 010  01001                          LOAD s0, 01[1'd]                                       ; phase for 0.224 degrees
 011  2F008                          STORE s0, 08
 012  0109E                          LOAD s0, 9E[StrtToneAInc]                              ; Tone increments to detect
 013  2F00A                          STORE s0, 0A[STRTAinc]
 014  01068                          LOAD s0, 68[StrtToneBInc]                              ; Tone increments to detect
 015  2F014                          STORE s0, 14[STRTBinc]
 016  01059                          LOAD s0, 59[StopToneAInc]                              ; Tone increments to detect
 017  2F01E                          STORE s0, 1E[STPAinc]
 018  01077                          LOAD s0, 77[StopToneBInc]                              ; Tone increments to detect
 019  2F028                          STORE s0, 28[STPBinc]
 01A  09002                          INPUT s0, 02[Strobe]
 01B                                 ;     AND   s0, 04  ; tone detect disabled if set to 1
 01B                                 ;
 01B                                 ;     STORE     s0, ToneDetectState  ; tone detect is disabled if 04
 01B                                 ;      CALL N3ZtoneDetected ;Start with speaker ON !!!!!!!!!!!!!!!!!!!!!!
 01B                                 ; Routine to look at lowest bit of Strobe to detect rising edge.
 01B                  AwaitAudioVal: 
 01B  2DD02                          OUTPUT sD[Mode], 02[ToneMode]                          ;Make mode value available outside
 01C                                 ;     INPUT     s0, Strobe
 01C                                 ;Tone detect is no longer disabled by this pico - is disabled directly in logic
 01C                                 ;                    AND       s0, 04               ; look only at lowest bit
 01C                                 ;     FETCH     s1, ToneDetectState
 01C                                 ;                    COMPARE   s0, s1
 01C                                 ;     CALL   NZ, ToneDetectStateChanged
 01C  09002                          INPUT s0, 02[Strobe]
 01D  03001                          AND s0, 01                                             ; look only at lowest bit
 01E  1D001                          COMPARE s0, 01
 01F  3201B                          JUMP Z, 01B[AwaitAudioVal]                             ; if 1 wait...
 020  09002               AwaitRise: INPUT s0, 02[Strobe]
 021  03001                          AND s0, 01                                             ; look only at lowest bit
 022  1D000                          COMPARE s0, 00
 023  32020                          JUMP Z, 020[AwaitRise]                                 ; if 0 still, wait a bit more...
 024                                 ;Demod signal is not stable till ~6 clock cycles after rising edge, so should maybe use falling edge??
 024                                 ;so will be stable after ~3 instructions!
 024  09002                          INPUT s0, 02[Strobe]                                   ;To check if in TX mode
 025  03002                          AND s0, 02                                             ;look at bit 1
 026  1D000                          COMPARE s0, 00
 027  3202A                          JUMP Z, 02A[isReceiving]                               ;TX_High not set
 028  01D04                          LOAD sD[Mode], 04                                      ;keep in TX mode
 029  2201B                          JUMP 01B[AwaitAudioVal]                                ; keep looping (was mistakenly on AwaitRise April 18)
 02A                    isReceiving: 
 02A  11C01                          ADD sC[SampleTimer], 01                                ;Always increment timer in receive mode
 02B  1DD04                          COMPARE sD[Mode], 04
 02C  36030                          JUMP NZ, 030[StartDemod]                               ;has not just come out of TX
 02D                                 ;Only do this bit once when going from Transmit mode (Mode 4) to Receive.
 02D  201E9                          CALL 1E9[delay_100ms]                                  ;has just come out of TX so wait a bit before detecting tones GN ?????? is this needed???????
 02E  20124                          CALL 124[N3ZtoneLost]                                  ;Make sure tone detect is off
 02F  01D00                          LOAD sD[Mode], 00                                      ;has just come out of TX, so reset mode to idle
 030                                 ;start treating StrtToneA
 030  0100A              StartDemod: LOAD s0, 0A[STRTAinc]                                  ;Note s0 is being used to point to the location of the values in scratch memory!
 031  01100                          LOAD s1, 00[00'd]                                      ;(counter value when mature)
 032  2003D                          CALL 03D[DemodulateTone]                               ;and checks if the accumulation has matured (from s1) and if so do cordic
 033                                 ;start treating StrtToneB
 033  01014                          LOAD s0, 14[STRTBinc]
 034  01110                          LOAD s1, 10[16'd]                                      ;(counter value when mature)
 035  2003D                          CALL 03D[DemodulateTone]
 036                                 ;start treating StpToneA
 036  0101E                          LOAD s0, 1E[STPAinc]
 037  01120                          LOAD s1, 20[32'd]                                      ;(counter value when mature)
 038  2003D                          CALL 03D[DemodulateTone]
 039                                 ;start treating StpToneB
 039  01028                          LOAD s0, 28[STPBinc]
 03A  01130                          LOAD s1, 30[48'd]                                      ;(counter value when mature)
 03B  2003D                          CALL 03D[DemodulateTone]
 03C                                 ;add more tones to demodulate here for digital modes.
 03C  2201B                          JUMP 01B[AwaitAudioVal]
 03D                                 ; -------------This is end of main loop--------------------------------
 03D                                 ;Accumulate and demodulate routine
 03D                                 ;Enter with mature index in s1 (0-63 to stagger output to the UART) and the scratch base address to treat in s0 - this is the scratch
 03D                                 ;address for the toneinc
 03D  0A200          DemodulateTone: FETCH s2, (s0)                                         ;Tone increment (pointed to in scratch by s0, to increment through sine wave LUT)
 03E  01300                          LOAD s3, 00
 03F                                 ;Need to right shift into s3 to scale correctly (as they are 4 times too big)
 03F  1420E                          SR0 s2                                                 ;The increment is a positive value (0-255 when x4) so should be kept positive!
 040  14308                          SRA s3                                                 ;and carry containing lowest bit
 041  1420E                          SR0 s2
 042  14308                          SRA s3                                                 ;and carry containing lowest bit (doing this twice limits highest frequency to about 2kHz)
 043  11001                          ADD s0, 01
 044  0A400                          FETCH s4, (s0)                                         ;MSB of LUTptr
 045  11001                          ADD s0, 01
 046  0A500                          FETCH s5, (s0)                                         ;LSB of LUTptr
 047  10530                          ADD s5, s3                                             ;increment LUTptr
 048  12420                          ADDCY s4, s2                                           ;increment LUTptr
 049  2E500                          STORE s5, (s0)                                         ;update LSB LUTptr
 04A  19001                          SUB s0, 01                                             ;decrement scratch pointer s0
 04B  2E400                          STORE s4, (s0)                                         ;update MSB LUTptr
 04C                                 ;           OUTPUT s5,LOLSB ;Send next sinewave address to LUT
 04C  2D401                          OUTPUT s4, 01[LOMSB]                                   ;Actually only need to output MSB  - use write of MSB to delay trigger latch of multiplier
 04D  20152                          CALL 152[waitabit]
 04E                                 ;NEED To wait for multiplication otherwise cordic will be out of step
 04E  09203                          INPUT s2, 03[DemodMSB]                                 ;input previous LO tone multiplied by the signal (for accumulation)
 04F  09304                          INPUT s3, 04[DemodLSB]
 050                                 ;This value may be too big as it stands to accumulate so need to scale down so as not to overflow
 050                                 ;   SRX s2
 050                                 ;   SRA s3
 050                                 ;   SRX s2
 050                                 ;   SRA s3
 050                                 ;   SRX s2
 050                                 ;   SRA s3
 050  11002                          ADD s0, 02                                             ;move back up to scratch pointer location for MSB of I accumulating signal (of previous tone!)
 051  0A600                          FETCH s6, (s0)                                         ;MSB of Accumulated I demod value
 052                                 ;added this bit to get debug info again !!!!!!!!!!!!!!!!!!!!!!
 052  19001                          SUB s0, 01                                             ;to get an even value!
 053  14008                          SRA s0                                                 ;divide by 2 to get 6,11,16 or 21
 054  2C600                          OUTPUT s6, (s0)                                        ;Export intermediate I value accumulated
 055  14000                          SLA s0                                                 ;now get s0 back on track
 056  11001                          ADD s0, 01                                             ;add one to get back and another to advance to I LSB accu
 057                                 ;Would be ADD s0,01 instead of the above debug
 057  11001                          ADD s0, 01                                             ;add one to get back and another to advance to I LSB accu
 058  0A700                          FETCH s7, (s0)                                         ;LSB of Accumulated I demod value (base + 4)
 059  10730                          ADD s7, s3                                             ;signed accumulate into Accumulated value
 05A  12620                          ADDCY s6, s2                                           ;accumulate into Accumulated value
 05B  200C3                          CALL 0C3[CheckNotTooBigI]                              ;Check s6(MSB),s7 not to big (ie bigger than 40)
 05C  2E700                          STORE s7, (s0)                                         ;update LSB Accumulated value
 05D  19001                          SUB s0, 01                                             ;decrement scratch pointer s0
 05E  2E600                          STORE s6, (s0)                                         ;update MSB Accumulated value
 05F  00E00                          LOAD sE[TempScratchPointer], s0                        ;temporarily store pointer to MSB of accumulated I value
 060                                 ;s4 and s5 still have LUTptr to add pi/2
 060  11440                          ADD s4, 40[64'd]
 061                                 ;    OUTPUT s5,LOLSB ;Send next sinewave address to LUT -  already done!
 061  2D401                          OUTPUT s4, 01[LOMSB]                                   ;Actually only need to output MSB  - use write of MSB to delay trigger latch of multiplier
 062  20152                          CALL 152[waitabit]
 063                                 ;NEED To wait for multiplication otherwise cordic will be out of step
 063  09203                          INPUT s2, 03[DemodMSB]                                 ;input previous LO tone multiplied by the signal (for accumulation)
 064  09304                          INPUT s3, 04[DemodLSB]
 065                                 ;This value may be too big as it stands to accumulate so need to scale down so as not to overflow?
 065                                 ;   SRX s2
 065                                 ;   SRA s3
 065                                 ;   SRX s2
 065                                 ;   SRA s3
 065                                 ;   SRX s2
 065                                 ;   SRA s3
 065  11002                          ADD s0, 02                                             ;move back up to scratch pointer location for Q MSB of accumulating signal (of previous tone!)
 066  0A600                          FETCH s6, (s0)                                         ;MSB of Accumulated Q demod value
 067                                 ;added this bit to get debug info renable !!!!!!!!!!!!!!!!!!!!!!!!!!
 067  19001                          SUB s0, 01                                             ;to get an even value!
 068  14008                          SRA s0                                                 ;divide by 2 to get 7,12,17 or 22
 069  2C600                          OUTPUT s6, (s0)                                        ;Export MSB of  Q value accumulated
 06A  14000                          SLA s0                                                 ;now get s0 back on track
 06B  11001                          ADD s0, 01                                             ;add one to get back and another to advance to I LSB accu
 06C                                 ;Would be ADD s0,01 instead of the above debug
 06C  11001                          ADD s0, 01                                             ;add one to get back and another to advance to I LSB accu
 06D  0A700                          FETCH s7, (s0)                                         ;LSB of Accumulated Q demod value (base + 6)
 06E  10730                          ADD s7, s3                                             ;signed accumulate into Accumulated value
 06F  12620                          ADDCY s6, s2                                           ;accumulate into Accumulated value
 070  200D6                          CALL 0D6[CheckNotTooBigQ]                              ;Check s6(MSB),s7 not to0 big (ie bigger than 48)
 071  2E700                          STORE s7, (s0)                                         ;update LSB Accumulated value
 072  19001                          SUB s0, 01                                             ;decrement scratch pointer s0 (s0 now at base + 5)
 073  2E600                          STORE s6, (s0)                                         ;update MSB Accumulated value
 074  20076                          CALL 076[CheckMatureAndOutput]
 075  25000                          RETURN 
 076                                 ;Checks s1 is mature
 076  003C0    CheckMatureAndOutput: LOAD s3, sC[SampleTimer]                               ;Use the always incremented timer!
 077  0333F                          AND s3, 3F                                             ;mod 64
 078  1C310                          COMPARE s3, s1
 079  3007B                          CALL Z, 07B[Matured]                                   ;OK to do cordic and output - this will happen every 2ms (or every 1ms with 8 tones being decoded)
 07A  25000                          RETURN 
 07B                                 ;Cordic takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
 07B                                 ; Useable range is for I and Q up to about +/-$3000
 07B                                 ;normally get I and Q values from scratch. Scratch pointer
 07B                                 ;need to use TempScratchPointer as s0 value which had pointed to the scratch area has been lost
 07B  0A1E0                 Matured: FETCH s1, (sE[TempScratchPointer])                     ;pointer at MSB of I accumulated
 07C  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to LSB of I accumulated
 07D  0A0E0                          FETCH s0, (sE[TempScratchPointer])
 07E  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to MSB of Q accumulated
 07F  0A3E0                          FETCH s3, (sE[TempScratchPointer])
 080  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to LSB of Q accumulated
 081  0A2E0                          FETCH s2, (sE[TempScratchPointer])                     ;TempScratchPointer has now increased by 3
 082  20156                          CALL 156[cordic]
 083                                 ;now have amplitude and phase in s0/s1(MSB AMP)...s4,s5(MSB Phase) - need to calculate phase change and output the MSBs
 083                                 ;Use MSB amp in s1 - only interested in SartAmpA value - put in fixed scratch location if TempScratchPointer is +6,for this tone, ie is STRTAAccuDemodQLSB
 083  1DE10                          COMPARE sE[TempScratchPointer], 10[STRTAAccuDemodQLSB] ; are we treating StartToneA
 084  36086                          JUMP NZ, 086[CarryOn]                                  ;if not do not store in scratch
 085  2F15B                          STORE s1, 5B[StartAmpA]                                ;Save the current amplitude of the A tone
 086                                 ;have phase in s5
 086  11E02                 CarryOn: ADD sE[TempScratchPointer], 02
 087  0A4E0                          FETCH s4, (sE[TempScratchPointer])                     ;get last phase (inc+8)
 088  2E5E0                          STORE s5, (sE[TempScratchPointer])                     ;update current phase
 089  19E01                          SUB sE[TempScratchPointer], 01
 08A  2E4E0                          STORE s4, (sE[TempScratchPointer])                     ;update previous phase (inc+7)
 08B  19E01                          SUB sE[TempScratchPointer], 01
 08C                                 ;Send to ARM
 08C  2014D                          CALL 14D[StreamPhase]                                  ; This does not affect s5! - but does kill s0
 08D  00510                          LOAD s5, s1
 08E  20149                          CALL 149[StreamAmp]
 08F                                 ;Need to reset accumulators to zero! (Tempscratch (originally inc+3) is now inc+6 but need to reseet addresses of original! TempScratchPointer, TempScratchPointer+1,+2 +3)
 08F                                 ;This is executed every 2ms if 4 tones are treated as executed 4 times per cycle - if more tones added, this will run more frequently and so counter timeouts will need adjusting!
 08F  000E0                          LOAD s0, sE[TempScratchPointer]
 090  01100                          LOAD s1, 00
 091  2E100                          STORE s1, (s0)
 092  19001                          SUB s0, 01
 093  2E100                          STORE s1, (s0)
 094  19001                          SUB s0, 01
 095  2E100                          STORE s1, (s0)
 096  19001                          SUB s0, 01
 097  2E100                          STORE s1, (s0)
 098  20107                          CALL 107[CheckforTimeOuts]
 099  1DD00                          COMPARE sD[Mode], 00
 09A  340BD                          CALL NZ, 0BD[IncrementCounter]                         ;Unless Idle!
 09B                                 ;This last part to be corrected to check magnitude of phase shift
 09B                                 ;OK ready to do now using software multiply
 09B  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to previous phase (inc+7)
 09C  0A2E0                          FETCH s2, (sE[TempScratchPointer])                     ;s2 now has msb of previous phase
 09D  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to current phase (inc+8)
 09E  0A3E0                          FETCH s3, (sE[TempScratchPointer])                     ;s3 now has msb of current phase
 09F  18230                          SUB s2, s3                                             ;delta phase (signed)
 0A0  201A3                          CALL 1A3[absval]                                       ;gets absolute value of s2 (abs phase shift)
 0A1  11E01                          ADD sE[TempScratchPointer], 01                         ;move pointer on to counter (inc+9)
 0A2  0A1E0                          FETCH s1, (sE[TempScratchPointer])                     ;s1 has the counter
 0A3  000E0                          LOAD s0, sE[TempScratchPointer]
 0A4  19005                          SUB s0, 05                                             ;to get inc+4
 0A5  14008                          SRA s0                                                 ;divide by 2 to get 7,12,17 or 22
 0A6                                 ;
 0A6                                 ;Debug output Counter value and Phase difference
 0A6                                 ;   OUTPUT s1,(s0) ;Export Counter value come out on 'IQ stoptones', when value '5' is selected
 0A6                                 ;   SUB s0,01 ;to get 6,11,16,21 to align with 'IQStarttones' read by selecting '4' value
 0A6                                 ;   OUTPUT s2,(s0) ;Export phase difference value come out on 'IQ starttones', when value '4' is selected
 0A6  1D21E                          COMPARE s2, 1E[phase_threshold]                        ;is it less than threshold, then set carry
 0A7  3E0B8                          JUMP NC, 0B8[dropcounter]                              ; if failed then drop the counter and return
 0A8  11101                          ADD s1, 01                                             ;otherwise is small phase shift so advance counter
 0A9  2E1E0                          STORE s1, (sE[TempScratchPointer])                     ;now save the counter
 0AA  1D109                          COMPARE s1, 09[count_value_to_trig]                    ;s1 has phase constant counter, carry not set if count is high enough.
 0AB  3C0AD                          CALL NC, 0AD[Whoopie]                                  ;seem to have a tone here!
 0AC  25000                          RETURN 
 0AD                                 ;Ultimately will use TempScratchPointer to work out which tone was detected
 0AD                                 ;need to reset counter to Zero!!
 0AD  01000                 Whoopie: LOAD s0, 00
 0AE  2E0E0                          STORE s0, (sE[TempScratchPointer])                     ;reset counter to zero
 0AF  1DE13                          COMPARE sE[TempScratchPointer], 13[19'd]               ;if start tone A counter
 0B0  300E9                          CALL Z, 0E9[isStrtToneA]
 0B1  1DE1D                          COMPARE sE[TempScratchPointer], 1D[29'd]               ;if start tone B counter
 0B2  300F1                          CALL Z, 0F1[isStrtToneB]
 0B3  1DE27                          COMPARE sE[TempScratchPointer], 27[39'd]               ;if start tone A counter
 0B4  300F8                          CALL Z, 0F8[isStopToneA]
 0B5  1DE31                          COMPARE sE[TempScratchPointer], 31[49'd]               ;if start tone A counter
 0B6  300FE                          CALL Z, 0FE[isStopToneB]
 0B7  25000                          RETURN 
 0B8  1D102             dropcounter: COMPARE s1, 02
 0B9  39000                          RETURN C                                               ;return if counter 1 or zero
 0BA  19102                          SUB s1, 02                                             ;drop counter by 2
 0BB  2E1E0                          STORE s1, (sE[TempScratchPointer])                     ;now set counter to new value
 0BC  25000                          RETURN 
 0BD                                 ;Update sample counter (increments every 2ms if treating all 4 tones simultaneously, would be 1ms if treating 8 tones)
 0BD                                 ;This only advances in modes 1,2 and 3
 0BD  0B05A        IncrementCounter: FETCH s0, 5A[SampleCounterMSB]
 0BE  11F01                          ADD sF[SampleCounter], 01                              ;increment counter
 0BF  13000                          ADDCY s0, 00
 0C0  2F05A                          STORE s0, 5A[SampleCounterMSB]                         ;increment MSB on rollover
 0C1                                 ;Check if any of the time outs are passed
 0C1  20107                          CALL 107[CheckforTimeOuts]
 0C2  25000                          RETURN 
 0C3                                 ;This is to drop the value of the accumulated I and Q values so that don't end up getting too big for the Cordic
 0C3  00260         CheckNotTooBigI: LOAD s2, s6
 0C4  00360                          LOAD s3, s6                                            ;also have to save s6 as absval kills s6
 0C5  201A3                          CALL 1A3[absval]                                       ;return absval in s2
 0C6  00630                          LOAD s6, s3                                            ;put value back in s6
 0C7  1D230                          COMPARE s2, 30                                         ;is absolute value bigger than or equal 30 (then NC)
 0C8  39000                          RETURN C                                               ;if not return
 0C9  1460A                          SRX s6
 0CA  14708                          SRA s7                                                 ;half value in s6/s7
 0CB                                 ;now need to drop value in accummulated Q
 0CB  11002                          ADD s0, 02                                             ;increase scratch pointer to Q accumulation values
 0CC  0A300                          FETCH s3, (s0)                                         ;LSB of Q accumulated
 0CD  19001                          SUB s0, 01
 0CE  0A200                          FETCH s2, (s0)                                         ;MSB of Q accumulated
 0CF  1420A                          SRX s2
 0D0  14308                          SRA s3                                                 ;half Q accumulated value
 0D1  2E200                          STORE s2, (s0)
 0D2  11001                          ADD s0, 01
 0D3  2E300                          STORE s3, (s0)
 0D4  19002                          SUB s0, 02                                             ;Get s0 back to its original value
 0D5  25000                          RETURN 
 0D6  00260         CheckNotTooBigQ: LOAD s2, s6
 0D7  00360                          LOAD s3, s6                                            ;also have to save s6 as absval kills s6
 0D8  201A3                          CALL 1A3[absval]                                       ;return absval in s2
 0D9  00630                          LOAD s6, s3                                            ;put value back in s6
 0DA  1D230                          COMPARE s2, 30                                         ;is absolute value bigger than or equal 30 (then NC)
 0DB  39000                          RETURN C                                               ;if not return
 0DC  1460A                          SRX s6
 0DD  14708                          SRA s7                                                 ;half value in s6/s7
 0DE                                 ;now need to drop value in accummulated Q
 0DE  19002                          SUB s0, 02                                             ;reduce scratch pointer to I accumulation values
 0DF  0A300                          FETCH s3, (s0)                                         ;LSB of I accumulated
 0E0  19001                          SUB s0, 01
 0E1  0A200                          FETCH s2, (s0)                                         ;MSB of I accumulated
 0E2  1420A                          SRX s2
 0E3  14308                          SRA s3                                                 ;half I accumulated value
 0E4  2E200                          STORE s2, (s0)
 0E5  11001                          ADD s0, 01
 0E6  2E300                          STORE s3, (s0)
 0E7  11002                          ADD s0, 02                                             ;Get s0 back to its original value
 0E8  25000                          RETURN 
 0E9                                 ;Treat different mode cases
 0E9                                 ;Mode 0 Idle
 0E9                                 ;Mode 1 Starting  (Start tone A detected)
 0E9                                 ;Mode 2 Recieving Voice
 0E9                                 ;Mode 3 Stopping
 0E9                                 ;Mode 4 TX
 0E9  1DD00             isStrtToneA: COMPARE sD[Mode], 00                                   ;Check if currently idle
 0EA  35000                          RETURN NZ                                              ;Don't do anything if not currently idle
 0EB  0B05B                          FETCH s0, 5B[StartAmpA]                                ;Get thepreviously stored amplitude
 0EC  2D019                          OUTPUT s0, 19[StartAmpOut]                             ;and output to be read by the DSP Pico
 0ED  01D01                          LOAD sD[Mode], 01                                      ;Move in to starting mode
 0EE  01F00                          LOAD sF[SampleCounter], 00
 0EF  2FF5A                          STORE sF[SampleCounter], 5A[SampleCounterMSB]          ;Reset counter and allow about 160ms to receive tone B
 0F0  25000                          RETURN 
 0F1  1DD01             isStrtToneB: COMPARE sD[Mode], 01                                   ;Check if in starting mode
 0F2  35000                          RETURN NZ                                              ;Don't do anything if not starting
 0F3  01D02                          LOAD sD[Mode], 02                                      ;go ahead in to receive
 0F4  2011D                          CALL 11D[N3ZtoneDetected]                              ;N3Z transmission detected
 0F5  01F00                          LOAD sF[SampleCounter], 00
 0F6  2FF5A                          STORE sF[SampleCounter], 5A[SampleCounterMSB]          ;Reset counter and allow about 160ms to receive tone B
 0F7  25000                          RETURN 
 0F8  1DD02             isStopToneA: COMPARE sD[Mode], 02                                   ;Check if in RX mode
 0F9  35000                          RETURN NZ                                              ;Don't do anything if not in RX
 0FA  01D03                          LOAD sD[Mode], 03                                      ;Move in to stopping mode
 0FB  01F00                          LOAD sF[SampleCounter], 00
 0FC  2FF5A                          STORE sF[SampleCounter], 5A[SampleCounterMSB]          ;Reset counter and allow about 512ms to receive tone B
 0FD  25000                          RETURN 
 0FE  1DD03             isStopToneB: COMPARE sD[Mode], 03                                   ;Check if in stopping mode
 0FF  35000                          RETURN NZ                                              ;Don't do anything if not stopping
 100  01D00                          LOAD sD[Mode], 00                                      ;go back to idle
 101  201DB                          CALL 1DB[delay_1s]                                     ;dont indicate N3Z transmission detected yet
 102  201DB                          CALL 1DB[delay_1s]                                     ;in a bit...
 103  20124                          CALL 124[N3ZtoneLost]                                  ;Turn N3Z transmission detected off
 104  01F00                          LOAD sF[SampleCounter], 00
 105  2FF5A                          STORE sF[SampleCounter], 5A[SampleCounterMSB]          ;Reset counter (not really needed, but just for tidiness)
 106  25000                          RETURN 
 107                                 ;timeout values in units of 2ms - this will drop to 1ms if more tones added, so timeout values will need re-adjusting
 107  1DD01        CheckforTimeOuts: COMPARE sD[Mode], 01
 108  3010E                          CALL Z, 10E[checkStarttoneAtimeout]
 109  1DD02                          COMPARE sD[Mode], 02
 10A  30112                          CALL Z, 112[checkRXtimeout]
 10B  1DD03                          COMPARE sD[Mode], 03
 10C  30118                          CALL Z, 118[checkStoptoneAtimeout]
 10D  25000                          RETURN 
 10E  1DF50  checkStarttoneAtimeout: COMPARE sF[SampleCounter], 50[80'd]                    ;This will need to be 160'd with 8 tones
 10F  39000                          RETURN C                                               ;Counter<80 (160ms) so OK
 110  01D00                          LOAD sD[Mode], 00                                      ;Set mode back to idle - tone B was not received in time
 111  25000                          RETURN 
 112  0B05A          checkRXtimeout: FETCH s0, 5A[SampleCounterMSB]                         ;Get counter
 113  1D03D                          COMPARE s0, 3D[61'd]                                   ;-about 30 secs - COmpare with 122'd if using 8 tones
 114  39000                          RETURN C                                               ;Can carry on listening (not timed out)
 115  01D00                          LOAD sD[Mode], 00                                      ;Set mode back to idle - seems to have been transmitting too long
 116  20124                          CALL 124[N3ZtoneLost]                                  ;stop N3Z transmission detected (timeout)
 117  25000                          RETURN 
 118  0B05A   checkStoptoneAtimeout: FETCH s0, 5A[SampleCounterMSB]                         ;Get counter
 119  1D001                          COMPARE s0, 01                                         ;-about 512ms - need to compare with 02 if using 8 tones
 11A  39000                          RETURN C                                               ;Counter MSB still 0 so within 512ms of receiving StoptoneA
 11B  01D02                          LOAD sD[Mode], 02                                      ;Set mode back to RX - tone B was not received in time so must have been a chance tone
 11C  25000                          RETURN 
 11D                                 ;ToneDetectStateChanged:
 11D                                 ;     STORE     s0, ToneDetectState
 11D                                 ;
 11D                                 ;     CALL N3ZtoneDetected  ; always set N3Z transmission detected on if changed
 11D                                 ;
 11D                                 ;     RETURN
 11D                N3ZtoneDetected: 
 11D                                 ;    INPUT    s0, Strobe
 11D                                 ;    AND   s0, 04  ; tone detect disabled if set to 1
 11D                                 ;    JUMP     NZ, TDIsOff   ; not control if Tone detect not enabled
 11D                                 ;FETCH    s0, ToneDetectEnabled
 11D                                 ;ADD      s0, 00
 11D                                 ;RETURN   Z
 11D  01001                          LOAD s0, 01
 11E  2D01A                          OUTPUT s0, 1A[State]                                   ;N3Z signal being received flag on
 11F  0102B                          LOAD s0, 2B[43'd]                                      ;
 120  2D000                          OUTPUT s0, 00[CmdToUser]
 121  01031                          LOAD s0, 31[49'd]                                      ;
 122  2D000                          OUTPUT s0, 00[CmdToUser]
 123  25000                          RETURN 
 124                                 ;TDIsOff:
 124                                 ;    LOAD     s0,01   ; make sure speaker is on
 124                                 ;               OUTPUT s0,State
 124                                 ;
 124                                 ;               LOAD      s0, 43'd              ;
 124                                 ;              OUTPUT    s0, CmdToUser
 124                                 ;
 124                                 ;    LOAD      s0, 50'd              ; tell user pico
 124                                 ;               OUTPUT    s0, CmdToUser
 124                                 ;    RETURN
 124                    N3ZtoneLost: 
 124                                 ;    INPUT    s0, Strobe
 124                                 ;    AND   s0, 04  ; tone detect disabled if set to 1
 124                                 ;
 124                                 ;    JUMP     NZ, TDIsOff   ; not control if Tone detect not enabled
 124                                 ;
 124                                 ;FETCH    s0, ToneDetectEnabled
 124                                 ;ADD      s0, 00
 124                                 ;RETURN   Z
 124  01000                          LOAD s0, 00                                            ;sets signal detected state to off
 125  2D01A                          OUTPUT s0, 1A[State]
 126  01D00                          LOAD sD[Mode], 00                                      ;return to idle state
 127  0102B                          LOAD s0, 2B[43'd]                                      ; '+'
 128  2D000                          OUTPUT s0, 00[CmdToUser]
 129  01030                          LOAD s0, 30[48'd]                                      ;
 12A  2D000                          OUTPUT s0, 00[CmdToUser]
 12B  25000                          RETURN 
 12C                                 ;Does 16 bit signed accumulation of 8 bit signed value in s1 into s4/s5 which are recoverred from scratch pad pointed to by s2 (loading here the offset to the actual tone
 12C                                 ;dependent on how many times round the loop we are)
 12C  10260            DoAccumulate: ADD s2, s6
 12D  0A420                          FETCH s4, (s2)                                         ;Now Get AveSToneLSB_Is in s4 etc...
 12E  19201                          SUB s2, 01                                             ;step back to MSB
 12F  0A520                          FETCH s5, (s2)                                         ;Get AveSToneMSB_Is in s5
 130  013FF                          LOAD s3, FF                                            ;Assume s1 is negative and use s3 for sign extension
 131  1D180                          COMPARE s1, 80[128'd]                                  ;if s1 is 128 or bigger, then it is negative (carry not set)
 132  3E134                          JUMP NC, 134[negaccum]
 133  01300                          LOAD s3, 00                                            ;sign extend with zeros
 134  10410                negaccum: ADD s4, s1                                             ;Accumulate into averageLsB
 135  12530                          ADDCY s5, s3                                           ;do carry to add into upper byte (keeping carry from previous add!!)
 136  00050                          LOAD s0, s5
 137  1400A                          SRX s0
 138  1400A                          SRX s0                                                 ;reduce value to subtract by factor 4 to increase integration time constant and gain.
 139  13000                          ADDCY s0, 00                                           ;round up if necessary
 13A  18400                          SUB s4, s0
 13B  013FF                          LOAD s3, FF                                            ;Assume s5 is negative and use s3 for sign extension
 13C  1D580                          COMPARE s5, 80[128'd]                                  ;is this a negative number?
 13D  3E13F                          JUMP NC, 13F[negdecrmnt]
 13E  01300                          LOAD s3, 00                                            ;do this if s5 is positive (sign extension)
 13F  18400              negdecrmnt: SUB s4, s0
 140  1A530                          SUBCY s5, s3                                           ;subtract 1/256
 141  2E520                          STORE s5, (s2)
 142  11201                          ADD s2, 01                                             ;move down to LSB again
 143  2E420                          STORE s4, (s2)                                         ;update scratchpad values
 144  25000                          RETURN 
 145                                 ; This TBD, should output 16 bit value, that goes through a sinewave LUT and multiplies by the signal and recover
 145  2D101          LUTandMultiply: OUTPUT s1, 01[LOMSB]
 146  09903                          INPUT s9, 03[DemodMSB]                                 ;actually gets previously latched multiply corresponding to previous tone!
 147  09804                          INPUT s8, 04[DemodLSB]
 148  25000                          RETURN 
 149  000E0               StreamAmp: LOAD s0, sE[TempScratchPointer]                        ;possible values are 16,26,36 and 46
 14A  1400E                          SR0 s0                                                 ;Divide by 0 to get 8 STRTA,13  STRTB ,18 STPA or 23  STPB
 14B  2C500                          OUTPUT s5, (s0)                                        ;direct amplitude MSB to the appropriate port
 14C  25000                          RETURN 
 14D  000E0             StreamPhase: LOAD s0, sE[TempScratchPointer]
 14E  1400E                          SR0 s0
 14F  11001                          ADD s0, 01                                             ;Offset to output phase values get 9 STRTA,14  STRTB ,19 STPA or 24  STPB
 150  2C500                          OUTPUT s5, (s0)                                        ;direct phase MSB to the appropriate port
 151  25000                          RETURN 
 152  00220                waitabit: LOAD s2, s2
 153  00220                          LOAD s2, s2
 154  00220                          LOAD s2, s2                                            ;is this long enough?
 155  25000                          RETURN 
 156                                 ; CORDIC  Takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
 156                                 ; Useable range is for I and Q up to about +/-$3000
 156  01400                  cordic: LOAD s4, 00
 157  01500                          LOAD s5, 00
 158  1D180                          COMPARE s1, 80[128'd]
 159  3C18D                          CALL NC, 18D[rotate90]                                 ; if I negative then need to bring back into RH 2 quadrants.
 15A                                 ; now enter loop
 15A  01800                          LOAD s8, 00                                            ; counter of times to iterate.
 15B  00710              cordicloop: LOAD s7, s1                                            ; temporary store for I
 15C  00600                          LOAD s6, s0                                            ; temp store
 15D  1D380                          COMPARE s3, 80[128'd]                                  ; is Q negative?
 15E  3E16D                          JUMP NC, 16D[posrotate]                                ; if negative rotate positive
 15F  00A20               negrotate: LOAD sA, s2
 160  00B30                          LOAD sB, s3                                            ; put Q into working registers
 161  20186                          CALL 186[shift]                                        ; shift Q by the amount in s8
 162  100A0                          ADD s0, sA                                             ; add shifted Q to I
 163  121B0                          ADDCY s1, sB
 164  00A60                          LOAD sA, s6                                            ; prepare working registers (sA,sB) with original value of I
 165  00B70                          LOAD sB, s7
 166  20186                          CALL 186[shift]
 167  182A0                          SUB s2, sA
 168  1A3B0                          SUBCY s3, sB
 169  2017E                          CALL 17E[GetPhaseIncrement]
 16A  184A0                          SUB s4, sA
 16B  1A5B0                          SUBCY s5, sB
 16C  2217A                          JUMP 17A[testcordicend]
 16D  00A20               posrotate: LOAD sA, s2
 16E  00B30                          LOAD sB, s3                                            ; put Q into working registers
 16F  20186                          CALL 186[shift]                                        ; shift Q by the amount in s8
 170  180A0                          SUB s0, sA                                             ; add shifted Q to I
 171  1A1B0                          SUBCY s1, sB
 172  00A60                          LOAD sA, s6                                            ; prepare working registers with original value of I
 173  00B70                          LOAD sB, s7
 174  20186                          CALL 186[shift]
 175  102A0                          ADD s2, sA
 176  123B0                          ADDCY s3, sB
 177  2017E                          CALL 17E[GetPhaseIncrement]
 178  104A0                          ADD s4, sA
 179  125B0                          ADDCY s5, sB
 17A  11801           testcordicend: ADD s8, 01
 17B  1D809                          COMPARE s8, 09[m_plus_1]                               ;m + 1
 17C  3A15B                          JUMP C, 15B[cordicloop]
 17D  25000                          RETURN 
 17E                                 ; routine to lookup from the cordic look up table (scratchpad), the phase increment - stored as 8 bits at the location pointed to be s8, returned as 16 bits in sA and sB
 17E                                 ; sB is MSB
 17E  0AB80       GetPhaseIncrement: FETCH sB, (s8)
 17F  14B0E                          SR0 sB
 180  14A08                          SRA sA
 181  14B0E                          SR0 sB
 182  14A08                          SRA sA
 183  14B0E                          SR0 sB
 184  14A08                          SRA sA                                                 ; This multiplies the 8 bit stored value by 32 so that max scratchpad value 255->255*32 equivalent to 44.82degrees
 185  25000                          RETURN 
 186  00980                   shift: LOAD s9, s8
 187  1D900               shiftloop: COMPARE s9, 00
 188  31000                          RETURN Z
 189  19901                          SUB s9, 01
 18A  14B0A                          SRX sB
 18B  14A08                          SRA sA
 18C  22187                          JUMP 187[shiftloop]
 18D  00710                rotate90: LOAD s7, s1                                            ; temporary store for I
 18E  00600                          LOAD s6, s0                                            ; temp store
 18F  1D380                          COMPARE s3, 80[128'd]                                  ; is Q negative?
 190  3E19A                          JUMP NC, 19A[add90]                                    ; if negative add 90
 191  00130                   sub90: LOAD s1, s3
 192  00020                          LOAD s0, s2                                            ; I=Q
 193  01200                          LOAD s2, 00
 194  01300                          LOAD s3, 00
 195  18260                          SUB s2, s6
 196  1A370                          SUBCY s3, s7                                           ; Q=-I
 197  19400                          SUB s4, 00[half_pi_LSB]
 198  1B540                          SUBCY s5, 40[half_pi_MSB]
 199  25000                          RETURN 
 19A  01100                   add90: LOAD s1, 00
 19B  01000                          LOAD s0, 00
 19C  18020                          SUB s0, s2
 19D  1A130                          SUBCY s1, s3                                           ; I=-Q
 19E  00260                          LOAD s2, s6
 19F  00370                          LOAD s3, s7                                            ; Q=I
 1A0  01400                          LOAD s4, 00[half_pi_LSB]
 1A1  01540                          LOAD s5, 40[half_pi_MSB]
 1A2  25000                          RETURN 
 1A3                                 ;takes s2 and returns in s2 the absolute value of s2 (uses s6)
 1A3  1D280                  absval: COMPARE s2, 80[128'd]
 1A4  3C1A6                          CALL NC, 1A6[makeposval]
 1A5  25000                          RETURN 
 1A6                                 ; Turn negative value in s2 into a positive one (well will actualy make a positive value negative as well).
 1A6  01600              makeposval: LOAD s6, 00
 1A7  18620                          SUB s6, s2
 1A8  00260                          LOAD s2, s6
 1A9  25000                          RETURN 
 1AA                                 ; Takes value in s5 and converts to 2 ascii codes which are sent to the user picoblaze.
 1AA  201C8             Export2User: CALL 1C8[Byte2Chars]
 1AB  2D600                          OUTPUT s6, 00[CmdToUser]
 1AC  2D700                          OUTPUT s7, 00[CmdToUser]
 1AD  01614                          LOAD s6, 14[20'd]                                      ; terminate with space character
 1AE  2D600                          OUTPUT s6, 00[CmdToUser]
 1AF  25000                          RETURN 
 1B0  0160D                 AddCRLF: LOAD s6, 0D[13'd]                                      ; terminate with CR
 1B1  2D600                          OUTPUT s6, 00[CmdToUser]
 1B2  0160A                          LOAD s6, 0A[10'd]                                      ; and with LF
 1B3  2D600                          OUTPUT s6, 00[CmdToUser]
 1B4  25000                          RETURN 
 1B5                                 ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 1B5  00860              Chars2Byte: LOAD s8, s6
 1B6  201C0                          CALL 1C0[Get4bits]
 1B7  00580                          LOAD s5, s8
 1B8  14506                          SL0 s5
 1B9  14506                          SL0 s5
 1BA  14506                          SL0 s5
 1BB  14506                          SL0 s5                                                 ; put these 4 bits to MSBs
 1BC  00870                          LOAD s8, s7
 1BD  201C0                          CALL 1C0[Get4bits]
 1BE  10580                          ADD s5, s8
 1BF  25000                          RETURN 
 1C0                                 ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 1C0  1D83C                Get4bits: COMPARE s8, 3C[60'd]                                   ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 1C1  3A1C5                          JUMP C, 1C5[char0_9]
 1C2  19837                          SUB s8, 37[55'd]                                       ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 1C3  0380F                          AND s8, 0F                                             ; make sure only return 4 bits
 1C4  25000                          RETURN 
 1C5  19830                 char0_9: SUB s8, 30[48'd]
 1C6  0380F                          AND s8, 0F                                             ; make sure only return 4 bits
 1C7  25000                          RETURN 
 1C8                                 ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 1C8  00850              Byte2Chars: LOAD s8, s5                                            ; assumes 8 bit data is in s5
 1C9  1450E                          SR0 s5
 1CA  1450E                          SR0 s5
 1CB  1450E                          SR0 s5
 1CC  1450E                          SR0 s5                                                 ; get first hex character
 1CD  201D4                          CALL 1D4[GetChar]
 1CE  00650                          LOAD s6, s5                                            ; first ascii char
 1CF  00580                          LOAD s5, s8
 1D0  0350F                          AND s5, 0F
 1D1  201D4                          CALL 1D4[GetChar]                                      ; send to LCD or UART
 1D2  00750                          LOAD s7, s5                                            ; second ascii char
 1D3  25000                          RETURN 
 1D4                                 ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 1D4  1950A                 GetChar: SUB s5, 0A[10'd]                                       ; Test if s5 greater than 9
 1D5  3A1D8                          JUMP C, 1D8[is_0_9]                                    ; Hex character is 0_9
 1D6  11541                          ADD s5, 41[65'd]                                       ; offset for Ascii code 'A'
 1D7  25000                          RETURN 
 1D8  1150A                  is_0_9: ADD s5, 0A[10'd]                                       ; return to range 0-9
 1D9  11530                          ADD s5, 30[48'd]                                       ; offset to Ascii code for '0'
 1DA  25000                          RETURN 
 1DB                                 ; Registers used s0, s1, s2, s3, s4 and s5.
 1DB                                 ;
 1DB  01500                delay_1s: LOAD s5, 00                                            ; clear cycle counter
 1DC  01400                          LOAD s4, 00
 1DD  201EE                 wait_1s: CALL 1EE[delay_1ms]
 1DE  11401                          ADD s4, 01                                             ; increment cycle counter
 1DF  13500                          ADDCY s5, 00
 1E0  1D4E8                          COMPARE s4, E8[count_1000_lsb]                         ; test for 1000ms
 1E1  361DD                          JUMP NZ, 1DD[wait_1s]
 1E2  1D503                          COMPARE s5, 03[count_1000_msb]
 1E3  361DD                          JUMP NZ, 1DD[wait_1s]
 1E4  25000                          RETURN 
 1E5                                 ;
 1E5                                 ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 1E5                                 ;
 1E5                                 ;
 1E5                                 ; Registers used s0, s1, s2, s3 and s4.
 1E5                                 ;
 1E5  201E9             delay_300ms: CALL 1E9[delay_100ms]
 1E6  201E9             delay_200ms: CALL 1E9[delay_100ms]
 1E7  201E9                          CALL 1E9[delay_100ms]
 1E8  25000                          RETURN 
 1E9                                 ;
 1E9                                 ; Delay of approximately 100ms used for switch debounce
 1E9                                 ;
 1E9                                 ; Registers used s0, s1, s2, s3 and s4.
 1E9                                 ;
 1E9  01464             delay_100ms: LOAD s4, 64                                            ; repeat 1ms delay 100 times
 1EA  201EE              wait_100ms: CALL 1EE[delay_1ms]
 1EB  19401                          SUB s4, 01
 1EC  361EA                          JUMP NZ, 1EA[wait_100ms]
 1ED  25000                          RETURN 
 1EE                                 ;
 1EE                                 ; Delay of approximately 1ms required by LCD display
 1EE                                 ;
 1EE                                 ; Registers used s0, s1, s2 and s3.
 1EE                                 ;
 1EE  01300               delay_1ms: LOAD s3, 00                                            ; clear cycle counter
 1EF  01200                          LOAD s2, 00
 1F0  201FD                wait_1ms: CALL 1FD[delay_1us]
 1F1  11201                          ADD s2, 01                                             ; increment cycle counter
 1F2  13300                          ADDCY s3, 00
 1F3  1D2E8                          COMPARE s2, E8[count_1000_lsb]                         ; test for 1000us
 1F4  361F0                          JUMP NZ, 1F0[wait_1ms]
 1F5  1D303                          COMPARE s3, 03[count_1000_msb]
 1F6  361F0                          JUMP NZ, 1F0[wait_1ms]
 1F7  25000                          RETURN 
 1F8                                 ;
 1F8                                 ; Delay of approximately 50us required by LCD display
 1F8                                 ;
 1F8                                 ; Registers used s0 and s1.
 1F8                                 ;
 1F8  01132              delay_50us: LOAD s1, 32[50'd]                                      ; repeat 1us delay 50 times
 1F9  201FD               wait_50us: CALL 1FD[delay_1us]
 1FA  19101                          SUB s1, 01
 1FB  361F9                          JUMP NZ, 1F9[wait_50us]
 1FC  25000                          RETURN 
 1FD                                 ; Delay of approximately 1us used to provide timing reference for
 1FD                                 ; LCD operations. This must be adjusted to reflect the clock
 1FD                                 ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 1FD                                 ;
 1FD                                 ; The software delay loop is formed using register s0. This register
 1FD                                 ; must be loaded with an integer value close to the result of....
 1FD                                 ;
 1FD                                 ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 1FD                                 ;
 1FD                                 ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 1FD                                 ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 1FD                                 ; operation will become lower than the 100KHz target intended.
 1FD                                 ;
 1FD                                 ; Register used s0.
 1FD                                 ;
 1FD  01006               delay_1us: LOAD s0, 06[delay_1us_constant]                        ; delay value of 12 decimal for a 50MHz clock
 1FE  19001                wait_1us: SUB s0, 01
 1FF  361FE                          JUMP NZ, 1FE[wait_1us]
 200  25000                          RETURN 
 201                                 ;
 201                                 ;
 201                                 ; Multiplier Routine (8-bit x 8-bit = 16-bit product) - Ken Chapman
 201                                 ; ==================================================
 201                                 ; Shift and add algorithm
 201                                 ;
 201                       mult_8x8: 
 201                                 NAMEREG s0, multiplicand                               ; preserved
 201                                 NAMEREG s1, multiplier                                 ; preserved
 201                                 NAMEREG s2, bit_mask                                   ; modified
 201                                 NAMEREG s3, result_msb                                 ; most-significant byte (MSB) of result,
 201                                 ; modified
 201                                 NAMEREG s4, result_lsb                                 ; least-significant byte (LSB) of result,
 201                                 ; modified
 201                                 ;
 201  01201                          LOAD s2[bit_mask], 01                                  ; start with least-significant bit (lsb)
 202  01300                          LOAD s3[result_msb], 00                                ; clear product MSB
 203  01400                          LOAD s4[result_lsb], 00                                ; clear product LSB (not required)
 204                                 ;
 204                                 ; loop through all bits in multiplier
 204  0C120               mult_loop: TEST s1[multiplier], s2[bit_mask]                      ; check if bit is set
 205  32207                          JUMP Z, 207[no_add]                                    ; if bit is not set, skip addition
 206                                 ;
 206  10300                          ADD s3[result_msb], s0[multiplicand]                   ; addition only occurs in MSB
 207                                 ;
 207  14308                  no_add: SRA s3[result_msb]                                     ; shift MSB right, CARRY into bit 7,
 208                                 ; lsb into CARRY
 208  14408                          SRA s4[result_lsb]                                     ; shift LSB right,
 209                                 ; lsb from result_msb into bit 7
 209                                 ;
 209  14206                          SL0 s2[bit_mask]                                       ; shift bit_mask left to examine
 20A                                 ; next bit in multiplier
 20A                                 ;
 20A  36204                          JUMP NZ, 204[mult_loop]                                ; if all bit examined, then bit_mask = 0


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\home\gnaylor\Dropbox\N3SysGen\ToneDetectpico.psm



List of defined constants

 CONSTANT name       Value        Source PSM File

 timestamp_hours     21'd         
 timestamp_minutes   38'd         
 timestamp_seconds   16'd         
 datestamp_year      18'd         
 datestamp_month     4'd          
 datestamp_day       12'd         
 NUL                 00           
 BEL                 07           
 BS                  08           
 HT                  09           
 LF                  0A           
 VT                  0B           
 CR                  0D           
 ESC                 1B           
 DEL                 7F           
 DCS                 90           
 ST                  9C           
 delay_1us_constant  06           ToneDetectpico.psm
 m                   8'd          ToneDetectpico.psm
 m_plus_1            9'd          ToneDetectpico.psm
 count_1000_lsb      E8           ToneDetectpico.psm
 count_1000_msb      03           ToneDetectpico.psm
 half_pi_LSB         00           ToneDetectpico.psm
 half_pi_MSB         40           ToneDetectpico.psm
 phase_threshold     30'd         ToneDetectpico.psm
 count_value_to_trig 9'd          ToneDetectpico.psm
 audioTest           2'd          ToneDetectpico.psm
 StrtToneAInc        9E           ToneDetectpico.psm
 StrtToneBInc        68           ToneDetectpico.psm
 StopToneAInc        59           ToneDetectpico.psm
 StopToneBInc        77           ToneDetectpico.psm
 AudioMSB            0'd          ToneDetectpico.psm
 AudioLSB            1'd          ToneDetectpico.psm
 Strobe              2'd          ToneDetectpico.psm
 DemodMSB            3'd          ToneDetectpico.psm
 DemodLSB            4'd          ToneDetectpico.psm
 TBD0                5'd          ToneDetectpico.psm
 TBD1                6'd          ToneDetectpico.psm
 TBD2                7'd          ToneDetectpico.psm
 CmdToUser           0'd          ToneDetectpico.psm
 LOMSB               1'd          ToneDetectpico.psm
 ToneMode            2'd          ToneDetectpico.psm
 BRAMaddrLSB         3'd          ToneDetectpico.psm
 StartAmpOut         25'd         ToneDetectpico.psm
 State               26'd         ToneDetectpico.psm
 AVEtoneAmp          9'd          ToneDetectpico.psm
 STRTAinc            10'd         ToneDetectpico.psm
 STRTAptrMSB         11'd         ToneDetectpico.psm
 STRTAptrLSB         12'd         ToneDetectpico.psm
 STRTAAccuDemodIMSB  13'd         ToneDetectpico.psm
 STRTAAccuDemodILSB  14'd         ToneDetectpico.psm
 STRTAAccuDemodQMSB  15'd         ToneDetectpico.psm
 STRTAAccuDemodQLSB  16'd         ToneDetectpico.psm
 STRTAcurrentPhase   17'd         ToneDetectpico.psm
 STRTApreviousPhase  18'd         ToneDetectpico.psm
 STRTAcounter        19'd         ToneDetectpico.psm
 STRTBinc            20'd         ToneDetectpico.psm
 STPAinc             30'd         ToneDetectpico.psm
 STPBinc             40'd         ToneDetectpico.psm
 SampleCounterMSB    90'd         ToneDetectpico.psm
 StartAmpA           91'd         ToneDetectpico.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "12 Apr 2018"  
 timestamp$        "21:38:16"     



List of line labels

   Label                    Addr  Source PSM File

 * cold_start               000   ToneDetectpico.psm
   AwaitAudioVal            01B   ToneDetectpico.psm
   AwaitRise                020   ToneDetectpico.psm
   isReceiving              02A   ToneDetectpico.psm
   StartDemod               030   ToneDetectpico.psm
   DemodulateTone           03D   ToneDetectpico.psm
   CheckMatureAndOutput     076   ToneDetectpico.psm
   Matured                  07B   ToneDetectpico.psm
   CarryOn                  086   ToneDetectpico.psm
   Whoopie                  0AD   ToneDetectpico.psm
   dropcounter              0B8   ToneDetectpico.psm
   IncrementCounter         0BD   ToneDetectpico.psm
   CheckNotTooBigI          0C3   ToneDetectpico.psm
   CheckNotTooBigQ          0D6   ToneDetectpico.psm
   isStrtToneA              0E9   ToneDetectpico.psm
   isStrtToneB              0F1   ToneDetectpico.psm
   isStopToneA              0F8   ToneDetectpico.psm
   isStopToneB              0FE   ToneDetectpico.psm
   CheckforTimeOuts         107   ToneDetectpico.psm
   checkStarttoneAtimeout   10E   ToneDetectpico.psm
   checkRXtimeout           112   ToneDetectpico.psm
   checkStoptoneAtimeout    118   ToneDetectpico.psm
   N3ZtoneDetected          11D   ToneDetectpico.psm
   N3ZtoneLost              124   ToneDetectpico.psm
 * DoAccumulate             12C   ToneDetectpico.psm
   negaccum                 134   ToneDetectpico.psm
   negdecrmnt               13F   ToneDetectpico.psm
 * LUTandMultiply           145   ToneDetectpico.psm
   StreamAmp                149   ToneDetectpico.psm
   StreamPhase              14D   ToneDetectpico.psm
   waitabit                 152   ToneDetectpico.psm
   cordic                   156   ToneDetectpico.psm
   cordicloop               15B   ToneDetectpico.psm
 * negrotate                15F   ToneDetectpico.psm
   posrotate                16D   ToneDetectpico.psm
   testcordicend            17A   ToneDetectpico.psm
   GetPhaseIncrement        17E   ToneDetectpico.psm
   shift                    186   ToneDetectpico.psm
   shiftloop                187   ToneDetectpico.psm
   rotate90                 18D   ToneDetectpico.psm
 * sub90                    191   ToneDetectpico.psm
   add90                    19A   ToneDetectpico.psm
   absval                   1A3   ToneDetectpico.psm
   makeposval               1A6   ToneDetectpico.psm
 * Export2User              1AA   ToneDetectpico.psm
 * AddCRLF                  1B0   ToneDetectpico.psm
 * Chars2Byte               1B5   ToneDetectpico.psm
   Get4bits                 1C0   ToneDetectpico.psm
   char0_9                  1C5   ToneDetectpico.psm
   Byte2Chars               1C8   ToneDetectpico.psm
   GetChar                  1D4   ToneDetectpico.psm
   is_0_9                   1D8   ToneDetectpico.psm
   delay_1s                 1DB   ToneDetectpico.psm
   wait_1s                  1DD   ToneDetectpico.psm
 * delay_300ms              1E5   ToneDetectpico.psm
 * delay_200ms              1E6   ToneDetectpico.psm
   delay_100ms              1E9   ToneDetectpico.psm
   wait_100ms               1EA   ToneDetectpico.psm
   delay_1ms                1EE   ToneDetectpico.psm
   wait_1ms                 1F0   ToneDetectpico.psm
 * delay_50us               1F8   ToneDetectpico.psm
   wait_50us                1F9   ToneDetectpico.psm
   delay_1us                1FD   ToneDetectpico.psm
   wait_1us                 1FE   ToneDetectpico.psm
 * mult_8x8                 201   ToneDetectpico.psm
   mult_loop                204   ToneDetectpico.psm
   no_add                   207   ToneDetectpico.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            113
 STAR              -

 AND               7
 OR                -
 XOR               -

 ADD              41
 ADDCY            11
 SUB              34
 SUBCY             7

 TEST              1
 TESTCY            -
 COMPARE          39
 COMPARECY         -

 SL0               5
 SL1               -
 SLX               -
 SLA               2
 RL                -
 SR0              11
 SR1               -
 SRX               7
 SRA              15
 RR                -

 REGBANK           -

 INPUT            10
 OUTPUT           20
 OUTPUTK           -

 STORE            26
 FETCH            26

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             26
 JUMP@             -
 CALL             54
 CALL@             -
 RETURN           54
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
