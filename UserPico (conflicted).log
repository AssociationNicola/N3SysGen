KCPSM6 Assembler log file for program 'Z:\home\gnaylor\Dropbox\N3SysGen\UserPico.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 14 May 2017
Assembly timestamp: 10:33:08

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 373 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 884
Memory locations available: 3212


Assembly listing

 Addr Code                        Instruction

 000                              ;GV0A redo Target levels in user and DSP for AGC
 000                              ;GV09 changed terminator caracter to LF rather than CR
 000                              ;GV08 lower audio volume control to about 0.8V (Prod7)
 000                              ;GV07 correct incorrect data archive and demod peak display problem (MSB/LSB mixup!)
 000                              ;GV06 Increase output amplitude of SSB in DSPpico on TX
 000                              ;GV05 Modified frequencies (MMCM and KeypadPico values) to work with 33.333MHz clock for production model (Apr 2012)
 000                              ;GV04 Now using mic preamp so need to fix AGCs
 000                              ;GV03 Mods to DSP to try and get volume load and saturate OutAmp properly
 000                              ;GV02 Halved AGC thresholds to avoid clipping SysGen v1.18
 000                              ;GV01 add redirect command SW for UART to patch through to BT module
 000                              ;GV01 Reduce Speaker volume AGC on startup
 000                              ;GV00 Reset GV to 0 for new TE0722 working version
 000                              ;GVA5 for TE0722, with RX/TX frequencies adjusted for 32.768MHz
 000                              ;GVA4 corrected DSPprog to not crash (AGC suddenly dropping)
 000                              ;GVA2 send demod level to LCD display
 000                              ;GVA0 Add temporary measures around line 510 to transmit values from DSPpico (of tone demod levels as ascii characters on to the LCD)
 000                              ;GV9A, correct Earth Loop setting incorrect and make immediate.
 000                              ; GV99 corrected Attenuator not adding 30 on level display in TX mode, add turn on pad and entenna select
 000                              ; GV98 More BT mic boost
 000                              ; GV97 corrected BT combination
 000                              ; GV96 drop ADC gain RX to 70% and TX to 50%
 000                              ; GV95 Frequency now set from keypad pico
 000                              ; GV94  24 Feb 2015 Pete  -  re-enable BT commands and add scratchpad clear
 000                              ; GV93 add code in KP pico and firmware to display ADC and demod level
 000                              ; GV92 add Pete's new BTcode with shorter inquiry time - but hadn't put in the script at the end of model propertes to get the correct mem files from Pete
 000                              ; line407 disable loran blank for 31kHz
 000                              ; GV91 increased ADC level 10dB by increasing RXAGClevel
 000                              ; GV90 Version to run at 31.008kHz so use 1323 ($52B) for TX and 10925 ($2AAD) for RX
 000                              ; GV51 Use DSP 51 to only attenuate on receive (which had clipping - but transmit was OK)
 000                              ; GV50 Adjusted DSP AGC back down as there was still clipping
 000                              ; GV4F Adjusted AGC thresholds in SP3E and DSPprogN3GV47 to improve clarity of speech
 000                              ; GV4D PMOD2 now used to control extra attenuation (~30dB)
 000                              ; GV4C back to TX_LOW but PMOD1 held low
 000                              ; GV4B For proto D with TX_high  output instead of TX_LOW
 000                              ; GV4A For ProtoD with new keypad
 000                              ; GV48 changed CheckADClevel routine - but still need to change display (KP pico code) to display signal level and gain value. No Beacon
 000                              ; GV46 BT present cuts audio - modified BT detect logic
 000                              ; GV45 Corrected resetting of AveSignalMSB to middle value so as to avoid double jump and increased allowable rang to avoid unnecessary jumps
 000                              ; GV44 Add SU command to set UART output streaming
 000                              ; GV43 Correct beacon phase wander in DSP pico code
 000                              ; GV42 As 41 but with UART testing bits removed
 000                              ; GV41 send DSP data to UART in normal loop and streaming loop
 000                              ; GV40 correct streaming mode bits and shift beacon mode check to end of loop
 000                              ; GV3F  Add UART streaming command for transmit - SS<xx> where xx is hex value of number of bits to shift the values Add GL command to get Loran blank rate
 000                              ; GV3E some work on AGCcounter to include sinewave addition, but mainly add command GS to get AveSignalMSB
 000                              ; GV3D change the way the AGC works in the DSP pico to speed up increasing attenuation if the signal is very strong
 000                              ; GV3C change pincode in BTText to 1234 for HFP profile
 000                              ; GV3A send prompt to DSPcore to grab AGCvalue and store just before the EOT warble + store ADCgain (lower 4 bits) for TX and RX modes (that will be used by CALL SetAnGain )
 000                              ; GV39 Includes Pete's BT code and new DSP AGC stuff (from GV38)
 000                              ; GV36 reduce initial ADC gain on tranmit (reduce mic gain)
 000                              ; GV35 Uses nw I_Q demodulator
 000                              ; GV33 Add delay to audio stream (reduce fdbk?) and use phase incrementing on TX.
 000                              ; GV32 Adjust AGCs
 000                              ; GV31 Now starting to use LPF in DSPprogN3WithLPF and has SL command to set Loran Blanking (SL01)
 000                              ; GV30 reduce RX ADC gain and increase TX (mic) gain.
 000                              ; GV27 Default Loran Blanking on
 000                              ; GV26 for N2 with Higher gain on DSP RF output and shorter beacon period
 000                              ; GV24 for N2
 000                              ; GV23 Corrected some of the RAM block writing issues
 000                              ; GV22 Correct loop not completing when no character! Now displays ADC gain setting on
 000                              ; GV21 use with keypad prog to inhibit pad scan and here send adc level info (should auto gain on ADC to keep between 30 and 100 ie ~$20 and ~$60)
 000                              ; GV20 Corrected non switching of ADC input to MIC!
 000                              ; GV1F Normal orientation of ADC inputs with auto BT audio switching
 000                              ; GV1E temporarily switch ADC input channel as op amp blown!
 000                              ; GV1D Heyphone but for prototype 2 (using TX_HIGH!!)
 000                              ; GV1C For HeyPhone
 000                              ; GV1A Correct flash writing errors to point to right memory address
 000                              ; GV1A
 000                              ; GV19 corrected phase interpretation of SSB encoding
 000                              ; GV18 Try dirac input
 000                              ; GV17 Add STT command to send test sinewave for transmit - Now removed March 2012
 000                              ; GV16 Worked on Beacon lockup, now starts with beacon, press button for ~6secs
 000                              ; GV14 try beacon again at startup
 000                              ; GV15 try to fix not stopping beacon issue (don't start with beacon!) - display mode value on LCD (send to KPpico)
 000                              ; GV13 no beacon
 000                              ; GV11 fix beacon mode so that DSP is blocked at frequency offset and fixed amp for ~1s when ending TX mode - also set Beacon mode on power up which stops when button pressed
 000                              ; Set ADC gain in initialisation properly to calibrate aswell.
 000                              ; GV10 Add ADC signal level monitoring and try phase SSB encoding again with 2x phase to SSB module
 000                              ; Command GL in version GV10 allows the signal level to be returned from the ADC
 000                              ; GV0F Use phase encoding
 000                              ; GV0E full 16 bit frequency coding of TX 29/8/11
 000                              ; GV0D With Beacon
 000                              ; GV0C add BT mic input
 000                              ; GV09 stopped sending r/T t seria; port an adjusted reading from KPfifo
 000                              ; GV08 Added facility to switch RX/TX from keypad
 000                              ; GV07  Increased sensitivity of touch pads June 11
 000                              ; May 26- try and modify so that it starts correctly when powerred up with user program
 000                              ; MayA 11 use PMOD 2 to switch serial port and activate keypad
 000                              ; May 11, add SAO command to set audio channel (00, for BT, 01 for radio transceiver)
 000                              ; March 2011 testing SPI interface:
 000                              ; commands
 000                              ; WREN $06 (enable writing)
 000                              ; WRDI $04 (disable writing)
 000                              ; FAST_READ $0B followed by 3 address bytes, 1 dummy byte and then n bytes to feed back data and leave last 2 values for readback
 000                              ; BERASE  $C7 (bulk erase) - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                              ; SE     $D8 (sector erase) followed by 3 address bytes, - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                              ; PP     $02 (page program) followed by 3 address bytes,  then n bytes of data to be written (need then to pulse Send2Flash by writing 16 to ProgramM)
 000                              ;
 000                              ; Example commands:
 000                              ; SMW0102030405060708090A     -writes values 1-10 to flash addresses from 800000
 000                              ; SMR800002 should read the bytes 03 and 02 ??
 000                              ; Now for Godil Board
 000                              ; Version for multi pico boot with shifted bit offsets on oport
 000                              CONSTANT Versionno, 10'd             ; Redid AGC levels
 000                              CONSTANT InitialVolume, 133'd        ;lowerred volume
 000                              CONSTANT MinoxrVersionno, EE         ; Pete
 000                              ; CONSTANT TXType,       7E                 ; $7E for N2 and $80 for Heyphone
 000                              ; CONSTANT RXType,       46                 ; $46 for N2 and 55 for Heyphone)
 000                              CONSTANT Bmode, 00
 000                              ; Set thresholds for AGC
 000                              CONSTANT AGCupperRX, 32              ; Increased factor 2 on RX and TX with signal level monitor - increased RX 3 again from $18 (24 to 72, ie $48)
 000                              CONSTANT AGClowerRX, 12              ; was $0C, increased to 36=$24
 000                              CONSTANT AGCupperTX, 40              ;Quadrupled target TX values for ADC 17/4/17
 000                              CONSTANT AGClowerTX, 18
 000                              ; SAI Set analogue input SAI<xx>  xx=00 or 01
 000                              ; SAO Set audio Output source
 000                              ; SAS Set archive source SAS<xx>
 000                              ; SAG Set analogue gain SAG<xx>
 000                              ; SB set beacon mode
 000                              ; SRM set receive mode
 000                              ; SRF set receive frequency
 000                              ; STM set transmit mode
 000                              ; STF set transmit frequency
 000                              ; SAG   Set analogue gain, use: 51-5E + automatic calibration
 000                              ; SAS <value> - set archive source (0 or 1)
 000                              ; GA get archive
 000                              ; GT get status of touch
 000                              ; GV get version
 000                              ; GP get response from DSP
 000                              ; GB get response from BT
 000                              ; GKT get touch response from KP
 000                              ; March 2009, now using loading over BT, implement server commands
 000                              ; Dec 2008 - implementing on SSBN3.mdl
 000                              ; Test Spartan 3e board May 2007
 000                              ; Program for user interface: Pico 1
 000                              ; Load SP3E with bit file - spartan3e_adcrx_tx_cw.bit using USB download cable (+ImpacT)
 000                              ; Connect serial lead and send file for test program from Matlab using somethng like
 000                              ; LCDtestprog=getpblazidefile('LCDUartS3e.mem');
 000                              ; Send6bitInstructionsPico1
 000                              ;
 000                              ; Addresses of latched data
 000                              ; 0 Cmd Control Pico2
 000                              ; 1 UartTx
 000                              ; 2 Gain ChA (bits 0-2)
 000                              ; Gain ChB(bits 4-6)
 000                              ; 3 Instruction first 6bits (MSB)
 000                              ; 4 Instruction 2nd 6 bits
 000                              ; 5 Instruction 3rd 6 bits
 000                              ; 6 Program Address LSB
 000                              ; 7 Program Address upper 2 bits
 000                              ;  bit 2,3 and 4 decoded to either Write ROM1,Write ROM2,Write ROM3,Write ROM4 or reset picos
 000                              ;  bit 5-Enable archive
 000                              ;  bit 6-Select archive source
 000                              ;  bit 7 TX_HIGH
 000                              ; 10 Set_RXFreq LSbyte
 000                              ; 11 Set_RXFreq USbyte
 000                              ; 12 Set_TXFreq LSbyte
 000                              ; 13 Set_TXFreq USbyte
 000                              ; 14 Message character 1 -***Note these data ports are for writing characters at the address bus to the message RAM!!
 000                              ; 15 Message character 2
 000                              ; 16 Message character 3 - RAM is written on write to this port (last 6 bit character)
 000                              ; 17 Relay ctrl
 000                              ; 18 Battery monitor
 000                              CONSTANT delay_1us_constant, 12'd    ; Now 49.152MHz Value (13)19 or 12? decimal suitable for 50MHz clock or about 6 for 33MHz?
 000                              CONSTANT WREN, 06                    ; (enable writing)
 000                              CONSTANT FAST_READ, 0B               ; followed by 3 address bytes, 1 dummy byte and then n bytes to feed back data and leave last 2 values for readback
 000                              CONSTANT BERASE, C7                  ; (bulk erase) - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                              CONSTANT SER, D8                     ; (sector erase) followed by 3 address bytes, - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                              CONSTANT RDID, 9F
 000                              CONSTANT PP, 02                      ; (page program) followed by 3 address bytes,  then n bytes of data to be written (need then to pulse Send2Flash by writing 16 to CMD2DSP)
 000                              CONSTANT RDSR, 05
 000                              ; Registers
 000                              ;counter             EQU       sC                  ; Counter - for Acquisitions
 000                              ;ScratchPointer      EQU       sB                  ; pointer for decoding command in scratch memory
 000                              NAMEREG sC, counter                  ; Counter - for Acquisitions
 000                              NAMEREG sB, ScratchPointer           ; pointer for decoding command in scratch memory
 000                              ; Scratch pad
 000                              ; Locations 0-15 reserved for incoming command
 000                              CONSTANT Latch7, 16'd                ; This is the current value of an output control register (ProgramM) - used to control writing etc.
 000                              CONSTANT LastDSPbyte, 17'd
 000                              CONSTANT Mode, 18'd                  ; N3 status: bit 0 Beacon mode, bit 1 RX/TX mode, bit 2 Uart streaming mode (TX), bit 3 RX to UART streaming, bit 4 to set loop antenna input
 000                              CONSTANT ADCstate, 19'd              ; saves ADC state
 000                              CONSTANT SelectScratch, 20'd         ; used to store selections (archive source etc.)
 000                              CONSTANT ADCLevel, 21'd
 000                              CONSTANT ADCgain, 22'd               ; 0 means no output, 0E is max gain of 128. Upper 4 bits contain ADC config data
 000                              CONSTANT TX_F_MSB, 23'd              ; Store TX req (16 bits)
 000                              CONSTANT TX_F_LSB, 24'd
 000                              CONSTANT ADCAGCUpperThreshold, 25'd  ; Sets value for AGC on RAW input
 000                              CONSTANT ADCAGCLowerThreshold, 26'd  ; Sets value for AGC on RAW input
 000                              CONSTANT ADCGainTX, 27'd             ; Analogue gain for TX
 000                              CONSTANT ADCGainRX, 28'd             ; Analogue gain for RX
 000                              CONSTANT peteTXMode, 40'd            ; Pete's transmit mode flag
 000                              ;removed Attenuator state
 000                              ;;CONSTANT BluetoothXmit,   43                 ; from Pete's build - assumes large scratchpad
 000                              ; Input port
 000                              CONSTANT Uart_rx, 00
 000                              CONSTANT Uart_status, 01             ; Uart RX data bit0, Uart TX half full bit 1
 000                              ; bits 2:
 000                              ; Bit 2 BattMon comparator
 000                              ; Offsets:
 000                              CONSTANT BattMon, 4'd
 000                              CONSTANT ArchiveDataLSB, 2'd
 000                              CONSTANT ArchiveDataMSB, 3'd
 000                              CONSTANT DSPcmd, 4'd                 ; message from DSP unit
 000                              CONSTANT BTcmd, 5'd                  ; message from BT unit
 000                              CONSTANT KPcmd, 6'd                  ; message from KeyPad unit
 000                              CONSTANT TDcmd, 7'd                  ; message from Tone detect
 000                              ;CONSTANT DataReadback_1,  8'd                   ; message from KeyPad unit TEMP - DataReadback_1 from Flash
 000                              CONSTANT DSPRAMrdbkMSB, 9'd
 000                              CONSTANT DSPRAMrdbkLSB, 10'd
 000                              CONSTANT BTRAMrdbkMSB, 11'd
 000                              CONSTANT BTRAMrdbkLSB, 12'd
 000                              CONSTANT KPRAMrdbkMSB, 13'd
 000                              CONSTANT KPRAMrdbkLSB, 14'd
 000                              CONSTANT ADCSignalLevel, 15'd
 000                              ; Output ports
 000                              CONSTANT CMD2DSP, 00                 ; ALSO USED for data to write to SPI flash (sends write automatically)
 000                              CONSTANT UART_TX, 01
 000                              CONSTANT GainPD, 02                  ; Lower 4 bits: 1=0 gain to E=gain 128, bits 4-6 should be 101 and bit 7 is for calibration
 000                              ; Lower 4 bits gain, bits 4-6 for PD0-2 - PD bits should be set to 0101 (ie 5 hex) to enable everything
 000                              CONSTANT Instructiona, 03
 000                              CONSTANT Instructionb, 04
 000                              CONSTANT Instructionc, 05
 000                              CONSTANT ProgramL, 06
 000                              CONSTANT ProgramM, 07
 000                              ; bits 0 and 1 for address, subsequent 4 bits to select which pico to write (bits 2,3,4,5 decoded) - these 3 bits are decoded such that:
 000                              ; if bits 2:5 represent:
 000                              ; 1 - Write Inst1 (User pico instruction) - ie MSB of address should be ORed with 4.
 000                              ; 2 - Write Inst2 (DSP pico instruction) - ie MSB of address should be ORed with 8.
 000                              ; 3 - Write Inst3 (BT pico instruction) - ie MSB of address should be ORed with $0C.
 000                              ; 4 - Write Inst4 (KP pico instruction)
 000                              ; 5 - Write DSP RAM
 000                              ; 6 - Write BT RAM
 000                              ; 7 - Reset other picos
 000                              ; 8 - Write KP RAM
 000                              ; 9 - Send Flash fifo contents (written to on FlashDATA port) to FLASH chip
 000                              ; bit 6 enable archive, and bit 7 TXhigh
 000                              ;
 000                              CONSTANT EnArchive, 64'd
 000                              CONSTANT TX_HIGH, 128'd              ; bit 7
 000                              CONSTANT SelectArchiveSource, 8'd
 000                              CONSTANT Configure, 9'd
 000                              CONSTANT RXFreqMSB, 10'd             ; 769A for 88.956kHz ie 86.956kHz carrier and allow range up to 154kHz
 000                              CONSTANT RXFreqLSB, 11'd
 000                              CONSTANT AudioVolume, 12'd           ; Initialy 141
 000                              CONSTANT Tone, 13'd                  ; Carrier increment to cause a tone modulation on TX
 000                              CONSTANT Acknowledge, 14'd
 000                              ; offsets:
 000                              CONSTANT DSPFifo, 16'd
 000                              CONSTANT BTFifo, 32'd
 000                              CONSTANT KPFifo, 64'd
 000                              CONSTANT TDFifo, 128'd
 000                              ; Set bit 4,5,6,7 to acknowledge FIFO of DSP,BT, Keypad, Tone Detect (ie write 16,32, 64 or 128)
 000                              CONSTANT FlashData, 17'd
 000                              ; CONSTANT BatteryMon,   18'd
 000                              CONSTANT ADCstate_port, 19'd         ; Lower 5 bits are not used, bit 6 indictes which ADC channel is read
 000                              ; offset of port 19
 000                              CONSTANT LoranBlank, 16'd            ; $10
 000                              CONSTANT AudioOutSelect, 32'd
 000                              CONSTANT AnalogueChannel, 64'd       ; bit 6
 000                              CONSTANT CMD2BT, 20'd
 000                              CONSTANT CMD2KP, 21'd
 000                              CONSTANT RAMDataMSB, 22'd            ; To send to KP, DSP or BT picos
 000                              CONSTANT RAMDataLSB, 23'd            ; To send to KP, DSP or BT picos
 000                              CONSTANT RAMwriteControl, 25'd
 000                              ; ;; Pete - Bluetooth
 000                              CONSTANT TRANSMIT_ON, 14             ; BT -> User
 000                              CONSTANT TRANSMIT_OFF, 15            ; BT -> User
 000                              ;GenerateCode        MEM       "S3eUser_interface.mem"
 000                              ; Start of test program Must send $40,$50 over serial port to initiate if not re-programming!
 000  22021                 boot: JUMP 021[cold_start]
 001                       start: 
 001  2001B               reboot: CALL 01B[GetByte]
 002  1D140                       COMPARE s1, 40[64'd]                 ; do we have for start byte (64 )
 003  32007                       JUMP Z, 007[DoUserProg]
 004  1D141                       COMPARE s1, 41[65'd]
 005  3E022                       JUMP NC, 022[ProgDSP]                ; This will actually write DSP or other prog (start byte =65 or greater) aargh 27/8/10 - was JUMP Z....
 006  22001                       JUMP 001[reboot]
 007  01704           DoUserProg: LOAD s7, 04
 008  01220                       LOAD s2, 20[32'd]
 009  01300                       LOAD s3, 00                          ; s2 (LSB),s3(USB) of prog counter of first address of new program!
 00A  2001B              GetProg: CALL 01B[GetByte]
 00B  1D150                       COMPARE s1, 50[80'd]                 ; 80 ($50) indicates end of program
 00C  32021                       JUMP Z, 021[cold_start]              ; When end of prog byte 80 is received
 00D  2D103                       OUTPUT s1, 03[Instructiona]
 00E  2001B                       CALL 01B[GetByte]
 00F  2D104                       OUTPUT s1, 04[Instructionb]
 010  2001B                       CALL 01B[GetByte]
 011  2D105                       OUTPUT s1, 05[Instructionc]          ; write 3x 6bits to latches ready for instruction write
 012  2D206                       OUTPUT s2, 06[ProgramL]
 013  2D307                       OUTPUT s3, 07[ProgramM]              ; Load memory address to write (starting from 32!)
 014  00470                       LOAD s4, s7                          ; Set bit 2 to perform write to RAM 1 or bit 3 to write RAM 2 depending whether start byte was 64 or 65
 015  2D419                       OUTPUT s4, 19[RAMwriteControl]
 016  01400                       LOAD s4, 00
 017  2D419                       OUTPUT s4, 19[RAMwriteControl]       ; Set write line back to zero
 018  11201                       ADD s2, 01
 019  13300                       ADDCY s3, 00                         ; Increment program counter
 01A  2200A                       JUMP 00A[GetProg]                    ; Get next instruction
 01B  09001              GetByte: INPUT s0, 01[Uart_status]            ; Is there a byte available?
 01C  03001                       AND s0, 01
 01D  1D001                       COMPARE s0, 01
 01E  3601B                       JUMP NZ, 01B[GetByte]                ; until there is a byte in the input buffer!
 01F  09100                       INPUT s1, 00[Uart_rx]
 020  25000                       RETURN 
 021  01000           cold_start: LOAD s0, 00                          ; Note the label 'ProgDSP' is only to allow re-boot to work!
 022                     ProgDSP: 
 022                              ; need to clear scratchpad
 022  01100                       LOAD s1, 00
 023                ScratchClear: 
 023  2E010                       STORE s0, (s1)                       ; zero location
 024  11101                       ADD s1, 01                           ; next
 025  1D100                       COMPARE s1, 00                       ; do all 256 bytes
 026  36023                       JUMP NZ, 023[ScratchClear]           ;
 027                              ;LOAD   s5,83      ;value for 'S'
 027                              ;CALL      Byte2UART
 027                              ;CALL      Byte2UART     ;send 'SS' to 'Uart' - ie ARM
 027                              ;CALL      SendCRLF            ; added to allow get line to read OK
 027                              ;LOAD      s6, 42'd             ; *
 027                              ;CALL      Send2UartTX
 027                              ;LOAD      s6, 43'd             ; +
 027                              ;CALL      Send2UartTX
 027                              ;CALL      SendCRLF            ; added to allow get line to read OK
 027                              ;LOAD      s6, 0A               ; ensure FIFO is flushed
 027                              ;CALL      Send2UartTX
 027  20346                       CALL 346[SendCRLF]                   ; added to allow get line to read OK
 028  01B00                 init: LOAD sB[ScratchPointer], 00
 029  01000                       LOAD s0, 00
 02A  2F010                       STORE s0, 10[Latch7]                 ; initialise latch 7 bits!
 02B  01553                       LOAD s5, 53                          ; gain to lowish
 02C  2F516                       STORE s5, 16[ADCgain]                ; save initial value
 02D  2F51C                       STORE s5, 1C[ADCGainRX]              ; save initial value for RX
 02E  2010A                       CALL 10A[SetAnGain]                  ; set gain and calibrate
 02F  01559                       LOAD s5, 59                          ; gain to lowish
 030  2F51B                       STORE s5, 1B[ADCGainTX]              ; save initial value forTX
 031                              ;Frequency of TX/RX now set by keypad pico
 031  01032                       LOAD s0, 32[AGCupperRX]
 032  2F019                       STORE s0, 19[ADCAGCUpperThreshold]
 033  01012                       LOAD s0, 12[AGClowerRX]
 034  2F01A                       STORE s0, 1A[ADCAGCLowerThreshold]
 035  200C2                       CALL 0C2[RX]                         ; set receive mode
 036  01100                       LOAD s1, 00
 037  20316                       CALL 316[ArchiveSource]
 038  2031D                       CALL 31D[EnableArchive]
 039  01085                       LOAD s0, 85[InitialVolume]           ;set lowish audio volume
 03A  2D00C                       OUTPUT s0, 0C[AudioVolume]
 03B  2035C                       CALL 35C[delay_100ms]
 03C  01020                       LOAD s0, 20[AudioOutSelect]          ; + 16; normal ADC channel, AudioOUtSelect doesn't do anything here! The 16also sets Loran Blanking if in firmware.
 03D  2F013                       STORE s0, 13[ADCstate]               ; save
 03E  2D013                       OUTPUT s0, 13[ADCstate_port]         ; Also sets analogue input to 0
 03F                   startLoop: 
 03F  01B00                       LOAD sB[ScratchPointer], 00
 040  2006B                 loop: CALL 06B[CheckADClevel]
 041  0B012                       FETCH s0, 12[Mode]
 042  03004                       AND s0, 04                           ; look at streaming bit
 043  1D004                       COMPARE s0, 04
 044  32196                       JUMP Z, 196[isSSloop]                ; if streaming TX mode, then send a Uart character and return (but will not be able to interpret any command so is stuck!)
 045  0B012                       FETCH s0, 12[Mode]
 046  03008                       AND s0, 08                           ; look at streaming RX bit
 047  1D008                       COMPARE s0, 08
 048  302B2                       CALL Z, 2B2[Check4CmdfromDSP]        ; If fifo character then send to terminal !!!!!!!!!!!!!!!!!!!! reinstate this 9/7/2013
 049  302C0                       CALL Z, 2C0[Check4CmdfromTD]         ; If fifo character then send to terminal
 04A  202BB                       CALL 2BB[Check4CmdfromKP]
 04B  1D680                       COMPARE s6, 80[128'd]                ;see if there is a character from the kppico (eg r or t signal)
 04C  380A7                       CALL C, 0A7[checkrqst]
 04D                              ; Re-enable Beacon mode
 04D  0B012                       FETCH s0, 12[Mode]
 04E                              ;      OUTPUT    s0,CMD2KP      ;send value to LCD for display - send adc level data instead
 04E  03001                       AND s0, 01                           ; only interrested in bit0
 04F  1D001                       COMPARE s0, 01                       ; Is it beacon mode?
 050  30288                       CALL Z, 288[BeaconBeep]
 051                              ; Pete  enabled 24 Feb 2015 - inhibit in tonedetect
 051                              ;                    CALL      Check4CmdfromBT     ; receive from BT and echo to terminal
 051                              ;                    JUMP      C, HandleBTCommand  ; If less than 128 there is a value to give back and display.
 051                              ;HandleBTCommand_Done:
 051                              ; pete end
 051  20298                       CALL 298[getUARTchar]
 052                              ;COMPARE      s6, 32'd
 052                              ;JUMP      Z, loop             ; If a space then skip
 052                              ; Had mistankenly changed the next line!
 052  1D6FF                       COMPARE s6, FF
 053  32040                       JUMP Z, 040[loop]                    ; If no character then skip-MAKE SURE ANYTHINGTO BE PERFORMED REGULARLY IS DONE BEFORE THIS POINT
 054  1D60A                       COMPARE s6, 0A[10'd]
 055  32115                       JUMP Z, 115[interpcommand]           ; This is end of command character (LF now! as of Dec 2016)
 056  1D60D                       COMPARE s6, 0D[13'd]
 057  32040                       JUMP Z, 040[loop]                    ; If CR ignore
 058  1DB10                       COMPARE sB[ScratchPointer], 10[16'd] ; Check we are not writing too many characters to the scratchpad
 059  3E040                       JUMP NC, 040[loop]                   ; don't write to scratch if Pointer (counter) 16 or above
 05A  2E6B0                       STORE s6, (sB[ScratchPointer])       ; Save command character
 05B  11B01                       ADD sB[ScratchPointer], 01           ; is a command char so increment
 05C  22040                       JUMP 040[loop]
 05D                SendADCToARM: 
 05D  0B128                       FETCH s1, 28[peteTXMode]
 05E  1D101                       COMPARE s1, 01
 05F  35000                       RETURN NZ                            ; do not send unless transmitting
 060  01626                       LOAD s6, 26["&"]
 061  2033B                       CALL 33B[Send2UartTX]                ; send the &
 062  01665                       LOAD s6, 65["e"]                     ; indicates 'earthing' quality
 063  2033B                       CALL 33B[Send2UartTX]                ; send the &
 064                              ; Byte2Chars takes data in s5 and returns two ascii codes in s6,s7
 064                              ;(s7 is character for lower 4 bits) sent as second character
 064  00500                       LOAD s5, s0
 065  202F0                       CALL 2F0[Byte2Chars]
 066  2033B                       CALL 33B[Send2UartTX]                ; send the upper ADC value
 067  00670                       LOAD s6, s7
 068  2033B                       CALL 33B[Send2UartTX]                ; send the lower ADC value
 069  20346                       CALL 346[SendCRLF]
 06A  25000                       RETURN 
 06B  0900F        CheckADClevel: INPUT s0, 0F[ADCSignalLevel]
 06C  0B115                       FETCH s1, 15[ADCLevel]
 06D  1C010                       COMPARE s0, s1
 06E  31000                       RETURN Z                             ; return if the value is still the same (ie wait for new value)
 06F                              ;__________________________________________________
 06F                              ;TEMPORARY SKIP to TEMPskip:  (values will be redirected directly from DSP to KP in
 06F                              ;      JUMP  Tempskip NOTnow 19 sep 2015
 06F                              ;____________________________________________________
 06F  0117F                       LOAD s1, 7F                          ; Note top bit is not received! Send command to expect signal level
 070                              ;OUTPUT       s1, CMD2KP          ; send ADCgain value to LCD for display
 070  2F015                       STORE s0, 15[ADCLevel]               ; save new value of ADClevel
 071  2005D                       CALL 05D[SendADCToARM]               ; send to ARM
 072                              ; Code to send a value for display as 2 decimal digits in the range 00 to 74 (~42dB) representing the broad band signal strength (5 units per gain step, 1 unit per 8 units of ADC level
 072                              ; assuming ADClevel kept betweeen $18 and $40, signal level within range covers ~8dB, display about 1.7 x value in dB in steps of 2 (~1.2dB)
 072  0B116                       FETCH s1, 16[ADCgain]
 073  0310F                       AND s1, 0F                           ; Gain level just in lower 4 bits
 074  0120E                       LOAD s2, 0E
 075  18210                       SUB s2, s1                           ; Invert gain level to signal level ie highest gain of $E becomes zero
 076  01100                       LOAD s1, 00                          ; use this as counter for lower decimal digit
 077  1420E                       SR0 s2                               ; half the value and send half to the carry flag (to add 5)
 078  3E07A                       JUMP NC, 07A[nofive]                 ; only add 5 to lower digit if carry set
 079  01105                       LOAD s1, 05[5'd]
 07A  1D010               nofive: COMPARE s0, 10[16'd]                 ; skip if below first step (about 1.2dB)
 07B  3A07D                       JUMP C, 07D[First]
 07C  11102                       ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 07D  1D012                First: COMPARE s0, 12[18'd]                 ; skip if below second step (about 1.2dB)
 07E  3A080                       JUMP C, 080[Second]
 07F  11102                       ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 080  1D015               Second: COMPARE s0, 15[21'd]                 ; skip if below third step (about 1.2dB)
 081  3A083                       JUMP C, 083[Third]
 082  11102                       ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 083  1D018                Third: COMPARE s0, 18[24'd]                 ; skip if below
 084  3A086                       JUMP C, 086[Fourth]
 085  11102                       ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 086  1D01C               Fourth: COMPARE s0, 1C[28'd]                 ; skip if below
 087  3A089                       JUMP C, 089[Fifth]
 088  11102                       ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 089                              ; now check if s1 (lower decimal digit) is above 9
 089  1D10A                Fifth: COMPARE s1, 0A[10'd]
 08A  3A08D                       JUMP C, 08D[ToLCD]
 08B  11201                       ADD s2, 01[1'd]                      ; Add 1 to first decimal digit
 08C  1910A                       SUB s1, 0A[10'd]                     ; subtract 10 from lower digit
 08D                              ;Deleted part that tried to apply attenuator
 08D                       ToLCD: ;OUTPUT       s2, CMD2KP          ; Send first decimal digit (as binary value 0-7)
 08D                              ;OUTPUT       s1, CMD2KP          ; send second decimal digit (as binary value for 0-9)
 08D                              ; s0 should hoperfully still have ADCsignal level!
 08D                              ;_______________________________
 08D                              ;Temp bit
 08D                    Tempskip: 
 08D                              ;_____________________________________
 08D                              ; LOAD      s5, s0
 08D                              ;      ;CALL      Byte2UART    ;and echo to UART  - not now!
 08D  0B119                       FETCH s1, 19[ADCAGCUpperThreshold]
 08E  0B015                       FETCH s0, 15[ADCLevel]               ; had lost the s0 value at this point!
 08F  1C010                       COMPARE s0, s1                       ; aim to keep value around $15? - need to drop this further! Needs to be lower for transmission??
 090  3C095                       CALL NC, 095[ReduceADCgain]
 091  0B11A                       FETCH s1, 1A[ADCAGCLowerThreshold]
 092  1C010                       COMPARE s0, s1                       ; aim to keep value around $15? -
 093  3809E                       CALL C, 09E[IncreaseADCgain]
 094  25000                       RETURN 
 095  0B016        ReduceADCgain: FETCH s0, 16[ADCgain]
 096  00100                       LOAD s1, s0
 097  0310F                       AND s1, 0F                           ; mask lower 4 bits
 098  1D101                       COMPARE s1, 01                       ; don't drop to zero!
 099  31000                       RETURN Z
 09A  19001                       SUB s0, 01[1'd]
 09B  2F016                       STORE s0, 16[ADCgain]
 09C  2D002                       OUTPUT s0, 02[GainPD]                ; set ADC pre-amp
 09D                              ; OUTPUT       s0, CMD2KP          ; send value to LCD for display - don't bother
 09D  25000                       RETURN 
 09E  0B016      IncreaseADCgain: FETCH s0, 16[ADCgain]
 09F  00100                       LOAD s1, s0
 0A0  0310F                       AND s1, 0F                           ; mask lower 4 bits
 0A1  1D10E                       COMPARE s1, 0E                       ; don't go past $0E!
 0A2  31000                       RETURN Z
 0A3  11001                       ADD s0, 01[1'd]
 0A4  2F016                       STORE s0, 16[ADCgain]
 0A5  2D002                       OUTPUT s0, 02[GainPD]                ; set ADC pre-amp
 0A6                              ; OUTPUT       s0, CMD2KP          ; send value to LCD for display
 0A6  25000                       RETURN 
 0A7                              ;Delete setting and resetting Attenuator (March 2016)
 0A7                   checkrqst: ;COMPARE      s6, "r"    ;character_r
 0A7                              ;CALL      Z, checkRXmode
 0A7                              ;COMPARE      s6, "t"   ;character_t
 0A7                              ;CALL      Z, checkTXmode
 0A7                              ;COMPARE      s6, "e"   ;character_e
 0A7                              ;CALL      Z, setEarthAntennas
 0A7                              ;COMPARE      s6, "l"   ; character_l
 0A7                              ;CALL      Z, setLoopAntennas
 0A7  1D626                       COMPARE s6, 26["&"]
 0A8  300AA                       CALL Z, 0AA[SendToARM]
 0A9  25000                       RETURN 
 0AA                   SendToARM: 
 0AA  2033B                       CALL 33B[Send2UartTX]                ; send the &
 0AB  202BB           waitForKey: CALL 2BB[Check4CmdfromKP]
 0AC  1D680                       COMPARE s6, 80[128'd]
 0AD  320AB                       JUMP Z, 0AB[waitForKey]
 0AE  2033B                       CALL 33B[Send2UartTX]                ; send the keypress value
 0AF  20346                       CALL 346[SendCRLF]
 0B0                              ;LOAD      s6, 0D             ; c/r
 0B0                              ;CALL      Send2UartTX   ; send
 0B0                              ;LOAD      s6, 0A             ; only l/f is needed
 0B0                              ;CALL      Send2UartTX   ; send
 0B0  25000                       RETURN 
 0B1  0B012     setEarthAntennas: FETCH s0, 12[Mode]
 0B2  030EF                       AND s0, EF[239'd]                    ; 255-16  ;reset bit 4
 0B3  2F012                       STORE s0, 12[Mode]
 0B4  200F1                       CALL 0F1[setRXmode]                  ;Make active and return to RX
 0B5  25000                       RETURN 
 0B6  0B012      setLoopAntennas: FETCH s0, 12[Mode]
 0B7  05010                       OR s0, 10[16'd]                      ;set bit 4
 0B8  2F012                       STORE s0, 12[Mode]
 0B9  200F1                       CALL 0F1[setRXmode]
 0BA  25000                       RETURN 
 0BB                 checkRXmode: 
 0BB                              ; ;; Pete added for Bluetooth (temp)
 0BB                              ;FETCH     s0, BluetoothXmit
 0BB                              ;ADD       s0, 00
 0BB                              ;RETURN       NZ                  ; do nothing if BT transmitting
 0BB                              ; ;; end Pete added for BT
 0BB                              ;FETCH     s0, Mode
 0BB                              ;AND       s0, 02               ; mask bit 1
 0BB                              ;COMPARE      s0, 02               ; is it set ie currently in TX mode?
 0BB                              ;RETURN       NZ                  ; return if already in RX mode return
 0BB  01626                       LOAD s6, 26["&"]
 0BC  2033B                       CALL 33B[Send2UartTX]
 0BD  0165A                       LOAD s6, 5A["Z"]
 0BE  2033B                       CALL 33B[Send2UartTX]
 0BF  20346                       CALL 346[SendCRLF]
 0C0  200F1                       CALL 0F1[setRXmode]                  ; so go ahead and set up RX mode
 0C1  25000                       RETURN 
 0C2                              ; Routine to set receive mode - just basic function ie doesn't set mode etc.
 0C2                          RX: 
 0C2  01530                       LOAD s5, 30[48'd]                    ; Ascii code for '0' - set receive mode
 0C3  2D500                       OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 0C4  0B510                       FETCH s5, 10[Latch7]
 0C5  0357F                       AND s5, 7F[~TX_HIGH]                 ; reset bit 7
 0C6  2F510                       STORE s5, 10[Latch7]
 0C7  2D507                       OUTPUT s5, 07[ProgramM]
 0C8  25000                       RETURN 
 0C9                 checkTXmode: 
 0C9                              ; Would NEED to reinstate this GN April 2017 for helloworld version     ;FETCH     s0, Mode
 0C9                              ;AND       s0, 02               ; mask bit 1 here 2 means TX mode 0 RX mode
 0C9                              ;COMPARE      s0, 00               ; is it not set ie currently in RX mode?
 0C9                              ;RETURN       NZ                  ; return if already in TX mode
 0C9  01626                       LOAD s6, 26["&"]
 0CA  2033B                       CALL 33B[Send2UartTX]
 0CB  01659                       LOAD s6, 59["Y"]
 0CC  2033B                       CALL 33B[Send2UartTX]
 0CD  20346                       CALL 346[SendCRLF]
 0CE  200D0                       CALL 0D0[setTXmode]                  ; so go ahead and set up TX mode
 0CF  25000                       RETURN 
 0D0                              ; need to set scratch pad mode, set RX freq to 0 (SRF0155), et TX freq to 86.95 STF0E7E, input channel with equivalent of SAI01 and send transmit mode command to DSP
 0D0                   setTXmode: 
 0D0                              ;FETCH     s0, Mode
 0D0                              ;OR        s0, 02               ; set TX bit
 0D0                              ;AND       s0, FE             ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 0D0                              ;STORE     s0, Mode
 0D0                              ; LOAD      s0, 01      Don't need this is keypad is sorting it!
 0D0                              ; OUTPUT       s0, RXFreqMSB
 0D0                              ; LOAD      s0, 55
 0D0                              ; OUTPUT       s0, RXFreqLSB       ; drop detection to baseband (for when using wired mic)
 0D0  01001                       LOAD s0, 01
 0D1  2F028                       STORE s0, 28[peteTXMode]
 0D2  0B013                       FETCH s0, 13[ADCstate]
 0D3  05040                       OR s0, 40[AnalogueChannel]           ; set bit 6 (SAI01) - Channel 1 in Matlab GUI
 0D4  2F013                       STORE s0, 13[ADCstate]               ; save
 0D5  2D013                       OUTPUT s0, 13[ADCstate_port]         ; set port to new ADC channel
 0D6  0B516                       FETCH s5, 16[ADCgain]                ; get gain used for RX
 0D7  2F51C                       STORE s5, 1C[ADCGainRX]              ; this value is tracked
 0D8  0B51B                       FETCH s5, 1B[ADCGainTX]              ; gain to last value used for TX
 0D9  2F516                       STORE s5, 16[ADCgain]                ; and make current ADCgain value
 0DA  2010A                       CALL 10A[SetAnGain]                  ; set analogue gain to moderate
 0DB  01040                       LOAD s0, 40[AGCupperTX]
 0DC  2F019                       STORE s0, 19[ADCAGCUpperThreshold]
 0DD  01018                       LOAD s0, 18[AGClowerTX]
 0DE  2F01A                       STORE s0, 1A[ADCAGCLowerThreshold]
 0DF  200EA                       CALL 0EA[TX]
 0E0  20223                       CALL 223[Twotone]                    ; added to give start of message beep
 0E1  01624                       LOAD s6, 24["$"]                     ; c/r
 0E2  2033B                       CALL 33B[Send2UartTX]                ; send
 0E3  01674                       LOAD s6, 74["t"]                     ; c/r
 0E4  2033B                       CALL 33B[Send2UartTX]                ; send
 0E5  0160D                       LOAD s6, 0D                          ; c/r
 0E6  2033B                       CALL 33B[Send2UartTX]                ; send
 0E7  0160A                       LOAD s6, 0A                          ; c/r
 0E8  2033B                       CALL 33B[Send2UartTX]                ; send
 0E9  25000                       RETURN 
 0EA                              ; routine to set transmit mode
 0EA  01531                   TX: LOAD s5, 31[49'd]                    ; Ascii code for '1' - set transmit mode
 0EB  2D500                       OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 0EC  0B510                       FETCH s5, 10[Latch7]
 0ED  05580                       OR s5, 80[TX_HIGH]                   ; set bit 7
 0EE  2F510                       STORE s5, 10[Latch7]
 0EF  2D507                       OUTPUT s5, 07[ProgramM]
 0F0  25000                       RETURN 
 0F1                              ; need to set scratch pad mode, set RX freq to 86.95 (SRF769A or for 87kHz need 76AB), input channel with equivalent of SAI00 and send receive mode command to DSP, set analog gain to 8
 0F1                   setRXmode: 
 0F1                              ;CALL      Warble             ; added to give start of message beep
 0F1  01532                       LOAD s5, 32[50'd]                    ; Ascii code for '2' - DSP to grap the AGCvalue before the warble
 0F2  2D500                       OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 0F3                              ;CALL      Warble             ; added to give start of message beep
 0F3  0B516                       FETCH s5, 16[ADCgain]                ; gain used during TX mode
 0F4  2F51B                       STORE s5, 1B[ADCGainTX]              ; Save for next TX mode
 0F5  20277                       CALL 277[Warble]
 0F6  01000                       LOAD s0, 00
 0F7  2F028                       STORE s0, 28[peteTXMode]
 0F8                              ;FETCH     s0, Mode
 0F8                              ;AND       s0, 252'd    ;255 - 3         ; reset TX bit AND becon on bit
 0F8                              ;STORE     s0, Mode
 0F8                              ; LOAD      s0, 2A             ; $75 for new demodulator   Don't need this from GV95 as keypad sets the frequency
 0F8                              ; OUTPUT       s0, RXFreqMSB
 0F8                              ; LOAD      s0, AD          ; $ N2 or Heyphone)
 0F8                              ; OUTPUT       s0, RXFreqLSB
 0F8                              ;Set ADC channel depending on whether using loop or earth wires (Mode bit 4 set for loop)
 0F8  0B012                       FETCH s0, 12[Mode]
 0F9  03010                       AND s0, 10[16'd]                     ;antenna input select bit (4)
 0FA  14006                       SL0 s0
 0FB  14006                       SL0 s0                               ;to affect bit 6
 0FC  0B113                       FETCH s1, 13[ADCstate]
 0FD  031BF                       AND s1, BF[191'd]                    ; 255 - 64        ; reset  bit 6
 0FE  04100                       OR s1, s0                            ;now affect bit 6 = Mode bit 4 setting
 0FF  2F113                       STORE s1, 13[ADCstate]               ; save
 100  2D113                       OUTPUT s1, 13[ADCstate_port]         ; set port to new ADC channel
 101  0B51C                       FETCH s5, 1C[ADCGainRX]              ; gain to last value used for RX
 102  2F516                       STORE s5, 16[ADCgain]                ; this value is tracked
 103  2010A                       CALL 10A[SetAnGain]                  ; set analogue gain to moderate
 104  01032                       LOAD s0, 32[AGCupperRX]
 105  2F019                       STORE s0, 19[ADCAGCUpperThreshold]
 106  01012                       LOAD s0, 12[AGClowerRX]
 107  2F01A                       STORE s0, 1A[ADCAGCLowerThreshold]
 108  200C2                       CALL 0C2[RX]
 109  25000                       RETURN 
 10A                              ; set gain to 32 or is it 48?, enter with gain value in s5 (ie $DA for transmit)
 10A  0350F            SetAnGain: AND s5, 0F                           ; only affect lower 4 bits
 10B  0B016                       FETCH s0, 16[ADCgain]
 10C  030F0                       AND s0, F0                           ; keep upper bits
 10D  04500                       OR s5, s0                            ; combine
 10E  2F516                       STORE s5, 16[ADCgain]                ; save new value (includes all bits)
 10F  05580                       OR s5, 80                            ; set bit 7 to start calibration
 110  2D502                       OUTPUT s5, 02[GainPD]
 111  20361                       CALL 361[delay_1ms]                  ; wait for calib
 112  0357F                       AND s5, 7F[127'd]                    ; reset bit 7
 113  2D502                       OUTPUT s5, 02[GainPD]
 114  25000                       RETURN 
 115                              ; Now interpret the command in the Scratch buffer and return to init
 115  01900        interpcommand: LOAD s9, 00                          ; counter through scratchpad addresses.
 116  1C9B0           interploop: COMPARE s9, sB[ScratchPointer]
 117  3203F                       JUMP Z, 03F[startLoop]               ; break out of loop after reading final character command.
 118  2032B                       CALL 32B[getnextscratchchar]
 119  1D02A                       COMPARE s0, 2A["*"]                  ; is this a * = command from ARM menu
 11A  32123                       JUMP Z, 123[MsgFromARM]
 11B  1D053                       COMPARE s0, 53[83'd]                 ; is this a S?
 11C  32134                       JUMP Z, 134[isS]
 11D  1D047                       COMPARE s0, 47[71'd]                 ; is this a G?
 11E  32146                       JUMP Z, 146[isG]
 11F                              ;      COMPARE      s0, 77'd              ; is this a M?
 11F                              ; JUMP      Z, isM
 11F  1D05A                       COMPARE s0, 5A[90'd]                 ; is this a Z?
 120  32001                       JUMP Z, 001[reboot]                  ; then go to reboot code (ie to reboot need to send Z<CR>, then do Prog...)
 121  20346                       CALL 346[SendCRLF]
 122  2203F                       JUMP 03F[startLoop]
 123                  MsgFromARM: 
 123  2032B                       CALL 32B[getnextscratchchar]
 124  1D672                       COMPARE s6, 72["r"]                  ;character_r
 125                              ;CALL      Z, checkRXmode
 125  300F1                       CALL Z, 0F1[setRXmode]
 126  1D674                       COMPARE s6, 74["t"]                  ;character_t
 127                              ;CALL      Z, checkTXmode
 127  300D0                       CALL Z, 0D0[setTXmode]
 128  1D663                       COMPARE s6, 63["c"]                  ;send confidence beep
 129  30230                       CALL Z, 230[Confidence]
 12A  1D662                       COMPARE s6, 62["b"]                  ;send beacon beep
 12B  30288                       CALL Z, 288[BeaconBeep]
 12C  1D679                       COMPARE s6, 79["y"]                  ;send LCD on to Keypad
 12D  30294                       CALL Z, 294[SendToKeypad]
 12E  1D659                       COMPARE s6, 59["Y"]                  ;send LCD off to Keypad
 12F  30294                       CALL Z, 294[SendToKeypad]
 130  1D65A                       COMPARE s6, 5A["Z"]                  ;send turn radio off to Keypad
 131  30293                       CALL Z, 293[SendTurnOffToKeypad]
 132                              ;LOAD      s6, "$"   ;send confidence beep
 132                              ;CALL      Send2UartTX   ; send the keypress value
 132  20346                       CALL 346[SendCRLF]
 133  2203F                       JUMP 03F[startLoop]
 134  2032B                  isS: CALL 32B[getnextscratchchar]
 135  1D042                       COMPARE s0, 42[66'd]                 ; is this a B?
 136  32162                       JUMP Z, 162[isSB]                    ;
 137  1D041                       COMPARE s0, 41[65'd]                 ; is this a A?
 138  32158                       JUMP Z, 158[isSA]
 139  1D052                       COMPARE s0, 52[82'd]                 ; is this a R?
 13A  321A8                       JUMP Z, 1A8[isSR]
 13B  1D054                       COMPARE s0, 54[84'd]                 ; is this a T?
 13C  321AE                       JUMP Z, 1AE[isST]
 13D  1D04B                       COMPARE s0, 4B[75'd]                 ; is this a K?
 13E  32169                       JUMP Z, 169[isSK]                    ;
 13F  1D04C                       COMPARE s0, 4C[76'd]                 ; is this a L?
 140  3216D                       JUMP Z, 16D[isSL]                    ; Set Loran Blanking
 141                              ;      COMPARE      s0, 83'd              ; is this a S?
 141                              ; JUMP      Z, isSS             ;
 141  1D055                       COMPARE s0, 55[85'd]                 ; is this a U
 142  32183                       JUMP Z, 183[isSU]
 143  1D057                       COMPARE s0, 57[87'd]                 ; is this a W
 144  32188                       JUMP Z, 188[isSW]
 145  2203F                       JUMP 03F[startLoop]
 146  2032B                  isG: CALL 32B[getnextscratchchar]
 147  1D041                       COMPARE s0, 41[65'd]                 ; is this a A?
 148  3221D                       JUMP Z, 21D[isGA]
 149  1D042                       COMPARE s0, 42[66'd]                 ; is this a B?
 14A  321EE                       JUMP Z, 1EE[isGB]
 14B  1D043                       COMPARE s0, 43[67'd]                 ; is this a C?
 14C  321F6                       JUMP Z, 1F6[isGC]
 14D  1D04B                       COMPARE s0, 4B[75'd]                 ; is this a K?
 14E  321F9                       JUMP Z, 1F9[isGK]
 14F  1D04C                       COMPARE s0, 4C[76'd]                 ; is this a L?
 150  321FF                       JUMP Z, 1FF[isGL]
 151  1D056                       COMPARE s0, 56[86'd]                 ; is this a V?
 152  3221F                       JUMP Z, 21F[isGV]
 153  1D047                       COMPARE s0, 47[71'd]                 ; is this a G?
 154  321DC                       JUMP Z, 1DC[isGG]
 155  1D053                       COMPARE s0, 53[83'd]                 ; is this a S?
 156  321E5                       JUMP Z, 1E5[isGS]
 157  2203F                       JUMP 03F[startLoop]
 158  2032B                 isSA: CALL 32B[getnextscratchchar]
 159  1D053                       COMPARE s0, 53[83'd]                 ; is this a S?
 15A  321B2                       JUMP Z, 1B2[isSAS]                   ;
 15B  1D047                       COMPARE s0, 47[71'd]                 ; is this a G?
 15C  321B6                       JUMP Z, 1B6[isSAG]                   ;
 15D  1D04F                       COMPARE s0, 4F[79'd]                 ; is this a O?
 15E  321C8                       JUMP Z, 1C8[isSAO]                   ;
 15F  1D049                       COMPARE s0, 49[73'd]                 ; is this a I?
 160  321BD                       JUMP Z, 1BD[isSAI]                   ;
 161  2203F                       JUMP 03F[startLoop]
 162                              ; SB - set beacon mode (SB<xx>
 162  20330                 isSB: CALL 330[getnextvalue]
 163  03501                       AND s5, 01                           ; Mask bit 0
 164  0B012                       FETCH s0, 12[Mode]
 165  030FE                       AND s0, FE[254'd]                    ; reset bit 0
 166  04050                       OR s0, s5                            ; affect bit 0
 167  2F012                       STORE s0, 12[Mode]
 168  22028                       JUMP 028[init]
 169                              ; Commands for keypad pico
 169  2032B                 isSK: CALL 32B[getnextscratchchar]
 16A  1D053                       COMPARE s0, 53[83'd]                 ; is this a S?
 16B  32178                       JUMP Z, 178[isSKS]                   ;
 16C  22028                       JUMP 028[init]
 16D  20330                 isSL: CALL 330[getnextvalue]
 16E  01400                       LOAD s4, 00
 16F  1D501                       COMPARE s5, 01                       ; is it 1
 170  36172                       JUMP NZ, 172[setLoranBlank]
 171  01410                       LOAD s4, 10[LoranBlank]
 172  0B013        setLoranBlank: FETCH s0, 13[ADCstate]
 173  030EF                       AND s0, EF[~LoranBlank]              ; reset bit for Loran blanking
 174  04040                       OR s0, s4                            ; affect this bit
 175  2F013                       STORE s0, 13[ADCstate]               ; save
 176  2D013                       OUTPUT s0, 13[ADCstate_port]         ; set port to new ADC channel
 177  22028                       JUMP 028[init]
 178                       isSKS: ; LOAD      s0, 83'd              ; letter S
 178                              ; OUTPUT       s0, CMD2KP          ; send S to KP
 178                              ; CALL      getnextscratchchar
 178                              ; SUB       s0, 48'd
 178                              ; OUTPUT       s0, CMD2KP          ; send select value as binary value to KP
 178  22028                       JUMP 028[init]
 179                              ; This streams from UART data to DSP to TX and never exits!
 179  2032B                 isSS: CALL 32B[getnextscratchchar]         ; get beacon offset in s0
 17A  01533                       LOAD s5, 33[51'd]                    ; Ascii code for '3' - set stream mode -NO ESCAPE!
 17B  2D500                       OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 17C  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send raw data byte of bit offset
 17D  200EA                       CALL 0EA[TX]
 17E  0B012                       FETCH s0, 12[Mode]
 17F  05004                       OR s0, 04                            ; set 'Streaming TX' bit
 180  030FE                       AND s0, FE                           ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 181  2F012                       STORE s0, 12[Mode]
 182  22040                       JUMP 040[loop]                       ;
 183                              ; Stream RX data to UART
 183  0B012                 isSU: FETCH s0, 12[Mode]
 184  05008                       OR s0, 08                            ; set 'Streaming TX' bit
 185  030FE                       AND s0, FE                           ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 186  2F012                       STORE s0, 12[Mode]
 187  22028                       JUMP 028[init]                       ;
 188                              ; Redirect Serial to and from BT module
 188  01654                 isSW: LOAD s6, 54["T"]
 189  2033B                       CALL 33B[Send2UartTX]
 18A  0164F                       LOAD s6, 4F["O"]
 18B  2033B                       CALL 33B[Send2UartTX]
 18C  01620                       LOAD s6, 20                          ;Space character
 18D  2033B                       CALL 33B[Send2UartTX]
 18E  01642                       LOAD s6, 42["B"]
 18F  2033B                       CALL 33B[Send2UartTX]
 190  01654                       LOAD s6, 54["T"]
 191  2033B                       CALL 33B[Send2UartTX]
 192  20346                       CALL 346[SendCRLF]
 193  01001                       LOAD s0, 01
 194  2D009                       OUTPUT s0, 09[Configure]
 195  22028                       JUMP 028[init]                       ;
 196                              ; Now get a raw UART byte
 196  20337             isSSloop: CALL 337[CheckUartRx]
 197  36196                       JUMP NZ, 196[isSSloop]               ; loop if nothing in UART buffer
 198  09500                       INPUT s5, 00[Uart_rx]                ; get byte
 199  202F0                       CALL 2F0[Byte2Chars]
 19A  2D600                       OUTPUT s6, 00[CMD2DSP]               ; Send audio MSBbyte to DSP
 19B  2D700                       OUTPUT s7, 00[CMD2DSP]               ; Send audio LSBbyte to DSP
 19C  202B2                       CALL 2B2[Check4CmdfromDSP]           ; If fifo character then send to terminal !!!!!!!!!!!!!!!!!!!! reinstate this 15/5/2013
 19D  22040                       JUMP 040[loop]                       ; Try making this a called routine, sending 1 value per loop
 19E                              ; this is same as following routine except it returns rather than jumping to init
 19E  01524    nowsend2flashback: LOAD s5, 24[36'd]                    ; was 16 should be 9x4=36
 19F  2D507                       OUTPUT s5, 07[ProgramM]              ; initiates flash write - may take some time for pp command!
 1A0  20361                       CALL 361[delay_1ms]                  ; wait to complete
 1A1  20361                       CALL 361[delay_1ms]
 1A2  20361                       CALL 361[delay_1ms]                  ; TO be OPTIMIZED!!!!!!!!!!!!!!!!!!!!!!!
 1A3  01500                       LOAD s5, 00                          ; reset send2flash
 1A4  2D507                       OUTPUT s5, 07[ProgramM]              ; initiates flash write - may take some time for pp command!
 1A5  25000                       RETURN 
 1A6  2019E        nowsend2flash: CALL 19E[nowsend2flashback]
 1A7  22028                       JUMP 028[init]
 1A8  2032B                 isSR: CALL 32B[getnextscratchchar]
 1A9  1D046                       COMPARE s0, 46[70'd]                 ; is this a F?
 1AA  321D3                       JUMP Z, 1D3[isSRF]                   ;
 1AB  1D04D                       COMPARE s0, 4D[77'd]                 ; is this a M?
 1AC  321D8                       JUMP Z, 1D8[isSRM]                   ;
 1AD  22028                       JUMP 028[init]
 1AE                              ; Testmemory TEMP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END
 1AE  2032B                 isST: CALL 32B[getnextscratchchar]
 1AF                              ;                    COMPARE      s0, 70'd              ; is this a F?
 1AF                              ;                   JUMP      Z, isSTF            ;
 1AF  1D04D                       COMPARE s0, 4D[77'd]                 ; is this a M?
 1B0  321DA                       JUMP Z, 1DA[isSTM]                   ;
 1B1  22028                       JUMP 028[init]
 1B2                              ; SAS - set archive source
 1B2  20330                isSAS: CALL 330[getnextvalue]
 1B3  00150                       LOAD s1, s5
 1B4  20316                       CALL 316[ArchiveSource]
 1B5  22028                       JUMP 028[init]
 1B6                              ; SAG   Set analogue gain
 1B6  20330                isSAG: CALL 330[getnextvalue]
 1B7  05580                       OR s5, 80[128'd]                     ; set bit 7
 1B8  2D502                       OUTPUT s5, 02[GainPD]
 1B9  20361                       CALL 361[delay_1ms]                  ; wait for calib
 1BA  0357F                       AND s5, 7F[127'd]                    ; reset bit 7
 1BB  2D502                       OUTPUT s5, 02[GainPD]
 1BC  22028                       JUMP 028[init]
 1BD  20330                isSAI: CALL 330[getnextvalue]
 1BE  01400                       LOAD s4, 00
 1BF  1D501                       COMPARE s5, 01                       ; is it 1
 1C0  361C2                       JUMP NZ, 1C2[setADC]
 1C1  01440                       LOAD s4, 40[64'd]
 1C2  0B013               setADC: FETCH s0, 13[ADCstate]
 1C3  030BF                       AND s0, BF[191'd]                    ; reset bit 6
 1C4  04040                       OR s0, s4                            ; affect bit 6
 1C5  2F013                       STORE s0, 13[ADCstate]               ; save
 1C6  2D013                       OUTPUT s0, 13[ADCstate_port]         ; set port to new ADC channel
 1C7  22028                       JUMP 028[init]
 1C8  20330                isSAO: CALL 330[getnextvalue]
 1C9  01400                       LOAD s4, 00
 1CA  1D501                       COMPARE s5, 01                       ; is it 1
 1CB  361CD                       JUMP NZ, 1CD[setAudioOut]
 1CC  01420                       LOAD s4, 20[32'd]
 1CD  0B013          setAudioOut: FETCH s0, 13[ADCstate]
 1CE  030DF                       AND s0, DF[223'd]                    ; 255 - 32        ; reset bit5
 1CF  04040                       OR s0, s4                            ; affect bit 5
 1D0  2F013                       STORE s0, 13[ADCstate]               ; save
 1D1  2D013                       OUTPUT s0, 13[ADCstate_port]         ; set port to new audio channel
 1D2  22028                       JUMP 028[init]
 1D3                              ; SRF - set receive frequency (gets 4 hex digits
 1D3  20330                isSRF: CALL 330[getnextvalue]               ; get byte represented by 2 digits
 1D4  2D50A                       OUTPUT s5, 0A[RXFreqMSB]
 1D5  20330                       CALL 330[getnextvalue]
 1D6  2D50B                       OUTPUT s5, 0B[RXFreqLSB]
 1D7  22028                       JUMP 028[init]
 1D8                              ; set receive mode
 1D8  200F1                isSRM: CALL 0F1[setRXmode]                  ; used to be RX, but that doesn't change mode and frequency etc.
 1D9  22028                       JUMP 028[init]
 1DA                              ; set Tranmit mode
 1DA  200D0                isSTM: CALL 0D0[setTXmode]                  ; used to be TX 20/5/2013
 1DB  22028                       JUMP 028[init]
 1DC                              ; STF - set transmit frequency (gets 4 hex digits -Frequency now set by Keypad
 1DC                              ;isSTF:              CALL      getnextvalue        ; get byte represented by 2 digits
 1DC                              ;                   OUTPUT       s5, TXFreqMSB
 1DC                              ;                  CALL      getnextvalue
 1DC                              ;                 OUTPUT       s5, TXFreqLSB
 1DC                              ;                JUMP      init
 1DC                              ; GET AGC value from DSP
 1DC  01047                 isGG: LOAD s0, 47[71'd]                    ; letter G
 1DD  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send G to DSP
 1DE  20346                       CALL 346[SendCRLF]
 1DF  20361                       CALL 361[delay_1ms]
 1E0  202B2                       CALL 2B2[Check4CmdfromDSP]           ; if character send to terminal
 1E1  202B2                       CALL 2B2[Check4CmdfromDSP]           ; if character send to terminal
 1E2  202B2                       CALL 2B2[Check4CmdfromDSP]           ; if character send to terminal
 1E3  202B2                       CALL 2B2[Check4CmdfromDSP]           ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 1E4                              ;      CALL      SendCRLF
 1E4  22028                       JUMP 028[init]
 1E5                              ; Get AVEsignal level from DSP
 1E5  01053                 isGS: LOAD s0, 53[83'd]                    ; letter S
 1E6  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send S to DSP
 1E7  20346                       CALL 346[SendCRLF]
 1E8  20361                       CALL 361[delay_1ms]
 1E9  202B2                       CALL 2B2[Check4CmdfromDSP]           ; if character send to terminal
 1EA  202B2                       CALL 2B2[Check4CmdfromDSP]           ; if character send to terminal
 1EB  202B2                       CALL 2B2[Check4CmdfromDSP]           ; if character send to terminal
 1EC  202B2                       CALL 2B2[Check4CmdfromDSP]           ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 1ED                              ;      CALL      SendCRLF
 1ED  22028                       JUMP 028[init]
 1EE                              ; send test command to BT pico
 1EE  01047                 isGB: LOAD s0, 47[71'd]                    ; letter G
 1EF  2D014                       OUTPUT s0, 14[CMD2BT]                ; send G to BT
 1F0                              ;      CALL      SendCRLF
 1F0  20361                       CALL 361[delay_1ms]
 1F1  202B7                       CALL 2B7[Check4CmdfromBT]            ; if character send to terminal
 1F2  202B7                       CALL 2B7[Check4CmdfromBT]            ; if character send to terminal
 1F3  202B7                       CALL 2B7[Check4CmdfromBT]            ; if character send to terminal
 1F4  202B7                       CALL 2B7[Check4CmdfromBT]            ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 1F5                              ;      CALL      SendCRLF
 1F5  22028                       JUMP 028[init]
 1F6                              ; Return Loran inhibit rate
 1F6  09508                 isGC: INPUT s5, 08
 1F7  20341                       CALL 341[Byte2UART]
 1F8  25000                       RETURN 
 1F9                              ; Request from keypad pico
 1F9  2032B                 isGK: CALL 32B[getnextscratchchar]
 1FA  1D054                       COMPARE s0, 54[84'd]                 ; is this a T?
 1FB  3220B                       JUMP Z, 20B[isGKT]
 1FC  1D056                       COMPARE s0, 56[86'd]                 ; is this a V?
 1FD  32214                       JUMP Z, 214[isGKV]
 1FE  22028                       JUMP 028[init]
 1FF                              ; report signal level from the ADC
 1FF  0B515                 isGL: FETCH s5, 15[ADCLevel]
 200  20341                       CALL 341[Byte2UART]
 201  01620                       LOAD s6, 20                          ; space
 202  2033B                       CALL 33B[Send2UartTX]
 203  0950F                       INPUT s5, 0F[ADCSignalLevel]
 204  20341                       CALL 341[Byte2UART]
 205  01620                       LOAD s6, 20                          ; space
 206  2033B                       CALL 33B[Send2UartTX]
 207  0B516                       FETCH s5, 16[ADCgain]
 208  20341                       CALL 341[Byte2UART]
 209  20346                       CALL 346[SendCRLF]
 20A  22028                       JUMP 028[init]
 20B                              ; send test command to KP pico
 20B  01054                isGKT: LOAD s0, 54[84'd]                    ; letter T
 20C  2D015                       OUTPUT s0, 15[CMD2KP]                ; send T to KP
 20D  20346                       CALL 346[SendCRLF]
 20E  20361                       CALL 361[delay_1ms]
 20F  202BB                       CALL 2BB[Check4CmdfromKP]            ; if character send to terminal
 210  202BB                       CALL 2BB[Check4CmdfromKP]            ; if character send to terminal
 211  202BB                       CALL 2BB[Check4CmdfromKP]            ; if character send to terminal
 212  202BB                       CALL 2BB[Check4CmdfromKP]            ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 213                              ;      CALL      SendCRLF
 213  22028                       JUMP 028[init]
 214  01056                isGKV: LOAD s0, 56[86'd]                    ; letter V
 215  2D015                       OUTPUT s0, 15[CMD2KP]                ; send V to KP
 216  20346                       CALL 346[SendCRLF]
 217  20361                       CALL 361[delay_1ms]
 218  202BB                       CALL 2BB[Check4CmdfromKP]            ; if character send to terminal
 219  202BB                       CALL 2BB[Check4CmdfromKP]            ; if character send to terminal
 21A  202BB                       CALL 2BB[Check4CmdfromKP]            ; if character send to terminal
 21B  202BB                       CALL 2BB[Check4CmdfromKP]            ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 21C                              ;      CALL      SendCRLF
 21C  22028                       JUMP 028[init]
 21D  20303                 isGA: CALL 303[SendArchive]
 21E  22028                       JUMP 028[init]
 21F                        isGV: 
 21F  0150A                       LOAD s5, 0A[Versionno]
 220  20341                       CALL 341[Byte2UART]
 221  20346                       CALL 346[SendCRLF]                   ; added to allow get line to read OK
 222  22028                       JUMP 028[init]
 223  01042              Twotone: LOAD s0, 42[66'd]                    ; Block DSPpico
 224  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send B to DSP to block it
 225                              ; need to output TX freq carrier plus 30 then 40 and then return to carrier - now simply as an increment
 225  01035                       LOAD s0, 35[53'd]
 226  2D00D                       OUTPUT s0, 0D[Tone]
 227  2035C                       CALL 35C[delay_100ms]
 228  01023                       LOAD s0, 23[35'd]
 229  2D00D                       OUTPUT s0, 0D[Tone]
 22A  2035C                       CALL 35C[delay_100ms]
 22B  01000                       LOAD s0, 00
 22C  2D00D                       OUTPUT s0, 0D[Tone]                  ; and send value to SSB modulatorto reset to normal frequency
 22D  01052                       LOAD s0, 52[82'd]                    ; Un Block DSPpico
 22E  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send R to DSP (release)
 22F  25000                       RETURN 
 230                  Confidence: 
 230  200EA                       CALL 0EA[TX]
 231  01500                       LOAD s5, 00
 232              Confidenceloop: 
 232  01042                       LOAD s0, 42[66'd]                    ; Block DSPpico 0x42
 233  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send B to DSP to block it
 234                              ; need to output TX freq carrier plus 30 then 40 and then
 234                              ; return to carrier - now simply as an increment
 234  01014                       LOAD s0, 14[20'd]
 235  2D00D                       OUTPUT s0, 0D[Tone]
 236  2035C                       CALL 35C[delay_100ms]
 237  01028                       LOAD s0, 28[40'd]
 238  2D00D                       OUTPUT s0, 0D[Tone]
 239  2035C                       CALL 35C[delay_100ms]
 23A  0103C                       LOAD s0, 3C[60'd]
 23B  2D00D                       OUTPUT s0, 0D[Tone]
 23C  2035C                       CALL 35C[delay_100ms]
 23D  01050                       LOAD s0, 50[80'd]
 23E  2D00D                       OUTPUT s0, 0D[Tone]
 23F  2035C                       CALL 35C[delay_100ms]
 240  01064                       LOAD s0, 64[100'd]
 241  2D00D                       OUTPUT s0, 0D[Tone]
 242  2035C                       CALL 35C[delay_100ms]
 243                              ;ADD       s5, 01
 243                              ;COMPARE      s5, 02               ; Do this 4 times
 243                              ;JUMP      NZ, Confidenceloop
 243  01000                       LOAD s0, 00
 244  2D00D                       OUTPUT s0, 0D[Tone]                  ; and send value to SSB modulatorto reset to normal frequency
 245  01052                       LOAD s0, 52[82'd]                    ; Un Block DSPpico 0x52
 246  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send R to DSP (release)
 247  200C2                       CALL 0C2[RX]
 248  25000                       RETURN 
 249               TurnOffWarble: 
 249  200EA                       CALL 0EA[TX]
 24A  01500                       LOAD s5, 00
 24B           TurnOffWarbleloop: 
 24B  01042                       LOAD s0, 42[66'd]                    ; Block DSPpico 0x42
 24C  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send B to DSP to block it
 24D                              ; need to output TX freq carrier plus 30 then 40 and then
 24D                              ; return to carrier - now simply as an increment
 24D  01050                       LOAD s0, 50[80'd]
 24E  2D00D                       OUTPUT s0, 0D[Tone]
 24F  2035C                       CALL 35C[delay_100ms]
 250  0103C                       LOAD s0, 3C[60'd]
 251  2D00D                       OUTPUT s0, 0D[Tone]
 252  2035C                       CALL 35C[delay_100ms]
 253  01028                       LOAD s0, 28[40'd]
 254  2D00D                       OUTPUT s0, 0D[Tone]
 255  2035C                       CALL 35C[delay_100ms]
 256  01050                       LOAD s0, 50[80'd]
 257  2D00D                       OUTPUT s0, 0D[Tone]
 258  2035C                       CALL 35C[delay_100ms]
 259  0103C                       LOAD s0, 3C[60'd]
 25A  2D00D                       OUTPUT s0, 0D[Tone]
 25B  2035C                       CALL 35C[delay_100ms]
 25C  01028                       LOAD s0, 28[40'd]
 25D  2D00D                       OUTPUT s0, 0D[Tone]
 25E  2035C                       CALL 35C[delay_100ms]
 25F  01050                       LOAD s0, 50[80'd]
 260  2D00D                       OUTPUT s0, 0D[Tone]
 261  2035C                       CALL 35C[delay_100ms]
 262  0103C                       LOAD s0, 3C[60'd]
 263  2D00D                       OUTPUT s0, 0D[Tone]
 264  2035C                       CALL 35C[delay_100ms]
 265  01028                       LOAD s0, 28[40'd]
 266  2D00D                       OUTPUT s0, 0D[Tone]
 267  2035C                       CALL 35C[delay_100ms]
 268  01050                       LOAD s0, 50[80'd]
 269  2D00D                       OUTPUT s0, 0D[Tone]
 26A  2035C                       CALL 35C[delay_100ms]
 26B  0103C                       LOAD s0, 3C[60'd]
 26C  2D00D                       OUTPUT s0, 0D[Tone]
 26D  2035C                       CALL 35C[delay_100ms]
 26E  01028                       LOAD s0, 28[40'd]
 26F  2D00D                       OUTPUT s0, 0D[Tone]
 270  2035C                       CALL 35C[delay_100ms]
 271                              ;ADD       s5, 01
 271                              ;COMPARE      s5, 02               ; Do this 4 times
 271                              ;JUMP      NZ, TurnOffWarbleloop
 271  01000                       LOAD s0, 00
 272  2D00D                       OUTPUT s0, 0D[Tone]                  ; and send value to SSB modulatorto reset to normal frequency
 273  01052                       LOAD s0, 52[82'd]                    ; Un Block DSPpico 0x52
 274  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send R to DSP (release)
 275  200C2                       CALL 0C2[RX]
 276  25000                       RETURN 
 277  01500               Warble: LOAD s5, 00
 278  01042           Warbleloop: LOAD s0, 42[66'd]                    ; Block DSPpico 0x42
 279  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send B to DSP to block it
 27A                              ; need to output TX freq carrier plus 30 then 40 and then return to carrier - now simply as an increment
 27A  0101E                       LOAD s0, 1E[30'd]
 27B  2D00D                       OUTPUT s0, 0D[Tone]
 27C  2035C                       CALL 35C[delay_100ms]
 27D  01028                       LOAD s0, 28[40'd]
 27E  2D00D                       OUTPUT s0, 0D[Tone]
 27F  2035C                       CALL 35C[delay_100ms]
 280  11501                       ADD s5, 01
 281  1D504                       COMPARE s5, 04                       ; Do this 4 times
 282  36278                       JUMP NZ, 278[Warbleloop]
 283  01000                       LOAD s0, 00
 284  2D00D                       OUTPUT s0, 0D[Tone]                  ; and send value to SSB modulatorto reset to normal frequency
 285  01052                       LOAD s0, 52[82'd]                    ; Un Block DSPpico 0x52
 286  2D000                       OUTPUT s0, 00[CMD2DSP]               ; send R to DSP (release)
 287  25000                       RETURN 
 288  200EA           BeaconBeep: CALL 0EA[TX]
 289  01700                       LOAD s7, 00
 28A  20277           Beaconloop: CALL 277[Warble]
 28B                              ; Keep checking fifo for a character to keep it clear!
 28B                              ;CALL      Check4CmdfromKP
 28B                              ;COMPARE      s6, "t" ; character_t
 28B                              ;JUMP      Z, cancelbeacon     ; Escape if is key pressed - changed this 2/5/13 to speed up beacon cancel
 28B  11701                       ADD s7, 01
 28C  1D703                       COMPARE s7, 03
 28D                              ;JUMP      NZ, Beaconloop      ; do warble 3 times
 28D  200C2                       CALL 0C2[RX]
 28E                              ;CALL      delay_1s
 28E                              ; Keep checking fifo for a character to keep it clear!
 28E                              ;CALL      Check4CmdfromKP
 28E                              ;COMPARE      s6, "t"  ; character_t
 28E                              ;JUMP      Z, cancelbeacon     ; Escape if is key pressed
 28E                              ;CALL      delay_1s
 28E                              ; Keep checking fifo for a character to keep it clear!
 28E                              ;CALL      Check4CmdfromKP
 28E                              ;COMPARE      s6, "t"  ; character_t
 28E                              ;JUMP      Z, cancelbeacon     ; Escape if is key pressed
 28E                              ; 6/7/12 reduced receive period to 2s
 28E  25000                       RETURN 
 28F  0B012         cancelbeacon: FETCH s0, 12[Mode]
 290  030FE                       AND s0, FE[254'd]                    ; cancel beaon mode
 291  2F012                       STORE s0, 12[Mode]                   ; Hah - had forgotton to update the mode! 20/5/13
 292  25000                       RETURN 
 293                              ; ;;Pete
 293                              ; ;;Pete
 293                              ; ;;Pete
 293                              ;HandleBTCommand:
 293                              ; ;;LOAD      s6, 'A'             ; get character
 293                              ; ;;CALL      Send2UartTX         ; and echo back to terminal
 293                              ;                    AND       s0, 7F             ; mask off top bit
 293                              ; need to interpret commands from BT Here
 293                              ;                    COMPARE      s0, TRANSMIT_ON
 293                              ;                    JUMP      Z, FromBT_XMIT      ; Bluetooth Headset transmit
 293                              ;                    COMPARE      s0, TRANSMIT_OFF
 293                              ;                    JUMP      Z, FromBT_RECEIVE   ; Bluetooth Headset stop transmit
 293         SendTurnOffToKeypad: 
 293  20249                       CALL 249[TurnOffWarble]              ; audio turn off to other end
 294                              ; only works if switching off through keypad
 294                SendToKeypad: 
 294  0102A                       LOAD s0, 2A["*"]
 295  2D015                       OUTPUT s0, 15[CMD2KP]                ; trigger message to keypad
 296  2D615                       OUTPUT s6, 15[CMD2KP]                ; send turn off
 297  25000                       RETURN 
 298                              ; ;;COMPARE      s0, FLASH_WRITE
 298                              ; ;;JUMP      Z, FromBT_WRITE     ; PC has sent a WRITE to Flash request
 298                              ; ;;COMPARE      s0, FLASH_WRITE_PAGE
 298                              ; ;;JUMP      Z, FromBT_WRITE_PAGE; PC has sent a WRITE PAGE to Flash request
 298                              ; ;;COMPARE      s0, FLASH_ERASE
 298                              ; ;;JUMP      Z, FromBT_ERASE     ; PC has sent a Erase the Write message
 298                              ; ;;COMPARE      s0, FLASH_READ
 298                              ; ;;JUMP      Z, FromBT_READ      ; PC has sent a Read request
 298                              ; ;;COMPARE      s0, FLASH_READ_PAGE
 298                              ; ;;JUMP      Z, FromBT_READ_PAGE ; PC has sent a Read Page request
 298                              ; ;;COMPARE      s0, FLASH_WRITE_TEXT
 298                              ; ;;JUMP      Z, FromBT_WRITE_TEXT; PC has sent a WRITE TEXT to Flash request
 298                              ; LOAD      s0, 2F             ; send message back
 298                              ; OUTPUT       s0, CMD2BT          ; send Go to BT
 298                              ; CALL      SendCharToBT
 298                              ;                    JUMP      HandleBTCommand_Done
 298                              ;FromBT_XMIT:
 298                              ;                    CALL      SendCRLF
 298                              ;                    LOAD      s6, "T"
 298                              ;                    CALL      Send2UartTX         ; and echo back to terminal. Message mode
 298                              ;                    LOAD      s6, "x"
 298                              ;                    CALL      Send2UartTX         ; and echo back to terminal. Message mode
 298                              ;                    CALL      setTXmode
 298                              ;                    CALL      SendCRLF
 298                              ;                    LOAD      s0, 01
 298                              ;                    STORE     s0, BluetoothXmit
 298                              ;                    JUMP      HandleBTCommand_Done
 298                              ;FromBT_RECEIVE:
 298                              ;                    CALL      SendCRLF
 298                              ;                    LOAD      s6, "R"
 298                              ;                    CALL      Send2UartTX         ; and echo back to terminal. Message mode
 298                              ;                    LOAD      s6, "c"
 298                              ;                    CALL      Send2UartTX         ; and echo back to terminal. Message mode
 298                              ;                    CALL      setRXmode
 298                              ;                    CALL      SendCRLF
 298                              ;                    LOAD      s0, 00
 298                              ;                    STORE     s0, BluetoothXmit
 298                              ;                    JUMP      HandleBTCommand_Done
 298                              ; ;; end Pete
 298                              ; ;; end Pete
 298                              ; ;; end Pete
 298  016FF          getUARTchar: LOAD s6, FF                          ; Return FF if no character
 299  20337                       CALL 337[CheckUartRx]
 29A  35000                       RETURN NZ                            ; Return if no character with s6=$FF
 29B  09600                       INPUT s6, 00[Uart_rx]                ; get character
 29C  0367F                       AND s6, 7F
 29D                              ; CALL      Send2UartTX         ; and echo back to terminal. - SHOULD USE Send2UartTX (not in message mode)
 29D  25000                       RETURN 
 29E                              ; returns fifo character in s6 assuming present
 29E  202C5     sendDSP2Terminal: CALL 2C5[GetDSPFifoChar]
 29F  01600                       LOAD s6, 00                          ; get character
 2A0  0367F                       AND s6, 7F                           ; top bit is for empty fifo flag!
 2A1                              ;Send to keypad pico (LCD) instead
 2A1                              ;                    CALL      Send2UartTX         ; and echo back to terminal.
 2A1  2D615                       OUTPUT s6, 15[CMD2KP]                ; send code 0-7F (normally ascii, but $7F would tell it to expect a value to display at a particular place)
 2A2  25000                       RETURN 
 2A3                              ; returns BT fifo character in s6 assuming present
 2A3  202CB      sendBT2Terminal: CALL 2CB[GetBTFifoChar]
 2A4  00600                       LOAD s6, s0                          ; get character
 2A5  0367F                       AND s6, 7F
 2A6  2033B                       CALL 33B[Send2UartTX]                ; and echo back to terminal.
 2A7  25000                       RETURN 
 2A8                              ; returns KP fifo character in s6 assuming present
 2A8  202D1      sendKP2Terminal: CALL 2D1[GetKPFifoChar]
 2A9  00600                       LOAD s6, s0                          ; get character
 2AA  0367F                       AND s6, 7F
 2AB  2033B                       CALL 33B[Send2UartTX]                ; and echo back to terminal.
 2AC  25000                       RETURN 
 2AD                              ; returns KP fifo character in s6 assuming present
 2AD  202D7      sendTD2Terminal: CALL 2D7[GetTDFifoChar]
 2AE  00600                       LOAD s6, s0                          ; get character
 2AF  0367F                       AND s6, 7F
 2B0  2033B                       CALL 33B[Send2UartTX]                ; and echo back to terminal.
 2B1  25000                       RETURN 
 2B2                              ; checks for command from DSP pico, if present in s6 and echo to terminal - otherwise s6>127
 2B2  09104     Check4CmdfromDSP: INPUT s1, 04[DSPcmd]                 ; Get character from DSP picoblaze (if present should be less than 128)
 2B3  00610                       LOAD s6, s1
 2B4  1D180                       COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 2B5  3829E                       CALL C, 29E[sendDSP2Terminal]        ; If less than 128 there is a value to give back and display.
 2B6  25000                       RETURN 
 2B7                              ; checks for command from BTpico, if present in s6 and echo to terminal - otherwise s6>127
 2B7  09105      Check4CmdfromBT: INPUT s1, 05[BTcmd]                  ; Get character from BT picoblaze (if present should be less than 128)
 2B8  00610                       LOAD s6, s1
 2B9  1D180                       COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 2BA                              ;CALL      C, sendBT2Terminal  ; If less than 128 there is a value to give back and display.
 2BA  25000                       RETURN 
 2BB                              ; checks for command from KPpico, if present in s6  - otherwise s6>127
 2BB  09106      Check4CmdfromKP: INPUT s1, 06[KPcmd]                  ; Get character from BT picoblaze (if present should be less than 128)
 2BC  00610                       LOAD s6, s1
 2BD  1D180                       COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 2BE  382D1                       CALL C, 2D1[GetKPFifoChar]
 2BF  25000                       RETURN 
 2C0                              ; checks for command from TDpico, if present in s6  - otherwise s6>127
 2C0  09107      Check4CmdfromTD: INPUT s1, 07[TDcmd]                  ; Get character from BT picoblaze (if present should be less than 128)
 2C1  00610                       LOAD s6, s1
 2C2  1D180                       COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 2C3  382D7                       CALL C, 2D7[GetTDFifoChar]
 2C4  25000                       RETURN 
 2C5                              ; Routine to recover a byte, (character?) from the FIFO in s0
 2C5  01010       GetDSPFifoChar: LOAD s0, 10[DSPFifo]
 2C6  2D00E                       OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 2C7  01010                       LOAD s0, 10[DSPFifo]                 ; dummy, wait a bit longer for character to present itself
 2C8  09004                       INPUT s0, 04[DSPcmd]                 ; now get my character
 2C9  0307F                       AND s0, 7F                           ; mask off top bit
 2CA  25000                       RETURN 
 2CB                              ; Routine to recover a character from the BTFIFO in s0
 2CB  01020        GetBTFifoChar: LOAD s0, 20[BTFifo]
 2CC  2D00E                       OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 2CD  01020                       LOAD s0, 20[BTFifo]                  ; dummy, wait a bit longer for character to present itself
 2CE  09005                       INPUT s0, 05[BTcmd]                  ; now get my character
 2CF  0307F                       AND s0, 7F                           ; mask off top bit
 2D0  25000                       RETURN 
 2D1                              ; Routine to recover a character from the KPFIFO in s6
 2D1  01040        GetKPFifoChar: LOAD s0, 40[KPFifo]
 2D2  2D00E                       OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 2D3  01040                       LOAD s0, 40[KPFifo]                  ; dummy, wait a bit longer for character to present itself
 2D4  09606                       INPUT s6, 06[KPcmd]                  ; now get my character
 2D5  0367F                       AND s6, 7F                           ; mask off top bit
 2D6  25000                       RETURN 
 2D7                              ; Routine to recover a character from the TDFIFO in s6
 2D7  01080        GetTDFifoChar: LOAD s0, 80[TDFifo]
 2D8  2D00E                       OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 2D9  01040                       LOAD s0, 40[KPFifo]                  ; dummy, wait a bit longer for character to present itself
 2DA  09607                       INPUT s6, 07[TDcmd]                  ; now get my character
 2DB  0367F                       AND s6, 7F                           ; mask off top bit
 2DC  25000                       RETURN 
 2DD                              ; sayOK:              CALL      SendCRLF
 2DD                              ; LOAD      s6, 79
 2DD                              ; CALL      Send2UartTX
 2DD                              ; LOAD      s6, 75
 2DD                              ; CALL      Send2UartTX
 2DD                              ; CALL      SendCRLF
 2DD                              ; RETURN
 2DD                              ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 2DD  00860           Chars2Byte: LOAD s8, s6
 2DE  202E8                       CALL 2E8[Get4bits]
 2DF  00580                       LOAD s5, s8
 2E0  14506                       SL0 s5
 2E1  14506                       SL0 s5
 2E2  14506                       SL0 s5
 2E3  14506                       SL0 s5                               ; put these 4 bits to MSBs
 2E4  00870                       LOAD s8, s7
 2E5  202E8                       CALL 2E8[Get4bits]
 2E6  10580                       ADD s5, s8
 2E7  25000                       RETURN 
 2E8                              ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 2E8  1D83C             Get4bits: COMPARE s8, 3C[60'd]                 ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 2E9  3A2ED                       JUMP C, 2ED[char0_9]
 2EA  19837                       SUB s8, 37[55'd]                     ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 2EB  0380F                       AND s8, 0F                           ; make sure only return 4 bits
 2EC  25000                       RETURN 
 2ED  19830              char0_9: SUB s8, 30[48'd]
 2EE  0380F                       AND s8, 0F                           ; make sure only return 4 bits
 2EF  25000                       RETURN 
 2F0                              ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 2F0  00850           Byte2Chars: LOAD s8, s5                          ; assumes 8 bit data is in s5
 2F1  1450E                       SR0 s5
 2F2  1450E                       SR0 s5
 2F3  1450E                       SR0 s5
 2F4  1450E                       SR0 s5                               ; get first hex character
 2F5  202FC                       CALL 2FC[GetChar]
 2F6  00650                       LOAD s6, s5                          ; first ascii char
 2F7  00580                       LOAD s5, s8
 2F8  0350F                       AND s5, 0F
 2F9  202FC                       CALL 2FC[GetChar]                    ;
 2FA  00750                       LOAD s7, s5                          ; second ascii char
 2FB  25000                       RETURN 
 2FC                              ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 2FC  1950A              GetChar: SUB s5, 0A[10'd]                     ; Test if s5 greater than 9
 2FD  3A300                       JUMP C, 300[is_0_9]                  ; Hex character is 0_9
 2FE  11541                       ADD s5, 41[65'd]                     ; offset for Ascii code 'A'
 2FF  25000                       RETURN 
 300  1150A               is_0_9: ADD s5, 0A[10'd]                     ; return to range 0-9
 301  11530                       ADD s5, 30[48'd]                     ; offset to Ascii code for '0'
 302  25000                       RETURN 
 303                              ; To send to Uart, simply use: OUTPUT       s3, UART_TX         ; Sends value in s3 to Uart Tx
 303                              ; Dump archive RAM to RS232 port as 4 Ascii codes per data value followed by carriage return and line feed.
 303  20322          SendArchive: CALL 322[DisableArchive]             ; Stop archiving
 304  01000                       LOAD s0, 00
 305  01100                       LOAD s1, 00
 306  0B410            SendAloop: FETCH s4, 10[Latch7]
 307  034FC                       AND s4, FC[252'd]                    ; set top 2 address bits to zero
 308  2D006                       OUTPUT s0, 06[ProgramL]
 309  04410                       OR s4, s1                            ; patch in top 2 address bits
 30A  2D407                       OUTPUT s4, 07[ProgramM]              ; and send to the output port
 30B  09503                       INPUT s5, 03[ArchiveDataMSB]
 30C  20341                       CALL 341[Byte2UART]
 30D  09502                       INPUT s5, 02[ArchiveDataLSB]         ; grab bottom byte
 30E  20341                       CALL 341[Byte2UART]
 30F  11001                       ADD s0, 01
 310  13100                       ADDCY s1, 00
 311  20346                       CALL 346[SendCRLF]
 312  1D104                       COMPARE s1, 04
 313  36306                       JUMP NZ, 306[SendAloop]
 314  2031D                       CALL 31D[EnableArchive]              ; Restart archiving
 315  25000                       RETURN 
 316                              ; Select Archiving source, if s1 is 0 then raw 16bit ADC data is archived, or if s1=1 then 16bit data from the DSP picoblaze (DATA2Archve) is archived at 6kHz
 316  03103        ArchiveSource: AND s1, 03
 317  0B014                       FETCH s0, 14[SelectScratch]          ; get current value of selections
 318  030FC                       AND s0, FC[252'd]                    ; first reset first 2 bits
 319  04010                       OR s0, s1                            ; affect bits 0-1
 31A  2D008                       OUTPUT s0, 08[SelectArchiveSource]   ; update archive control port
 31B  2F014                       STORE s0, 14[SelectScratch]          ; Update scratchpad
 31C                              ;      LOAD   s5,s0
 31C                              ;      CALL   Byte2Chars
 31C  25000                       RETURN 
 31D                              ; Enable Archiving
 31D  0B010        EnableArchive: FETCH s0, 10[Latch7]                 ; get current value of control port
 31E  05040                       OR s0, 40[EnArchive]                 ; set bit 5
 31F  2D007                       OUTPUT s0, 07[ProgramM]
 320  2F010                       STORE s0, 10[Latch7]                 ; get current value of control port
 321  25000                       RETURN 
 322                              ; Disable Archiving
 322  00600       DisableArchive: LOAD s6, s0
 323  2036B                       CALL 36B[delay_50us]                 ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324                              ; CALL      delay_1ms           ; wait for a bit more archiving first!
 324  20361                       CALL 361[delay_1ms]                  ; wait for a bit more archiving first!
 325  0B010                       FETCH s0, 10[Latch7]                 ; get current value of control port
 326  030BF                       AND s0, BF[~EnArchive]               ; reset bit 5
 327  2D007                       OUTPUT s0, 07[ProgramM]
 328  2F010                       STORE s0, 10[Latch7]                 ; get current value of control port
 329  00060                       LOAD s0, s6                          ; restore s0 value
 32A  25000                       RETURN 
 32B                              ; Character parsing:
 32B                              ; returns next command character in s0
 32B  0A090   getnextscratchchar: FETCH s0, (s9)
 32C  11901                       ADD s9, 01                           ; increment pointer
 32D  00600                       LOAD s6, s0
 32E  2033B                       CALL 33B[Send2UartTX]                ; and echo back to terminal. Message mode
 32F  25000                       RETURN 
 330                              ; Reads 2 ascii codes and returns the byte represented in hex as binary value in s5
 330  2032B         getnextvalue: CALL 32B[getnextscratchchar]
 331  00400                       LOAD s4, s0
 332  2032B                       CALL 32B[getnextscratchchar]
 333  00700                       LOAD s7, s0
 334  00640                       LOAD s6, s4
 335  202DD                       CALL 2DD[Chars2Byte]                 ; return byte in s5
 336  25000                       RETURN 
 337                              ; UART control
 337  09001          CheckUartRx: INPUT s0, 01[Uart_status]            ; Check if there is RX data
 338  03001                       AND s0, 01
 339  1D001                       COMPARE s0, 01
 33A  25000                       RETURN 
 33B                              ; send character in s6 to Uart - also uses s8!
 33B  09801          Send2UartTX: INPUT s8, 01[Uart_status]            ; Check if TX buffer is full
 33C  03802                       AND s8, 02
 33D  1D802                       COMPARE s8, 02                       ; if 2 then wait
 33E  3233B                       JUMP Z, 33B[Send2UartTX]
 33F  2D601                       OUTPUT s6, 01[UART_TX]
 340  25000                       RETURN 
 341                              ; Convert byte in s5 into 2 ascii codes in hexadecimal and send to the serial port.
 341  202F0            Byte2UART: CALL 2F0[Byte2Chars]
 342  2033B                       CALL 33B[Send2UartTX]
 343  00670                       LOAD s6, s7
 344  2033B                       CALL 33B[Send2UartTX]
 345  25000                       RETURN 
 346  0160D             SendCRLF: LOAD s6, 0D
 347  2033B                       CALL 33B[Send2UartTX]
 348  0160A                       LOAD s6, 0A
 349  2033B                       CALL 33B[Send2UartTX]
 34A  25000                       RETURN 
 34B  01620            SendSPACE: LOAD s6, 20
 34C  2033B                       CALL 33B[Send2UartTX]
 34D  25000                       RETURN 
 34E                              CONSTANT count_1000_lsb, E8          ; lower 8-bits of 1000 count value
 34E                              CONSTANT count_1000_msb, 03          ; upper 8-bits of 1000 count value
 34E                              ; Registers used s0, s1, s2, s3, s4 and s5.
 34E                              ;
 34E  01500             delay_1s: LOAD s5, 00                          ; clear cycle counter
 34F  01400                       LOAD s4, 00
 350  20361              wait_1s: CALL 361[delay_1ms]
 351  11401                       ADD s4, 01                           ; increment cycle counter
 352  13500                       ADDCY s5, 00
 353  1D4E8                       COMPARE s4, E8[count_1000_lsb]       ; test for 1000ms
 354  36350                       JUMP NZ, 350[wait_1s]
 355  1D503                       COMPARE s5, 03[count_1000_msb]
 356  36350                       JUMP NZ, 350[wait_1s]
 357  25000                       RETURN 
 358                              ;
 358                              ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 358                              ;
 358                              ;
 358                              ; Registers used s0, s1, s2, s3 and s4.
 358                              ;
 358  2035C          delay_300ms: CALL 35C[delay_100ms]
 359  2035C          delay_200ms: CALL 35C[delay_100ms]
 35A  2035C                       CALL 35C[delay_100ms]
 35B  25000                       RETURN 
 35C                              ;
 35C                              ; Delay of approximately 100ms used for switch debounce
 35C                              ;
 35C                              ; Registers used s0, s1, s2, s3 and s4.
 35C                              ;
 35C  01464          delay_100ms: LOAD s4, 64                          ; repeat 1ms delay 100 times
 35D  20361           wait_100ms: CALL 361[delay_1ms]
 35E  19401                       SUB s4, 01
 35F  3635D                       JUMP NZ, 35D[wait_100ms]
 360  25000                       RETURN 
 361                              ;
 361                              ; Registers used s0, s1, s2 and s3.
 361                              ;
 361  01300            delay_1ms: LOAD s3, 00                          ; clear cycle counter
 362  01200                       LOAD s2, 00
 363  20370             wait_1ms: CALL 370[delay_1us]
 364  11201                       ADD s2, 01                           ; increment cycle counter
 365  13300                       ADDCY s3, 00
 366  1D2E8                       COMPARE s2, E8[count_1000_lsb]       ; test for 1000us
 367  36363                       JUMP NZ, 363[wait_1ms]
 368  1D303                       COMPARE s3, 03[count_1000_msb]
 369  36363                       JUMP NZ, 363[wait_1ms]
 36A  25000                       RETURN 
 36B                              ;
 36B                              ; Delay of approximately 50us required by LCD display
 36B                              ;
 36B                              ; Registers used s0 and s1.
 36B                              ;
 36B  01132           delay_50us: LOAD s1, 32[50'd]                    ; repeat 1us delay 50 times
 36C  20370            wait_50us: CALL 370[delay_1us]
 36D  19101                       SUB s1, 01
 36E  3636C                       JUMP NZ, 36C[wait_50us]
 36F  25000                       RETURN 
 370                              ; Delay of approximately 1us used to provide timing reference for
 370                              ; LCD operations. This must be adjusted to reflect the clock
 370                              ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 370                              ;
 370                              ; The software delay loop is formed using register s0. This register
 370                              ; must be loaded with an integer value close to the result of....
 370                              ;
 370                              ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 370                              ;
 370                              ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 370                              ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 370                              ; operation will become lower than the 100KHz target intended.
 370                              ;
 370                              ; Register used s0.
 370                              ;
 370  0100C            delay_1us: LOAD s0, 0C[delay_1us_constant]      ; delay value of 12 decimal for a 50MHz clock
 371  19001             wait_1us: SUB s0, 01
 372  36371                       JUMP NZ, 371[wait_1us]
 373  25000                       RETURN 
 374                              ;
 374                              ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\home\gnaylor\Dropbox\N3SysGen\UserPico.psm



List of defined constants

 CONSTANT name        Value        Source PSM File

 timestamp_hours      10'd         
 timestamp_minutes    33'd         
 timestamp_seconds    08'd         
 datestamp_year       17'd         
 datestamp_month      5'd          
 datestamp_day        14'd         
 NUL                  00           
 BEL                  07           
 BS                   08           
 HT                   09           
 LF                   0A           
 VT                   0B           
 CR                   0D           
 ESC                  1B           
 DEL                  7F           
 DCS                  90           
 ST                   9C           
 Versionno            10'd         UserPico.psm
 InitialVolume        133'd        UserPico.psm
 MinoxrVersionno      EE           UserPico.psm
 Bmode                00           UserPico.psm
 AGCupperRX           32           UserPico.psm
 AGClowerRX           12           UserPico.psm
 AGCupperTX           40           UserPico.psm
 AGClowerTX           18           UserPico.psm
 delay_1us_constant   12'd         UserPico.psm
 WREN                 06           UserPico.psm
 FAST_READ            0B           UserPico.psm
 BERASE               C7           UserPico.psm
 SER                  D8           UserPico.psm
 RDID                 9F           UserPico.psm
 PP                   02           UserPico.psm
 RDSR                 05           UserPico.psm
 Latch7               16'd         UserPico.psm
 LastDSPbyte          17'd         UserPico.psm
 Mode                 18'd         UserPico.psm
 ADCstate             19'd         UserPico.psm
 SelectScratch        20'd         UserPico.psm
 ADCLevel             21'd         UserPico.psm
 ADCgain              22'd         UserPico.psm
 TX_F_MSB             23'd         UserPico.psm
 TX_F_LSB             24'd         UserPico.psm
 ADCAGCUpperThreshold 25'd         UserPico.psm
 ADCAGCLowerThreshold 26'd         UserPico.psm
 ADCGainTX            27'd         UserPico.psm
 ADCGainRX            28'd         UserPico.psm
 peteTXMode           40'd         UserPico.psm
 Uart_rx              00           UserPico.psm
 Uart_status          01           UserPico.psm
 BattMon              4'd          UserPico.psm
 ArchiveDataLSB       2'd          UserPico.psm
 ArchiveDataMSB       3'd          UserPico.psm
 DSPcmd               4'd          UserPico.psm
 BTcmd                5'd          UserPico.psm
 KPcmd                6'd          UserPico.psm
 TDcmd                7'd          UserPico.psm
 DSPRAMrdbkMSB        9'd          UserPico.psm
 DSPRAMrdbkLSB        10'd         UserPico.psm
 BTRAMrdbkMSB         11'd         UserPico.psm
 BTRAMrdbkLSB         12'd         UserPico.psm
 KPRAMrdbkMSB         13'd         UserPico.psm
 KPRAMrdbkLSB         14'd         UserPico.psm
 ADCSignalLevel       15'd         UserPico.psm
 CMD2DSP              00           UserPico.psm
 UART_TX              01           UserPico.psm
 GainPD               02           UserPico.psm
 Instructiona         03           UserPico.psm
 Instructionb         04           UserPico.psm
 Instructionc         05           UserPico.psm
 ProgramL             06           UserPico.psm
 ProgramM             07           UserPico.psm
 EnArchive            64'd         UserPico.psm
 TX_HIGH              128'd        UserPico.psm
 SelectArchiveSource  8'd          UserPico.psm
 Configure            9'd          UserPico.psm
 RXFreqMSB            10'd         UserPico.psm
 RXFreqLSB            11'd         UserPico.psm
 AudioVolume          12'd         UserPico.psm
 Tone                 13'd         UserPico.psm
 Acknowledge          14'd         UserPico.psm
 DSPFifo              16'd         UserPico.psm
 BTFifo               32'd         UserPico.psm
 KPFifo               64'd         UserPico.psm
 TDFifo               128'd        UserPico.psm
 FlashData            17'd         UserPico.psm
 ADCstate_port        19'd         UserPico.psm
 LoranBlank           16'd         UserPico.psm
 AudioOutSelect       32'd         UserPico.psm
 AnalogueChannel      64'd         UserPico.psm
 CMD2BT               20'd         UserPico.psm
 CMD2KP               21'd         UserPico.psm
 RAMDataMSB           22'd         UserPico.psm
 RAMDataLSB           23'd         UserPico.psm
 RAMwriteControl      25'd         UserPico.psm
 TRANSMIT_ON          14           UserPico.psm
 TRANSMIT_OFF         15           UserPico.psm
 count_1000_lsb       E8           UserPico.psm
 count_1000_msb       03           UserPico.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "14 May 2017"  
 timestamp$        "10:33:08"     



List of line labels

   Label                 Addr  Source PSM File

 * boot                  000   UserPico.psm
 * start                 001   UserPico.psm
   reboot                001   UserPico.psm
   DoUserProg            007   UserPico.psm
   GetProg               00A   UserPico.psm
   GetByte               01B   UserPico.psm
   cold_start            021   UserPico.psm
   ProgDSP               022   UserPico.psm
   ScratchClear          023   UserPico.psm
   init                  028   UserPico.psm
   startLoop             03F   UserPico.psm
   loop                  040   UserPico.psm
   SendADCToARM          05D   UserPico.psm
   CheckADClevel         06B   UserPico.psm
   nofive                07A   UserPico.psm
   First                 07D   UserPico.psm
   Second                080   UserPico.psm
   Third                 083   UserPico.psm
   Fourth                086   UserPico.psm
   Fifth                 089   UserPico.psm
   ToLCD                 08D   UserPico.psm
 * Tempskip              08D   UserPico.psm
   ReduceADCgain         095   UserPico.psm
   IncreaseADCgain       09E   UserPico.psm
   checkrqst             0A7   UserPico.psm
   SendToARM             0AA   UserPico.psm
   waitForKey            0AB   UserPico.psm
 * setEarthAntennas      0B1   UserPico.psm
 * setLoopAntennas       0B6   UserPico.psm
 * checkRXmode           0BB   UserPico.psm
   RX                    0C2   UserPico.psm
 * checkTXmode           0C9   UserPico.psm
   setTXmode             0D0   UserPico.psm
   TX                    0EA   UserPico.psm
   setRXmode             0F1   UserPico.psm
   SetAnGain             10A   UserPico.psm
   interpcommand         115   UserPico.psm
 * interploop            116   UserPico.psm
   MsgFromARM            123   UserPico.psm
   isS                   134   UserPico.psm
   isG                   146   UserPico.psm
   isSA                  158   UserPico.psm
   isSB                  162   UserPico.psm
   isSK                  169   UserPico.psm
   isSL                  16D   UserPico.psm
   setLoranBlank         172   UserPico.psm
   isSKS                 178   UserPico.psm
 * isSS                  179   UserPico.psm
   isSU                  183   UserPico.psm
   isSW                  188   UserPico.psm
   isSSloop              196   UserPico.psm
   nowsend2flashback     19E   UserPico.psm
 * nowsend2flash         1A6   UserPico.psm
   isSR                  1A8   UserPico.psm
   isST                  1AE   UserPico.psm
   isSAS                 1B2   UserPico.psm
   isSAG                 1B6   UserPico.psm
   isSAI                 1BD   UserPico.psm
   setADC                1C2   UserPico.psm
   isSAO                 1C8   UserPico.psm
   setAudioOut           1CD   UserPico.psm
   isSRF                 1D3   UserPico.psm
   isSRM                 1D8   UserPico.psm
   isSTM                 1DA   UserPico.psm
   isGG                  1DC   UserPico.psm
   isGS                  1E5   UserPico.psm
   isGB                  1EE   UserPico.psm
   isGC                  1F6   UserPico.psm
   isGK                  1F9   UserPico.psm
   isGL                  1FF   UserPico.psm
   isGKT                 20B   UserPico.psm
   isGKV                 214   UserPico.psm
   isGA                  21D   UserPico.psm
   isGV                  21F   UserPico.psm
   Twotone               223   UserPico.psm
   Confidence            230   UserPico.psm
 * Confidenceloop        232   UserPico.psm
   TurnOffWarble         249   UserPico.psm
 * TurnOffWarbleloop     24B   UserPico.psm
   Warble                277   UserPico.psm
   Warbleloop            278   UserPico.psm
   BeaconBeep            288   UserPico.psm
 * Beaconloop            28A   UserPico.psm
 * cancelbeacon          28F   UserPico.psm
   SendTurnOffToKeypad   293   UserPico.psm
   SendToKeypad          294   UserPico.psm
   getUARTchar           298   UserPico.psm
   sendDSP2Terminal      29E   UserPico.psm
 * sendBT2Terminal       2A3   UserPico.psm
 * sendKP2Terminal       2A8   UserPico.psm
 * sendTD2Terminal       2AD   UserPico.psm
   Check4CmdfromDSP      2B2   UserPico.psm
   Check4CmdfromBT       2B7   UserPico.psm
   Check4CmdfromKP       2BB   UserPico.psm
   Check4CmdfromTD       2C0   UserPico.psm
   GetDSPFifoChar        2C5   UserPico.psm
   GetBTFifoChar         2CB   UserPico.psm
   GetKPFifoChar         2D1   UserPico.psm
   GetTDFifoChar         2D7   UserPico.psm
   Chars2Byte            2DD   UserPico.psm
   Get4bits              2E8   UserPico.psm
   char0_9               2ED   UserPico.psm
   Byte2Chars            2F0   UserPico.psm
   GetChar               2FC   UserPico.psm
   is_0_9                300   UserPico.psm
   SendArchive           303   UserPico.psm
   SendAloop             306   UserPico.psm
   ArchiveSource         316   UserPico.psm
   EnableArchive         31D   UserPico.psm
   DisableArchive        322   UserPico.psm
   getnextscratchchar    32B   UserPico.psm
   getnextvalue          330   UserPico.psm
   CheckUartRx           337   UserPico.psm
   Send2UartTX           33B   UserPico.psm
   Byte2UART             341   UserPico.psm
   SendCRLF              346   UserPico.psm
 * SendSPACE             34B   UserPico.psm
 * delay_1s              34E   UserPico.psm
   wait_1s               350   UserPico.psm
 * delay_300ms           358   UserPico.psm
 * delay_200ms           359   UserPico.psm
   delay_100ms           35C   UserPico.psm
   wait_100ms            35D   UserPico.psm
   delay_1ms             361   UserPico.psm
   wait_1ms              363   UserPico.psm
   delay_50us            36B   UserPico.psm
   wait_50us             36C   UserPico.psm
   delay_1us             370   UserPico.psm
   wait_1us              371   UserPico.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            150
 STAR              -

 AND              41
 OR               16
 XOR               -

 ADD              20
 ADDCY             4
 SUB               9
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          82
 COMPARECY         -

 SL0               6
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               5
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT            19
 OUTPUT           85
 OUTPUTK           -

 STORE            37
 FETCH            37

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP            101
 JUMP@             -
 CALL            204
 CALL@             -
 RETURN           66
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
