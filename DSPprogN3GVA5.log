KCPSM6 Assembler log file for program 'C:\Users\gnaylor\Dropbox\N3workingG\TE0722Rebuild\DSPprogN3GVA5.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 13 Dec 2015
Assembly timestamp: 17:41:44

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 355 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 854
Memory locations available: 3242


Assembly listing

 Addr Code                           Instruction

 000                                 ;GVA5 for TE0722, with RX/TX frequencies adjusted for 32.768MHz (mod in Keypad assembler)
 000                                 ;GVA4 correct bad setting of AvesignalMSB instead of USB (caused crashing)
 000                                 ;GVA2 BT input from mic is taken externally in logic - also removed audio double so as not to saturate voice on transmission (but will drop volume on handset ~6dB)
 000                                 ;AND over haul AGC to use 24 bit average level registering so level is monitored with AveSignalUSB
 000                                 ;GVA1 Try to implement tone detect parts
 000                                 ;GVA0 Project to get AGC to act on external MUX, but still use last 4 bits for decrease 3dB and 1.5dB in the Pico
 000                                 ;GV9B to do - mods to detect start and end tones
 000                                 ;GV96 readjust AGC settings and bit offsets
 000                                 ;GV93add back divide by 2 on transmit line 567
 000                                 ; GV51 remove level divide by 2 on transmit to compensate for drop in AGC level (so only reduces level for receive)
 000                                 ;GV50, drop DSP AGC levels back to just below as in GV45
 000                                 ;GV47 increase DSP AGC thresholds
 000                                 ;GV46 added further double on RF out amplitude
 000                                 ;GV45 Corrected resetting of AveSignalMSB to middle value so as to avoid double jump and increased allowable rang to avoid unnecessary jumps (abd corrected AGC wrapping in GV44 when limiting if greater than 44 rather than to 44 ie CALL Z not CALL NC !!!)
 000                                 ;GV44 add 1_5dB decrease - still need to correct AGC range (increase another factor 2) and decrease limits
 000                                 ;GV43 correct beacon phase wander
 000                                 ;GV42 disable UART streaming
 000                                 ;GV3F Add streaming over UART on TX (State bit 2 set)
 000                                 ;GV3E try adding small sine wave - not yet implemented
 000                                 ;For GV3D, need to add further routines, increaseAGC2 and increaseAGC4 that increase attenuation 6dB and 12dB respectively (within limits) - look at how AveSignalMSB is reset.
 000                                 ;For GV3B try to correct incorrect AGC operation with twice as many values
 000                                 ;store TX AGCvalue before warble (or when stable) and add 3dB steps to AGCvalue
 000                                 ;31/1/13 Added 12dB to BT mic level using Audiodouble
 000                                 ;GV38 Use audio double on transmitpath
 000                                 ;For GV37 Adjusted AGC thresholds and increased time constant a factor 8.
 000                                 ;31/12/12 increase volume and transmitted power by increasing AGC setting a factor of 2 (from 4,12 to 8,24 - AGCupp/lowthreshold). Also set AGCvalue to 06 INITIALY (may need to be adjusted) recall last AGCvalue when switch mode. Line 439 increase TX modulation.
 000                                 ;removed LPF
 000                                 ;Increased AGC setting -36 OK, 72 too high (bad clipping noise)
 000                                 ;Slow saturation of SSBamp
 000                                 ;Added BT signal not present flag (16/1/12)
 000                                 ;Try to fix failure to un-block DSP problem (18/11/11 in DSPblock routine)
 000                                 ;Uses phase representation of TX audio - works in study OK 18/11/11
 000                                 ;29/8/11 Increased audio frequency resolution to 16 bits
 000                                 ;19/8/11, tweaked audio scaling of TX
 000                                 ;Modified vor BT input
 000                                 ;This needs to be modified for COTS version at 49.152MHz - in particular calibration of audio frequency output to SSB modulator has been modified see line 398
 000                                 ; Inputs sine wave as audio
 000                                 ; 20/7 updated input and output ports for multipico version
 000                                 ; Feb 09 Start testing AGC part of streamed signal
 000                                 ; Now implementing on SSBN.mdl
 000                                 ;
 000                                 ; DSP routine for SSB picoblaze
 000                                 ;
 000                                 ; Implemented commands:
 000                                 ; 0 = RX mode
 000                                 CONSTANT AGClowthreshold, 6'd                  ;;These are thresholds for the measured signal
 000                                 CONSTANT AGClowthreshold2, 3'd                 ;;These are thresholds for the measured signal
 000                                 CONSTANT AGCInitial, 8'd                       ;;This is mid way between thresholds
 000                                 CONSTANT AGCuppthreshold, 10'd
 000                                 CONSTANT AGCuppthreshold2, 15'd                ;3dB above first threshold
 000                                 CONSTANT AGCuppthreshold4, 22'd
 000                                 CONSTANT delay_1us_constant, 12'd              ; Value (13)19 or 12? decimal suitable for 50MHz clock – about 8 for 20MHz
 000                                 CONSTANT m, 8'd                                ; No. of iterations for cordic
 000                                 CONSTANT m_plus_1, 9'd                         ; No. of iterations for cordic
 000                                 CONSTANT count_1000_lsb, E8                    ; lower 8-bits of 1000 count value
 000                                 CONSTANT count_1000_msb, 03                    ; upper 8-bits of 1000 count value
 000                                 CONSTANT half_pi_LSB, 00                       ;
 000                                 CONSTANT half_pi_MSB, 40                       ; 360 degrees = $10000
 000                                 CONSTANT audioTest, 2'd                        ; Frequency 2=800Hz, 3=1200Hz, 4=1.6kHz 7=2.8kHz
 000                                 ;Frequency values for start and stop tones
 000                                 CONSTANT StrtToneAInc, 9F
 000                                 CONSTANT StrtToneBInc, 69
 000                                 CONSTANT StopToneAInc, 5A
 000                                 CONSTANT StopToneBInc, 78
 000                                 ; FIR coefficients for 0 and 90 degree filterred signals, these are SIGNED values!!
 000                                 CONSTANT coeffI0MSB, F6                        ; Smallest coefficient (negative value!)
 000                                 CONSTANT coeffI0LSB, 92
 000                                 CONSTANT coeffI1MSB, F4
 000                                 CONSTANT coeffI1LSB, 8A
 000                                 CONSTANT coeffI2MSB, F2
 000                                 CONSTANT coeffI2LSB, CC
 000                                 CONSTANT coeffI3MSB, F1
 000                                 CONSTANT coeffI3LSB, 77
 000                                 CONSTANT coeffI4MSB, F0
 000                                 CONSTANT coeffI4LSB, A1
 000                                 CONSTANT coeffI5MSB, 40                        ; Actualy half value of peak
 000                                 CONSTANT coeffI5LSB, 00
 000                                 ; Q values are still signed but are all positive
 000                                 CONSTANT coeffQ0MSB, 00                        ; Smallest coefficient
 000                                 CONSTANT coeffQ0LSB, A7
 000                                 CONSTANT coeffQ1MSB, 05
 000                                 CONSTANT coeffQ1LSB, 2D
 000                                 CONSTANT coeffQ2MSB, 0C
 000                                 CONSTANT coeffQ2LSB, 83
 000                                 CONSTANT coeffQ3MSB, 1B
 000                                 CONSTANT coeffQ3LSB, 4F
 000                                 CONSTANT coeffQ4MSB, 5C
 000                                 CONSTANT coeffQ4LSB, 2F
 000                                 ; Registers
 000                                 NAMEREG sF, AveSignalUSB                       ; In fact average of magnitude
 000                                 NAMEREG sE, AveSignalMSB
 000                                 NAMEREG sD, AveSignalLSB
 000                                 ;NAMEREG  sD, BaselineMSB                  ; In fact average of signed signal
 000                                 ;NAMEREG  sC, BaselineLSB
 000                                 NAMEREG sC, SineCtr                            ;Aargh sB is used by the Cordic!! - but not used now
 000                                 ; registers sA-sD are used for longish term storage...!
 000                                 ; sA used for cordic calcs and FIR work for relative pos of roving ptr
 000                                 ; Scratch pad
 000                                 ; registers 0-8 used for cordic table:
 000                                 ; reg 0=45degrees
 000                                 ; ..
 000                                 ; reg 7=0.44761degrees
 000                                 ; Input port
 000                                 CONSTANT AudioMSB, 0'd
 000                                 CONSTANT AudioLSB, 1'd
 000                                 CONSTANT Strobe, 2'd                           ;     bit0=6kHz square wave - the rest are now zeros
 000                                 CONSTANT Command, 3'd                          ; From interface pico
 000                                 CONSTANT MltplyMSB, 4'd                        ; Top significant byte of multiplier output
 000                                 CONSTANT MltplyLSB, 5'd                        ; (only 16 bits retained)
 000                                 CONSTANT BTaudioMSB, 6'd                       ; Input from headset micro
 000                                 CONSTANT BTaudioLSB, 7'd                       ;
 000                                 CONSTANT RAMdataMSB, 8'd                       ;Data from variable storage RAM
 000                                 CONSTANT RAMdataLSB, 9'd
 000                                 CONSTANT Status, 10'd                          ;bit 0 is DSP2user fifo full, bit 1 is no BT audio stream from headset microphone.
 000                                 ; Output ports
 000                                 CONSTANT MSBAudio, 0'd
 000                                 CONSTANT LSBAudio, 1'd
 000                                 CONSTANT SSBAmp, 2'd
 000                                 CONSTANT CmdToUser, 3'd
 000                                 CONSTANT CoeffMSB, 4'd
 000                                 CONSTANT CoeffLSB, 5'd
 000                                 CONSTANT SignalMSB, 6'd
 000                                 CONSTANT SignalLSB, 7'd
 000                                 CONSTANT Data2archiveMSB, 10'd
 000                                 CONSTANT Data2archiveLSB, 11'd
 000                                 CONSTANT Controlbits, 12'd                     ; BIT OFFSETS:
 000                                 ; Bit offsets:
 000                                 CONSTANT EnMult, 1'd
 000                                 CONSTANT AckFIFO, 32'd                         ;   5 Acknowledge FIFO (present character)
 000                                 CONSTANT PhaseIncrement, 13'd
 000                                 CONSTANT AudioFreqLSB, 14'd
 000                                 CONSTANT AudioPhaseMSB, 15'd
 000                                 CONSTANT AudioPhaseLSB, 16'd
 000                                 CONSTANT EnableSpeaker, 17'd
 000                                 CONSTANT MUXport, 18'd                         ;New port to drive AGC MUX
 000                                 CONSTANT StartToneA, 19'd
 000                                 CONSTANT StartToneALong, 20'd
 000                                 CONSTANT StartToneB, 21'd
 000                                 CONSTANT StartToneBLong, 22'd
 000                                 CONSTANT StopToneA, 23'd
 000                                 CONSTANT StopToneALong, 24'd
 000                                 CONSTANT StopToneB, 25'd
 000                                 CONSTANT StopToneBLong, 26'd
 000                                 ; Scratchpad registers
 000                                 ; 0-8 used for Cordic Table!
 000                                 CONSTANT AmpMSB, 10'd
 000                                 CONSTANT AmpLSB, 11'd                          ; Bit 0 toggles at 16kHz
 000                                 CONSTANT PhaseMSB, 12'd
 000                                 CONSTANT PhaseLSB, 13'd                        ; Is this necessary?
 000                                 CONSTANT AGCvalue, 14'd                        ; Two times number of bits to shift (250-11) ie -6 (FA -wk signal) to 11 (0B -Strong signal)
 000                                 CONSTANT VolSetting, 15'd
 000                                 CONSTANT OldPhaseMSB, 16'd
 000                                 CONSTANT AudioScratch, 17'd
 000                                 CONSTANT State, 18'd                           ; Bit 1 0=RX, 1=TX (TX_high), Bit 2 set is streaming TX data from UART
 000                                 ;CONSTANT NormalisedSignalMSB,   19'd                  ; Current signal MSB after AGC
 000                                 CONSTANT LVPtr, 20'd                           ; From HistoryStart to HistoryStart+41 (place to store most recent signal value)
 000                                 CONSTANT IaccuMSB, 21'd
 000                                 CONSTANT IaccuLSB, 22'd
 000                                 CONSTANT QaccuMSB, 23'd
 000                                 CONSTANT QaccuLSB, 24'd
 000                                 CONSTANT OldPhaseLSB, 25'd
 000                                 ; Scratch pad 30-69 used for sinewave - 20 values for sinewave, 40 for dirac
 000                                 CONSTANT startsine, 30'd
 000                                 CONSTANT endsine, 45'd
 000                                 CONSTANT HistoryStart, 70'd                    ; 2 bytes per historical sample - 21 2byte history values
 000                                 CONSTANT HistoryStart42, 112'd                 ; 2 bytes per historical sample - 21 2byte history values
 000                                 ; History values up to and including 111
 000                                 CONSTANT AGCvalueTX, 112'd
 000                                 CONSTANT AGCvalueRX, 113'd
 000                                 CONSTANT AGCcounter, 114'd                     ;store counter 0 to 255 to only perform AGC calc every 1 in 4 audio samples and sinewave increment every 8 samples
 000                                 CONSTANT UARTBitshift, 115'd
 000                                 ;Register values for tone detection part
 000                                 CONSTANT AveStrtToneAMSB_I, 116'd
 000                                 CONSTANT AveStrtToneALSB_I, 117'd
 000                                 CONSTANT AveStrtToneBMSB_I, 118'd
 000                                 CONSTANT AveStrtToneBLSB_I, 119'd
 000                                 CONSTANT AveStopToneAMSB_I, 120'd
 000                                 CONSTANT AveStopToneALSB_I, 121'd
 000                                 CONSTANT AveStopToneBMSB_I, 122'd
 000                                 CONSTANT AveStopToneBLSB_I, 123'd
 000                                 CONSTANT LongAveStrtToneAMSB_I, 124'd
 000                                 CONSTANT LongAveStrtToneALSB_I, 125'd
 000                                 CONSTANT LongAveStrtToneBMSB_I, 126'd
 000                                 CONSTANT LongAveStrtToneBLSB_I, 127'd
 000                                 CONSTANT LongAveStopToneAMSB_I, 128'd
 000                                 CONSTANT LongAveStopToneALSB_I, 129'd
 000                                 CONSTANT LongAveStopToneBMSB_I, 130'd
 000                                 CONSTANT LongAveStopToneBLSB_I, 131'd
 000                                 CONSTANT AveStrtToneAMSB_Q, 132'd
 000                                 CONSTANT AveStrtToneALSB_Q, 133'd
 000                                 CONSTANT AveStrtToneBMSB_Q, 134'd
 000                                 CONSTANT AveStrtToneBLSB_Q, 135'd
 000                                 CONSTANT AveStopToneAMSB_Q, 136'd
 000                                 CONSTANT AveStopToneALSB_Q, 137'd
 000                                 CONSTANT AveStopToneBMSB_Q, 138'd
 000                                 CONSTANT AveStopToneBLSB_Q, 139'd
 000                                 CONSTANT LongAveStrtToneAMSB_Q, 140'd
 000                                 CONSTANT LongAveStrtToneALSB_Q, 141'd
 000                                 CONSTANT LongAveStrtToneBMSB_Q, 142'd
 000                                 CONSTANT LongAveStrtToneBLSB_Q, 143'd
 000                                 CONSTANT LongAveStopToneAMSB_Q, 144'd
 000                                 CONSTANT LongAveStopToneALSB_Q, 145'd
 000                                 CONSTANT LongAveStopToneBMSB_Q, 146'd
 000                                 CONSTANT LongAveStopToneBLSB_Q, 147'd
 000                                 ;Pointers for tones in sinewave - use 4 bits for actual ptr in scratchpad (bottom 2bits of MSB and top 2 bits of LSB)
 000                                 CONSTANT StrtToneAPtrMSB, 148'd
 000                                 CONSTANT StrtToneAPtrLSB, 149'd
 000                                 CONSTANT StrtToneBPtrMSB, 150'd
 000                                 CONSTANT StrtToneBPtrLSB, 151'd
 000                                 CONSTANT StopToneAPtrMSB, 152'd
 000                                 CONSTANT StopToneAPtrLSB, 153'd
 000                                 CONSTANT StopToneBPtrMSB, 154'd
 000                                 CONSTANT StopToneBPtrLSB, 155'd
 000                                 CONSTANT FirstToneInc, 156'd                   ;4 Locations to store tone increments (actually there are 4 unused registers here as well)
 000                                 CONSTANT FirstToneInc02, 158'd                 ;4 Locations to store tone increments (actually there are 4 unused registers here as well)
 000                                 CONSTANT FirstToneInc04, 160'd                 ;4 Locations to store tone increments (actually there are 4 unused registers here as well)
 000                                 CONSTANT FirstToneInc06, 162'd                 ;4 Locations to store tone increments (actually there are 4 unused registers here as well)
 000                                 CONSTANT NormalisedMagMSB, 164'd               ;Absolute value of current signal
 000                                 CONSTANT NormalisedMagLSB, 165'd               ;Absolute value of current signal
 000                                 ;GenerateCode        MEM       "S3eDSPprog.mem"
 000                                 ;start:              JUMP      cold_start       -Try without jump to $20 offset - should work!?
 000                                 ; Start of program (Jump instruction in preloaded memory!)
 000                                 ;                   ORG       $20
 000                                 ; pre-load scratchpad with cordic table.. 360 degrees is $0800 - then *32=$10000
 000  010FF              cold_start: LOAD s0, FF[255'd]                             ; phase for 45 degrees- actually a bit less!
 001  2F000                          STORE s0, 00
 002  01097                          LOAD s0, 97[151'd]                             ; phase for 26.565 degrees
 003  2F001                          STORE s0, 01
 004  01050                          LOAD s0, 50[80'd]                              ; phase for 14.036 degrees
 005  2F002                          STORE s0, 02
 006  01029                          LOAD s0, 29[41'd]                              ; phase for 7.125 degrees
 007  2F003                          STORE s0, 03
 008  01014                          LOAD s0, 14[20'd]                              ; phase for 3.576 degrees
 009  2F004                          STORE s0, 04
 00A  0100A                          LOAD s0, 0A[10'd]                              ; phase for 1.79 degrees
 00B  2F005                          STORE s0, 05
 00C  01005                          LOAD s0, 05[5'd]                               ; phase for 0.895 degrees
 00D  2F006                          STORE s0, 06
 00E  01003                          LOAD s0, 03[3'd]                               ; phase for 0.448 degrees
 00F  2F007                          STORE s0, 07
 010  01001                          LOAD s0, 01[1'd]                               ; phase for 0.224 degrees
 011  2F008                          STORE s0, 08
 012  01010                          LOAD s0, 10[16'd]
 013  2F070                          STORE s0, 70[AGCvalueTX]
 014  2F071                          STORE s0, 71[AGCvalueRX]
 015                                 ; LOAD      s1, 30
 015                                 ; LOAD      s0, 0
 015                                 ; diracload:          STORE     s0, s1
 015                                 ; ADD       s1, 1
 015                                 ; COMP      s1, 69
 015                                 ; JUMP      NZ, diracload
 015                                 ; LOAD      s0, 75
 015                                 ; STORE     s0, 69
 015                                 ;Sinewave table: Step through this 1 in 8 loops to give 62.5Hz sinewave on transmission
 015  01002                          LOAD s0, 02[2'd]                               ; 1st element of sinewave
 016  2F01E                          STORE s0, 1E[30'd]
 017  01003                          LOAD s0, 03[3'd]                               ; 2nd element of sinewave
 018  2F01F                          STORE s0, 1F[31'd]
 019  01004                          LOAD s0, 04[4'd]                               ; 3rd element of sinewave
 01A  2F020                          STORE s0, 20[32'd]
 01B  01004                          LOAD s0, 04[4'd]                               ; etc
 01C  2F021                          STORE s0, 21[33'd]
 01D  01004                          LOAD s0, 04[4'd]                               ; etc
 01E  2F022                          STORE s0, 22[34'd]
 01F  01003                          LOAD s0, 03[3'd]                               ;
 020  2F023                          STORE s0, 23[35'd]
 021  01002                          LOAD s0, 02[2'd]                               ; etc
 022  2F024                          STORE s0, 24[36'd]
 023  01000                          LOAD s0, 00[0'd]                               ; etc
 024  2F025                          STORE s0, 25[37'd]
 025  010FE                          LOAD s0, FE[254'd]                             ; etc
 026  2F026                          STORE s0, 26[38'd]
 027  010FD                          LOAD s0, FD[253'd]                             ;
 028  2F027                          STORE s0, 27[39'd]
 029  010FC                          LOAD s0, FC[252'd]                             ; etc
 02A  2F028                          STORE s0, 28[40'd]
 02B  010FC                          LOAD s0, FC[252'd]                             ; etc
 02C  2F029                          STORE s0, 29[41'd]
 02D  010FC                          LOAD s0, FC[252'd]                             ; etc
 02E  2F02A                          STORE s0, 2A[42'd]
 02F  010FD                          LOAD s0, FD[253'd]                             ;
 030  2F02B                          STORE s0, 2B[43'd]
 031  010FE                          LOAD s0, FE[254'd]                             ; etc
 032  2F02C                          STORE s0, 2C[44'd]
 033  01000                          LOAD s0, 00[0'd]                               ; etc
 034  2F02D                          STORE s0, 2D[45'd]
 035                                 ;                LOAD      s0, 254'd             ; etc
 035                                 ;                   STORE     s0, 46'd
 035                                 ;                  LOAD      s0, 0'd             ;
 035                                 ;                 STORE     s0, 47'd
 035                                 ;                LOAD      s0, 247'd             ; etc
 035                                 ;               STORE     s0, 48'd
 035                                 ;              LOAD      s0, 0'd               ; etc
 035                                 ;             STORE     s0, 49'd
 035  0109F                          LOAD s0, 9F[StrtToneAInc]
 036  2F09C                          STORE s0, 9C[FirstToneInc]
 037  01069                          LOAD s0, 69[StrtToneBInc]
 038  2F09E                          STORE s0, 9E[FirstToneInc02]
 039  0105A                          LOAD s0, 5A[StopToneAInc]
 03A  2F0A0                          STORE s0, A0[FirstToneInc04]
 03B  01078                          LOAD s0, 78[StopToneBInc]
 03C  2F0A2                          STORE s0, A2[FirstToneInc06]
 03D  0102A                          LOAD s0, 2A[42'd]
 03E  2D002                          OUTPUT s0, 02[SSBAmp]
 03F  01000                          LOAD s0, 00
 040  2F012                          STORE s0, 12[State]                            ; Set state to 0 ie receive
 041  01C1E                          LOAD sC[SineCtr], 1E[startsine]                ; reset SineCtr
 042  01046                          LOAD s0, 46[HistoryStart]                      ;aargh - had commented this out!!!! May2013
 043  2F014                          STORE s0, 14[LVPtr]
 044                                 ; Initialise AGC
 044  010FF                          LOAD s0, FF[255'd]                             ; - 1
 045  2F00F                          STORE s0, 0F[VolSetting]
 046  01020                          LOAD s0, 20[32'd]                              ;Start with mid value for external AGC MUX version
 047  2F00E                          STORE s0, 0E[AGCvalue]                         ;maybe start with 16 (was 8)?
 048  01F08                          LOAD sF[AveSignalUSB], 08[AGCInitial]          ; set signal averager to moderate level
 049                                 ;                    LOAD      AveSignalUSB, AGClowthreshold       ; set signal averager to moderate level
 049                                 ;                    ADD       AveSignalUSB, AGCuppthreshold       ; set signal averager to moderate level
 049                                 ;     SR0       AveSignalUSB
 049                                 ;                    LOAD   BaselineMSB,0
 049                                 ; routine to take signal in s0,s1,s2 (MSB-LSB) and return 16bit signal in s0,s1 using AGC and volume settings
 049                                 ; TO DOOOOOOOOOOOO
 049                                 ; Routine to look at lowest bit of Strobe to detect rising edge.
 049  09002           AwaitAudioVal: INPUT s0, 02[Strobe]
 04A  03001                          AND s0, 01                                     ; look only at lowest bit
 04B  1D001                          COMPARE s0, 01
 04C  32049                          JUMP Z, 049[AwaitAudioVal]                     ; if 1 wait...
 04D  09002               AwaitRise: INPUT s0, 02[Strobe]
 04E  03001                          AND s0, 01                                     ; look only at lowest bit
 04F  1D000                          COMPARE s0, 00
 050  3204D                          JUMP Z, 04D[AwaitRise]                         ; if 0 still, wait a bit more...
 051  09001                          INPUT s0, 01[AudioLSB]                         ; Now have the new value (different addresses from before!)
 052  09100                          INPUT s1, 00[AudioMSB]
 053                                 ;      INPUT    s2,AudioUSB    ;not when using external MUX for AGC
 053                                 ;     OUTPUT     s1,Data2archiveLSB           ;This is received demodulated data - normally s0
 053                                 ;     OUTPUT     s2,Data2archiveMSB
 053                                 ; Temp sine wave simulation
 053                                 ;Display demodulated values always:
 053                                 ;     OUTPUT     s1,Data2archiveLSB
 053                                 ;     OUTPUT     s2,Data2archiveMSB
 053                                 ;                    ADD       SineCtr, audioTest
 053                                 ;                   COMP      SineCtr, 50         ; should be 50 with sine wave - extend to 70 for dirac!
 053                                 ;                  JUMP      C, contsine         ; skip over if still below 50
 053                                 ;                 SUB      SineCtr, 20  ; reset counter back to start (1 period)
 053                                 ;contsine:           FETCH     s1, SineCtr         ; put value of sine from table into AudioMSB
 053                                 ;                   LOAD      s2, 0
 053                                 ;                  LOAD    s0,0
 053                                 ;                 COMP      s1, 128             ; but is sine negative?
 053                                 ;                JUMP      C, skipneg
 053                                 ;               LOAD      s2, 255             ; interpret as negative number
 053                                 ;skipneg:
 053                                 ; now apply volume setting
 053                                 ; FETCH     s3, VolSetting
 053                                 ; CALL      AGC
 053                                 ;This part allows insertion of UART streamed values on RX and transmit - removed in GV42
 053                                 ;                FETCH     s3,State
 053                                 ;     AND    s3,4
 053                                 ;     COMP   s3,4        ;is this stream mode
 053                                 ;     CALL   Z,GetUartValues
 053                                 ;_____________________________________________________________
 053                                 ; perform automatic gain contrl
 053  0B30E                          FETCH s3, 0E[AGCvalue]
 054  201C2                          CALL 1C2[AGC]                                  ;Now with external MUX to adjust AGC
 055  20197                          CALL 197[Abs16Val]
 056  2F3A4                          STORE s3, A4[NormalisedMagMSB]
 057  2F2A5                          STORE s2, A5[NormalisedMagLSB]
 058                                 ;_______________Add Jan 2013 to increase volume without clipping____________Sept 2015 Not during transmit!
 058                                 ;        CALL AudioDouble
 058                                 ;        CALL AudioDouble     ;increase volume 12 dB!
 058                                 ;_____________________________________________________________________________
 058                                 ;Now check if we are transmitting this value!
 058  0B212                          FETCH s2, 12[State]
 059  03202                          AND s2, 02
 05A  1D202                          COMPARE s2, 02                                 ; Check if transmit mode
 05B  3216B                          JUMP Z, 16B[TransmitAudio]
 05C                                 ; This section will only be performed in receive mode
 05C                                 ; Perform volume adjustment here **********To Be Done************************
 05C                                 ;            SL0   s0
 05C                                 ;           SLA  s1    ;double received signal to speaker
 05C                                 ;            SL0   s0
 05C                                 ;           SLA  s1    ;further double received signal to speaker BUT removed 31/12/12 as was clipping with AGC thresholds set
 05C                                 ;        CALL AudioDouble     ;increase volume another 6 dB on receive! - removed 28/5/13
 05C                                 ;_______________________________
 05C                                 ;Test value by sending out to Uart - shift this section as required - but check s3 not used! Removed for GV42 and GV45
 05C                                 ;       LOAD     s3, s1
 05C                                 ;       SRX   s3
 05C                                 ;                     OUT       s3, CmdToUser    ;Send receive signal in 7 bits (divide by 2!) to user pico to send to UART
 05C                                 ;__________________________________
 05C  2014C                          CALL 14C[AudioDouble]                          ;increase volume 12 dB! Add 2 of these 26/2/15
 05D  2014C                          CALL 14C[AudioDouble]                          ;increase volume 12 dB!
 05E  2D100                          OUTPUT s1, 00[MSBAudio]
 05F  2D001                          OUTPUT s0, 01[LSBAudio]
 060                                 ;Display demodulated values only in receive
 060  2D00A                          OUTPUT s0, 0A[Data2archiveMSB]                 ;This is received demodulated data
 061  2D10B                          OUTPUT s1, 0B[Data2archiveLSB]
 062  14000                          SLA s0                                         ;shift top bit into carry
 063  13100                          ADDCY s1, 00                                   ;s1 now rounded value of upper 8 bits (but s0 wasted!)
 064                                 ;Disable for the moment!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 064                                 ;       CALL   AverageToneDemod ;Maybe stuck due to scratchpad not being 256 extended
 064                                 ; Check if there is a command from the User, return here with JUMP command from TransmitAudio macro
 064  09003    BackfromTransmitting: INPUT s0, 03[Command]                          ; Check if FIFO character present
 065  1D080                          COMPARE s0, 80[128'd]                          ; is there a character?
 066  382E5                          CALL C, 2E5[Respond2Fifo]
 067                                 ; Accumulate magnitude
 067                                 ;__________________________________________________________________________________________
 067                                 ;Only do this 1 in 4 (8) times -add this part to Pete's Jan 2013 code - should give 1s time constant on AGC to try and reduce gain ramping up during quiet speech parts
 067  0B372                          FETCH s3, 72[AGCcounter]
 068  11301                          ADD s3, 01
 069  2F372                          STORE s3, 72[AGCcounter]
 06A                                 ;            AND    s3,3   ;take only lowest 2 bits
 06A                                 ;            COMP    s3,0 ;skip 4 times (default 8?)
 06A                                 ;                   JUMP   NZ,AwaitAudioVal  ;if not 8th time then go back to start
 06A                                 ;                    LOAD   s3,0   Don't need to do this as lowest 2 bits are already zero
 06A                                 ;            STORE   s3,AGCcounter
 06A                                 ;NOW do it every time!
 06A                                 ;_____________________________________________________________________________________________
 06A                                 ;Need to overhaul this !! Oct2015
 06A                                 ;So do this bit at 8kHz rate - so has about a 1s time constant
 06A                                 ; Add 1/32 x abs(new normalised value - which is 256 times smaller than averaged value)
 06A  0B3A4                          FETCH s3, A4[NormalisedMagMSB]
 06B  0B2A5                          FETCH s2, A5[NormalisedMagLSB]                 ;These are absolute values
 06C  2008B                          CALL 08B[Divide32]
 06D  10D20                          ADD sD[AveSignalLSB], s2
 06E  12E30                          ADDCY sE[AveSignalMSB], s3
 06F  13F00                          ADDCY sF[AveSignalUSB], 00
 070                                 ; now subtract 1/8192 of current value of average
 070  003F0                          LOAD s3, sF[AveSignalUSB]
 071  002E0                          LOAD s2, sE[AveSignalMSB]                      ; These should be positive values!
 072  2008B                          CALL 08B[Divide32]
 073  18D20                          SUB sD[AveSignalLSB], s2
 074  1AE30                          SUBCY sE[AveSignalMSB], s3
 075  1BF00                          SUBCY sF[AveSignalUSB], 00
 076                                 ; Accumulate signed value - try to get DC offset - but apparently not used
 076                                 ; Add 1/256 x abs(new normalised value)
 076                                 ;                    FETCH      s3, NormalisedSignalMSB
 076                                 ;                   LOAD      s4, 0
 076                                 ;                  COMP      s3, 128
 076                                 ;                 JUMP      C, ispos1           ; the signal is positive
 076                                 ;                LOAD      s4, $FF             ; in case accum signed value is negative (which it could well be!!!
 076                                 ;ispos1:             ADD       BaselineLSB, s3
 076                                 ;                   ADDC      BaselineMSB, s4
 076                                 ; now subtract 1/256of current baseline value
 076                                 ;                    LOAD      s3, BaselineMSB
 076                                 ;                  LOAD      s4, 0
 076                                 ;                   COMP      s3, 128
 076                                 ;                 JUMP      C, ispos2           ; the accumulated value is positive
 076                                 ;                LOAD      s4, $FF             ; in case accum signed value is negative (which it could well be!!!
 076                                 ;ispos2:             SUB       BaselineLSB, s3
 076                                 ;                   SUBC      BaselineMSB, s4
 076                                 ;TEMP DISPLAY of AveSignalMSB!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 076  003F0                          LOAD s3, sF[AveSignalUSB]                      ;AveSignalMSB is actually a register!
 077  2D318                          OUTPUT s3, 18[StopToneALong]
 078  003E0                          LOAD s3, sE[AveSignalMSB]                      ;AveSignalMSB is actually a register!
 079  2D319                          OUTPUT s3, 19[StopToneB]
 07A  003D0                          LOAD s3, sD[AveSignalLSB]                      ;AveSignalMSB is actually a register!
 07B  2D31A                          OUTPUT s3, 1A[StopToneBLong]
 07C  0B30E                          FETCH s3, 0E[AGCvalue]
 07D  2D317                          OUTPUT s3, 17[StopToneA]                       ;TEMP !!!!!!!!!!!!!!!! send AGC value to this position
 07E                                 ; Now adjust AGC value if necessary
 07E  0B30E                          FETCH s3, 0E[AGCvalue]
 07F  1DF16                          COMPARE sF[AveSignalUSB], 16[AGCuppthreshold4] ;Is really big? ie at threshold or above
 080  3C1B5                          CALL NC, 1B5[increaseAGC4]                     ; signal too big, increase attenuation by 12dB
 081  1DF0F                          COMPARE sF[AveSignalUSB], 0F[AGCuppthreshold2] ;Is pretty big
 082  3C1B0                          CALL NC, 1B0[increaseAGC2]                     ; signal too big, increase attenuation by 6dB
 083  1DF0A                          COMPARE sF[AveSignalUSB], 0A[AGCuppthreshold]  ;or 18 or 9
 084  3C1AB                          CALL NC, 1AB[increaseAGC]                      ; signal slightly too big, increase attenuation by 1_5dB
 085  1DF03                          COMPARE sF[AveSignalUSB], 03[AGClowthreshold2] ;
 086  381BD                          CALL C, 1BD[decreaseAGC2]                      ;ie below threshold2 (4 or below)
 087  1DF06                          COMPARE sF[AveSignalUSB], 06[AGClowthreshold]  ; ie below threshold (7 or less)
 088  381B8                          CALL C, 1B8[decreaseAGC]
 089  2F30E                          STORE s3, 0E[AGCvalue]
 08A  22049                          JUMP 049[AwaitAudioVal]
 08B                                 ; -------------This is end of main loop--------------------------------
 08B                                 ;Routine to take 16 bit value in s3,s2 and shift right by 5 to divide by 32 and leave value in s3,s2
 08B                                 ;Assumes this is an unsigned numbers - normally used on a magnitude.
 08B  20090                Divide32: CALL 090[Divide4]
 08C  20090                          CALL 090[Divide4]
 08D  1430E                          SR0 s3
 08E  14208                          SRA s2
 08F  25000                          RETURN 
 090  1430E                 Divide4: SR0 s3
 091  14208                          SRA s2
 092  1430E                          SR0 s3
 093  14208                          SRA s2
 094  25000                          RETURN 
 095  01101               SpeakerOn: LOAD s1, 01
 096  2D111                          OUTPUT s1, 11[EnableSpeaker]
 097  25000                          RETURN 
 098  25000              SpeakerOff: RETURN                                         ;Disable for the moment
 099  01100                          LOAD s1, 00
 09A  2D111                          OUTPUT s1, 11[EnableSpeaker]
 09B  25000                          RETURN 
 09C                                 ;Routines to average I and Q demodulated tone signals
 09C                                 ;Check the amplitude of the demodulated and averaged signals compared to long average - AGCcounter==0 can be used to top up long average
 09C                                 ;s7 used to note if LO is negative
 09C                                 ;Enter with received signal MSB in s1 and try and keep in s8!
 09C                                 ;first accumulate short and long averages of all tones I and Q
 09C  00810        AverageToneDemod: LOAD s8, s1
 09D  01600                          LOAD s6, 00                                    ;This will be used to count through 4 tones in the loop below
 09E  01595               DemodLoop: LOAD s5, 95[StrtToneAPtrLSB]                   ;value of LSB of pointer to Scratchpad element for TonePtrs
 09F  10560                          ADD s5, s6                                     ;Move up to ptr being treated
 0A0  0A050                          FETCH s0, (s5)                                 ;the tone pointer for the LSB should now be in s0
 0A1  0129C                          LOAD s2, 9C[FirstToneInc]                      ;Scratch address for StrtToneAInc
 0A2  10260                          ADD s2, s6
 0A3  0A420                          FETCH s4, (s2)                                 ;Get StrtToneAInc in s4 etc...
 0A4  19501                          SUB s5, 01                                     ;Back 1 index to MSB
 0A5  0A150                          FETCH s1, (s5)                                 ;the sinewave pointer for the MSB should now be in s1
 0A6  10040                          ADD s0, s4                                     ;Increment LSB!!
 0A7  13100                          ADDCY s1, 00                                   ;Add carry to MSB    ->This is OK as increment is positive
 0A8  2E150                          STORE s1, (s5)                                 ;Value of MSB of sinewave pointer has been incremented in scratch pad
 0A9  11501                          ADD s5, 01
 0AA  2E050                          STORE s0, (s5)                                 ;Value of LSB of pointer has been incremented in scratch pad
 0AB                                 ;now rotate 16 bit pointer to get 4 bits used to address the sinewave values
 0AB  14006                          SL0 s0
 0AC  14100                          SLA s1
 0AD  14006                          SL0 s0
 0AE  14100                          SLA s1
 0AF  0310F                          AND s1, 0F                                     ;keep lowest 4 bits to have pointer to one of 16 sinewave values
 0B0  00910                          LOAD s9, s1
 0B1  0A390                          FETCH s3, (s9)                                 ;get sinewave at ptr value in s9 and put in s3
 0B2  2011F                          CALL 11F[MultSigByLO]
 0B3                                 ;Now need to accumulate demodulated I value which is in s1:
 0B3                                 ;value to accumulate is in s1
 0B3  01275                          LOAD s2, 75[AveStrtToneALSB_I]                 ;This is load not FETCH as s2 is loaded with the pointer value to the first scratchpad average register
 0B4  20106                          CALL 106[DoAccumulate]
 0B5                                 ;Now treat Q_LO value
 0B5  11904                          ADD s9, 04                                     ;add 1/4 period
 0B6  0390F                          AND s9, 0F                                     ;keep lowest 4 bits to have pointer to one of 16 cosinewave values
 0B7  0A390                          FETCH s3, (s9)                                 ;get cosinewave at ptr value in s9 and put in s3
 0B8  2011F                          CALL 11F[MultSigByLO]
 0B9                                 ; accumulate demodulated Q value which is in s1:
 0B9  01285                          LOAD s2, 85[AveStrtToneALSB_Q]
 0BA  20106                          CALL 106[DoAccumulate]
 0BB  0B072                          FETCH s0, 72[AGCcounter]
 0BC  1D000                          COMPARE s0, 00
 0BD  3012D                          CALL Z, 12D[DolongAve]
 0BE                                 ;now check for end of looping
 0BE  11602                          ADD s6, 02                                     ;next tone
 0BF  1D608                          COMPARE s6, 08
 0C0  3609E                          JUMP NZ, 09E[DemodLoop]                        ;loop if more tones to demodulate
 0C1                                 ;Now check amplitude of demodulated signals
 0C1  0B374                          FETCH s3, 74[AveStrtToneAMSB_I]
 0C2  201A0                          CALL 1A0[absval]                               ;Get the magnitude
 0C3  00030                          LOAD s0, s3                                    ;Abs value of ToneA_I in s0
 0C4  0B384                          FETCH s3, 84[AveStrtToneAMSB_Q]
 0C5  201A0                          CALL 1A0[absval]                               ;Get the magnitude
 0C6  10030                          ADD s0, s3                                     ;Abs value of ToneA_I +Q in s0
 0C7  14008                          SRA s0                                         ;Divide by 2 to get carry back into the s0 register
 0C8                                 ;    SR0 s0     ;Divide by 2 again
 0C8                                 ;    SR0 s0     ;Divide by 2 again - increase gain by further 4
 0C8  0B37C                          FETCH s3, 7C[LongAveStrtToneAMSB_I]
 0C9  201A0                          CALL 1A0[absval]                               ;Get the magnitude
 0CA  00130                          LOAD s1, s3                                    ;Abs value of ToneA_I in s1
 0CB  0B38C                          FETCH s3, 8C[LongAveStrtToneAMSB_Q]
 0CC  201A0                          CALL 1A0[absval]                               ;Get the magnitude
 0CD  10130                          ADD s1, s3                                     ;Abs value of ToneA_I +Q in s1
 0CE  14106                          SL0 s1                                         ;Multiply by 2 and assume the averaged value is small!
 0CF                                 ;Now s1 has long term average level and s0 has short term average value of start tone A (but 4 times smaller)
 0CF  2D013                          OUTPUT s0, 13[StartToneA]
 0D0  2D114                          OUTPUT s1, 14[StartToneALong]
 0D1  1C100                          COMPARE s1, s0                                 ;See if short term average is bigger than 4 times long term average (Carry will be set)
 0D2  38095                          CALL C, 095[SpeakerOn]
 0D3  0B376                          FETCH s3, 76[AveStrtToneBMSB_I]
 0D4  201A0                          CALL 1A0[absval]                               ;Get the magnitude
 0D5  00030                          LOAD s0, s3                                    ;Abs value of ToneA_I in s0
 0D6  0B386                          FETCH s3, 86[AveStrtToneBMSB_Q]
 0D7  201A0                          CALL 1A0[absval]                               ;Get the magnitude
 0D8  10030                          ADD s0, s3                                     ;Abs value of ToneA_I +Q in s0
 0D9  14008                          SRA s0                                         ;Divide by 2 to get carry back into the s0 register
 0DA                                 ;    SR0 s0     ;Divide by 2 again
 0DA                                 ;    SR0 s0     ;Divide by 2 again
 0DA  0B37E                          FETCH s3, 7E[LongAveStrtToneBMSB_I]
 0DB  201A0                          CALL 1A0[absval]                               ;Get the magnitude
 0DC  00130                          LOAD s1, s3                                    ;Abs value of ToneA_I in s0
 0DD  0B38E                          FETCH s3, 8E[LongAveStrtToneBMSB_Q]
 0DE  201A0                          CALL 1A0[absval]                               ;Get the magnitude
 0DF  10130                          ADD s1, s3                                     ;Abs value of ToneA_I +Q in s0
 0E0  14106                          SL0 s1                                         ;Multiply by 2 and assume the averaged value is small!
 0E1                                 ;Now s1 has long term average level and s0 has short term average value of start tone B (but 4 times smaller)
 0E1  2D015                          OUTPUT s0, 15[StartToneB]
 0E2  2D116                          OUTPUT s1, 16[StartToneBLong]
 0E3  1C100                          COMPARE s1, s0                                 ;See if short term average is bigger than 4 times long term average (Carry will be set)
 0E4  38095                          CALL C, 095[SpeakerOn]
 0E5  0B378                          FETCH s3, 78[AveStopToneAMSB_I]
 0E6  201A0                          CALL 1A0[absval]                               ;Get the magnitude
 0E7  00030                          LOAD s0, s3                                    ;Abs value of ToneA_I in s0
 0E8  0B388                          FETCH s3, 88[AveStopToneAMSB_Q]
 0E9  201A0                          CALL 1A0[absval]                               ;Get the magnitude
 0EA  10030                          ADD s0, s3                                     ;Abs value of ToneA_I +Q in s0
 0EB  14008                          SRA s0                                         ;Divide by 2 to get carry back into the s0 register
 0EC                                 ;    SR0 s0     ;Divide by 2 again
 0EC                                 ;    SR0 s0     ;Divide by 2 again
 0EC  0B380                          FETCH s3, 80[LongAveStopToneAMSB_I]
 0ED  201A0                          CALL 1A0[absval]                               ;Get the magnitude
 0EE  00130                          LOAD s1, s3                                    ;Abs value of ToneA_I in s0
 0EF  0B390                          FETCH s3, 90[LongAveStopToneAMSB_Q]
 0F0  201A0                          CALL 1A0[absval]                               ;Get the magnitude
 0F1  10130                          ADD s1, s3                                     ;Abs value of ToneA_I +Q in s0
 0F2  14106                          SL0 s1                                         ;Multiply by 2 and assume the averaged value is small!
 0F3                                 ;Now s1 has long term average level and s0 has short term average value of stop tone A (but 4 times smaller)
 0F3                                 ;    OUTPUT s0,StopToneA
 0F3                                 ; Moved earlier   LOAD s3,AveSignalMSB     ;AveSignalMSB is actually a register!
 0F3                                 ;    OUTPUT s3,StopToneALong
 0F3                                 ;    OUTPUT s1,StopToneALong
 0F3  1C100                          COMPARE s1, s0                                 ;See if short term average is bigger than 4 times long term average (Carry will be set)
 0F4  38098                          CALL C, 098[SpeakerOff]
 0F5  0B37A                          FETCH s3, 7A[AveStopToneBMSB_I]
 0F6  201A0                          CALL 1A0[absval]                               ;Get the magnitude
 0F7  00030                          LOAD s0, s3                                    ;Abs value of ToneA_I in s0
 0F8  0B38A                          FETCH s3, 8A[AveStopToneBMSB_Q]
 0F9  201A0                          CALL 1A0[absval]                               ;Get the magnitude
 0FA  10030                          ADD s0, s3                                     ;Abs value of ToneA_I +Q in s0
 0FB  14008                          SRA s0                                         ;Divide by 2 to get carry back into the s0 register
 0FC                                 ;    SR0 s0     ;Divide by 2 again
 0FC                                 ;    SR0 s0     ;Divide by 2 again
 0FC  0B382                          FETCH s3, 82[LongAveStopToneBMSB_I]
 0FD  201A0                          CALL 1A0[absval]                               ;Get the magnitude
 0FE  00130                          LOAD s1, s3                                    ;Abs value of ToneA_I in s0
 0FF  0B392                          FETCH s3, 92[LongAveStopToneBMSB_Q]
 100  201A0                          CALL 1A0[absval]                               ;Get the magnitude
 101  10130                          ADD s1, s3                                     ;Abs value of ToneA_I +Q in s0
 102  14106                          SL0 s1                                         ;Multiply by 2 and assume the averaged value is small!
 103                                 ;Now s1 has long term average level and s0 has short term average value of stop tone B (but 4 times smaller)
 103                                 ;    OUTPUT s0,StopToneB
 103                                 ;   OUTPUT s1,StopToneBLong
 103  1C100                          COMPARE s1, s0                                 ;See if short term average is bigger than 4 times long term average (Carry will be set)
 104  38098                          CALL C, 098[SpeakerOff]
 105  25000                          RETURN 
 106                                 ;Does 16 bit signed accumulation of 8 bit signed value in s1 into s4/s5 which are recoverred from scratch pad pointed to by s2 (loading here the offset to the actual tone
 106                                 ;dependent on how many times round the loop we are)
 106  10260            DoAccumulate: ADD s2, s6
 107  0A420                          FETCH s4, (s2)                                 ;Now Get AveSToneLSB_Is in s4 etc...
 108  19201                          SUB s2, 01                                     ;step back to MSB
 109  0A520                          FETCH s5, (s2)                                 ;Get AveSToneMSB_Is in s5
 10A  013FF                          LOAD s3, FF                                    ;Assume s1 is negative and use s3 for sign extension
 10B  1D180                          COMPARE s1, 80[128'd]                          ;if s1 is 128 or bigger, then it is negative (carry not set)
 10C  3E10E                          JUMP NC, 10E[negaccum]
 10D  01300                          LOAD s3, 00                                    ;sign extend with zeros
 10E  10410                negaccum: ADD s4, s1                                     ;Accumulate into averageLsB
 10F  12530                          ADDCY s5, s3                                   ;do carry to add into upper byte (keeping carry from previous add!!)
 110  00050                          LOAD s0, s5
 111  1400A                          SRX s0
 112  1400A                          SRX s0                                         ;reduce value to subtract by factor 4 to increase integration time constant and gain.
 113  13000                          ADDCY s0, 00                                   ;round up if necessary
 114  18400                          SUB s4, s0
 115  013FF                          LOAD s3, FF                                    ;Assume s5 is negative and use s3 for sign extension
 116  1D580                          COMPARE s5, 80[128'd]                          ;is this a negative number?
 117  3E119                          JUMP NC, 119[negdecrmnt]
 118  01300                          LOAD s3, 00                                    ;do this if s5 is positive (sign extension)
 119  18400              negdecrmnt: SUB s4, s0
 11A  1A530                          SUBCY s5, s3                                   ;subtract 1/256
 11B  2E520                          STORE s5, (s2)
 11C  11201                          ADD s2, 01                                     ;move down to LSB again
 11D  2E420                          STORE s4, (s2)                                 ;update scratchpad values
 11E  25000                          RETURN 
 11F                                 ;Routine to do LO_I and LO_Q multiplications - LO value in s3 (enter with s3) and signal in s1 (recoverred here from s8) -> result in s1
 11F  1D380             MultSigByLO: COMPARE s3, 80[128'd]
 120  3E140                          JUMP NC, 140[LOisNeg]                          ;Jump out if sinewave val is negative
 121  01700           BackFromLOPos: LOAD s7, 00                                    ;LO is not negative
 122  00180           BackFromLONeg: LOAD s1, s8                                    ;stick signal value back in s1
 123  1D304                          COMPARE s3, 04                                 ;This is the ABSOLUTE value of the LO
 124  30143                          CALL Z, 143[MultiplyBy4]
 125  1D303                          COMPARE s3, 03                                 ;This is the ABSOLUTE value of the LO
 126  30148                          CALL Z, 148[MultiplyBy3]
 127  1D302                          COMPARE s3, 02                                 ;This is the ABSOLUTE value of the LO
 128  30146                          CALL Z, 146[MultiplyBy2]
 129                                 ;if abs(LO)=1  do nothing
 129  1D701                          COMPARE s7, 01                                 ;was the LO value negative?
 12A  35000                          RETURN NZ                                      ;return if positive
 12B  201A7                          CALL 1A7[invertval]                            ;invert sign of s1 if negative
 12C  25000                          RETURN 
 12D                                 ;Routine every 256 cycles to update longer average
 12D  01274               DolongAve: LOAD s2, 74[AveStrtToneAMSB_I]                 ;This is load not FETCH as s2 is loaded with the pointer value to the first scratchpad average register
 12E  10260                          ADD s2, s6
 12F  0A120                          FETCH s1, (s2)                                 ;Now Get AveSToneMSB_Is in s1 etc...
 130  11201                          ADD s2, 01
 131  0A020                          FETCH s0, (s2)                                 ;Now Get AveSToneLSB_Is in s0 etc...
 132  14000                          SLA s0
 133  13100                          ADDCY s1, 00                                   ;should now be rounded correctly
 134  0127D                          LOAD s2, 7D[LongAveStrtToneALSB_I]             ;This is load not FETCH as s2 is loaded with the pointer value to the first scratchpad average register
 135  20106                          CALL 106[DoAccumulate]
 136  01284                          LOAD s2, 84[AveStrtToneAMSB_Q]                 ;This is load not FETCH as s2 is loaded with the pointer value to the first scratchpad average register
 137  10260                          ADD s2, s6
 138  0A120                          FETCH s1, (s2)                                 ;Now Get AveSToneMSB_Qs in s1 etc...
 139  11201                          ADD s2, 01
 13A  0A020                          FETCH s0, (s2)                                 ;Now Get AveSToneLSB_Qs in s0 etc...
 13B  14000                          SLA s0
 13C  13100                          ADDCY s1, 00                                   ;should now be rounded correctly
 13D  0128D                          LOAD s2, 8D[LongAveStrtToneALSB_Q]
 13E  20106                          CALL 106[DoAccumulate]
 13F  25000                          RETURN 
 140                                 ;This inverts the sign of the LO sinewave to be positive, but notes this in a flag to take into account.
 140  01701                 LOisNeg: LOAD s7, 01                                    ;This means LO is negative
 141  201A3                          CALL 1A3[makeposval]
 142  22122                          JUMP 122[BackFromLONeg]
 143                                 ;Multiplies value of s1 by 4 (SL0 X2)
 143  14106             MultiplyBy4: SL0 s1
 144  14106                          SL0 s1
 145  25000                          RETURN 
 146  14106             MultiplyBy2: SL0 s1
 147  25000                          RETURN 
 148  00410             MultiplyBy3: LOAD s4, s1
 149  14106                          SL0 s1
 14A  10140                          ADD s1, s4
 14B  25000                          RETURN 
 14C                                 ;This routine aims to double the signed analoge value in s0,s1 by finding sign of the value and doubling if small, increasing magnitude by 32 if less than 95 but more than 32 then limiting to 127 if more than 95
 14C  1D180             AudioDouble: COMPARE s1, 80[128'd]
 14D  3A15B                          JUMP C, 15B[Posvalue]
 14E                                 ;otherwise must be negative
 14E  1D1E1                Negvalue: COMPARE s1, E1[225'd]                          ;256-31
 14F  3A153                          JUMP C, 153[islessthanneg31]
 150  14006                          SL0 s0
 151  14100                          SLA s1                                         ;double value
 152  25000                          RETURN 
 153  1D1C1         islessthanneg31: COMPARE s1, C1[193'd]                          ;256-63
 154  3A157                          JUMP C, 157[islessthanneg63]
 155  19120                          SUB s1, 20[32'd]
 156  25000                          RETURN 
 157  1410A         islessthanneg63: SRX s1
 158  14008                          SRA s0                                         ;half value
 159  19140                          SUB s1, 40[64'd]
 15A  25000                          RETURN 
 15B  1D120                Posvalue: COMPARE s1, 20[32'd]
 15C  3E160                          JUMP NC, 160[ismorethan31]
 15D  14006                          SL0 s0
 15E  14100                          SLA s1                                         ;double value
 15F  25000                          RETURN 
 160  1D140            ismorethan31: COMPARE s1, 40[64'd]
 161  3E164                          JUMP NC, 164[ismorethan63]                     ;positive and 64 or greater
 162  11120                          ADD s1, 20[32'd]
 163  25000                          RETURN 
 164  1410A            ismorethan63: SRX s1                                         ;sign extension should be zero!
 165  14008                          SRA s0
 166  11140                          ADD s1, 40[64'd]
 167  25000                          RETURN 
 168                                 ;-----------End Audio double
 168                                 ;Divides 16 bit signed value in s0,s1 by 2.
 168  1410A                 Divide2: SRX s1
 169  14008                          SRA s0
 16A  25000                          RETURN 
 16B                                 ;SUB16bit:   SUB    s8,s0
 16B                                 ;     SUBC   s9,s1    ;16 bit subtract
 16B                                 ;     RETURN
 16B                                 ;ADD16bit:   ADD    s8,s0
 16B                                 ;     ADDC   s9,s1    ;16 bit addition
 16B                                 ;     RETURN
 16B                  TransmitAudio: 
 16B                                 ;     IN  s2,Status
 16B                                 ;     AND s2,2  ;look at bit 1
 16B                                 ;In this version switching to BT input is through external multiplexer to go through emphasis filter
 16B                                 ;     COMP s2,0  ;True if BT signal present
 16B                                 ;     JUMP NZ,SkipNoBT   ;keep value from ADC if flag set
 16B                                 ;     IN  s0,BTaudioLSB  ;Use BT values instead if present
 16B                                 ;     IN  s1,BTaudioMSB
 16B                                 ;     CALL AudioDouble     ;increase volume 6 dB!  14/3/15
 16B                       SkipNoBT: 
 16B                                 ;At this point we have audio value to transmit in s1,s0 so can add a tone here
 16B                                 ;       CALL  ADDsinewave
 16B                                 ;Nov 2014 - have reduced DSP AGC level, so shouldn't need to do this? -reinstate Feb2015
 16B  1410A                          SRX s1                                         ;halve value before FIR to keep I and Q below $30 limit after FIR for CORDIC
 16C  14008                          SRA s0
 16D                                 ;Store data in RAM
 16D                                 ;       OUTPUT     s0,Data2archiveLSB
 16D                                 ;       OUTPUT     s1,Data2archiveMSB
 16D  201EF                          CALL 1EF[PerformFIR]
 16E                                 ;This should have decreased amplitude by about 6dB
 16E  2D00A                          OUTPUT s0, 0A[Data2archiveMSB]
 16F  2D10B                          OUTPUT s1, 0B[Data2archiveLSB]
 170                                 ;need to make sure that s3/s2 and s1/s0 DO NOT EXCEED $3000, ie 48 in the MSBs!
 170  2027A                          CALL 27A[cordic]                               ;This is upsettng the AGC when sinectr used sB!
 171  14006                          SL0 s0                                         ;add 6dB 4/10/11
 172  14100                          SLA s1
 173  1D140                          COMPARE s1, 40[64'd]                           ;see if it is not too big already
 174  3E190                          JUMP NC, 190[BiggerThan63]                     ;Skip if too big
 175  14006                          SL0 s0                                         ;add 6dB 4/10/11
 176  14100                          SLA s1
 177                                 ;added further 6dB Aug 2013
 177  1D140                          COMPARE s1, 40[64'd]                           ;see if it is not too big already
 178  3E190                          JUMP NC, 190[BiggerThan63]                     ;Skip if too big
 179  14006                          SL0 s0                                         ;add 6dB 4/10/11
 17A  14100                          SLA s1
 17B                         OutAmp: 
 17B                                 ;_______________________________
 17B                                 ;Test value by sending out to Uart - shift this section as required - but check s3 not used! Disable in GV44a to allow receipt of other values!
 17B                                 ;       LOAD   s3,s1
 17B                                 ;       SRX   s3             ;make sure am not spoiling s3!!!!!
 17B                                 ;                     OUT       s3, CmdToUser    ;Send amp in 7 bits (divide by 2!) to user pico to send to UART
 17B                                 ;__________________________________
 17B  2D102                          OUTPUT s1, 02[SSBAmp]                          ;********************disable for beacon tests
 17C  0B310                          FETCH s3, 10[OldPhaseMSB]
 17D  0B219                          FETCH s2, 19[OldPhaseLSB]
 17E  2F510                          STORE s5, 10[OldPhaseMSB]
 17F  2F419                          STORE s4, 19[OldPhaseLSB]                      ;s2,3 old phase, s4,5 new phase
 180  2D30F                          OUTPUT s3, 0F[AudioPhaseMSB]                   ;send old phase directly
 181  2D210                          OUTPUT s2, 10[AudioPhaseLSB]                   ;send old phase directly
 182  18420                          SUB s4, s2
 183  1A530                          SUBCY s5, s3                                   ;New phase-old phase
 184  1450A                          SRX s5
 185  00350                          LOAD s3, s5                                    ;divide MSB by2 and copy
 186  1430A                          SRX s3
 187  1430A                          SRX s3                                         ;s5/4
 188  10530                          ADD s5, s3
 189  1430A                          SRX s3
 18A  1430A                          SRX s3                                         ;s5/16, s5 should now be 4/3rds of Phase shift/2^9, or 2/3rds of phase shift/2^8 (should be 2/3rds of s5/2^11) so need further 2^3 attenuaion)
 18B  10530                          ADD s5, s3
 18C  2D50D                          OUTPUT s5, 0D[PhaseIncrement]
 18D                                 ;     OUTPUT     s4,Data2archiveLSB         ;Use this if want to store phase
 18D                                 ;     OUTPUT     s5,Data2archiveMSB
 18D  0B30E                          FETCH s3, 0E[AGCvalue]
 18E  2D317                          OUTPUT s3, 17[StopToneA]                       ;TEMP !!!!!!!!!!!!!!!! send AGC value to this position when transmitting
 18F  22064                          JUMP 064[BackfromTransmitting]
 190  1D181            BiggerThan63: COMPARE s1, 81[129'd]
 191  3E194                          JUMP NC, 194[BiggerThan128]
 192  11140                          ADD s1, 40[64'd]
 193  2217B                          JUMP 17B[OutAmp]
 194  1410E           BiggerThan128: SR0 s1                                         ;half value (127 max value)
 195  11180                          ADD s1, 80[128'd]                              ;add 128 (gives 255 max)
 196  2217B                          JUMP 17B[OutAmp]
 197                                 ;Enter with signed 16 bit value in s1,s0 and return magnitude in s3,s2
 197  00310                Abs16Val: LOAD s3, s1
 198  00200                          LOAD s2, s0
 199  1D180                          COMPARE s1, 80[128'd]
 19A  39000                          RETURN C
 19B  01300                          LOAD s3, 00
 19C  01200                          LOAD s2, 00
 19D  18200                          SUB s2, s0
 19E  1A310                          SUBCY s3, s1
 19F  25000                          RETURN 
 1A0  1D380                  absval: COMPARE s3, 80[128'd]
 1A1  3C1A3                          CALL NC, 1A3[makeposval]
 1A2  25000                          RETURN 
 1A3                                 ; Turn negative value in s3 into a positive one (well will actualy make a positive value negative as well).
 1A3  01400              makeposval: LOAD s4, 00
 1A4  18430                          SUB s4, s3
 1A5  00340                          LOAD s3, s4
 1A6  25000                          RETURN 
 1A7                                 ;invert value - actually same as makeposval, but works on s1
 1A7  01400               invertval: LOAD s4, 00
 1A8  18410                          SUB s4, s1
 1A9  00140                          LOAD s1, s4
 1AA  25000                          RETURN 
 1AB                                 ;Adds small amplitude roughly sinewave at 62.5Hz - not used (was to be used to add a sub-audio tone continuously)
 1AB                                 ;ADDsinewave:    FETCH   s2,AGCcounter
 1AB                                 ;       AND   s2,7
 1AB                                 ;       COMP     s2,0
 1AB                                 ;       JUMP    NZ,constsinectr
 1AB                                 ;       ADD    sinectr,1
 1AB                                 ;       COMP    sinectr, endsine+1
 1AB                                 ;       JUMP    NZ,constsinectr
 1AB                                 ;       LOAD    sinectr,startsine
 1AB                                 ;constsinectr:    FETCH    s3,sinectr
 1AB                                 ;       ADD    s1,s3      ;and hope it doesn't overflow!
 1AB                                 ;       RET
 1AB                                 ;Feb 2013 icrease number of AGC steps factor 2 and another factor 2 July 2013 (now granularity 1.5dB)
 1AB                                 ; increment attenuation
 1AB  1D33F             increaseAGC: COMPARE s3, 3F[63'd]                           ; was44
 1AC  31000                          RETURN Z                                       ; don't do anything if already 63 (was 44 (was 22, before that 11))
 1AD  01F08                          LOAD sF[AveSignalUSB], 08[AGCInitial]          ; set signal averager to moderate level
 1AE                                 ;                    LOAD      AveSignalUSB, AGClowthreshold       ; set signal averager to moderate level
 1AE                                 ;                    ADD       AveSignalUSB, AGCuppthreshold       ; set signal averager to moderate level
 1AE                                 ;     SR0       AveSignalUSB
 1AE  11301                          ADD s3, 01[1'd]                                ; so yes signal really has been too big for too long!
 1AF                                 ;           LOAD      s5, s3  ->this was just used when sending value to UART?
 1AF  25000                          RETURN 
 1B0                                 ;increase AGCvalue by 4 to give extra 6dB
 1B0  201AB            increaseAGC2: CALL 1AB[increaseAGC]
 1B1  201AB                          CALL 1AB[increaseAGC]
 1B2  201AB                          CALL 1AB[increaseAGC]
 1B3  201AB                          CALL 1AB[increaseAGC]
 1B4  25000                          RETURN 
 1B5  201B0            increaseAGC4: CALL 1B0[increaseAGC2]
 1B6  201B0                          CALL 1B0[increaseAGC2]
 1B7  25000                          RETURN 
 1B8                                 ; decrement attenuation
 1B8  1D300             decreaseAGC: COMPARE s3, 00                                 ; was232
 1B9  31000                          RETURN Z                                       ; don't do anything if already  0   (was 232 ie -24 (was 244, before that 250 ie -6) )
 1BA                                 ;    LOAD      s2,AveSignalMSB - this didn't seem to do anything (A0)
 1BA                                 ;       CALL     increase1_5dB
 1BA  01F08                          LOAD sF[AveSignalUSB], 08[AGCInitial]          ; set signal averager to moderate level
 1BB                                 ;                    LOAD      AveSignalUSB, AGClowthreshold       ; set signal averager to moderate level
 1BB                                 ;                    ADD       AveSignalUSB, AGCuppthreshold       ; set signal averager to moderate level
 1BB                                 ;     SR0       AveSignalUSB
 1BB  19301                          SUB s3, 01                                     ; so yes signal realy has been too small for too long!
 1BC                                 ; LOAD      s5, s3
 1BC                                 ; CALL      Export2User
 1BC  25000                          RETURN 
 1BD  201B8            decreaseAGC2: CALL 1B8[decreaseAGC]
 1BE  201B8                          CALL 1B8[decreaseAGC]
 1BF  201B8                          CALL 1B8[decreaseAGC]
 1C0  201B8                          CALL 1B8[decreaseAGC]
 1C1  25000                          RETURN 
 1C2                                 ; AGC takes 24 bit value, MSB in s2, LSB in s0 and returns normalised 16 bit value in s1,s0 using AGC value from s3
 1C2                                 ;AGC value in s3 should vary  0-63 in this version - higher value is higher attenuation so use higher significant bits on input MUX (4 bits - 16 inputs)
 1C2                                 ; This routine can also be use for the volume setting if value put in s3 ????????
 1C2  1430A                     AGC: SRX s3                                         ;divide s3 by 2 to get last AGC and put last bit into carry
 1C3  381D7                          CALL C, 1D7[decrease1_5dB]                     ;if last bit set then reduce by 3dB
 1C4  1430A                          SRX s3                                         ;divide s3 by 2 to get old AGC and put last bit into carry
 1C5  381C8                          CALL C, 1C8[decrease3dB]                       ;if last bit set then reduce by 3dB
 1C6  2D312                          OUTPUT s3, 12[MUXport]                         ;Now simply use remaining 4 bits to drive the MUX
 1C7  25000                          RETURN 
 1C8                                 ;AGCloop:            COMPARE      s3, 00
 1C8                                 ;                   RETURN       Z                   ; escape if AGC value zero
 1C8                                 ;                  SRX       s2
 1C8                                 ;                 SRA       s1
 1C8                                 ;                SRA       s0
 1C8                                 ;               SUB       s3, 1
 1C8                                 ;              JUMP      AGCloop
 1C8                                 ;negAGC:             COMP      s3, 0
 1C8                                 ;     RET       Z                   ; escape if AGC value zero
 1C8                                 ;                   SL0       s0      ;increase 24 bit value by 6dB
 1C8                                 ;                  SLA       s1
 1C8                                 ;                 SLA       s2
 1C8                                 ;                ADD       s3, 1
 1C8                                 ;               JUMP      negAGC
 1C8                                 ;this decreases value in (not s2),s1,s0 by factor 0.6875 (roughly 1/sqrt(2)) s2 not used with external MUX
 1C8  1410A             decrease3dB: SRX s1
 1C9  14008                          SRA s0
 1CA  00400                          LOAD s4, s0
 1CB  00510                          LOAD s5, s1
 1CC  1450A                          SRX s5
 1CD  14408                          SRA s4
 1CE  1450A                          SRX s5
 1CF  14408                          SRA s4
 1D0  10040                          ADD s0, s4
 1D1  12150                          ADDCY s1, s5
 1D2  1450A                          SRX s5
 1D3  14408                          SRA s4
 1D4  10040                          ADD s0, s4
 1D5  12150                          ADDCY s1, s5
 1D6  25000                          RETURN 
 1D7                                 ;multiply by 0.875 - modified for using only s1,s0
 1D7  1410A           decrease1_5dB: SRX s1
 1D8  14008                          SRA s0
 1D9  00400                          LOAD s4, s0
 1DA  00510                          LOAD s5, s1
 1DB  1450A                          SRX s5
 1DC  14408                          SRA s4
 1DD  10040                          ADD s0, s4
 1DE  12150                          ADDCY s1, s5
 1DF  1450A                          SRX s5
 1E0  14408                          SRA s4
 1E1  10040                          ADD s0, s4
 1E2  12150                          ADDCY s1, s5
 1E3  25000                          RETURN 
 1E4                                 ;multiply s2 by factor 1.25 (only used for AveSignalMSB) (not needed?)
 1E4                                 ;increase1_5dB:      LOAD   s6,s2
 1E4                                 ;     SRX       s6
 1E4                                 ;                   SRX       s6
 1E4                                 ;                  ADD    s2,s6
 1E4                                 ;
 1E4                                 ;     RET
 1E4                                 ;This is never called???????????????????
 1E4  01308                 AGCtest: LOAD s3, 08
 1E5  00010                          LOAD s0, s1
 1E6  00120                          LOAD s1, s2
 1E7  25000                          RETURN 
 1E8                                 ;This is never called???????????????????
 1E8  1D300              AGClooptst: COMPARE s3, 00
 1E9  31000                          RETURN Z                                       ; escape if AGC value zero
 1EA  1420A                          SRX s2
 1EB  14108                          SRA s1
 1EC  14008                          SRA s0
 1ED  19301                          SUB s3, 01
 1EE  221E8                          JUMP 1E8[AGClooptst]
 1EF                                 ; Routine to perform FIR takes new signal value in s1,s0 (s1 is MSB) and puts into scratch buffer and then outputs new filterred values for I in s1,s0 and Q in s3,s2
 1EF                                 ; First store latest value then increment LVptr
 1EF                                 ;OK Sept 2010
 1EF                                 ;reasonable match between I and Q components (within ~1dB), but about 6dB attenuation from input - OK.
 1EF  2D106              PerformFIR: OUTPUT s1, 06[SignalMSB]
 1F0  2D007                          OUTPUT s0, 07[SignalLSB]
 1F1  0B414                          FETCH s4, 14[LVPtr]                            ; value of the previous latest value
 1F2  11402                          ADD s4, 02                                     ; advance LVptr
 1F3  1D470                          COMPARE s4, 70[HistoryStart42]                 ; + 42
 1F4  3C25B                          CALL NC, 25B[resetLVptr]                       ; if gone past end of buffer reset pointer to start
 1F5  2F414                          STORE s4, 14[LVPtr]                            ; update incremented value of LVptr (by step +2)
 1F6  2E140                          STORE s1, (s4)                                 ; Store signalMSB at LVptr in scratch
 1F7  11401                          ADD s4, 01
 1F8  2E040                          STORE s0, (s4)                                 ; Store signalLSB at LVptr+1 in scratch
 1F9  19401                          SUB s4, 01                                     ; return to LVptr
 1FA  01A00                          LOAD sA, 00                                    ; Reset the register used for the difference between LVptr and Rptr (diff)
 1FB  2FA16                          STORE sA, 16[IaccuLSB]
 1FC  2FA15                          STORE sA, 15[IaccuMSB]
 1FD  2FA18                          STORE sA, 18[QaccuLSB]
 1FE  2FA17                          STORE sA, 17[QaccuMSB]                         ; Reset all accumulators
 1FF                                 ; now start filter with roving pointer in s5 starting at LVptr
 1FF                                 ; LOAD      s5, s4
 1FF  20260                          CALL 260[UpdateRptr]                           ; this should be equivalent to previous line!
 200  017F6                          LOAD s7, F6[coeffI0MSB]                        ; Smallest coefficients of I FIR - load values to go to multiplier input.
 201  01692                          LOAD s6, 92[coeffI0LSB]
 202  20226                          CALL 226[Ibussiness]
 203  01700                          LOAD s7, 00[coeffQ0MSB]                        ; Smallest coefficients of Q FIR
 204  016A7                          LOAD s6, A7[coeffQ0LSB]
 205  2022C                          CALL 22C[Qbussiness]
 206  017F4                          LOAD s7, F4[coeffI1MSB]                        ; coefficient of I FIR
 207  0168A                          LOAD s6, 8A[coeffI1LSB]
 208  20226                          CALL 226[Ibussiness]
 209  01705                          LOAD s7, 05[coeffQ1MSB]                        ; coefficient of Q FIR
 20A  0162D                          LOAD s6, 2D[coeffQ1LSB]
 20B  2022C                          CALL 22C[Qbussiness]
 20C  017F2                          LOAD s7, F2[coeffI2MSB]                        ; coefficient of I FIR
 20D  016CC                          LOAD s6, CC[coeffI2LSB]
 20E  20226                          CALL 226[Ibussiness]
 20F  0170C                          LOAD s7, 0C[coeffQ2MSB]                        ; coefficient of Q FIR
 210  01683                          LOAD s6, 83[coeffQ2LSB]
 211  2022C                          CALL 22C[Qbussiness]
 212  017F1                          LOAD s7, F1[coeffI3MSB]                        ; coefficient of I FIR
 213  01677                          LOAD s6, 77[coeffI3LSB]
 214  20226                          CALL 226[Ibussiness]
 215  0171B                          LOAD s7, 1B[coeffQ3MSB]                        ; coefficient of Q FIR
 216  0164F                          LOAD s6, 4F[coeffQ3LSB]
 217  2022C                          CALL 22C[Qbussiness]
 218  017F0                          LOAD s7, F0[coeffI4MSB]                        ; coefficient of I FIR
 219  016A1                          LOAD s6, A1[coeffI4LSB]
 21A  20226                          CALL 226[Ibussiness]
 21B  0175C                          LOAD s7, 5C[coeffQ4MSB]                        ; coefficient of Q FIR
 21C  0162F                          LOAD s6, 2F[coeffQ4LSB]
 21D  2022C                          CALL 22C[Qbussiness]
 21E  01740                          LOAD s7, 40[coeffI5MSB]                        ; half of middle coefficient of I FIR
 21F  01600                          LOAD s6, 00[coeffI5LSB]
 220  20226                          CALL 226[Ibussiness]                           ; Roving pointer is advanced an 11th time but is reset before being used!
 221  0B016                          FETCH s0, 16[IaccuLSB]
 222  0B115                          FETCH s1, 15[IaccuMSB]
 223  0B218                          FETCH s2, 18[QaccuLSB]
 224  0B317                          FETCH s3, 17[QaccuMSB]
 225  25000                          RETURN                                         ; return from PerformFIR
 226                                 ; These assume coefficient is in s6,7 (LSB,MSB)
 226  20232              Ibussiness: CALL 232[doIplus]
 227  20266                          CALL 266[conjugateDiff]                        ; Roving, difference pointer in sA sent to conjugate value and update roving pointer s5
 228  20232                          CALL 232[doIplus]
 229  20266                          CALL 266[conjugateDiff]                        ; Return difference pointer in sA from its conjugate value
 22A  2025D                          CALL 25D[AdvanceRptr]                          ; This is relative shift to roving pointer (0->10 x2 ie 20)
 22B  25000                          RETURN 
 22C  2023A              Qbussiness: CALL 23A[doQplus]
 22D  20266                          CALL 266[conjugateDiff]                        ; Roving, difference pointer in sA sent to conjugate value, also update roving pointer.
 22E  20242                          CALL 242[doQminus]
 22F  20266                          CALL 266[conjugateDiff]                        ; Roving, difference pointer in sA sent to conjugate value, should go back to value before calling this function.
 230  2025D                          CALL 25D[AdvanceRptr]                          ; This uses relative shift to roving pointer (0->10x2 ie 20), sA used for difference value.
 231  25000                          RETURN 
 232                                 ; These assume coefficient is in s6,7 (LSB,MSB) for doMult, so make sure it doesn't pollute it for the next time!
 232  2024A                 doIplus: CALL 24A[doMult]
 233  0B016                          FETCH s0, 16[IaccuLSB]
 234  0B115                          FETCH s1, 15[IaccuMSB]
 235  10080                          ADD s0, s8
 236  12190                          ADDCY s1, s9
 237  2F016                          STORE s0, 16[IaccuLSB]
 238  2F115                          STORE s1, 15[IaccuMSB]
 239  25000                          RETURN 
 23A  2024A                 doQplus: CALL 24A[doMult]
 23B  0B018                          FETCH s0, 18[QaccuLSB]
 23C  0B117                          FETCH s1, 17[QaccuMSB]
 23D  10080                          ADD s0, s8
 23E  12190                          ADDCY s1, s9
 23F  2F018                          STORE s0, 18[QaccuLSB]
 240  2F117                          STORE s1, 17[QaccuMSB]
 241  25000                          RETURN 
 242  2024A                doQminus: CALL 24A[doMult]
 243  0B018                          FETCH s0, 18[QaccuLSB]
 244  0B117                          FETCH s1, 17[QaccuMSB]
 245  18080                          SUB s0, s8
 246  1A190                          SUBCY s1, s9
 247  2F018                          STORE s0, 18[QaccuLSB]
 248  2F117                          STORE s1, 17[QaccuMSB]
 249  25000                          RETURN 
 24A                                 ; History signal is first output to SignalMSB and SignalLSB, the signal is then multiplied by the coefficient (provided in s6,7 - LSB,MSB) and the result is returned in s8,9 (LSB,MSB)
 24A  20256                  doMult: CALL 256[GetRovingHistoryValues]
 24B  2D106                          OUTPUT s1, 06[SignalMSB]
 24C  2D007                          OUTPUT s0, 07[SignalLSB]                       ; Historical signal sent to multiplier
 24D  2D704                          OUTPUT s7, 04[CoeffMSB]
 24E  2D605                          OUTPUT s6, 05[CoeffLSB]
 24F  01000                          LOAD s0, 00
 250  01000                          LOAD s0, 00
 251  01000                          LOAD s0, 00                                    ; wait a bit (8 clock cycles enough?)
 252  01000                          LOAD s0, 00
 253  09904                          INPUT s9, 04[MltplyMSB]
 254  09805                          INPUT s8, 05[MltplyLSB]
 255  25000                          RETURN 
 256  0A150  GetRovingHistoryValues: FETCH s1, (s5)                                 ; Historical SignalMSB
 257  11501                          ADD s5, 01
 258  0A050                          FETCH s0, (s5)                                 ; Historical SignalLSB
 259  19501                          SUB s5, 01                                     ; return s5 vlue as there will be another mult before updating s5!!
 25A  25000                          RETURN 
 25B                                 ; To reset LVptr to start of history rolling buffer space. LVptr is 'Last Value Pointer'
 25B  01446              resetLVptr: LOAD s4, 46[HistoryStart]
 25C  25000                          RETURN 
 25D                                 ; and Rptr (Rptr is 'Roving Pointer'), next value (back 2 places), using advance of diff (sA) diff takes even values 0-40 inclusive (10 steps, ie 11 values, should never go beyond!, at each value conjugate point is also used. 11 value is diff=20 repeats itself at conjugate point)
 25D  11A02             AdvanceRptr: ADD sA, 02                                     ; advance diff (goes from 0 to 20)
 25E  20260                          CALL 260[UpdateRptr]
 25F  25000                          RETURN 
 260                                 ; uses value of diff to update value of Rptr
 260  00540              UpdateRptr: LOAD s5, s4                                    ; put LVptr in Rptr
 261  185A0                          SUB s5, sA                                     ; take off value of diff (sA)
 262  1D546                          COMPARE s5, 46[HistoryStart]
 263  3D000                          RETURN NC                                      ; if not gone below bottom of buffer return!, else....
 264  1152A                          ADD s5, 2A[42'd]                               ; send up again
 265  25000                          RETURN 
 266                                 ; - acts on diff (sA)
 266  01028           conjugateDiff: LOAD s0, 28[40'd]
 267  180A0                          SUB s0, sA                                     ; 40-sA
 268  00A00                          LOAD sA, s0                                    ; so sA is conjugate eg: 0->40,40->0, 20->20 etc
 269  20260                          CALL 260[UpdateRptr]                           ; calculate corresponding Rptr
 26A  25000                          RETURN 
 26B                                 ; the negative case means when the roving ptr is less than LVptr - is it done OK above 10 lines? diff is always positive (Rptr less than LVptr)
 26B                                 ; conjugateneg:
 26B                                 ; RET
 26B                                 ; Takes value in s5 and converts to 2 ascii codes which are sent to the user picoblaze.
 26B  2031D             Export2User: CALL 31D[Byte2Chars]
 26C  2D603                          OUTPUT s6, 03[CmdToUser]
 26D  2D703                          OUTPUT s7, 03[CmdToUser]
 26E  0100D                          LOAD s0, 0D[13'd]                              ; terminate with CR
 26F  2D003                          OUTPUT s0, 03[CmdToUser]
 270  0100A                          LOAD s0, 0A[10'd]                              ; and with LF
 271  2D003                          OUTPUT s0, 03[CmdToUser]
 272  25000                          RETURN 
 273                                 ; Takes 16 bit value in s6,s7 (MSB,LSB) and outputs to the archive memory (write enabled and selected by user picoblaze)
 273  2D60B             ArchiveData: OUTPUT s6, 0B[Data2archiveLSB]
 274  2D70A                          OUTPUT s7, 0A[Data2archiveMSB]
 275  25000                          RETURN 
 276                                 ; Frequency works out the phase increment - (this is to ~7 bit precission, but using LSB could get 8 bit?)
 276                                 ; Takes phase in s4 (and s5) and uses old phase value from scratchpad (which is then updated). The phase increment is returned in s4.
 276  0B010               Frequency: FETCH s0, 10[OldPhaseMSB]
 277  2F410                          STORE s4, 10[OldPhaseMSB]
 278  18400                          SUB s4, s0
 279  25000                          RETURN 
 27A                                 ; CORDIC  Takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
 27A                                 ; Useable range is for I and Q up to about +/-$3000
 27A  01400                  cordic: LOAD s4, 00
 27B  01500                          LOAD s5, 00
 27C  1D180                          COMPARE s1, 80[128'd]
 27D  3C2B1                          CALL NC, 2B1[rotate90]                         ; if I negative then need to bring back into RH 2 quadrants.
 27E                                 ; now enter loop
 27E  01800                          LOAD s8, 00                                    ; counter of times to iterate.
 27F  00710              cordicloop: LOAD s7, s1                                    ; temporary store for I
 280  00600                          LOAD s6, s0                                    ; temp store
 281  1D380                          COMPARE s3, 80[128'd]                          ; is Q negative?
 282  3E291                          JUMP NC, 291[posrotate]                        ; if negative rotate positive
 283  00A20               negrotate: LOAD sA, s2
 284  00B30                          LOAD sB, s3                                    ; put Q into working registers
 285  202AA                          CALL 2AA[shift]                                ; shift Q by the amount in s8
 286  100A0                          ADD s0, sA                                     ; add shifted Q to I
 287  121B0                          ADDCY s1, sB
 288  00A60                          LOAD sA, s6                                    ; prepare working registers (sA,sB) with original value of I
 289  00B70                          LOAD sB, s7
 28A  202AA                          CALL 2AA[shift]
 28B  182A0                          SUB s2, sA
 28C  1A3B0                          SUBCY s3, sB
 28D  202A2                          CALL 2A2[GetPhaseIncrement]
 28E  184A0                          SUB s4, sA
 28F  1A5B0                          SUBCY s5, sB
 290  2229E                          JUMP 29E[testcordicend]
 291  00A20               posrotate: LOAD sA, s2
 292  00B30                          LOAD sB, s3                                    ; put Q into working registers
 293  202AA                          CALL 2AA[shift]                                ; shift Q by the amount in s8
 294  180A0                          SUB s0, sA                                     ; add shifted Q to I
 295  1A1B0                          SUBCY s1, sB
 296  00A60                          LOAD sA, s6                                    ; prepare working registers with original value of I
 297  00B70                          LOAD sB, s7
 298  202AA                          CALL 2AA[shift]
 299  102A0                          ADD s2, sA
 29A  123B0                          ADDCY s3, sB
 29B  202A2                          CALL 2A2[GetPhaseIncrement]
 29C  104A0                          ADD s4, sA
 29D  125B0                          ADDCY s5, sB
 29E  11801           testcordicend: ADD s8, 01
 29F  1D809                          COMPARE s8, 09[m_plus_1]                       ;m + 1
 2A0  3A27F                          JUMP C, 27F[cordicloop]
 2A1  25000                          RETURN 
 2A2                                 ; routine to lookup from the cordic look up table (scratchpad), the phase increment - stored as 8 bits at the location pointed to be s8, returned as 16 bits in sA and sB
 2A2                                 ; sB is MSB
 2A2  0AB80       GetPhaseIncrement: FETCH sB, (s8)
 2A3  14B0E                          SR0 sB
 2A4  14A08                          SRA sA
 2A5  14B0E                          SR0 sB
 2A6  14A08                          SRA sA
 2A7  14B0E                          SR0 sB
 2A8  14A08                          SRA sA                                         ; This multiplies the 8 bit stored value by 32 so that max scratchpad value 255->255*32 equivalent to 44.82degrees
 2A9  25000                          RETURN 
 2AA  00980                   shift: LOAD s9, s8
 2AB  1D900               shiftloop: COMPARE s9, 00
 2AC  31000                          RETURN Z
 2AD  19901                          SUB s9, 01
 2AE  14B0A                          SRX sB
 2AF  14A08                          SRA sA
 2B0  222AB                          JUMP 2AB[shiftloop]
 2B1  00710                rotate90: LOAD s7, s1                                    ; temporary store for I
 2B2  00600                          LOAD s6, s0                                    ; temp store
 2B3  1D380                          COMPARE s3, 80[128'd]                          ; is Q negative?
 2B4  3E2BE                          JUMP NC, 2BE[add90]                            ; if negative add 90
 2B5  00130                   sub90: LOAD s1, s3
 2B6  00020                          LOAD s0, s2                                    ; I=Q
 2B7  01200                          LOAD s2, 00
 2B8  01300                          LOAD s3, 00
 2B9  18260                          SUB s2, s6
 2BA  1A370                          SUBCY s3, s7                                   ; Q=-I
 2BB  19400                          SUB s4, 00[half_pi_LSB]
 2BC  1B540                          SUBCY s5, 40[half_pi_MSB]
 2BD  25000                          RETURN 
 2BE  01100                   add90: LOAD s1, 00
 2BF  01000                          LOAD s0, 00
 2C0  18020                          SUB s0, s2
 2C1  1A130                          SUBCY s1, s3                                   ; I=-Q
 2C2  00260                          LOAD s2, s6
 2C3  00370                          LOAD s3, s7                                    ; Q=I
 2C4  01400                          LOAD s4, 00[half_pi_LSB]
 2C5  01540                          LOAD s5, 40[half_pi_MSB]
 2C6  25000                          RETURN 
 2C7  0B112            Transmitmode: FETCH s1, 12[State]
 2C8  05102                          OR s1, 02
 2C9  2F112                          STORE s1, 12[State]                            ; set bit 1
 2CA  0B10E                          FETCH s1, 0E[AGCvalue]
 2CB  2F171                          STORE s1, 71[AGCvalueRX]
 2CC  0B170                          FETCH s1, 70[AGCvalueTX]                       ;recovers last used value for AGCvalur in this mode
 2CD  2F10E                          STORE s1, 0E[AGCvalue]
 2CE  25000                          RETURN 
 2CF                                 ;Streammode:   CALL Transmitmode
 2CF                                 ;     FETCH     s1, State
 2CF                                 ;                   OR        s1, 4
 2CF                                 ;                  STORE     s1, State           ; set bit 2
 2CF                                 ;     RET
 2CF                                 ;GetUartValues:  CALL      Get2Chars     ;Changed name of this routine
 2CF                                 ;     LOAD   s1,$AA     ;rough value
 2CF                                 ;     LOAD   s2,s5      ;now put into top byte
 2CF                                 ;     SRX    s2
 2CF                                 ;     SRA    s1      ;divide signal by 2
 2CF                                 ;     SRX    s2
 2CF                                 ;     SRA    s1      ;divide signal by 2 again
 2CF                                 ;     LOAD    s0,$AA      ;set lowest bits to rough value
 2CF                                 ;        RET
 2CF  0B10E          GrabTXAGCvalue: FETCH s1, 0E[AGCvalue]
 2D0  2F170                          STORE s1, 70[AGCvalueTX]
 2D1  25000                          RETURN 
 2D2  0B112             Receivemode: FETCH s1, 12[State]
 2D3  031FD                          AND s1, FD[253'd]                              ; 255 - 2
 2D4  2F112                          STORE s1, 12[State]                            ; reset bit 1
 2D5  0B10E                          FETCH s1, 0E[AGCvalue]
 2D6  2F170                          STORE s1, 70[AGCvalueTX]
 2D7  0B171                          FETCH s1, 71[AGCvalueRX]                       ;recovers last used value for AGCvalur in this mode
 2D8  2F10E                          STORE s1, 0E[AGCvalue]
 2D9  25000                          RETURN 
 2DA  011F0            BlockDSPpico: LOAD s1, F0[240'd]
 2DB  2D102                          OUTPUT s1, 02[SSBAmp]                          ; Set signal amp to high
 2DC  01100                          LOAD s1, 00
 2DD  2D10D                          OUTPUT s1, 0D[PhaseIncrement]                  ;Make sure phase doesn't wander
 2DE  09003                          INPUT s0, 03[Command]                          ; Check if FIFO character present
 2DF  1D080                          COMPARE s0, 80[128'd]                          ; is there a character?
 2E0  3E2DA                          JUMP NC, 2DA[BlockDSPpico]                     ; no command received so carry on blocking
 2E1  202F9                          CALL 2F9[GetFifoChar]                          ;is command so get charcter
 2E2  1D052                          COMPARE s0, 52[82'd]                           ; character R
 2E3  31000                          RETURN Z                                       ;escape when R received from User Pico
 2E4  222DA                          JUMP 2DA[BlockDSPpico]
 2E5                                 ; Get fifo command and act on it.
 2E5                   Respond2Fifo: 
 2E5                                 ;         FETCH     s0,State
 2E5                                 ;     AND    s0,04
 2E5                                 ;     COMP   s0,04        ;is this stream mode
 2E5                                 ;     RETURN Z       ;if so then stick (no backing out!)
 2E5  202F9                          CALL 2F9[GetFifoChar]
 2E6                                 ;     COMPARE   s0,51'd       ;character 3
 2E6                                 ;     CALL   Z,Streammode
 2E6  1D032                          COMPARE s0, 32[50'd]                           ; character 2
 2E7  302CF                          CALL Z, 2CF[GrabTXAGCvalue]                    ;need to get this before userpico sends warble
 2E8  1D031                          COMPARE s0, 31[49'd]                           ; character 1
 2E9  302C7                          CALL Z, 2C7[Transmitmode]
 2EA  1D030                          COMPARE s0, 30[48'd]                           ; character 0
 2EB  302D2                          CALL Z, 2D2[Receivemode]
 2EC  1D047                          COMPARE s0, 47[71'd]                           ; character G (request for AGCvalue info from userpico)
 2ED  302F3                          CALL Z, 2F3[SendGParamBack]
 2EE  1D053                          COMPARE s0, 53[83'd]                           ; character S (request for AVEsignal info from userpico)
 2EF  302F6                          CALL Z, 2F6[SendSParamBack]
 2F0  1D042                          COMPARE s0, 42[66'd]                           ; character B (block)
 2F1  302DA                          CALL Z, 2DA[BlockDSPpico]
 2F2  25000                          RETURN 
 2F3                                 ;This can be adjusted for de-bugging AGCvalue
 2F3  0B50E          SendGParamBack: FETCH s5, 0E[AGCvalue]
 2F4  2026B                          CALL 26B[Export2User]
 2F5  25000                          RETURN 
 2F6                                 ;This can be adjusted for de-bugging AVEsignal
 2F6  005F0          SendSParamBack: LOAD s5, sF[AveSignalUSB]
 2F7  2026B                          CALL 26B[Export2User]
 2F8  25000                          RETURN 
 2F9                                 ; Routine to recover a character from the FIFO in s0
 2F9  01020             GetFifoChar: LOAD s0, 20[AckFIFO]
 2FA  2D00C                          OUTPUT s0, 0C[Controlbits]
 2FB  01020                          LOAD s0, 20[AckFIFO]                           ; Wait
 2FC  09003                          INPUT s0, 03[Command]                          ; now get my character
 2FD  0307F                          AND s0, 7F                                     ; mask off top bit
 2FE  25000                          RETURN 
 2FF                                 ; routine to look at command input and recover 2 characters and return the byte they represent in s5.
 2FF  09603               Get2Chars: INPUT s6, 03[Command]
 300  1D680                          COMPARE s6, 80[128'd]                          ; if greater than 128, then no character
 301  3E2FF                          JUMP NC, 2FF[Get2Chars]
 302  202F9                          CALL 2F9[GetFifoChar]
 303  00600                          LOAD s6, s0
 304  09703              Get2ndChar: INPUT s7, 03[Command]
 305  1D780                          COMPARE s7, 80[128'd]                          ; if greater than 128, then no character
 306  3E304                          JUMP NC, 304[Get2ndChar]
 307  202F9                          CALL 2F9[GetFifoChar]
 308  00700                          LOAD s7, s0
 309  2230A                          JUMP 30A[Chars2Byte]
 30A                                 ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 30A  00860              Chars2Byte: LOAD s8, s6
 30B  20315                          CALL 315[Get4bits]
 30C  00580                          LOAD s5, s8
 30D  14506                          SL0 s5
 30E  14506                          SL0 s5
 30F  14506                          SL0 s5
 310  14506                          SL0 s5                                         ; put these 4 bits to MSBs
 311  00870                          LOAD s8, s7
 312  20315                          CALL 315[Get4bits]
 313  10580                          ADD s5, s8
 314  25000                          RETURN 
 315                                 ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 315  1D83C                Get4bits: COMPARE s8, 3C[60'd]                           ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 316  3A31A                          JUMP C, 31A[char0_9]
 317  19837                          SUB s8, 37[55'd]                               ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 318  0380F                          AND s8, 0F                                     ; make sure only return 4 bits
 319  25000                          RETURN 
 31A  19830                 char0_9: SUB s8, 30[48'd]
 31B  0380F                          AND s8, 0F                                     ; make sure only return 4 bits
 31C  25000                          RETURN 
 31D                                 ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 31D  00850              Byte2Chars: LOAD s8, s5                                    ; assumes 8 bit data is in s5
 31E  1450E                          SR0 s5
 31F  1450E                          SR0 s5
 320  1450E                          SR0 s5
 321  1450E                          SR0 s5                                         ; get first hex character
 322  20329                          CALL 329[GetChar]
 323  00650                          LOAD s6, s5                                    ; first ascii char
 324  00580                          LOAD s5, s8
 325  0350F                          AND s5, 0F
 326  20329                          CALL 329[GetChar]                              ; send to LCD or UART
 327  00750                          LOAD s7, s5                                    ; second ascii char
 328  25000                          RETURN 
 329                                 ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 329  1950A                 GetChar: SUB s5, 0A[10'd]                               ; Test if s5 greater than 9
 32A  3A32D                          JUMP C, 32D[is_0_9]                            ; Hex character is 0_9
 32B  11541                          ADD s5, 41[65'd]                               ; offset for Ascii code 'A'
 32C  25000                          RETURN 
 32D  1150A                  is_0_9: ADD s5, 0A[10'd]                               ; return to range 0-9
 32E  11530                          ADD s5, 30[48'd]                               ; offset to Ascii code for '0'
 32F  25000                          RETURN 
 330                                 ; Registers used s0, s1, s2, s3, s4 and s5.
 330                                 ;
 330  01500                delay_1s: LOAD s5, 00                                    ; clear cycle counter
 331  01400                          LOAD s4, 00
 332  20343                 wait_1s: CALL 343[delay_1ms]
 333  11401                          ADD s4, 01                                     ; increment cycle counter
 334  13500                          ADDCY s5, 00
 335  1D4E8                          COMPARE s4, E8[count_1000_lsb]                 ; test for 1000ms
 336  36332                          JUMP NZ, 332[wait_1s]
 337  1D503                          COMPARE s5, 03[count_1000_msb]
 338  36332                          JUMP NZ, 332[wait_1s]
 339  25000                          RETURN 
 33A                                 ;
 33A                                 ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 33A                                 ;
 33A                                 ;
 33A                                 ; Registers used s0, s1, s2, s3 and s4.
 33A                                 ;
 33A  2033E             delay_300ms: CALL 33E[delay_100ms]
 33B  2033E             delay_200ms: CALL 33E[delay_100ms]
 33C  2033E                          CALL 33E[delay_100ms]
 33D  25000                          RETURN 
 33E                                 ;
 33E                                 ; Delay of approximately 100ms used for switch debounce
 33E                                 ;
 33E                                 ; Registers used s0, s1, s2, s3 and s4.
 33E                                 ;
 33E  01464             delay_100ms: LOAD s4, 64                                    ; repeat 1ms delay 100 times
 33F  20343              wait_100ms: CALL 343[delay_1ms]
 340  19401                          SUB s4, 01
 341  3633F                          JUMP NZ, 33F[wait_100ms]
 342  25000                          RETURN 
 343                                 ;
 343                                 ; Delay of approximately 1ms required by LCD display
 343                                 ;
 343                                 ; Registers used s0, s1, s2 and s3.
 343                                 ;
 343  01300               delay_1ms: LOAD s3, 00                                    ; clear cycle counter
 344  01200                          LOAD s2, 00
 345  20352                wait_1ms: CALL 352[delay_1us]
 346  11201                          ADD s2, 01                                     ; increment cycle counter
 347  13300                          ADDCY s3, 00
 348  1D2E8                          COMPARE s2, E8[count_1000_lsb]                 ; test for 1000us
 349  36345                          JUMP NZ, 345[wait_1ms]
 34A  1D303                          COMPARE s3, 03[count_1000_msb]
 34B  36345                          JUMP NZ, 345[wait_1ms]
 34C  25000                          RETURN 
 34D                                 ;
 34D                                 ; Delay of approximately 50us required by LCD display
 34D                                 ;
 34D                                 ; Registers used s0 and s1.
 34D                                 ;
 34D  01132              delay_50us: LOAD s1, 32[50'd]                              ; repeat 1us delay 50 times
 34E  20352               wait_50us: CALL 352[delay_1us]
 34F  19101                          SUB s1, 01
 350  3634E                          JUMP NZ, 34E[wait_50us]
 351  25000                          RETURN 
 352                                 ; Delay of approximately 1us used to provide timing reference for
 352                                 ; LCD operations. This must be adjusted to reflect the clock
 352                                 ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 352                                 ;
 352                                 ; The software delay loop is formed using register s0. This register
 352                                 ; must be loaded with an integer value close to the result of....
 352                                 ;
 352                                 ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 352                                 ;
 352                                 ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 352                                 ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 352                                 ; operation will become lower than the 100KHz target intended.
 352                                 ;
 352                                 ; Register used s0.
 352                                 ;
 352  0100C               delay_1us: LOAD s0, 0C[delay_1us_constant]                ; delay value of 12 decimal for a 50MHz clock
 353  19001                wait_1us: SUB s0, 01
 354  36353                          JUMP NZ, 353[wait_1us]
 355  25000                          RETURN 
 356                                 ;
 356                                 ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\Users\gnaylor\Dropbox\N3workingG\TE0722Rebuild\DSPprogN3GVA5.psm



List of defined constants

 CONSTANT name         Value        Source PSM File

 timestamp_hours       17'd         
 timestamp_minutes     41'd         
 timestamp_seconds     44'd         
 datestamp_year        15'd         
 datestamp_month       12'd         
 datestamp_day         13'd         
 NUL                   00           
 BEL                   07           
 BS                    08           
 HT                    09           
 LF                    0A           
 VT                    0B           
 CR                    0D           
 ESC                   1B           
 DEL                   7F           
 DCS                   90           
 ST                    9C           
 AGClowthreshold       6'd          DSPprogN3GVA5.psm
 AGClowthreshold2      3'd          DSPprogN3GVA5.psm
 AGCInitial            8'd          DSPprogN3GVA5.psm
 AGCuppthreshold       10'd         DSPprogN3GVA5.psm
 AGCuppthreshold2      15'd         DSPprogN3GVA5.psm
 AGCuppthreshold4      22'd         DSPprogN3GVA5.psm
 delay_1us_constant    12'd         DSPprogN3GVA5.psm
 m                     8'd          DSPprogN3GVA5.psm
 m_plus_1              9'd          DSPprogN3GVA5.psm
 count_1000_lsb        E8           DSPprogN3GVA5.psm
 count_1000_msb        03           DSPprogN3GVA5.psm
 half_pi_LSB           00           DSPprogN3GVA5.psm
 half_pi_MSB           40           DSPprogN3GVA5.psm
 audioTest             2'd          DSPprogN3GVA5.psm
 StrtToneAInc          9F           DSPprogN3GVA5.psm
 StrtToneBInc          69           DSPprogN3GVA5.psm
 StopToneAInc          5A           DSPprogN3GVA5.psm
 StopToneBInc          78           DSPprogN3GVA5.psm
 coeffI0MSB            F6           DSPprogN3GVA5.psm
 coeffI0LSB            92           DSPprogN3GVA5.psm
 coeffI1MSB            F4           DSPprogN3GVA5.psm
 coeffI1LSB            8A           DSPprogN3GVA5.psm
 coeffI2MSB            F2           DSPprogN3GVA5.psm
 coeffI2LSB            CC           DSPprogN3GVA5.psm
 coeffI3MSB            F1           DSPprogN3GVA5.psm
 coeffI3LSB            77           DSPprogN3GVA5.psm
 coeffI4MSB            F0           DSPprogN3GVA5.psm
 coeffI4LSB            A1           DSPprogN3GVA5.psm
 coeffI5MSB            40           DSPprogN3GVA5.psm
 coeffI5LSB            00           DSPprogN3GVA5.psm
 coeffQ0MSB            00           DSPprogN3GVA5.psm
 coeffQ0LSB            A7           DSPprogN3GVA5.psm
 coeffQ1MSB            05           DSPprogN3GVA5.psm
 coeffQ1LSB            2D           DSPprogN3GVA5.psm
 coeffQ2MSB            0C           DSPprogN3GVA5.psm
 coeffQ2LSB            83           DSPprogN3GVA5.psm
 coeffQ3MSB            1B           DSPprogN3GVA5.psm
 coeffQ3LSB            4F           DSPprogN3GVA5.psm
 coeffQ4MSB            5C           DSPprogN3GVA5.psm
 coeffQ4LSB            2F           DSPprogN3GVA5.psm
 AudioMSB              0'd          DSPprogN3GVA5.psm
 AudioLSB              1'd          DSPprogN3GVA5.psm
 Strobe                2'd          DSPprogN3GVA5.psm
 Command               3'd          DSPprogN3GVA5.psm
 MltplyMSB             4'd          DSPprogN3GVA5.psm
 MltplyLSB             5'd          DSPprogN3GVA5.psm
 BTaudioMSB            6'd          DSPprogN3GVA5.psm
 BTaudioLSB            7'd          DSPprogN3GVA5.psm
 RAMdataMSB            8'd          DSPprogN3GVA5.psm
 RAMdataLSB            9'd          DSPprogN3GVA5.psm
 Status                10'd         DSPprogN3GVA5.psm
 MSBAudio              0'd          DSPprogN3GVA5.psm
 LSBAudio              1'd          DSPprogN3GVA5.psm
 SSBAmp                2'd          DSPprogN3GVA5.psm
 CmdToUser             3'd          DSPprogN3GVA5.psm
 CoeffMSB              4'd          DSPprogN3GVA5.psm
 CoeffLSB              5'd          DSPprogN3GVA5.psm
 SignalMSB             6'd          DSPprogN3GVA5.psm
 SignalLSB             7'd          DSPprogN3GVA5.psm
 Data2archiveMSB       10'd         DSPprogN3GVA5.psm
 Data2archiveLSB       11'd         DSPprogN3GVA5.psm
 Controlbits           12'd         DSPprogN3GVA5.psm
 EnMult                1'd          DSPprogN3GVA5.psm
 AckFIFO               32'd         DSPprogN3GVA5.psm
 PhaseIncrement        13'd         DSPprogN3GVA5.psm
 AudioFreqLSB          14'd         DSPprogN3GVA5.psm
 AudioPhaseMSB         15'd         DSPprogN3GVA5.psm
 AudioPhaseLSB         16'd         DSPprogN3GVA5.psm
 EnableSpeaker         17'd         DSPprogN3GVA5.psm
 MUXport               18'd         DSPprogN3GVA5.psm
 StartToneA            19'd         DSPprogN3GVA5.psm
 StartToneALong        20'd         DSPprogN3GVA5.psm
 StartToneB            21'd         DSPprogN3GVA5.psm
 StartToneBLong        22'd         DSPprogN3GVA5.psm
 StopToneA             23'd         DSPprogN3GVA5.psm
 StopToneALong         24'd         DSPprogN3GVA5.psm
 StopToneB             25'd         DSPprogN3GVA5.psm
 StopToneBLong         26'd         DSPprogN3GVA5.psm
 AmpMSB                10'd         DSPprogN3GVA5.psm
 AmpLSB                11'd         DSPprogN3GVA5.psm
 PhaseMSB              12'd         DSPprogN3GVA5.psm
 PhaseLSB              13'd         DSPprogN3GVA5.psm
 AGCvalue              14'd         DSPprogN3GVA5.psm
 VolSetting            15'd         DSPprogN3GVA5.psm
 OldPhaseMSB           16'd         DSPprogN3GVA5.psm
 AudioScratch          17'd         DSPprogN3GVA5.psm
 State                 18'd         DSPprogN3GVA5.psm
 LVPtr                 20'd         DSPprogN3GVA5.psm
 IaccuMSB              21'd         DSPprogN3GVA5.psm
 IaccuLSB              22'd         DSPprogN3GVA5.psm
 QaccuMSB              23'd         DSPprogN3GVA5.psm
 QaccuLSB              24'd         DSPprogN3GVA5.psm
 OldPhaseLSB           25'd         DSPprogN3GVA5.psm
 startsine             30'd         DSPprogN3GVA5.psm
 endsine               45'd         DSPprogN3GVA5.psm
 HistoryStart          70'd         DSPprogN3GVA5.psm
 HistoryStart42        112'd        DSPprogN3GVA5.psm
 AGCvalueTX            112'd        DSPprogN3GVA5.psm
 AGCvalueRX            113'd        DSPprogN3GVA5.psm
 AGCcounter            114'd        DSPprogN3GVA5.psm
 UARTBitshift          115'd        DSPprogN3GVA5.psm
 AveStrtToneAMSB_I     116'd        DSPprogN3GVA5.psm
 AveStrtToneALSB_I     117'd        DSPprogN3GVA5.psm
 AveStrtToneBMSB_I     118'd        DSPprogN3GVA5.psm
 AveStrtToneBLSB_I     119'd        DSPprogN3GVA5.psm
 AveStopToneAMSB_I     120'd        DSPprogN3GVA5.psm
 AveStopToneALSB_I     121'd        DSPprogN3GVA5.psm
 AveStopToneBMSB_I     122'd        DSPprogN3GVA5.psm
 AveStopToneBLSB_I     123'd        DSPprogN3GVA5.psm
 LongAveStrtToneAMSB_I 124'd        DSPprogN3GVA5.psm
 LongAveStrtToneALSB_I 125'd        DSPprogN3GVA5.psm
 LongAveStrtToneBMSB_I 126'd        DSPprogN3GVA5.psm
 LongAveStrtToneBLSB_I 127'd        DSPprogN3GVA5.psm
 LongAveStopToneAMSB_I 128'd        DSPprogN3GVA5.psm
 LongAveStopToneALSB_I 129'd        DSPprogN3GVA5.psm
 LongAveStopToneBMSB_I 130'd        DSPprogN3GVA5.psm
 LongAveStopToneBLSB_I 131'd        DSPprogN3GVA5.psm
 AveStrtToneAMSB_Q     132'd        DSPprogN3GVA5.psm
 AveStrtToneALSB_Q     133'd        DSPprogN3GVA5.psm
 AveStrtToneBMSB_Q     134'd        DSPprogN3GVA5.psm
 AveStrtToneBLSB_Q     135'd        DSPprogN3GVA5.psm
 AveStopToneAMSB_Q     136'd        DSPprogN3GVA5.psm
 AveStopToneALSB_Q     137'd        DSPprogN3GVA5.psm
 AveStopToneBMSB_Q     138'd        DSPprogN3GVA5.psm
 AveStopToneBLSB_Q     139'd        DSPprogN3GVA5.psm
 LongAveStrtToneAMSB_Q 140'd        DSPprogN3GVA5.psm
 LongAveStrtToneALSB_Q 141'd        DSPprogN3GVA5.psm
 LongAveStrtToneBMSB_Q 142'd        DSPprogN3GVA5.psm
 LongAveStrtToneBLSB_Q 143'd        DSPprogN3GVA5.psm
 LongAveStopToneAMSB_Q 144'd        DSPprogN3GVA5.psm
 LongAveStopToneALSB_Q 145'd        DSPprogN3GVA5.psm
 LongAveStopToneBMSB_Q 146'd        DSPprogN3GVA5.psm
 LongAveStopToneBLSB_Q 147'd        DSPprogN3GVA5.psm
 StrtToneAPtrMSB       148'd        DSPprogN3GVA5.psm
 StrtToneAPtrLSB       149'd        DSPprogN3GVA5.psm
 StrtToneBPtrMSB       150'd        DSPprogN3GVA5.psm
 StrtToneBPtrLSB       151'd        DSPprogN3GVA5.psm
 StopToneAPtrMSB       152'd        DSPprogN3GVA5.psm
 StopToneAPtrLSB       153'd        DSPprogN3GVA5.psm
 StopToneBPtrMSB       154'd        DSPprogN3GVA5.psm
 StopToneBPtrLSB       155'd        DSPprogN3GVA5.psm
 FirstToneInc          156'd        DSPprogN3GVA5.psm
 FirstToneInc02        158'd        DSPprogN3GVA5.psm
 FirstToneInc04        160'd        DSPprogN3GVA5.psm
 FirstToneInc06        162'd        DSPprogN3GVA5.psm
 NormalisedMagMSB      164'd        DSPprogN3GVA5.psm
 NormalisedMagLSB      165'd        DSPprogN3GVA5.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "13 Dec 2015"  
 timestamp$        "17:41:44"     



List of line labels

   Label                    Addr  Source PSM File

 * cold_start               000   DSPprogN3GVA5.psm
   AwaitAudioVal            049   DSPprogN3GVA5.psm
   AwaitRise                04D   DSPprogN3GVA5.psm
   BackfromTransmitting     064   DSPprogN3GVA5.psm
   Divide32                 08B   DSPprogN3GVA5.psm
   Divide4                  090   DSPprogN3GVA5.psm
   SpeakerOn                095   DSPprogN3GVA5.psm
   SpeakerOff               098   DSPprogN3GVA5.psm
 * AverageToneDemod         09C   DSPprogN3GVA5.psm
   DemodLoop                09E   DSPprogN3GVA5.psm
   DoAccumulate             106   DSPprogN3GVA5.psm
   negaccum                 10E   DSPprogN3GVA5.psm
   negdecrmnt               119   DSPprogN3GVA5.psm
   MultSigByLO              11F   DSPprogN3GVA5.psm
 * BackFromLOPos            121   DSPprogN3GVA5.psm
   BackFromLONeg            122   DSPprogN3GVA5.psm
   DolongAve                12D   DSPprogN3GVA5.psm
   LOisNeg                  140   DSPprogN3GVA5.psm
   MultiplyBy4              143   DSPprogN3GVA5.psm
   MultiplyBy2              146   DSPprogN3GVA5.psm
   MultiplyBy3              148   DSPprogN3GVA5.psm
   AudioDouble              14C   DSPprogN3GVA5.psm
 * Negvalue                 14E   DSPprogN3GVA5.psm
   islessthanneg31          153   DSPprogN3GVA5.psm
   islessthanneg63          157   DSPprogN3GVA5.psm
   Posvalue                 15B   DSPprogN3GVA5.psm
   ismorethan31             160   DSPprogN3GVA5.psm
   ismorethan63             164   DSPprogN3GVA5.psm
 * Divide2                  168   DSPprogN3GVA5.psm
   TransmitAudio            16B   DSPprogN3GVA5.psm
 * SkipNoBT                 16B   DSPprogN3GVA5.psm
   OutAmp                   17B   DSPprogN3GVA5.psm
   BiggerThan63             190   DSPprogN3GVA5.psm
   BiggerThan128            194   DSPprogN3GVA5.psm
   Abs16Val                 197   DSPprogN3GVA5.psm
   absval                   1A0   DSPprogN3GVA5.psm
   makeposval               1A3   DSPprogN3GVA5.psm
   invertval                1A7   DSPprogN3GVA5.psm
   increaseAGC              1AB   DSPprogN3GVA5.psm
   increaseAGC2             1B0   DSPprogN3GVA5.psm
   increaseAGC4             1B5   DSPprogN3GVA5.psm
   decreaseAGC              1B8   DSPprogN3GVA5.psm
   decreaseAGC2             1BD   DSPprogN3GVA5.psm
   AGC                      1C2   DSPprogN3GVA5.psm
   decrease3dB              1C8   DSPprogN3GVA5.psm
   decrease1_5dB            1D7   DSPprogN3GVA5.psm
 * AGCtest                  1E4   DSPprogN3GVA5.psm
   AGClooptst               1E8   DSPprogN3GVA5.psm
   PerformFIR               1EF   DSPprogN3GVA5.psm
   Ibussiness               226   DSPprogN3GVA5.psm
   Qbussiness               22C   DSPprogN3GVA5.psm
   doIplus                  232   DSPprogN3GVA5.psm
   doQplus                  23A   DSPprogN3GVA5.psm
   doQminus                 242   DSPprogN3GVA5.psm
   doMult                   24A   DSPprogN3GVA5.psm
   GetRovingHistoryValues   256   DSPprogN3GVA5.psm
   resetLVptr               25B   DSPprogN3GVA5.psm
   AdvanceRptr              25D   DSPprogN3GVA5.psm
   UpdateRptr               260   DSPprogN3GVA5.psm
   conjugateDiff            266   DSPprogN3GVA5.psm
   Export2User              26B   DSPprogN3GVA5.psm
 * ArchiveData              273   DSPprogN3GVA5.psm
 * Frequency                276   DSPprogN3GVA5.psm
   cordic                   27A   DSPprogN3GVA5.psm
   cordicloop               27F   DSPprogN3GVA5.psm
 * negrotate                283   DSPprogN3GVA5.psm
   posrotate                291   DSPprogN3GVA5.psm
   testcordicend            29E   DSPprogN3GVA5.psm
   GetPhaseIncrement        2A2   DSPprogN3GVA5.psm
   shift                    2AA   DSPprogN3GVA5.psm
   shiftloop                2AB   DSPprogN3GVA5.psm
   rotate90                 2B1   DSPprogN3GVA5.psm
 * sub90                    2B5   DSPprogN3GVA5.psm
   add90                    2BE   DSPprogN3GVA5.psm
   Transmitmode             2C7   DSPprogN3GVA5.psm
   GrabTXAGCvalue           2CF   DSPprogN3GVA5.psm
   Receivemode              2D2   DSPprogN3GVA5.psm
   BlockDSPpico             2DA   DSPprogN3GVA5.psm
   Respond2Fifo             2E5   DSPprogN3GVA5.psm
   SendGParamBack           2F3   DSPprogN3GVA5.psm
   SendSParamBack           2F6   DSPprogN3GVA5.psm
   GetFifoChar              2F9   DSPprogN3GVA5.psm
   Get2Chars                2FF   DSPprogN3GVA5.psm
   Get2ndChar               304   DSPprogN3GVA5.psm
   Chars2Byte               30A   DSPprogN3GVA5.psm
   Get4bits                 315   DSPprogN3GVA5.psm
   char0_9                  31A   DSPprogN3GVA5.psm
   Byte2Chars               31D   DSPprogN3GVA5.psm
   GetChar                  329   DSPprogN3GVA5.psm
   is_0_9                   32D   DSPprogN3GVA5.psm
 * delay_1s                 330   DSPprogN3GVA5.psm
   wait_1s                  332   DSPprogN3GVA5.psm
 * delay_300ms              33A   DSPprogN3GVA5.psm
 * delay_200ms              33B   DSPprogN3GVA5.psm
   delay_100ms              33E   DSPprogN3GVA5.psm
   wait_100ms               33F   DSPprogN3GVA5.psm
   delay_1ms                343   DSPprogN3GVA5.psm
   wait_1ms                 345   DSPprogN3GVA5.psm
 * delay_50us               34D   DSPprogN3GVA5.psm
   wait_50us                34E   DSPprogN3GVA5.psm
   delay_1us                352   DSPprogN3GVA5.psm
   wait_1us                 353   DSPprogN3GVA5.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            170
 STAR              -

 AND              10
 OR                1
 XOR               -

 ADD              52
 ADDCY            19
 SUB              32
 SUBCY            12

 TEST              -
 TESTCY            -
 COMPARE          57
 COMPARECY         -

 SL0              19
 SL1               -
 SLX               -
 SLA              10
 RL                -
 SR0              11
 SR1               -
 SRX              22
 SRA              24
 RR                -

 REGBANK           -

 INPUT            11
 OUTPUT           38
 OUTPUTK           -

 STORE            61
 FETCH            61

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             40
 JUMP@             -
 CALL            121
 CALL@             -
 RETURN           78
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
