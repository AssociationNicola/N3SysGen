KCPSM6 Assembler log file for program 'Z:\home\gnaylor\Dropbox\N3SysGen\UserPico.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 06 Sep 2017
Assembly timestamp: 19:57:52

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 3BD hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 958
Memory locations available: 3138


Assembly listing

 Addr Code                          Instruction

 000                                ;GV0C add longer on warble for use with delayed mic audio and with delay 0.5s before turnoff warble
 000                                ;GV0B Getting ToneDetect link to ARM
 000                                ;GV0A redo Target levels in user and DSP for AGC
 000                                ;GV09 changed terminator caracter to LF rather than CR
 000                                ;GV08 lower audio volume control to about 0.8V (Prod7)
 000                                ;GV07 correct incorrect data archive and demod peak display problem (MSB/LSB mixup!)
 000                                ;GV06 Increase output amplitude of SSB in DSPpico on TX
 000                                ;GV05 Modified frequencies (MMCM and KeypadPico values) to work with 33.333MHz clock for production model (Apr 2012)
 000                                ;GV04 Now using mic preamp so need to fix AGCs
 000                                ;GV03 Mods to DSP to try and get volume load and saturate OutAmp properly
 000                                ;GV02 Halved AGC thresholds to avoid clipping SysGen v1.18
 000                                ;GV01 add redirect command SW for UART to patch through to BT module
 000                                ;GV01 Reduce Speaker volume AGC on startup
 000                                ;GV00 Reset GV to 0 for new TE0722 working version
 000                                ;GVA5 for TE0722, with RX/TX frequencies adjusted for 32.768MHz
 000                                ;GVA4 corrected DSPprog to not crash (AGC suddenly dropping)
 000                                ;GVA2 send demod level to LCD display
 000                                ;GVA0 Add temporary measures around line 510 to transmit values from DSPpico (of tone demod levels as ascii characters on to the LCD)
 000                                ;GV9A, correct Earth Loop setting incorrect and make immediate.
 000                                ; GV99 corrected Attenuator not adding 30 on level display in TX mode, add turn on pad and entenna select
 000                                ; GV98 More BT mic boost
 000                                ; GV97 corrected BT combination
 000                                ; GV96 drop ADC gain RX to 70% and TX to 50%
 000                                ; GV95 Frequency now set from keypad pico
 000                                ; GV94  24 Feb 2015 Pete  -  re-enable BT commands and add scratchpad clear
 000                                ; GV93 add code in KP pico and firmware to display ADC and demod level
 000                                ; GV92 add Pete's new BTcode with shorter inquiry time - but hadn't put in the script at the end of model propertes to get the correct mem files from Pete
 000                                ; line407 disable loran blank for 31kHz
 000                                ; GV91 increased ADC level 10dB by increasing RXAGClevel
 000                                ; GV90 Version to run at 31.008kHz so use 1323 ($52B) for TX and 10925 ($2AAD) for RX
 000                                ; GV51 Use DSP 51 to only attenuate on receive (which had clipping - but transmit was OK)
 000                                ; GV50 Adjusted DSP AGC back down as there was still clipping
 000                                ; GV4F Adjusted AGC thresholds in SP3E and DSPprogN3GV47 to improve clarity of speech
 000                                ; GV4D PMOD2 now used to control extra attenuation (~30dB)
 000                                ; GV4C back to TX_LOW but PMOD1 held low
 000                                ; GV4B For proto D with TX_high  output instead of TX_LOW
 000                                ; GV4A For ProtoD with new keypad
 000                                ; GV48 changed CheckADClevel routine - but still need to change display (KP pico code) to display signal level and gain value. No Beacon
 000                                ; GV46 BT present cuts audio - modified BT detect logic
 000                                ; GV45 Corrected resetting of AveSignalMSB to middle value so as to avoid double jump and increased allowable rang to avoid unnecessary jumps
 000                                ; GV44 Add SU command to set UART output streaming
 000                                ; GV43 Correct beacon phase wander in DSP pico code
 000                                ; GV42 As 41 but with UART testing bits removed
 000                                ; GV41 send DSP data to UART in normal loop and streaming loop
 000                                ; GV40 correct streaming mode bits and shift beacon mode check to end of loop
 000                                ; GV3F  Add UART streaming command for transmit - SS<xx> where xx is hex value of number of bits to shift the values Add GL command to get Loran blank rate
 000                                ; GV3E some work on AGCcounter to include sinewave addition, but mainly add command GS to get AveSignalMSB
 000                                ; GV3D change the way the AGC works in the DSP pico to speed up increasing attenuation if the signal is very strong
 000                                ; GV3C change pincode in BTText to 1234 for HFP profile
 000                                ; GV3A send prompt to DSPcore to grab AGCvalue and store just before the EOT warble + store ADCgain (lower 4 bits) for TX and RX modes (that will be used by CALL SetAnGain )
 000                                ; GV39 Includes Pete's BT code and new DSP AGC stuff (from GV38)
 000                                ; GV36 reduce initial ADC gain on tranmit (reduce mic gain)
 000                                ; GV35 Uses nw I_Q demodulator
 000                                ; GV33 Add delay to audio stream (reduce fdbk?) and use phase incrementing on TX.
 000                                ; GV32 Adjust AGCs
 000                                ; GV31 Now starting to use LPF in DSPprogN3WithLPF and has SL command to set Loran Blanking (SL01)
 000                                ; GV30 reduce RX ADC gain and increase TX (mic) gain.
 000                                ; GV27 Default Loran Blanking on
 000                                ; GV26 for N2 with Higher gain on DSP RF output and shorter beacon period
 000                                ; GV24 for N2
 000                                ; GV23 Corrected some of the RAM block writing issues
 000                                ; GV22 Correct loop not completing when no character! Now displays ADC gain setting on
 000                                ; GV21 use with keypad prog to inhibit pad scan and here send adc level info (should auto gain on ADC to keep between 30 and 100 ie ~$20 and ~$60)
 000                                ; GV20 Corrected non switching of ADC input to MIC!
 000                                ; GV1F Normal orientation of ADC inputs with auto BT audio switching
 000                                ; GV1E temporarily switch ADC input channel as op amp blown!
 000                                ; GV1D Heyphone but for prototype 2 (using TX_HIGH!!)
 000                                ; GV1C For HeyPhone
 000                                ; GV1A Correct flash writing errors to point to right memory address
 000                                ; GV1A
 000                                ; GV19 corrected phase interpretation of SSB encoding
 000                                ; GV18 Try dirac input
 000                                ; GV17 Add STT command to send test sinewave for transmit - Now removed March 2012
 000                                ; GV16 Worked on Beacon lockup, now starts with beacon, press button for ~6secs
 000                                ; GV14 try beacon again at startup
 000                                ; GV15 try to fix not stopping beacon issue (don't start with beacon!) - display mode value on LCD (send to KPpico)
 000                                ; GV13 no beacon
 000                                ; GV11 fix beacon mode so that DSP is blocked at frequency offset and fixed amp for ~1s when ending TX mode - also set Beacon mode on power up which stops when button pressed
 000                                ; Set ADC gain in initialisation properly to calibrate aswell.
 000                                ; GV10 Add ADC signal level monitoring and try phase SSB encoding again with 2x phase to SSB module
 000                                ; Command GL in version GV10 allows the signal level to be returned from the ADC
 000                                ; GV0F Use phase encoding
 000                                ; GV0E full 16 bit frequency coding of TX 29/8/11
 000                                ; GV0D With Beacon
 000                                ; GV0C add BT mic input
 000                                ; GV09 stopped sending r/T t seria; port an adjusted reading from KPfifo
 000                                ; GV08 Added facility to switch RX/TX from keypad
 000                                ; GV07  Increased sensitivity of touch pads June 11
 000                                ; May 26- try and modify so that it starts correctly when powerred up with user program
 000                                ; MayA 11 use PMOD 2 to switch serial port and activate keypad
 000                                ; May 11, add SAO command to set audio channel (00, for BT, 01 for radio transceiver)
 000                                ; March 2011 testing SPI interface:
 000                                ; commands
 000                                ; WREN $06 (enable writing)
 000                                ; WRDI $04 (disable writing)
 000                                ; FAST_READ $0B followed by 3 address bytes, 1 dummy byte and then n bytes to feed back data and leave last 2 values for readback
 000                                ; BERASE  $C7 (bulk erase) - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                                ; SE     $D8 (sector erase) followed by 3 address bytes, - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                                ; PP     $02 (page program) followed by 3 address bytes,  then n bytes of data to be written (need then to pulse Send2Flash by writing 16 to ProgramM)
 000                                ;
 000                                ; Example commands:
 000                                ; SMW0102030405060708090A     -writes values 1-10 to flash addresses from 800000
 000                                ; SMR800002 should read the bytes 03 and 02 ??
 000                                ; Now for Godil Board
 000                                ; Version for multi pico boot with shifted bit offsets on oport
 000                                CONSTANT Versionno, 0C               ;
 000                                CONSTANT InitialVolume, 133'd        ;lowerred volume
 000                                CONSTANT MinoxrVersionno, EE         ; Pete
 000                                ; CONSTANT TXType,       7E                 ; $7E for N2 and $80 for Heyphone
 000                                ; CONSTANT RXType,       46                 ; $46 for N2 and 55 for Heyphone)
 000                                CONSTANT Bmode, 00
 000                                ; Set thresholds for AGC
 000                                CONSTANT AGCupperRX, 32              ; Increased factor 2 on RX and TX with signal level monitor - increased RX 3 again from $18 (24 to 72, ie $48)
 000                                CONSTANT AGClowerRX, 12              ; was $0C, increased to 36=$24
 000                                CONSTANT AGCupperTX, 30              ;Quadrupled target TX values for ADC 17/4/17 dropped a bit July 2017 from 40 down to 30
 000                                CONSTANT AGClowerTX, 12
 000                                ; SAI Set analogue input SAI<xx>  xx=00 or 01
 000                                ; SAO Set audio Output source
 000                                ; SAS Set archive source SAS<xx>
 000                                ; SAG Set analogue gain SAG<xx>
 000                                ; SB set beacon mode
 000                                ; SRM set receive mode
 000                                ; SRF set receive frequency
 000                                ; STM set transmit mode
 000                                ; STF set transmit frequency
 000                                ; SAG   Set analogue gain, use: 51-5E + automatic calibration
 000                                ; SAS <value> - set archive source (0 or 1)
 000                                ; GA get archive
 000                                ; GT get status of touch
 000                                ; GV get version
 000                                ; GP get response from DSP
 000                                ; GB get response from BT
 000                                ; GKT get touch response from KP
 000                                ; March 2009, now using loading over BT, implement server commands
 000                                ; Dec 2008 - implementing on SSBN3.mdl
 000                                ; Test Spartan 3e board May 2007
 000                                ; Program for user interface: Pico 1
 000                                ; Load SP3E with bit file - spartan3e_adcrx_tx_cw.bit using USB download cable (+ImpacT)
 000                                ; Connect serial lead and send file for test program from Matlab using somethng like
 000                                ; LCDtestprog=getpblazidefile('LCDUartS3e.mem');
 000                                ; Send6bitInstructionsPico1
 000                                ;
 000                                ; Addresses of latched data
 000                                ; 0 Cmd Control Pico2
 000                                ; 1 UartTx
 000                                ; 2 Gain ChA (bits 0-2)
 000                                ; Gain ChB(bits 4-6)
 000                                ; 3 Instruction first 6bits (MSB)
 000                                ; 4 Instruction 2nd 6 bits
 000                                ; 5 Instruction 3rd 6 bits
 000                                ; 6 Program Address LSB
 000                                ; 7 Program Address upper 2 bits
 000                                ;  bit 2,3 and 4 decoded to either Write ROM1,Write ROM2,Write ROM3,Write ROM4 or reset picos
 000                                ;  bit 5-Enable archive
 000                                ;  bit 6-Select archive source
 000                                ;  bit 7 TX_HIGH
 000                                ; 10 Set_RXFreq LSbyte
 000                                ; 11 Set_RXFreq USbyte
 000                                ; 12 Set_TXFreq LSbyte
 000                                ; 13 Set_TXFreq USbyte
 000                                ; 14 Message character 1 -***Note these data ports are for writing characters at the address bus to the message RAM!!
 000                                ; 15 Message character 2
 000                                ; 16 Message character 3 - RAM is written on write to this port (last 6 bit character)
 000                                ; 17 Relay ctrl
 000                                ; 18 Battery monitor
 000                                CONSTANT delay_1us_constant, 12'd    ; Now 49.152MHz Value (13)19 or 12? decimal suitable for 50MHz clock or about 6 for 33MHz?
 000                                CONSTANT WREN, 06                    ; (enable writing)
 000                                CONSTANT FAST_READ, 0B               ; followed by 3 address bytes, 1 dummy byte and then n bytes to feed back data and leave last 2 values for readback
 000                                CONSTANT BERASE, C7                  ; (bulk erase) - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                                CONSTANT SER, D8                     ; (sector erase) followed by 3 address bytes, - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                                CONSTANT RDID, 9F
 000                                CONSTANT PP, 02                      ; (page program) followed by 3 address bytes,  then n bytes of data to be written (need then to pulse Send2Flash by writing 16 to CMD2DSP)
 000                                CONSTANT RDSR, 05
 000                                ; Registers
 000                                ;counter             EQU       sC                  ; Counter - for Acquisitions
 000                                ;ScratchPointer      EQU       sB                  ; pointer for decoding command in scratch memory
 000                                NAMEREG sC, counter                  ; Counter - for Acquisitions
 000                                NAMEREG sB, ScratchPointer           ; pointer for decoding command in scratch memory
 000                                ; Scratch pad
 000                                ; Locations 0-15 reserved for incoming command
 000                                CONSTANT Latch7, 16'd                ; This is the current value of an output control register (ProgramM) - used to control writing etc.
 000                                CONSTANT LastDSPbyte, 17'd
 000                                CONSTANT Mode, 18'd                  ; N3 status: bit 0 Beacon mode, bit 1 RX/TX mode, bit 2 Uart streaming mode (TX), bit 3 RX to UART streaming, bit 4 to set loop antenna input
 000                                CONSTANT ADCstate, 19'd              ; saves ADC state
 000                                CONSTANT SelectScratch, 20'd         ; used to store selections (archive source etc.)
 000                                CONSTANT ADCLevel, 21'd
 000                                CONSTANT ADCgain, 22'd               ; 0 means no output, 0E is max gain of 128. Upper 4 bits contain ADC config data
 000                                CONSTANT TX_F_MSB, 23'd              ; Store TX req (16 bits)
 000                                CONSTANT TX_F_LSB, 24'd
 000                                CONSTANT ADCAGCUpperThreshold, 25'd  ; Sets value for AGC on RAW input
 000                                CONSTANT ADCAGCLowerThreshold, 26'd  ; Sets value for AGC on RAW input
 000                                CONSTANT ADCGainTX, 27'd             ; Analogue gain for TX
 000                                CONSTANT ADCGainRX, 28'd             ; Analogue gain for RX
 000                                CONSTANT peteTXMode, 40'd            ; Pete's transmit mode flag
 000                                ;removed Attenuator state
 000                                ;;CONSTANT BluetoothXmit,   43                 ; from Pete's build - assumes large scratchpad
 000                                ; Input port
 000                                CONSTANT Uart_rx, 00
 000                                CONSTANT Uart_status, 01             ; Uart RX data bit0, Uart TX half full bit 1
 000                                ; bits 2:
 000                                ; Bit 2 BattMon comparator
 000                                ; Offsets:
 000                                CONSTANT BattMon, 4'd
 000                                CONSTANT ArchiveDataLSB, 2'd
 000                                CONSTANT ArchiveDataMSB, 3'd
 000                                CONSTANT DSPcmd, 4'd                 ; message from DSP unit
 000                                CONSTANT BTcmd, 5'd                  ; message from BT unit
 000                                CONSTANT KPcmd, 6'd                  ; message from KeyPad unit
 000                                CONSTANT TDcmd, 7'd                  ; message from Tone detect
 000                                ;CONSTANT DataReadback_1,  8'd                   ; message from KeyPad unit TEMP - DataReadback_1 from Flash
 000                                CONSTANT DSPRAMrdbkMSB, 9'd
 000                                CONSTANT DSPRAMrdbkLSB, 10'd
 000                                CONSTANT BTRAMrdbkMSB, 11'd
 000                                CONSTANT BTRAMrdbkLSB, 12'd
 000                                CONSTANT KPRAMrdbkMSB, 13'd
 000                                CONSTANT KPRAMrdbkLSB, 14'd
 000                                CONSTANT ADCSignalLevel, 15'd
 000                                ; Output ports
 000                                CONSTANT CMD2DSP, 00                 ; ALSO USED for data to write to SPI flash (sends write automatically)
 000                                CONSTANT UART_TX, 01
 000                                CONSTANT GainPD, 02                  ; Lower 4 bits: 1=0 gain to E=gain 128, bits 4-6 should be 101 and bit 7 is for calibration
 000                                ; Lower 4 bits gain, bits 4-6 for PD0-2 - PD bits should be set to 0101 (ie 5 hex) to enable everything
 000                                CONSTANT Instructiona, 03
 000                                CONSTANT Instructionb, 04
 000                                CONSTANT Instructionc, 05
 000                                CONSTANT ProgramL, 06
 000                                CONSTANT ProgramM, 07
 000                                ; bits 0 and 1 for address, subsequent 4 bits to select which pico to write (bits 2,3,4,5 decoded) - these 3 bits are decoded such that:
 000                                ; if bits 2:5 represent:
 000                                ; 1 - Write Inst1 (User pico instruction) - ie MSB of address should be ORed with 4.
 000                                ; 2 - Write Inst2 (DSP pico instruction) - ie MSB of address should be ORed with 8.
 000                                ; 3 - Write Inst3 (BT pico instruction) - ie MSB of address should be ORed with $0C.
 000                                ; 4 - Write Inst4 (KP pico instruction)
 000                                ; 5 - Write DSP RAM
 000                                ; 6 - Write BT RAM
 000                                ; 7 - Reset other picos
 000                                ; 8 - Write KP RAM
 000                                ; 9 - Send Flash fifo contents (written to on FlashDATA port) to FLASH chip
 000                                ; bit 6 enable archive, and bit 7 TXhigh
 000                                ;
 000                                CONSTANT EnArchive, 64'd
 000                                CONSTANT TX_HIGH, 128'd              ; bit 7
 000                                CONSTANT SelectArchiveSource, 8'd
 000                                CONSTANT Configure, 9'd
 000                                CONSTANT RXFreqMSB, 10'd             ; 769A for 88.956kHz ie 86.956kHz carrier and allow range up to 154kHz
 000                                CONSTANT RXFreqLSB, 11'd
 000                                CONSTANT AudioVolume, 12'd           ; Initialy 141
 000                                CONSTANT Tone, 13'd                  ; Carrier increment to cause a tone modulation on TX
 000                                CONSTANT Acknowledge, 14'd
 000                                ; offsets:
 000                                CONSTANT DSPFifo, 16'd
 000                                CONSTANT BTFifo, 32'd
 000                                CONSTANT KPFifo, 64'd
 000                                CONSTANT TDFifo, 128'd
 000                                ; Set bit 4,5,6,7 to acknowledge FIFO of DSP,BT, Keypad, Tone Detect (ie write 16,32, 64 or 128)
 000                                CONSTANT FlashData, 17'd
 000                                ; CONSTANT BatteryMon,   18'd
 000                                CONSTANT ADCstate_port, 19'd         ; Lower 5 bits are not used, bit 6 indictes which ADC channel is read
 000                                ; offset of port 19
 000                                CONSTANT LoranBlank, 16'd            ; $10
 000                                CONSTANT AudioOutSelect, 32'd
 000                                CONSTANT AnalogueChannel, 64'd       ; bit 6
 000                                CONSTANT CMD2BT, 20'd
 000                                CONSTANT CMD2KP, 21'd
 000                                CONSTANT RAMDataMSB, 22'd            ; To send to KP, DSP or BT picos
 000                                CONSTANT RAMDataLSB, 23'd            ; To send to KP, DSP or BT picos
 000                                CONSTANT RAMwriteControl, 25'd
 000                                ; ;; Pete - Bluetooth
 000                                CONSTANT TRANSMIT_ON, 14             ; BT -> User
 000                                CONSTANT TRANSMIT_OFF, 15            ; BT -> User
 000                                ;GenerateCode        MEM       "S3eUser_interface.mem"
 000                                ; Start of test program Must send $40,$50 over serial port to initiate if not re-programming!
 000  22021                   boot: JUMP 021[cold_start]
 001                         start: 
 001  2001B                 reboot: CALL 01B[GetByte]
 002  1D140                         COMPARE s1, 40[64'd]                 ; do we have for start byte (64 )
 003  32007                         JUMP Z, 007[DoUserProg]
 004  1D141                         COMPARE s1, 41[65'd]
 005  3E022                         JUMP NC, 022[ProgDSP]                ; This will actually write DSP or other prog (start byte =65 or greater) aargh 27/8/10 - was JUMP Z....
 006  22001                         JUMP 001[reboot]
 007  01704             DoUserProg: LOAD s7, 04
 008  01220                         LOAD s2, 20[32'd]
 009  01300                         LOAD s3, 00                          ; s2 (LSB),s3(USB) of prog counter of first address of new program!
 00A  2001B                GetProg: CALL 01B[GetByte]
 00B  1D150                         COMPARE s1, 50[80'd]                 ; 80 ($50) indicates end of program
 00C  32021                         JUMP Z, 021[cold_start]              ; When end of prog byte 80 is received
 00D  2D103                         OUTPUT s1, 03[Instructiona]
 00E  2001B                         CALL 01B[GetByte]
 00F  2D104                         OUTPUT s1, 04[Instructionb]
 010  2001B                         CALL 01B[GetByte]
 011  2D105                         OUTPUT s1, 05[Instructionc]          ; write 3x 6bits to latches ready for instruction write
 012  2D206                         OUTPUT s2, 06[ProgramL]
 013  2D307                         OUTPUT s3, 07[ProgramM]              ; Load memory address to write (starting from 32!)
 014  00470                         LOAD s4, s7                          ; Set bit 2 to perform write to RAM 1 or bit 3 to write RAM 2 depending whether start byte was 64 or 65
 015  2D419                         OUTPUT s4, 19[RAMwriteControl]
 016  01400                         LOAD s4, 00
 017  2D419                         OUTPUT s4, 19[RAMwriteControl]       ; Set write line back to zero
 018  11201                         ADD s2, 01
 019  13300                         ADDCY s3, 00                         ; Increment program counter
 01A  2200A                         JUMP 00A[GetProg]                    ; Get next instruction
 01B  09001                GetByte: INPUT s0, 01[Uart_status]            ; Is there a byte available?
 01C  03001                         AND s0, 01
 01D  1D001                         COMPARE s0, 01
 01E  3601B                         JUMP NZ, 01B[GetByte]                ; until there is a byte in the input buffer!
 01F  09100                         INPUT s1, 00[Uart_rx]
 020  25000                         RETURN 
 021  01000             cold_start: LOAD s0, 00                          ; Note the label 'ProgDSP' is only to allow re-boot to work!
 022                       ProgDSP: 
 022                                ; need to clear scratchpad
 022  01100                         LOAD s1, 00
 023                  ScratchClear: 
 023  2E010                         STORE s0, (s1)                       ; zero location
 024  11101                         ADD s1, 01                           ; next
 025  1D100                         COMPARE s1, 00                       ; do all 256 bytes
 026  36023                         JUMP NZ, 023[ScratchClear]           ;
 027                                ;LOAD   s5,83      ;value for 'S'
 027                                ;CALL      Byte2UART
 027                                ;CALL      Byte2UART     ;send 'SS' to 'Uart' - ie ARM
 027                                ;CALL      SendCRLF            ; added to allow get line to read OK
 027                                ;LOAD      s6, 42'd             ; *
 027                                ;CALL      Send2UartTX
 027                                ;LOAD      s6, 43'd             ; +
 027                                ;CALL      Send2UartTX
 027                                ;CALL      SendCRLF            ; added to allow get line to read OK
 027                                ;LOAD      s6, 0A               ; ensure FIFO is flushed
 027                                ;CALL      Send2UartTX
 027  2038E                         CALL 38E[SendCRLF]                   ; added to allow get line to read OK
 028  01B00                   init: LOAD sB[ScratchPointer], 00
 029  01000                         LOAD s0, 00
 02A  2F010                         STORE s0, 10[Latch7]                 ; initialise latch 7 bits!
 02B  01553                         LOAD s5, 53                          ; gain to lowish
 02C  2F516                         STORE s5, 16[ADCgain]                ; save initial value
 02D  2F51C                         STORE s5, 1C[ADCGainRX]              ; save initial value for RX
 02E  2011A                         CALL 11A[SetAnGain]                  ; set gain and calibrate
 02F  01559                         LOAD s5, 59                          ; gain to lowish
 030  2F51B                         STORE s5, 1B[ADCGainTX]              ; save initial value forTX
 031                                ;Frequency of TX/RX now set by keypad pico
 031  01032                         LOAD s0, 32[AGCupperRX]
 032  2F019                         STORE s0, 19[ADCAGCUpperThreshold]
 033  01012                         LOAD s0, 12[AGClowerRX]
 034  2F01A                         STORE s0, 1A[ADCAGCLowerThreshold]
 035  200D0                         CALL 0D0[RX]                         ; set receive mode
 036  01100                         LOAD s1, 00
 037  2035F                         CALL 35F[ArchiveSource]
 038  20366                         CALL 366[EnableArchive]
 039  01085                         LOAD s0, 85[InitialVolume]           ;set lowish audio volume
 03A  2D00C                         OUTPUT s0, 0C[AudioVolume]
 03B  203A6                         CALL 3A6[delay_100ms]
 03C  01020                         LOAD s0, 20[AudioOutSelect]          ; + 16; normal ADC channel, AudioOUtSelect doesn't do anything here! The 16also sets Loran Blanking if in firmware.
 03D  2F013                         STORE s0, 13[ADCstate]               ; save
 03E  2D013                         OUTPUT s0, 13[ADCstate_port]         ; Also sets analogue input to 0
 03F  010FF                         LOAD s0, FF
 040  2F015                         STORE s0, 15[ADCLevel]
 041                     startLoop: 
 041  01B00                         LOAD sB[ScratchPointer], 00
 042  2006F                   loop: CALL 06F[CheckADClevel]
 043  0B012                         FETCH s0, 12[Mode]
 044  03004                         AND s0, 04                           ; look at streaming bit
 045  1D004                         COMPARE s0, 04
 046  321B3                         JUMP Z, 1B3[isSSloop]                ; if streaming TX mode, then send a Uart character and return (but will not be able to interpret any command so is stuck!)
 047  0B012                         FETCH s0, 12[Mode]
 048  03008                         AND s0, 08                           ; look at streaming RX bit
 049  1D008                         COMPARE s0, 08
 04A  302FB                         CALL Z, 2FB[Check4CmdfromDSP]        ; If fifo character then send to terminal !!!!!!!!!!!!!!!!!!!! reinstate this 9/7/2013
 04B  20309                         CALL 309[Check4CmdfromTD]            ; If fifo character then send to terminal
 04C  1D680                         COMPARE s6, 80[128'd]
 04D  380AB                         CALL C, 0AB[checkMsgFromTD]
 04E  20304                         CALL 304[Check4CmdfromKP]
 04F  1D680                         COMPARE s6, 80[128'd]                ;see if there is a character from the kppico (eg r or t signal)
 050  380B5                         CALL C, 0B5[checkrqst]
 051                                ; Re-enable Beacon mode
 051  0B012                         FETCH s0, 12[Mode]
 052                                ;      OUTPUT    s0,CMD2KP      ;send value to LCD for display - send adc level data instead
 052  03001                         AND s0, 01                           ; only interrested in bit0
 053  1D001                         COMPARE s0, 01                       ; Is it beacon mode?
 054  302C6                         CALL Z, 2C6[BeaconBeep]
 055                                ; Pete  enabled 24 Feb 2015 - inhibit in tonedetect
 055                                ;                    CALL      Check4CmdfromBT     ; receive from BT and echo to terminal
 055                                ;                    JUMP      C, HandleBTCommand  ; If less than 128 there is a value to give back and display.
 055                                ;HandleBTCommand_Done:
 055                                ; pete end
 055  202E1                         CALL 2E1[getUARTchar]
 056                                ;COMPARE      s6, 32'd
 056                                ;JUMP      Z, loop             ; If a space then skip
 056                                ; Had mistankenly changed the next line!
 056  1D6FF                         COMPARE s6, FF
 057  32042                         JUMP Z, 042[loop]                    ; If no character then skip-MAKE SURE ANYTHINGTO BE PERFORMED REGULARLY IS DONE BEFORE THIS POINT
 058  1D60A                         COMPARE s6, 0A[10'd]
 059  32125                         JUMP Z, 125[interpcommand]           ; This is end of command character (LF now! as of Dec 2016)
 05A  1D60D                         COMPARE s6, 0D[13'd]
 05B  32042                         JUMP Z, 042[loop]                    ; If CR ignore
 05C  1DB10                         COMPARE sB[ScratchPointer], 10[16'd] ; Check we are not writing too many characters to the scratchpad
 05D  3E042                         JUMP NC, 042[loop]                   ; don't write to scratch if Pointer (counter) 16 or above
 05E  2E6B0                         STORE s6, (sB[ScratchPointer])       ; Save command character
 05F  11B01                         ADD sB[ScratchPointer], 01           ; is a command char so increment
 060  22042                         JUMP 042[loop]
 061                  SendADCToARM: 
 061  0B128                         FETCH s1, 28[peteTXMode]
 062  1D100                         COMPARE s1, 00
 063  35000                         RETURN NZ                            ; do not send unless receiving
 064  01626                         LOAD s6, 26["&"]
 065  20383                         CALL 383[Send2UartTX]                ; send the &
 066  01676                         LOAD s6, 76["v"]                     ; indicates 'earthing' quality
 067  20383                         CALL 383[Send2UartTX]                ; send the &
 068                                ; Byte2Chars takes data in s5 and returns two ascii codes in s6,s7
 068                                ;(s7 is character for lower 4 bits) sent as second character
 068  00500                         LOAD s5, s0
 069  20339                         CALL 339[Byte2Chars]
 06A  20383                         CALL 383[Send2UartTX]                ; send the upper ADC value
 06B  00670                         LOAD s6, s7
 06C  20383                         CALL 383[Send2UartTX]                ; send the lower ADC value
 06D  2038E                         CALL 38E[SendCRLF]
 06E  25000                         RETURN 
 06F  0900F          CheckADClevel: INPUT s0, 0F[ADCSignalLevel]
 070  0B115                         FETCH s1, 15[ADCLevel]
 071  1C010                         COMPARE s0, s1
 072  31000                         RETURN Z                             ; return if the value is still the same (ie wait for new value)
 073                                ;__________________________________________________
 073                                ;TEMPORARY SKIP to TEMPskip:  (values will be redirected directly from DSP to KP in
 073                                ;      JUMP  Tempskip NOTnow 19 sep 2015
 073                                ;____________________________________________________
 073  0117F                         LOAD s1, 7F                          ; Note top bit is not received! Send command to expect signal level
 074                                ;OUTPUT       s1, CMD2KP          ; send ADCgain value to LCD for display
 074  2F015                         STORE s0, 15[ADCLevel]               ; save new value of ADClevel
 075  20061                         CALL 061[SendADCToARM]               ; send to ARM
 076                                ; Code to send a value for display as 2 decimal digits in the range 00 to 74 (~42dB) representing the broad band signal strength (5 units per gain step, 1 unit per 8 units of ADC level
 076                                ; assuming ADClevel kept betweeen $18 and $40, signal level within range covers ~8dB, display about 1.7 x value in dB in steps of 2 (~1.2dB)
 076  0B116                         FETCH s1, 16[ADCgain]
 077  0310F                         AND s1, 0F                           ; Gain level just in lower 4 bits
 078  0120E                         LOAD s2, 0E
 079  18210                         SUB s2, s1                           ; Invert gain level to signal level ie highest gain of $E becomes zero
 07A  01100                         LOAD s1, 00                          ; use this as counter for lower decimal digit
 07B  1420E                         SR0 s2                               ; half the value and send half to the carry flag (to add 5)
 07C  3E07E                         JUMP NC, 07E[nofive]                 ; only add 5 to lower digit if carry set
 07D  01105                         LOAD s1, 05[5'd]
 07E  1D010                 nofive: COMPARE s0, 10[16'd]                 ; skip if below first step (about 1.2dB)
 07F  3A081                         JUMP C, 081[First]
 080  11102                         ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 081  1D012                  First: COMPARE s0, 12[18'd]                 ; skip if below second step (about 1.2dB)
 082  3A084                         JUMP C, 084[Second]
 083  11102                         ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 084  1D015                 Second: COMPARE s0, 15[21'd]                 ; skip if below third step (about 1.2dB)
 085  3A087                         JUMP C, 087[Third]
 086  11102                         ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 087  1D018                  Third: COMPARE s0, 18[24'd]                 ; skip if below
 088  3A08A                         JUMP C, 08A[Fourth]
 089  11102                         ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 08A  1D01C                 Fourth: COMPARE s0, 1C[28'd]                 ; skip if below
 08B  3A08D                         JUMP C, 08D[Fifth]
 08C  11102                         ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 08D                                ; now check if s1 (lower decimal digit) is above 9
 08D  1D10A                  Fifth: COMPARE s1, 0A[10'd]
 08E  3A091                         JUMP C, 091[ToLCD]
 08F  11201                         ADD s2, 01[1'd]                      ; Add 1 to first decimal digit
 090  1910A                         SUB s1, 0A[10'd]                     ; subtract 10 from lower digit
 091                                ;Deleted part that tried to apply attenuator
 091                         ToLCD: ;OUTPUT       s2, CMD2KP          ; Send first decimal digit (as binary value 0-7)
 091                                ;OUTPUT       s1, CMD2KP          ; send second decimal digit (as binary value for 0-9)
 091                                ; s0 should hoperfully still have ADCsignal level!
 091                                ;_______________________________
 091                                ;Temp bit
 091                      Tempskip: 
 091                                ;_____________________________________
 091                                ; LOAD      s5, s0
 091                                ;      ;CALL      Byte2UART    ;and echo to UART  - not now!
 091  0B119                         FETCH s1, 19[ADCAGCUpperThreshold]
 092  0B015                         FETCH s0, 15[ADCLevel]               ; had lost the s0 value at this point!
 093  1C010                         COMPARE s0, s1                       ; aim to keep value around $15? - need to drop this further! Needs to be lower for transmission??
 094  3C099                         CALL NC, 099[ReduceADCgain]
 095  0B11A                         FETCH s1, 1A[ADCAGCLowerThreshold]
 096  1C010                         COMPARE s0, s1                       ; aim to keep value around $15? -
 097  380A2                         CALL C, 0A2[IncreaseADCgain]
 098  25000                         RETURN 
 099  0B016          ReduceADCgain: FETCH s0, 16[ADCgain]
 09A  00100                         LOAD s1, s0
 09B  0310F                         AND s1, 0F                           ; mask lower 4 bits
 09C  1D101                         COMPARE s1, 01                       ; don't drop to zero!
 09D  31000                         RETURN Z
 09E  19001                         SUB s0, 01[1'd]
 09F  2F016                         STORE s0, 16[ADCgain]
 0A0  2D002                         OUTPUT s0, 02[GainPD]                ; set ADC pre-amp
 0A1                                ; OUTPUT       s0, CMD2KP          ; send value to LCD for display - don't bother
 0A1  25000                         RETURN 
 0A2  0B016        IncreaseADCgain: FETCH s0, 16[ADCgain]
 0A3  00100                         LOAD s1, s0
 0A4  0310F                         AND s1, 0F                           ; mask lower 4 bits
 0A5  1D10E                         COMPARE s1, 0E                       ; don't go past $0E!
 0A6  31000                         RETURN Z
 0A7  11001                         ADD s0, 01[1'd]
 0A8  2F016                         STORE s0, 16[ADCgain]
 0A9  2D002                         OUTPUT s0, 02[GainPD]                ; set ADC pre-amp
 0AA                                ; OUTPUT       s0, CMD2KP          ; send value to LCD for display
 0AA  25000                         RETURN 
 0AB                                ;Delete setting and resetting Attenuator (March 2016)
 0AB                                ;;; message from Tone Detect Pico
 0AB                checkMsgFromTD: 
 0AB                                ;COMPARE   s6, "+"
 0AB                                ;RETURN  NZ
 0AB  20383                         CALL 383[Send2UartTX]                ; send the +
 0AC            checkMsgFromTDloop: 
 0AC  20309                         CALL 309[Check4CmdfromTD]            ; If fifo character then send to terminal
 0AD  1D680                         COMPARE s6, 80[128'd]
 0AE  320AC                         JUMP Z, 0AC[checkMsgFromTDloop]
 0AF                                ;LOAD      s6, "="
 0AF  20383                         CALL 383[Send2UartTX]                ;
 0B0  0160D                         LOAD s6, 0D                          ;
 0B1  20383                         CALL 383[Send2UartTX]                ; send the lf
 0B2  0160A                         LOAD s6, 0A                          ; Line Feed should be enough
 0B3  20383                         CALL 383[Send2UartTX]                ; send the lf
 0B4  25000                         RETURN 
 0B5                     checkrqst: ;COMPARE      s6, "r"    ;character_r
 0B5                                ;CALL      Z, checkRXmode
 0B5                                ;COMPARE      s6, "t"   ;character_t
 0B5                                ;CALL      Z, checkTXmode
 0B5                                ;COMPARE      s6, "e"   ;character_e
 0B5                                ;CALL      Z, setEarthAntennas
 0B5                                ;COMPARE      s6, "l"   ; character_l
 0B5                                ;CALL      Z, setLoopAntennas
 0B5  1D626                         COMPARE s6, 26["&"]
 0B6  300B8                         CALL Z, 0B8[SendToARM]
 0B7  25000                         RETURN 
 0B8                     SendToARM: 
 0B8  20383                         CALL 383[Send2UartTX]                ; send the &
 0B9  20304             waitForKey: CALL 304[Check4CmdfromKP]
 0BA  1D680                         COMPARE s6, 80[128'd]
 0BB  320B9                         JUMP Z, 0B9[waitForKey]
 0BC  20383                         CALL 383[Send2UartTX]                ; send the keypress value
 0BD  2038E                         CALL 38E[SendCRLF]
 0BE                                ;LOAD      s6, 0D             ; c/r
 0BE                                ;CALL      Send2UartTX   ; send
 0BE                                ;LOAD      s6, 0A             ; only l/f is needed
 0BE                                ;CALL      Send2UartTX   ; send
 0BE  25000                         RETURN 
 0BF  0B012       setEarthAntennas: FETCH s0, 12[Mode]
 0C0  030EF                         AND s0, EF[239'd]                    ; 255-16  ;reset bit 4
 0C1  2F012                         STORE s0, 12[Mode]
 0C2  200FB                         CALL 0FB[setRXmode]                  ;Make active and return to RX
 0C3  25000                         RETURN 
 0C4  0B012        setLoopAntennas: FETCH s0, 12[Mode]
 0C5  05010                         OR s0, 10[16'd]                      ;set bit 4
 0C6  2F012                         STORE s0, 12[Mode]
 0C7  200FB                         CALL 0FB[setRXmode]
 0C8  25000                         RETURN 
 0C9                   checkRXmode: 
 0C9                                ; ;; Pete added for Bluetooth (temp)
 0C9                                ;FETCH     s0, BluetoothXmit
 0C9                                ;ADD       s0, 00
 0C9                                ;RETURN       NZ                  ; do nothing if BT transmitting
 0C9                                ; ;; end Pete added for BT
 0C9                                ;FETCH     s0, Mode
 0C9                                ;AND       s0, 02               ; mask bit 1
 0C9                                ;COMPARE      s0, 02               ; is it set ie currently in TX mode?
 0C9                                ;RETURN       NZ                  ; return if already in RX mode return
 0C9  01626                         LOAD s6, 26["&"]
 0CA  20383                         CALL 383[Send2UartTX]
 0CB  0165A                         LOAD s6, 5A["Z"]
 0CC  20383                         CALL 383[Send2UartTX]
 0CD  2038E                         CALL 38E[SendCRLF]
 0CE  200FB                         CALL 0FB[setRXmode]                  ; so go ahead and set up RX mode
 0CF  25000                         RETURN 
 0D0                                ; Routine to set receive mode - just basic function ie doesn't set mode etc.
 0D0                            RX: 
 0D0  01530                         LOAD s5, 30[48'd]                    ; Ascii code for '0' - set receive mode
 0D1  2D500                         OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 0D2  0B510                         FETCH s5, 10[Latch7]
 0D3  0357F                         AND s5, 7F[~TX_HIGH]                 ; reset bit 7
 0D4  2F510                         STORE s5, 10[Latch7]
 0D5  2D507                         OUTPUT s5, 07[ProgramM]
 0D6  25000                         RETURN 
 0D7                   checkTXmode: 
 0D7                                ; Would NEED to reinstate this GN April 2017 for helloworld version     ;FETCH     s0, Mode
 0D7                                ;AND       s0, 02               ; mask bit 1 here 2 means TX mode 0 RX mode
 0D7                                ;COMPARE      s0, 00               ; is it not set ie currently in RX mode?
 0D7                                ;RETURN       NZ                  ; return if already in TX mode
 0D7  01626                         LOAD s6, 26["&"]
 0D8  20383                         CALL 383[Send2UartTX]
 0D9  01659                         LOAD s6, 59["Y"]
 0DA  20383                         CALL 383[Send2UartTX]
 0DB  2038E                         CALL 38E[SendCRLF]
 0DC  200E0                         CALL 0E0[setTXmode]                  ; so go ahead and set up TX mode
 0DD  25000                         RETURN 
 0DE                                ; from ARM - call set TX then jump to start of loop
 0DE                  setTXmodeARM: 
 0DE  200E0                         CALL 0E0[setTXmode]
 0DF  22041                         JUMP 041[startLoop]
 0E0                                ; need to set scratch pad mode, set RX freq to 0 (SRF0155), et TX freq to 86.95 STF0E7E, input channel with equivalent of SAI01 and send transmit mode command to DSP
 0E0                     setTXmode: 
 0E0                                ;FETCH     s0, Mode
 0E0                                ;OR        s0, 02               ; set TX bit
 0E0                                ;AND       s0, FE             ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 0E0                                ;STORE     s0, Mode
 0E0                                ; LOAD      s0, 01      Don't need this is keypad is sorting it!
 0E0                                ; OUTPUT       s0, RXFreqMSB
 0E0                                ; LOAD      s0, 55
 0E0                                ; OUTPUT       s0, RXFreqLSB       ; drop detection to baseband (for when using wired mic)
 0E0  01001                         LOAD s0, 01
 0E1  2F028                         STORE s0, 28[peteTXMode]
 0E2  0B013                         FETCH s0, 13[ADCstate]
 0E3  05040                         OR s0, 40[AnalogueChannel]           ; set bit 6 (SAI01) - Channel 1 in Matlab GUI
 0E4  2F013                         STORE s0, 13[ADCstate]               ; save
 0E5  2D013                         OUTPUT s0, 13[ADCstate_port]         ; set port to new ADC channel
 0E6  0B516                         FETCH s5, 16[ADCgain]                ; get gain used for RX
 0E7  2F51C                         STORE s5, 1C[ADCGainRX]              ; this value is tracked
 0E8  0B51B                         FETCH s5, 1B[ADCGainTX]              ; gain to last value used for TX
 0E9  2F516                         STORE s5, 16[ADCgain]                ; and make current ADCgain value
 0EA  2011A                         CALL 11A[SetAnGain]                  ; set analogue gain to moderate
 0EB  01030                         LOAD s0, 30[AGCupperTX]
 0EC  2F019                         STORE s0, 19[ADCAGCUpperThreshold]
 0ED  01012                         LOAD s0, 12[AGClowerTX]
 0EE  2F01A                         STORE s0, 1A[ADCAGCLowerThreshold]
 0EF  200F2                         CALL 0F2[TX]
 0F0  20240                         CALL 240[TripleTwotone]              ; added to give longer start of message beep
 0F1                                ;LOAD      s6, "$"             ; debug
 0F1                                ;        CALL      Send2UartTX   ; send
 0F1                                ;LOAD      s6, "t"             ; debug
 0F1                                ;        CALL      Send2UartTX   ; send
 0F1                                ;LOAD      s6, 0D             ; c/r
 0F1                                ;        CALL      Send2UartTX   ; send
 0F1                                ;LOAD      s6, 0A             ; l/f
 0F1                                ;        CALL      Send2UartTX   ; send
 0F1  25000                         RETURN 
 0F2                                ; routine to set transmit mode
 0F2  01531                     TX: LOAD s5, 31[49'd]                    ; Ascii code for '1' - set transmit mode
 0F3  2D500                         OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 0F4  0B510                         FETCH s5, 10[Latch7]
 0F5  05580                         OR s5, 80[TX_HIGH]                   ; set bit 7
 0F6  2F510                         STORE s5, 10[Latch7]
 0F7  2D507                         OUTPUT s5, 07[ProgramM]
 0F8  25000                         RETURN 
 0F9                                ; from ARM - call set RX then jump to start of loop
 0F9                  setRXmodeARM: 
 0F9  200FB                         CALL 0FB[setRXmode]
 0FA  22041                         JUMP 041[startLoop]
 0FB                                ; need to set scratch pad mode, set RX freq to 86.95 (SRF769A or for 87kHz need 76AB), input channel with equivalent of SAI00 and send receive mode command to DSP, set analog gain to 8
 0FB                                ;delay about 0.5S before actually returning to receive to allow voice in buffer to be transmitted
 0FB  203A0              setRXmode: CALL 3A0[delay500ms]                 ;delay added here
 0FC  01532                         LOAD s5, 32[50'd]                    ; Ascii code for '2' - DSP to grap the AGCvalue before the warble
 0FD  2D500                         OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 0FE                                ;CALL      Warble             ; added to give start of message beep
 0FE  0B516                         FETCH s5, 16[ADCgain]                ; gain used during TX mode
 0FF  2F51B                         STORE s5, 1B[ADCGainTX]              ; Save for next TX mode
 100  202A2                         CALL 2A2[Warble]
 101  01000                         LOAD s0, 00
 102  2F028                         STORE s0, 28[peteTXMode]
 103                                ;FETCH     s0, Mode
 103                                ;AND       s0, 252'd    ;255 - 3         ; reset TX bit AND becon on bit
 103                                ;STORE     s0, Mode
 103                                ; LOAD      s0, 2A             ; $75 for new demodulator   Don't need this from GV95 as keypad sets the frequency
 103                                ; OUTPUT       s0, RXFreqMSB
 103                                ; LOAD      s0, AD          ; $ N2 or Heyphone)
 103                                ; OUTPUT       s0, RXFreqLSB
 103                                ;Set ADC channel depending on whether using loop or earth wires (Mode bit 4 set for loop)
 103  0B012                         FETCH s0, 12[Mode]
 104  03010                         AND s0, 10[16'd]                     ;antenna input select bit (4)
 105  14006                         SL0 s0
 106  14006                         SL0 s0                               ;to affect bit 6
 107  0B113                         FETCH s1, 13[ADCstate]
 108  031BF                         AND s1, BF[191'd]                    ; 255 - 64        ; reset  bit 6
 109  04100                         OR s1, s0                            ;now affect bit 6 = Mode bit 4 setting
 10A  2F113                         STORE s1, 13[ADCstate]               ; save
 10B  2D113                         OUTPUT s1, 13[ADCstate_port]         ; set port to new ADC channel
 10C  0B51C                         FETCH s5, 1C[ADCGainRX]              ; gain to last value used for RX
 10D  2F516                         STORE s5, 16[ADCgain]                ; this value is tracked
 10E  2011A                         CALL 11A[SetAnGain]                  ; set analogue gain to moderate
 10F  01032                         LOAD s0, 32[AGCupperRX]
 110  2F019                         STORE s0, 19[ADCAGCUpperThreshold]
 111  01012                         LOAD s0, 12[AGClowerRX]
 112  2F01A                         STORE s0, 1A[ADCAGCLowerThreshold]
 113  200D0                         CALL 0D0[RX]
 114  01626                         LOAD s6, 26["&"]
 115  20383                         CALL 383[Send2UartTX]                ; send the &
 116  01673                         LOAD s6, 73["s"]                     ; tell ARM warble is transmitted
 117  20383                         CALL 383[Send2UartTX]                ;
 118  2038E                         CALL 38E[SendCRLF]
 119  25000                         RETURN 
 11A                                ; set gain to 32 or is it 48?, enter with gain value in s5 (ie $DA for transmit)
 11A  0350F              SetAnGain: AND s5, 0F                           ; only affect lower 4 bits
 11B  0B016                         FETCH s0, 16[ADCgain]
 11C  030F0                         AND s0, F0                           ; keep upper bits
 11D  04500                         OR s5, s0                            ; combine
 11E  2F516                         STORE s5, 16[ADCgain]                ; save new value (includes all bits)
 11F  05580                         OR s5, 80                            ; set bit 7 to start calibration
 120  2D502                         OUTPUT s5, 02[GainPD]
 121  203AB                         CALL 3AB[delay_1ms]                  ; wait for calib
 122  0357F                         AND s5, 7F[127'd]                    ; reset bit 7
 123  2D502                         OUTPUT s5, 02[GainPD]
 124  25000                         RETURN 
 125                                ; Now interpret the command in the Scratch buffer and return to init
 125  01900          interpcommand: LOAD s9, 00                          ; counter through scratchpad addresses.
 126  1C9B0             interploop: COMPARE s9, sB[ScratchPointer]
 127  32041                         JUMP Z, 041[startLoop]               ; break out of loop after reading final character command.
 128  20374                         CALL 374[getnextscratchchar]
 129  1D02A                         COMPARE s0, 2A["*"]                  ; is this a * = command from ARM menu
 12A  32146                         JUMP Z, 146[MsgFromARM]
 12B  1D053                         COMPARE s0, 53[83'd]                 ; is this a S?
 12C  32151                         JUMP Z, 151[isS]
 12D  1D047                         COMPARE s0, 47[71'd]                 ; is this a G?
 12E  32163                         JUMP Z, 163[isG]
 12F                                ;      COMPARE      s0, 77'd              ; is this a M?
 12F                                ; JUMP      Z, isM
 12F  1D05A                         COMPARE s0, 5A[90'd]                 ; is this a Z?
 130  32001                         JUMP Z, 001[reboot]                  ; then go to reboot code (ie to reboot need to send Z<CR>, then do Prog...)
 131  0163F                         LOAD s6, 3F["?"]                     ;send unknown 3F
 132  20383                         CALL 383[Send2UartTX]                ; send the keypress value
 133  00600                         LOAD s6, s0
 134  20383                         CALL 383[Send2UartTX]                ; send the keypress value
 135  20374                         CALL 374[getnextscratchchar]
 136  00600                         LOAD s6, s0
 137  20383                         CALL 383[Send2UartTX]                ; send the keypress value
 138  20374                         CALL 374[getnextscratchchar]
 139  00600                         LOAD s6, s0
 13A  20383                         CALL 383[Send2UartTX]                ; send the keypress value
 13B  20374                         CALL 374[getnextscratchchar]
 13C  00600                         LOAD s6, s0
 13D  20383                         CALL 383[Send2UartTX]                ; send the keypress value
 13E  20374                         CALL 374[getnextscratchchar]
 13F  00600                         LOAD s6, s0
 140  20383                         CALL 383[Send2UartTX]                ; send the keypress value
 141  20374                         CALL 374[getnextscratchchar]
 142  00600                         LOAD s6, s0
 143  20383                         CALL 383[Send2UartTX]                ; send the keypress value
 144  2038E                         CALL 38E[SendCRLF]
 145  22041                         JUMP 041[startLoop]
 146                    MsgFromARM: 
 146  20374                         CALL 374[getnextscratchchar]
 147  1D672                         COMPARE s6, 72["r"]                  ;character_r
 148                                ;CALL      Z, checkRXmode
 148  320F9                         JUMP Z, 0F9[setRXmodeARM]
 149  1D674                         COMPARE s6, 74["t"]                  ;character_t
 14A                                ;CALL      Z, checkTXmode
 14A  320DE                         JUMP Z, 0DE[setTXmodeARM]
 14B  1D663                         COMPARE s6, 63["c"]                  ;send confidence beep
 14C  32259                         JUMP Z, 259[Confidence]
 14D                                ;COMPARE      s6, "b"   ;send beacon beep
 14D                                ;CALL      Z, BeaconBeep
 14D  1D657                         COMPARE s6, 57["W"]                  ;watchdog check
 14E  322D1                         JUMP Z, 2D1[SendWatchdogReply]       ; send User pico reply then pass onto Keypad
 14F                                ; send everything else to Keypad pico
 14F  202DD                         CALL 2DD[SendToKeypad]
 150  22041                         JUMP 041[startLoop]
 151  20374                    isS: CALL 374[getnextscratchchar]
 152  1D042                         COMPARE s0, 42[66'd]                 ; is this a B?
 153  3217F                         JUMP Z, 17F[isSB]                    ;
 154  1D041                         COMPARE s0, 41[65'd]                 ; is this a A?
 155  32175                         JUMP Z, 175[isSA]
 156  1D052                         COMPARE s0, 52[82'd]                 ; is this a R?
 157  321C5                         JUMP Z, 1C5[isSR]
 158  1D054                         COMPARE s0, 54[84'd]                 ; is this a T?
 159  321CB                         JUMP Z, 1CB[isST]
 15A  1D04B                         COMPARE s0, 4B[75'd]                 ; is this a K?
 15B  32186                         JUMP Z, 186[isSK]                    ;
 15C  1D04C                         COMPARE s0, 4C[76'd]                 ; is this a L?
 15D  3218A                         JUMP Z, 18A[isSL]                    ; Set Loran Blanking
 15E                                ;      COMPARE      s0, 83'd              ; is this a S?
 15E                                ; JUMP      Z, isSS             ;
 15E  1D055                         COMPARE s0, 55[85'd]                 ; is this a U
 15F  321A0                         JUMP Z, 1A0[isSU]
 160  1D057                         COMPARE s0, 57[87'd]                 ; is this a W
 161  321A5                         JUMP Z, 1A5[isSW]
 162  22041                         JUMP 041[startLoop]
 163  20374                    isG: CALL 374[getnextscratchchar]
 164  1D041                         COMPARE s0, 41[65'd]                 ; is this a A?
 165  3223A                         JUMP Z, 23A[isGA]
 166  1D042                         COMPARE s0, 42[66'd]                 ; is this a B?
 167  3220B                         JUMP Z, 20B[isGB]
 168  1D043                         COMPARE s0, 43[67'd]                 ; is this a C?
 169  32213                         JUMP Z, 213[isGC]
 16A  1D04B                         COMPARE s0, 4B[75'd]                 ; is this a K?
 16B  32216                         JUMP Z, 216[isGK]
 16C  1D04C                         COMPARE s0, 4C[76'd]                 ; is this a L?
 16D  3221C                         JUMP Z, 21C[isGL]
 16E  1D056                         COMPARE s0, 56[86'd]                 ; is this a V?
 16F  3223C                         JUMP Z, 23C[isGV]
 170  1D047                         COMPARE s0, 47[71'd]                 ; is this a G?
 171  321F9                         JUMP Z, 1F9[isGG]
 172  1D053                         COMPARE s0, 53[83'd]                 ; is this a S?
 173  32202                         JUMP Z, 202[isGS]
 174  22041                         JUMP 041[startLoop]
 175  20374                   isSA: CALL 374[getnextscratchchar]
 176  1D053                         COMPARE s0, 53[83'd]                 ; is this a S?
 177  321CF                         JUMP Z, 1CF[isSAS]                   ;
 178  1D047                         COMPARE s0, 47[71'd]                 ; is this a G?
 179  321D3                         JUMP Z, 1D3[isSAG]                   ;
 17A  1D04F                         COMPARE s0, 4F[79'd]                 ; is this a O?
 17B  321E5                         JUMP Z, 1E5[isSAO]                   ;
 17C  1D049                         COMPARE s0, 49[73'd]                 ; is this a I?
 17D  321DA                         JUMP Z, 1DA[isSAI]                   ;
 17E  22041                         JUMP 041[startLoop]
 17F                                ; SB - set beacon mode (SB<xx>
 17F  20378                   isSB: CALL 378[getnextvalue]
 180  03501                         AND s5, 01                           ; Mask bit 0
 181  0B012                         FETCH s0, 12[Mode]
 182  030FE                         AND s0, FE[254'd]                    ; reset bit 0
 183  04050                         OR s0, s5                            ; affect bit 0
 184  2F012                         STORE s0, 12[Mode]
 185  22028                         JUMP 028[init]
 186                                ; Commands for keypad pico
 186  20374                   isSK: CALL 374[getnextscratchchar]
 187  1D053                         COMPARE s0, 53[83'd]                 ; is this a S?
 188  32195                         JUMP Z, 195[isSKS]                   ;
 189  22028                         JUMP 028[init]
 18A  20378                   isSL: CALL 378[getnextvalue]
 18B  01400                         LOAD s4, 00
 18C  1D501                         COMPARE s5, 01                       ; is it 1
 18D  3618F                         JUMP NZ, 18F[setLoranBlank]
 18E  01410                         LOAD s4, 10[LoranBlank]
 18F  0B013          setLoranBlank: FETCH s0, 13[ADCstate]
 190  030EF                         AND s0, EF[~LoranBlank]              ; reset bit for Loran blanking
 191  04040                         OR s0, s4                            ; affect this bit
 192  2F013                         STORE s0, 13[ADCstate]               ; save
 193  2D013                         OUTPUT s0, 13[ADCstate_port]         ; set port to new ADC channel
 194  22028                         JUMP 028[init]
 195                         isSKS: ; LOAD      s0, 83'd              ; letter S
 195                                ; OUTPUT       s0, CMD2KP          ; send S to KP
 195                                ; CALL      getnextscratchchar
 195                                ; SUB       s0, 48'd
 195                                ; OUTPUT       s0, CMD2KP          ; send select value as binary value to KP
 195  22028                         JUMP 028[init]
 196                                ; This streams from UART data to DSP to TX and never exits!
 196  20374                   isSS: CALL 374[getnextscratchchar]         ; get beacon offset in s0
 197  01533                         LOAD s5, 33[51'd]                    ; Ascii code for '3' - set stream mode -NO ESCAPE!
 198  2D500                         OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 199  2D000                         OUTPUT s0, 00[CMD2DSP]               ; send raw data byte of bit offset
 19A  200F2                         CALL 0F2[TX]
 19B  0B012                         FETCH s0, 12[Mode]
 19C  05004                         OR s0, 04                            ; set 'Streaming TX' bit
 19D  030FE                         AND s0, FE                           ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 19E  2F012                         STORE s0, 12[Mode]
 19F  22042                         JUMP 042[loop]                       ;
 1A0                                ; Stream RX data to UART
 1A0  0B012                   isSU: FETCH s0, 12[Mode]
 1A1  05008                         OR s0, 08                            ; set 'Streaming TX' bit
 1A2  030FE                         AND s0, FE                           ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 1A3  2F012                         STORE s0, 12[Mode]
 1A4  22028                         JUMP 028[init]                       ;
 1A5                                ; Redirect Serial to and from BT module
 1A5  01654                   isSW: LOAD s6, 54["T"]
 1A6  20383                         CALL 383[Send2UartTX]
 1A7  0164F                         LOAD s6, 4F["O"]
 1A8  20383                         CALL 383[Send2UartTX]
 1A9  01620                         LOAD s6, 20                          ;Space character
 1AA  20383                         CALL 383[Send2UartTX]
 1AB  01642                         LOAD s6, 42["B"]
 1AC  20383                         CALL 383[Send2UartTX]
 1AD  01654                         LOAD s6, 54["T"]
 1AE  20383                         CALL 383[Send2UartTX]
 1AF  2038E                         CALL 38E[SendCRLF]
 1B0  01001                         LOAD s0, 01
 1B1  2D009                         OUTPUT s0, 09[Configure]
 1B2  22028                         JUMP 028[init]                       ;
 1B3                                ; Now get a raw UART byte
 1B3  2037F               isSSloop: CALL 37F[CheckUartRx]
 1B4  361B3                         JUMP NZ, 1B3[isSSloop]               ; loop if nothing in UART buffer
 1B5  09500                         INPUT s5, 00[Uart_rx]                ; get byte
 1B6  20339                         CALL 339[Byte2Chars]
 1B7  2D600                         OUTPUT s6, 00[CMD2DSP]               ; Send audio MSBbyte to DSP
 1B8  2D700                         OUTPUT s7, 00[CMD2DSP]               ; Send audio LSBbyte to DSP
 1B9  202FB                         CALL 2FB[Check4CmdfromDSP]           ; If fifo character then send to terminal !!!!!!!!!!!!!!!!!!!! reinstate this 15/5/2013
 1BA  22042                         JUMP 042[loop]                       ; Try making this a called routine, sending 1 value per loop
 1BB                                ; this is same as following routine except it returns rather than jumping to init
 1BB  01524      nowsend2flashback: LOAD s5, 24[36'd]                    ; was 16 should be 9x4=36
 1BC  2D507                         OUTPUT s5, 07[ProgramM]              ; initiates flash write - may take some time for pp command!
 1BD  203AB                         CALL 3AB[delay_1ms]                  ; wait to complete
 1BE  203AB                         CALL 3AB[delay_1ms]
 1BF  203AB                         CALL 3AB[delay_1ms]                  ; TO be OPTIMIZED!!!!!!!!!!!!!!!!!!!!!!!
 1C0  01500                         LOAD s5, 00                          ; reset send2flash
 1C1  2D507                         OUTPUT s5, 07[ProgramM]              ; initiates flash write - may take some time for pp command!
 1C2  25000                         RETURN 
 1C3  201BB          nowsend2flash: CALL 1BB[nowsend2flashback]
 1C4  22028                         JUMP 028[init]
 1C5  20374                   isSR: CALL 374[getnextscratchchar]
 1C6  1D046                         COMPARE s0, 46[70'd]                 ; is this a F?
 1C7  321F0                         JUMP Z, 1F0[isSRF]                   ;
 1C8  1D04D                         COMPARE s0, 4D[77'd]                 ; is this a M?
 1C9  321F5                         JUMP Z, 1F5[isSRM]                   ;
 1CA  22028                         JUMP 028[init]
 1CB                                ; Testmemory TEMP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END
 1CB  20374                   isST: CALL 374[getnextscratchchar]
 1CC                                ;                    COMPARE      s0, 70'd              ; is this a F?
 1CC                                ;                   JUMP      Z, isSTF            ;
 1CC  1D04D                         COMPARE s0, 4D[77'd]                 ; is this a M?
 1CD  321F7                         JUMP Z, 1F7[isSTM]                   ;
 1CE  22028                         JUMP 028[init]
 1CF                                ; SAS - set archive source
 1CF  20378                  isSAS: CALL 378[getnextvalue]
 1D0  00150                         LOAD s1, s5
 1D1  2035F                         CALL 35F[ArchiveSource]
 1D2  22028                         JUMP 028[init]
 1D3                                ; SAG   Set analogue gain
 1D3  20378                  isSAG: CALL 378[getnextvalue]
 1D4  05580                         OR s5, 80[128'd]                     ; set bit 7
 1D5  2D502                         OUTPUT s5, 02[GainPD]
 1D6  203AB                         CALL 3AB[delay_1ms]                  ; wait for calib
 1D7  0357F                         AND s5, 7F[127'd]                    ; reset bit 7
 1D8  2D502                         OUTPUT s5, 02[GainPD]
 1D9  22028                         JUMP 028[init]
 1DA  20378                  isSAI: CALL 378[getnextvalue]
 1DB  01400                         LOAD s4, 00
 1DC  1D501                         COMPARE s5, 01                       ; is it 1
 1DD  361DF                         JUMP NZ, 1DF[setADC]
 1DE  01440                         LOAD s4, 40[64'd]
 1DF  0B013                 setADC: FETCH s0, 13[ADCstate]
 1E0  030BF                         AND s0, BF[191'd]                    ; reset bit 6
 1E1  04040                         OR s0, s4                            ; affect bit 6
 1E2  2F013                         STORE s0, 13[ADCstate]               ; save
 1E3  2D013                         OUTPUT s0, 13[ADCstate_port]         ; set port to new ADC channel
 1E4  22028                         JUMP 028[init]
 1E5  20378                  isSAO: CALL 378[getnextvalue]
 1E6  01400                         LOAD s4, 00
 1E7  1D501                         COMPARE s5, 01                       ; is it 1
 1E8  361EA                         JUMP NZ, 1EA[setAudioOut]
 1E9  01420                         LOAD s4, 20[32'd]
 1EA  0B013            setAudioOut: FETCH s0, 13[ADCstate]
 1EB  030DF                         AND s0, DF[223'd]                    ; 255 - 32        ; reset bit5
 1EC  04040                         OR s0, s4                            ; affect bit 5
 1ED  2F013                         STORE s0, 13[ADCstate]               ; save
 1EE  2D013                         OUTPUT s0, 13[ADCstate_port]         ; set port to new audio channel
 1EF  22028                         JUMP 028[init]
 1F0                                ; SRF - set receive frequency (gets 4 hex digits
 1F0  20378                  isSRF: CALL 378[getnextvalue]               ; get byte represented by 2 digits
 1F1  2D50A                         OUTPUT s5, 0A[RXFreqMSB]
 1F2  20378                         CALL 378[getnextvalue]
 1F3  2D50B                         OUTPUT s5, 0B[RXFreqLSB]
 1F4  22028                         JUMP 028[init]
 1F5                                ; set receive mode
 1F5  200FB                  isSRM: CALL 0FB[setRXmode]                  ; used to be RX, but that doesn't change mode and frequency etc.
 1F6  22028                         JUMP 028[init]
 1F7                                ; set Tranmit mode
 1F7  200E0                  isSTM: CALL 0E0[setTXmode]                  ; used to be TX 20/5/2013
 1F8  22028                         JUMP 028[init]
 1F9                                ; STF - set transmit frequency (gets 4 hex digits -Frequency now set by Keypad
 1F9                                ;isSTF:              CALL      getnextvalue        ; get byte represented by 2 digits
 1F9                                ;                   OUTPUT       s5, TXFreqMSB
 1F9                                ;                  CALL      getnextvalue
 1F9                                ;                 OUTPUT       s5, TXFreqLSB
 1F9                                ;                JUMP      init
 1F9                                ; GET AGC value from DSP
 1F9  01047                   isGG: LOAD s0, 47[71'd]                    ; letter G
 1FA  2D000                         OUTPUT s0, 00[CMD2DSP]               ; send G to DSP
 1FB  2038E                         CALL 38E[SendCRLF]
 1FC  203AB                         CALL 3AB[delay_1ms]
 1FD  202FB                         CALL 2FB[Check4CmdfromDSP]           ; if character send to terminal
 1FE  202FB                         CALL 2FB[Check4CmdfromDSP]           ; if character send to terminal
 1FF  202FB                         CALL 2FB[Check4CmdfromDSP]           ; if character send to terminal
 200  202FB                         CALL 2FB[Check4CmdfromDSP]           ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 201                                ;      CALL      SendCRLF
 201  22028                         JUMP 028[init]
 202                                ; Get AVEsignal level from DSP
 202  01053                   isGS: LOAD s0, 53[83'd]                    ; letter S
 203  2D000                         OUTPUT s0, 00[CMD2DSP]               ; send S to DSP
 204  2038E                         CALL 38E[SendCRLF]
 205  203AB                         CALL 3AB[delay_1ms]
 206  202FB                         CALL 2FB[Check4CmdfromDSP]           ; if character send to terminal
 207  202FB                         CALL 2FB[Check4CmdfromDSP]           ; if character send to terminal
 208  202FB                         CALL 2FB[Check4CmdfromDSP]           ; if character send to terminal
 209  202FB                         CALL 2FB[Check4CmdfromDSP]           ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 20A                                ;      CALL      SendCRLF
 20A  22028                         JUMP 028[init]
 20B                                ; send test command to BT pico
 20B  01047                   isGB: LOAD s0, 47[71'd]                    ; letter G
 20C  2D014                         OUTPUT s0, 14[CMD2BT]                ; send G to BT
 20D                                ;      CALL      SendCRLF
 20D  203AB                         CALL 3AB[delay_1ms]
 20E  20300                         CALL 300[Check4CmdfromBT]            ; if character send to terminal
 20F  20300                         CALL 300[Check4CmdfromBT]            ; if character send to terminal
 210  20300                         CALL 300[Check4CmdfromBT]            ; if character send to terminal
 211  20300                         CALL 300[Check4CmdfromBT]            ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 212                                ;      CALL      SendCRLF
 212  22028                         JUMP 028[init]
 213                                ; Return Loran inhibit rate
 213  09508                   isGC: INPUT s5, 08
 214  20389                         CALL 389[Byte2UART]
 215  25000                         RETURN 
 216                                ; Request from keypad pico
 216  20374                   isGK: CALL 374[getnextscratchchar]
 217  1D054                         COMPARE s0, 54[84'd]                 ; is this a T?
 218  32228                         JUMP Z, 228[isGKT]
 219  1D056                         COMPARE s0, 56[86'd]                 ; is this a V?
 21A  32231                         JUMP Z, 231[isGKV]
 21B  22028                         JUMP 028[init]
 21C                                ; report signal level from the ADC
 21C  0B515                   isGL: FETCH s5, 15[ADCLevel]
 21D  20389                         CALL 389[Byte2UART]
 21E  01620                         LOAD s6, 20                          ; space
 21F  20383                         CALL 383[Send2UartTX]
 220  0950F                         INPUT s5, 0F[ADCSignalLevel]
 221  20389                         CALL 389[Byte2UART]
 222  01620                         LOAD s6, 20                          ; space
 223  20383                         CALL 383[Send2UartTX]
 224  0B516                         FETCH s5, 16[ADCgain]
 225  20389                         CALL 389[Byte2UART]
 226  2038E                         CALL 38E[SendCRLF]
 227  22028                         JUMP 028[init]
 228                                ; send test command to KP pico
 228  01054                  isGKT: LOAD s0, 54[84'd]                    ; letter T
 229  2D015                         OUTPUT s0, 15[CMD2KP]                ; send T to KP
 22A  2038E                         CALL 38E[SendCRLF]
 22B  203AB                         CALL 3AB[delay_1ms]
 22C  20304                         CALL 304[Check4CmdfromKP]            ; if character send to terminal
 22D  20304                         CALL 304[Check4CmdfromKP]            ; if character send to terminal
 22E  20304                         CALL 304[Check4CmdfromKP]            ; if character send to terminal
 22F  20304                         CALL 304[Check4CmdfromKP]            ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 230                                ;      CALL      SendCRLF
 230  22028                         JUMP 028[init]
 231  01056                  isGKV: LOAD s0, 56[86'd]                    ; letter V
 232  2D015                         OUTPUT s0, 15[CMD2KP]                ; send V to KP
 233  2038E                         CALL 38E[SendCRLF]
 234  203AB                         CALL 3AB[delay_1ms]
 235  20304                         CALL 304[Check4CmdfromKP]            ; if character send to terminal
 236  20304                         CALL 304[Check4CmdfromKP]            ; if character send to terminal
 237  20304                         CALL 304[Check4CmdfromKP]            ; if character send to terminal
 238  20304                         CALL 304[Check4CmdfromKP]            ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 239                                ;      CALL      SendCRLF
 239  22028                         JUMP 028[init]
 23A  2034C                   isGA: CALL 34C[SendArchive]
 23B  22028                         JUMP 028[init]
 23C                          isGV: 
 23C  0150C                         LOAD s5, 0C[Versionno]
 23D  20389                         CALL 389[Byte2UART]
 23E  2038E                         CALL 38E[SendCRLF]                   ; added to allow get line to read OK
 23F  22028                         JUMP 028[init]
 240  01042          TripleTwotone: LOAD s0, 42[66'd]                    ; Block DSPpico
 241  2D000                         OUTPUT s0, 00[CMD2DSP]               ; send B to DSP to block it
 242                                ; need to output TX freq carrier plus 30 then 40 and then return to carrier - now simply as an increment
 242  01035             StartTones: LOAD s0, 35[53'd]
 243  2D00D                         OUTPUT s0, 0D[Tone]
 244  203A6                         CALL 3A6[delay_100ms]
 245  01023                         LOAD s0, 23[35'd]
 246  2D00D                         OUTPUT s0, 0D[Tone]
 247  203A6                         CALL 3A6[delay_100ms]
 248  01035                         LOAD s0, 35[53'd]
 249  2D00D                         OUTPUT s0, 0D[Tone]
 24A  203A6                         CALL 3A6[delay_100ms]
 24B  01023                         LOAD s0, 23[35'd]
 24C  2D00D                         OUTPUT s0, 0D[Tone]
 24D  203A6                         CALL 3A6[delay_100ms]
 24E  01035                         LOAD s0, 35[53'd]
 24F  2D00D                         OUTPUT s0, 0D[Tone]
 250  203A6                         CALL 3A6[delay_100ms]
 251  01023                         LOAD s0, 23[35'd]
 252  2D00D                         OUTPUT s0, 0D[Tone]
 253  203A6                         CALL 3A6[delay_100ms]
 254  01000                         LOAD s0, 00
 255  2D00D                         OUTPUT s0, 0D[Tone]                  ; and send value to SSB modulatorto reset to normal frequency
 256  01052                         LOAD s0, 52[82'd]                    ; Un Block DSPpico
 257  2D000                         OUTPUT s0, 00[CMD2DSP]               ; send R to DSP (release)
 258  25000                         RETURN 
 259                    Confidence: 
 259  200F2                         CALL 0F2[TX]
 25A  01500                         LOAD s5, 00
 25B                Confidenceloop: 
 25B  01042                         LOAD s0, 42[66'd]                    ; Block DSPpico 0x42
 25C  2D000                         OUTPUT s0, 00[CMD2DSP]               ; send B to DSP to block it
 25D                                ; need to output TX freq carrier plus 30 then 40 and then
 25D                                ; return to carrier - now simply as an increment
 25D  20242                         CALL 242[StartTones]
 25E  01042                         LOAD s0, 42[66'd]                    ; Block DSPpico 0x42 - need to re-block
 25F  2D000                         OUTPUT s0, 00[CMD2DSP]               ; send B to DSP to block it
 260  01014                         LOAD s0, 14[20'd]
 261  2D00D                         OUTPUT s0, 0D[Tone]
 262  203A6                         CALL 3A6[delay_100ms]
 263  01028                         LOAD s0, 28[40'd]
 264  2D00D                         OUTPUT s0, 0D[Tone]
 265  203A6                         CALL 3A6[delay_100ms]
 266  0103C                         LOAD s0, 3C[60'd]
 267  2D00D                         OUTPUT s0, 0D[Tone]
 268  203A6                         CALL 3A6[delay_100ms]
 269  01050                         LOAD s0, 50[80'd]
 26A  2D00D                         OUTPUT s0, 0D[Tone]
 26B  203A6                         CALL 3A6[delay_100ms]
 26C  01064                         LOAD s0, 64[100'd]
 26D  2D00D                         OUTPUT s0, 0D[Tone]
 26E  203A6                         CALL 3A6[delay_100ms]
 26F  202A4                         CALL 2A4[Stoptones]
 270                                ;ADD       s5, 01
 270                                ;COMPARE      s5, 02               ; Do this 4 times
 270                                ;JUMP      NZ, Confidenceloop
 270  01000                         LOAD s0, 00
 271  2D00D                         OUTPUT s0, 0D[Tone]                  ; and send value to SSB modulatorto reset to normal frequency
 272                                ;                    LOAD      s0, 82'd              ; Un Block DSPpico 0x52 --- already unblocked by stoptones
 272                                ;                   OUTPUT       s0, CMD2DSP         ; send R to DSP (release)
 272  200D0                         CALL 0D0[RX]
 273                                ;RETURN
 273  22041                         JUMP 041[startLoop]
 274                 TurnOffWarble: 
 274  200F2                         CALL 0F2[TX]
 275  01500                         LOAD s5, 00
 276             TurnOffWarbleloop: 
 276  01042                         LOAD s0, 42[66'd]                    ; Block DSPpico 0x42
 277  2D000                         OUTPUT s0, 00[CMD2DSP]               ; send B to DSP to block it
 278                                ; need to output TX freq carrier plus 30 then 40 and then
 278                                ; return to carrier - now simply as an increment
 278  01050                         LOAD s0, 50[80'd]
 279  2D00D                         OUTPUT s0, 0D[Tone]
 27A  203A6                         CALL 3A6[delay_100ms]
 27B  0103C                         LOAD s0, 3C[60'd]
 27C  2D00D                         OUTPUT s0, 0D[Tone]
 27D  203A6                         CALL 3A6[delay_100ms]
 27E  01028                         LOAD s0, 28[40'd]
 27F  2D00D                         OUTPUT s0, 0D[Tone]
 280  203A6                         CALL 3A6[delay_100ms]
 281  01050                         LOAD s0, 50[80'd]
 282  2D00D                         OUTPUT s0, 0D[Tone]
 283  203A6                         CALL 3A6[delay_100ms]
 284  0103C                         LOAD s0, 3C[60'd]
 285  2D00D                         OUTPUT s0, 0D[Tone]
 286  203A6                         CALL 3A6[delay_100ms]
 287  01028                         LOAD s0, 28[40'd]
 288  2D00D                         OUTPUT s0, 0D[Tone]
 289  203A6                         CALL 3A6[delay_100ms]
 28A  01050                         LOAD s0, 50[80'd]
 28B  2D00D                         OUTPUT s0, 0D[Tone]
 28C  203A6                         CALL 3A6[delay_100ms]
 28D  0103C                         LOAD s0, 3C[60'd]
 28E  2D00D                         OUTPUT s0, 0D[Tone]
 28F  203A6                         CALL 3A6[delay_100ms]
 290  01028                         LOAD s0, 28[40'd]
 291  2D00D                         OUTPUT s0, 0D[Tone]
 292  203A6                         CALL 3A6[delay_100ms]
 293  01050                         LOAD s0, 50[80'd]
 294  2D00D                         OUTPUT s0, 0D[Tone]
 295  203A6                         CALL 3A6[delay_100ms]
 296  0103C                         LOAD s0, 3C[60'd]
 297  2D00D                         OUTPUT s0, 0D[Tone]
 298  203A6                         CALL 3A6[delay_100ms]
 299  01028                         LOAD s0, 28[40'd]
 29A  2D00D                         OUTPUT s0, 0D[Tone]
 29B  203A6                         CALL 3A6[delay_100ms]
 29C                                ;ADD       s5, 01
 29C                                ;COMPARE      s5, 02               ; Do this 4 times
 29C                                ;JUMP      NZ, TurnOffWarbleloop
 29C  01000                         LOAD s0, 00
 29D  2D00D                         OUTPUT s0, 0D[Tone]                  ; and send value to SSB modulatorto reset to normal frequency
 29E  01052                         LOAD s0, 52[82'd]                    ; Un Block DSPpico 0x52
 29F  2D000                         OUTPUT s0, 00[CMD2DSP]               ; send R to DSP (release)
 2A0  200D0                         CALL 0D0[RX]
 2A1  25000                         RETURN 
 2A2                        Warble: 
 2A2                                ;LOAD      ScratchPointer, 00  ; effectively ignores command (sB)
 2A2                                ;LOAD      s6, 1F  ;"?"             ; ? debug warble start
 2A2                                ;CALL      Send2UartTX
 2A2                                ;LOAD      s6, 1F  ;"?"             ; ? debug
 2A2                                ;CALL      Send2UartTX
 2A2                                ;LOAD      s6, 1F  ;"?"             ; ? debug
 2A2                                ;CALL      Send2UartTX
 2A2                                ;CALL      SendCRLF            ; added to allow get line to read OK
 2A2  01042                         LOAD s0, 42[66'd]                    ; Block DSPpico 0x42
 2A3  2D000                         OUTPUT s0, 00[CMD2DSP]               ; send B to DSP to block it
 2A4                                ; need to output TX freq carrier plus 30 then 40 and then return to carrier - now simply as an increment
 2A4  01500              Stoptones: LOAD s5, 00
 2A5  0101E             Warbleloop: LOAD s0, 1E[30'd]
 2A6  2D00D                         OUTPUT s0, 0D[Tone]
 2A7  203A6                         CALL 3A6[delay_100ms]
 2A8  202B5                         CALL 2B5[WarbleFlushFIFO]
 2A9  01028                         LOAD s0, 28[40'd]
 2AA  2D00D                         OUTPUT s0, 0D[Tone]
 2AB  203A6                         CALL 3A6[delay_100ms]
 2AC  202B5                         CALL 2B5[WarbleFlushFIFO]
 2AD  11501                         ADD s5, 01
 2AE  1D504                         COMPARE s5, 04                       ; Do this 4 times
 2AF  362A5                         JUMP NZ, 2A5[Warbleloop]
 2B0  01000                         LOAD s0, 00
 2B1  2D00D                         OUTPUT s0, 0D[Tone]                  ; and send value to SSB modulatorto reset to normal frequency
 2B2  01052                         LOAD s0, 52[82'd]                    ; Un Block DSPpico 0x52
 2B3  2D000                         OUTPUT s0, 00[CMD2DSP]               ; send R to DSP (release)
 2B4                                ;LOAD      s6, 0F  ;"?"             ; ? debug warble end
 2B4                                ;CALL      Send2UartTX
 2B4                                ;LOAD      s6, 0F  ;"?"             ; ? debug
 2B4                                ;CALL      Send2UartTX
 2B4                                ;LOAD      s6, 0F  ;"?"             ; ? debug
 2B4                                ;CALL      Send2UartTX
 2B4                                ;CALL      SendCRLF            ; added to allow get line to read OK
 2B4  25000                         RETURN 
 2B5               WarbleFlushFIFO: 
 2B5  202E1                         CALL 2E1[getUARTchar]
 2B6  1D6FF                         COMPARE s6, FF
 2B7  31000                         RETURN Z                             ; If no character then done
 2B8                                ;LOAD      s6, s0
 2B8  20383                         CALL 383[Send2UartTX]
 2B9                                ;COMPARE      s6, 10'd
 2B9                                ;JUMP      Z, WarbleFlushFIFOLF    ; This is end of command character (LF now! as of Dec 2016)
 2B9                                ;COMPARE      s6, 13'd
 2B9                                ;JUMP      Z, WarbleFlushFIFO             ; If CR ignore
 2B9                                ;COMPARE      ScratchPointer, 16'd  ; Check we are not writing too many characters to the scratchpad
 2B9                                ;JUMP      NC, WarbleFlushFIFO            ; don't write to scratch if Pointer (counter) 16 or above
 2B9                                ;STORE     s6, (ScratchPointer)  ; Save command character
 2B9                                ;ADD       ScratchPointer, 01   ; is a command char so increment
 2B9  222B5                         JUMP 2B5[WarbleFlushFIFO]
 2BA             WarbleFlushFIFOLF: 
 2BA  0163F                         LOAD s6, 3F["?"]                     ; ? debug
 2BB  20383                         CALL 383[Send2UartTX]
 2BC  01900                         LOAD s9, 00                          ;
 2BD         WarbleFlushFIFOLFLoop: 
 2BD  20374                         CALL 374[getnextscratchchar]
 2BE                                ;;;LOAD      s6, s0             ; ? debug
 2BE  20383                         CALL 383[Send2UartTX]
 2BF                                ;COMPARE      s6, 0A               ; is this a LF
 2BF                                ;JUMP      Z, WarbleFlushFIFOLFDone
 2BF  1CB90                         COMPARE sB[ScratchPointer], s9       ; check end
 2C0  362B5                         JUMP NZ, 2B5[WarbleFlushFIFO]
 2C1         WarbleFlushFIFOLFDone: 
 2C1  0161F                         LOAD s6, 1F                          ;"?"             ; ? debug
 2C2  20383                         CALL 383[Send2UartTX]
 2C3  2038E                         CALL 38E[SendCRLF]                   ; added to allow get line to read OK
 2C4  01B00                         LOAD sB[ScratchPointer], 00          ; effectively ignores command (sB)
 2C5  222B5                         JUMP 2B5[WarbleFlushFIFO]
 2C6  200F2             BeaconBeep: CALL 0F2[TX]
 2C7  01700                         LOAD s7, 00
 2C8  202A2             Beaconloop: CALL 2A2[Warble]
 2C9                                ; Keep checking fifo for a character to keep it clear!
 2C9                                ;CALL      Check4CmdfromKP
 2C9                                ;COMPARE      s6, "t" ; character_t
 2C9                                ;JUMP      Z, cancelbeacon     ; Escape if is key pressed - changed this 2/5/13 to speed up beacon cancel
 2C9  11701                         ADD s7, 01
 2CA  1D703                         COMPARE s7, 03
 2CB                                ;JUMP      NZ, Beaconloop      ; do warble 3 times
 2CB  200D0                         CALL 0D0[RX]
 2CC                                ;CALL      delay_1s
 2CC                                ; Keep checking fifo for a character to keep it clear!
 2CC                                ;CALL      Check4CmdfromKP
 2CC                                ;COMPARE      s6, "t"  ; character_t
 2CC                                ;JUMP      Z, cancelbeacon     ; Escape if is key pressed
 2CC                                ;CALL      delay_1s
 2CC                                ; Keep checking fifo for a character to keep it clear!
 2CC                                ;CALL      Check4CmdfromKP
 2CC                                ;COMPARE      s6, "t"  ; character_t
 2CC                                ;JUMP      Z, cancelbeacon     ; Escape if is key pressed
 2CC                                ; 6/7/12 reduced receive period to 2s
 2CC  25000                         RETURN 
 2CD  0B012           cancelbeacon: FETCH s0, 12[Mode]
 2CE  030FE                         AND s0, FE[254'd]                    ; cancel beaon mode
 2CF  2F012                         STORE s0, 12[Mode]                   ; Hah - had forgotton to update the mode! 20/5/13
 2D0  25000                         RETURN 
 2D1             SendWatchdogReply: 
 2D1  202DD                         CALL 2DD[SendToKeypad]
 2D2  01626                         LOAD s6, 26["&"]                     ; start of message
 2D3  20383                         CALL 383[Send2UartTX]                ; send
 2D4  01670                         LOAD s6, 70["p"]                     ; User Watchdog going
 2D5  20383                         CALL 383[Send2UartTX]                ; send
 2D6  0160D                         LOAD s6, 0D                          ; c/r
 2D7  20383                         CALL 383[Send2UartTX]                ; send
 2D8  0160A                         LOAD s6, 0A
 2D9  20383                         CALL 383[Send2UartTX]                ; send
 2DA  01657                         LOAD s6, 57["W"]                     ; recover watchdog request from ARM
 2DB  22041                         JUMP 041[startLoop]
 2DC                                ; ;;Pete
 2DC                                ; ;;Pete
 2DC                                ; ;;Pete
 2DC                                ;HandleBTCommand:
 2DC                                ; ;;LOAD      s6, 'A'             ; get character
 2DC                                ; ;;CALL      Send2UartTX         ; and echo back to terminal
 2DC                                ;                    AND       s0, 7F             ; mask off top bit
 2DC                                ; need to interpret commands from BT Here
 2DC                                ;                    COMPARE      s0, TRANSMIT_ON
 2DC                                ;                    JUMP      Z, FromBT_XMIT      ; Bluetooth Headset transmit
 2DC                                ;                    COMPARE      s0, TRANSMIT_OFF
 2DC                                ;                    JUMP      Z, FromBT_RECEIVE   ; Bluetooth Headset stop transmit
 2DC           SendTurnOffToKeypad: 
 2DC  20274                         CALL 274[TurnOffWarble]              ; audio turn off to other end
 2DD                                ; only works if switching off through keypad
 2DD                  SendToKeypad: 
 2DD  0102A                         LOAD s0, 2A["*"]
 2DE  2D015                         OUTPUT s0, 15[CMD2KP]                ; trigger message to keypad
 2DF  2D615                         OUTPUT s6, 15[CMD2KP]                ; send turn off
 2E0  25000                         RETURN 
 2E1                                ; ;;COMPARE      s0, FLASH_WRITE
 2E1                                ; ;;JUMP      Z, FromBT_WRITE     ; PC has sent a WRITE to Flash request
 2E1                                ; ;;COMPARE      s0, FLASH_WRITE_PAGE
 2E1                                ; ;;JUMP      Z, FromBT_WRITE_PAGE; PC has sent a WRITE PAGE to Flash request
 2E1                                ; ;;COMPARE      s0, FLASH_ERASE
 2E1                                ; ;;JUMP      Z, FromBT_ERASE     ; PC has sent a Erase the Write message
 2E1                                ; ;;COMPARE      s0, FLASH_READ
 2E1                                ; ;;JUMP      Z, FromBT_READ      ; PC has sent a Read request
 2E1                                ; ;;COMPARE      s0, FLASH_READ_PAGE
 2E1                                ; ;;JUMP      Z, FromBT_READ_PAGE ; PC has sent a Read Page request
 2E1                                ; ;;COMPARE      s0, FLASH_WRITE_TEXT
 2E1                                ; ;;JUMP      Z, FromBT_WRITE_TEXT; PC has sent a WRITE TEXT to Flash request
 2E1                                ; LOAD      s0, 2F             ; send message back
 2E1                                ; OUTPUT       s0, CMD2BT          ; send Go to BT
 2E1                                ; CALL      SendCharToBT
 2E1                                ;                    JUMP      HandleBTCommand_Done
 2E1                                ;FromBT_XMIT:
 2E1                                ;                    CALL      SendCRLF
 2E1                                ;                    LOAD      s6, "T"
 2E1                                ;                    CALL      Send2UartTX         ; and echo back to terminal. Message mode
 2E1                                ;                    LOAD      s6, "x"
 2E1                                ;                    CALL      Send2UartTX         ; and echo back to terminal. Message mode
 2E1                                ;                    CALL      setTXmode
 2E1                                ;                    CALL      SendCRLF
 2E1                                ;                    LOAD      s0, 01
 2E1                                ;                    STORE     s0, BluetoothXmit
 2E1                                ;                    JUMP      HandleBTCommand_Done
 2E1                                ;FromBT_RECEIVE:
 2E1                                ;                    CALL      SendCRLF
 2E1                                ;                    LOAD      s6, "R"
 2E1                                ;                    CALL      Send2UartTX         ; and echo back to terminal. Message mode
 2E1                                ;                    LOAD      s6, "c"
 2E1                                ;                    CALL      Send2UartTX         ; and echo back to terminal. Message mode
 2E1                                ;                    CALL      setRXmode
 2E1                                ;                    CALL      SendCRLF
 2E1                                ;                    LOAD      s0, 00
 2E1                                ;                    STORE     s0, BluetoothXmit
 2E1                                ;                    JUMP      HandleBTCommand_Done
 2E1                                ; ;; end Pete
 2E1                                ; ;; end Pete
 2E1                                ; ;; end Pete
 2E1  016FF            getUARTchar: LOAD s6, FF                          ; Return FF if no character
 2E2  2037F                         CALL 37F[CheckUartRx]
 2E3  35000                         RETURN NZ                            ; Return if no character with s6=$FF
 2E4  09600                         INPUT s6, 00[Uart_rx]                ; get character
 2E5  0367F                         AND s6, 7F
 2E6                                ; CALL      Send2UartTX         ; and echo back to terminal. - SHOULD USE Send2UartTX (not in message mode)
 2E6  25000                         RETURN 
 2E7                                ; returns fifo character in s6 assuming present
 2E7  2030E       sendDSP2Terminal: CALL 30E[GetDSPFifoChar]
 2E8  01600                         LOAD s6, 00                          ; get character
 2E9  0367F                         AND s6, 7F                           ; top bit is for empty fifo flag!
 2EA                                ;Send to keypad pico (LCD) instead
 2EA                                ;                    CALL      Send2UartTX         ; and echo back to terminal.
 2EA  2D615                         OUTPUT s6, 15[CMD2KP]                ; send code 0-7F (normally ascii, but $7F would tell it to expect a value to display at a particular place)
 2EB  25000                         RETURN 
 2EC                                ; returns BT fifo character in s6 assuming present
 2EC  20314        sendBT2Terminal: CALL 314[GetBTFifoChar]
 2ED  00600                         LOAD s6, s0                          ; get character
 2EE  0367F                         AND s6, 7F
 2EF  20383                         CALL 383[Send2UartTX]                ; and echo back to terminal.
 2F0  25000                         RETURN 
 2F1                                ; returns KP fifo character in s6 assuming present
 2F1  2031A        sendKP2Terminal: CALL 31A[GetKPFifoChar]
 2F2  00600                         LOAD s6, s0                          ; get character
 2F3  0367F                         AND s6, 7F
 2F4  20383                         CALL 383[Send2UartTX]                ; and echo back to terminal.
 2F5  25000                         RETURN 
 2F6                                ; returns KP fifo character in s6 assuming present
 2F6  20320        sendTD2Terminal: CALL 320[GetTDFifoChar]
 2F7  00600                         LOAD s6, s0                          ; get character
 2F8  0367F                         AND s6, 7F
 2F9  20383                         CALL 383[Send2UartTX]                ; and echo back to terminal.
 2FA  25000                         RETURN 
 2FB                                ; checks for command from DSP pico, if present in s6 and echo to terminal - otherwise s6>127
 2FB  09104       Check4CmdfromDSP: INPUT s1, 04[DSPcmd]                 ; Get character from DSP picoblaze (if present should be less than 128)
 2FC  00610                         LOAD s6, s1
 2FD  1D180                         COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 2FE  382E7                         CALL C, 2E7[sendDSP2Terminal]        ; If less than 128 there is a value to give back and display.
 2FF  25000                         RETURN 
 300                                ; checks for command from BTpico, if present in s6 and echo to terminal - otherwise s6>127
 300  09105        Check4CmdfromBT: INPUT s1, 05[BTcmd]                  ; Get character from BT picoblaze (if present should be less than 128)
 301  00610                         LOAD s6, s1
 302  1D180                         COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 303                                ;CALL      C, sendBT2Terminal  ; If less than 128 there is a value to give back and display.
 303  25000                         RETURN 
 304                                ; checks for command from KPpico, if present in s6  - otherwise s6>127
 304  09106        Check4CmdfromKP: INPUT s1, 06[KPcmd]                  ; Get character from BT picoblaze (if present should be less than 128)
 305  00610                         LOAD s6, s1
 306  1D180                         COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 307  3831A                         CALL C, 31A[GetKPFifoChar]
 308  25000                         RETURN 
 309                                ; checks for command from TDpico, if present in s6  - otherwise s6>127
 309  09107        Check4CmdfromTD: INPUT s1, 07[TDcmd]                  ; Get character from BT picoblaze (if present should be less than 128)
 30A  00610                         LOAD s6, s1
 30B  1D180                         COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 30C  38320                         CALL C, 320[GetTDFifoChar]
 30D  25000                         RETURN 
 30E                                ; Routine to recover a byte, (character?) from the FIFO in s0
 30E  01010         GetDSPFifoChar: LOAD s0, 10[DSPFifo]
 30F  2D00E                         OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 310  01010                         LOAD s0, 10[DSPFifo]                 ; dummy, wait a bit longer for character to present itself
 311  09004                         INPUT s0, 04[DSPcmd]                 ; now get my character
 312  0307F                         AND s0, 7F                           ; mask off top bit
 313  25000                         RETURN 
 314                                ; Routine to recover a character from the BTFIFO in s0
 314  01020          GetBTFifoChar: LOAD s0, 20[BTFifo]
 315  2D00E                         OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 316  01020                         LOAD s0, 20[BTFifo]                  ; dummy, wait a bit longer for character to present itself
 317  09005                         INPUT s0, 05[BTcmd]                  ; now get my character
 318  0307F                         AND s0, 7F                           ; mask off top bit
 319  25000                         RETURN 
 31A                                ; Routine to recover a character from the KPFIFO in s6
 31A  01040          GetKPFifoChar: LOAD s0, 40[KPFifo]
 31B  2D00E                         OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 31C  01040                         LOAD s0, 40[KPFifo]                  ; dummy, wait a bit longer for character to present itself
 31D  09606                         INPUT s6, 06[KPcmd]                  ; now get my character
 31E  0367F                         AND s6, 7F                           ; mask off top bit
 31F  25000                         RETURN 
 320                                ; Routine to recover a character from the TDFIFO in s6
 320  01080          GetTDFifoChar: LOAD s0, 80[TDFifo]
 321  2D00E                         OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 322  01040                         LOAD s0, 40[KPFifo]                  ; dummy, wait a bit longer for character to present itself
 323  09607                         INPUT s6, 07[TDcmd]                  ; now get my character
 324  0367F                         AND s6, 7F                           ; mask off top bit
 325  25000                         RETURN 
 326                                ; sayOK:              CALL      SendCRLF
 326                                ; LOAD      s6, 79
 326                                ; CALL      Send2UartTX
 326                                ; LOAD      s6, 75
 326                                ; CALL      Send2UartTX
 326                                ; CALL      SendCRLF
 326                                ; RETURN
 326                                ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 326  00860             Chars2Byte: LOAD s8, s6
 327  20331                         CALL 331[Get4bits]
 328  00580                         LOAD s5, s8
 329  14506                         SL0 s5
 32A  14506                         SL0 s5
 32B  14506                         SL0 s5
 32C  14506                         SL0 s5                               ; put these 4 bits to MSBs
 32D  00870                         LOAD s8, s7
 32E  20331                         CALL 331[Get4bits]
 32F  10580                         ADD s5, s8
 330  25000                         RETURN 
 331                                ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 331  1D83C               Get4bits: COMPARE s8, 3C[60'd]                 ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 332  3A336                         JUMP C, 336[char0_9]
 333  19837                         SUB s8, 37[55'd]                     ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 334  0380F                         AND s8, 0F                           ; make sure only return 4 bits
 335  25000                         RETURN 
 336  19830                char0_9: SUB s8, 30[48'd]
 337  0380F                         AND s8, 0F                           ; make sure only return 4 bits
 338  25000                         RETURN 
 339                                ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 339  00850             Byte2Chars: LOAD s8, s5                          ; assumes 8 bit data is in s5
 33A  1450E                         SR0 s5
 33B  1450E                         SR0 s5
 33C  1450E                         SR0 s5
 33D  1450E                         SR0 s5                               ; get first hex character
 33E  20345                         CALL 345[GetChar]
 33F  00650                         LOAD s6, s5                          ; first ascii char
 340  00580                         LOAD s5, s8
 341  0350F                         AND s5, 0F
 342  20345                         CALL 345[GetChar]                    ;
 343  00750                         LOAD s7, s5                          ; second ascii char
 344  25000                         RETURN 
 345                                ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 345  1950A                GetChar: SUB s5, 0A[10'd]                     ; Test if s5 greater than 9
 346  3A349                         JUMP C, 349[is_0_9]                  ; Hex character is 0_9
 347  11541                         ADD s5, 41[65'd]                     ; offset for Ascii code 'A'
 348  25000                         RETURN 
 349  1150A                 is_0_9: ADD s5, 0A[10'd]                     ; return to range 0-9
 34A  11530                         ADD s5, 30[48'd]                     ; offset to Ascii code for '0'
 34B  25000                         RETURN 
 34C                                ; To send to Uart, simply use: OUTPUT       s3, UART_TX         ; Sends value in s3 to Uart Tx
 34C                                ; Dump archive RAM to RS232 port as 4 Ascii codes per data value followed by carriage return and line feed.
 34C  2036B            SendArchive: CALL 36B[DisableArchive]             ; Stop archiving
 34D  01000                         LOAD s0, 00
 34E  01100                         LOAD s1, 00
 34F  0B410              SendAloop: FETCH s4, 10[Latch7]
 350  034FC                         AND s4, FC[252'd]                    ; set top 2 address bits to zero
 351  2D006                         OUTPUT s0, 06[ProgramL]
 352  04410                         OR s4, s1                            ; patch in top 2 address bits
 353  2D407                         OUTPUT s4, 07[ProgramM]              ; and send to the output port
 354  09503                         INPUT s5, 03[ArchiveDataMSB]
 355  20389                         CALL 389[Byte2UART]
 356  09502                         INPUT s5, 02[ArchiveDataLSB]         ; grab bottom byte
 357  20389                         CALL 389[Byte2UART]
 358  11001                         ADD s0, 01
 359  13100                         ADDCY s1, 00
 35A  2038E                         CALL 38E[SendCRLF]
 35B  1D104                         COMPARE s1, 04
 35C  3634F                         JUMP NZ, 34F[SendAloop]
 35D  20366                         CALL 366[EnableArchive]              ; Restart archiving
 35E  25000                         RETURN 
 35F                                ; Select Archiving source, if s1 is 0 then raw 16bit ADC data is archived, or if s1=1 then 16bit data from the DSP picoblaze (DATA2Archve) is archived at 6kHz
 35F  03103          ArchiveSource: AND s1, 03
 360  0B014                         FETCH s0, 14[SelectScratch]          ; get current value of selections
 361  030FC                         AND s0, FC[252'd]                    ; first reset first 2 bits
 362  04010                         OR s0, s1                            ; affect bits 0-1
 363  2D008                         OUTPUT s0, 08[SelectArchiveSource]   ; update archive control port
 364  2F014                         STORE s0, 14[SelectScratch]          ; Update scratchpad
 365                                ;      LOAD   s5,s0
 365                                ;      CALL   Byte2Chars
 365  25000                         RETURN 
 366                                ; Enable Archiving
 366  0B010          EnableArchive: FETCH s0, 10[Latch7]                 ; get current value of control port
 367  05040                         OR s0, 40[EnArchive]                 ; set bit 5
 368  2D007                         OUTPUT s0, 07[ProgramM]
 369  2F010                         STORE s0, 10[Latch7]                 ; get current value of control port
 36A  25000                         RETURN 
 36B                                ; Disable Archiving
 36B  00600         DisableArchive: LOAD s6, s0
 36C  203B5                         CALL 3B5[delay_50us]                 ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D                                ; CALL      delay_1ms           ; wait for a bit more archiving first!
 36D  203AB                         CALL 3AB[delay_1ms]                  ; wait for a bit more archiving first!
 36E  0B010                         FETCH s0, 10[Latch7]                 ; get current value of control port
 36F  030BF                         AND s0, BF[~EnArchive]               ; reset bit 5
 370  2D007                         OUTPUT s0, 07[ProgramM]
 371  2F010                         STORE s0, 10[Latch7]                 ; get current value of control port
 372  00060                         LOAD s0, s6                          ; restore s0 value
 373  25000                         RETURN 
 374                                ; Character parsing:
 374                                ; returns next command character in s0
 374  0A090     getnextscratchchar: FETCH s0, (s9)
 375  11901                         ADD s9, 01                           ; increment pointer
 376  00600                         LOAD s6, s0
 377  25000                         RETURN 
 378                                ; Reads 2 ascii codes and returns the byte represented in hex as binary value in s5
 378  20374           getnextvalue: CALL 374[getnextscratchchar]
 379  00400                         LOAD s4, s0
 37A  20374                         CALL 374[getnextscratchchar]
 37B  00700                         LOAD s7, s0
 37C  00640                         LOAD s6, s4
 37D  20326                         CALL 326[Chars2Byte]                 ; return byte in s5
 37E  25000                         RETURN 
 37F                                ; UART control
 37F  09001            CheckUartRx: INPUT s0, 01[Uart_status]            ; Check if there is RX data
 380  03001                         AND s0, 01
 381  1D001                         COMPARE s0, 01
 382  25000                         RETURN 
 383                                ; send character in s6 to Uart - also uses s8!
 383  09801            Send2UartTX: INPUT s8, 01[Uart_status]            ; Check if TX buffer is full
 384  03802                         AND s8, 02
 385  1D802                         COMPARE s8, 02                       ; if 2 then wait
 386  32383                         JUMP Z, 383[Send2UartTX]
 387  2D601                         OUTPUT s6, 01[UART_TX]
 388  25000                         RETURN 
 389                                ; Convert byte in s5 into 2 ascii codes in hexadecimal and send to the serial port.
 389  20339              Byte2UART: CALL 339[Byte2Chars]
 38A  20383                         CALL 383[Send2UartTX]
 38B  00670                         LOAD s6, s7
 38C  20383                         CALL 383[Send2UartTX]
 38D  25000                         RETURN 
 38E  0160D               SendCRLF: LOAD s6, 0D
 38F  20383                         CALL 383[Send2UartTX]
 390  0160A                         LOAD s6, 0A
 391  20383                         CALL 383[Send2UartTX]
 392  25000                         RETURN 
 393  01620              SendSPACE: LOAD s6, 20
 394  20383                         CALL 383[Send2UartTX]
 395  25000                         RETURN 
 396                                CONSTANT count_1000_lsb, E8          ; lower 8-bits of 1000 count value
 396                                CONSTANT count_1000_msb, 03          ; upper 8-bits of 1000 count value
 396                                ; Registers used s0, s1, s2, s3, s4 and s5.
 396                                ;
 396  01500               delay_1s: LOAD s5, 00                          ; clear cycle counter
 397  01400                         LOAD s4, 00
 398  203AB                wait_1s: CALL 3AB[delay_1ms]
 399  11401                         ADD s4, 01                           ; increment cycle counter
 39A  13500                         ADDCY s5, 00
 39B  1D4E8                         COMPARE s4, E8[count_1000_lsb]       ; test for 1000ms
 39C  36398                         JUMP NZ, 398[wait_1s]
 39D  1D503                         COMPARE s5, 03[count_1000_msb]
 39E  36398                         JUMP NZ, 398[wait_1s]
 39F  25000                         RETURN 
 3A0                                ;
 3A0                                ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 3A0                                ;
 3A0                                ;
 3A0                                ; Registers used s0, s1, s2, s3 and s4.
 3A0                                ;
 3A0  203A6             delay500ms: CALL 3A6[delay_100ms]
 3A1  203A6                         CALL 3A6[delay_100ms]
 3A2  203A6            delay_300ms: CALL 3A6[delay_100ms]
 3A3  203A6            delay_200ms: CALL 3A6[delay_100ms]
 3A4  203A6                         CALL 3A6[delay_100ms]
 3A5  25000                         RETURN 
 3A6                                ;
 3A6                                ; Delay of approximately 100ms used for switch debounce
 3A6                                ;
 3A6                                ; Registers used s0, s1, s2, s3 and s4.
 3A6                                ;
 3A6  01464            delay_100ms: LOAD s4, 64                          ; repeat 1ms delay 100 times
 3A7  203AB             wait_100ms: CALL 3AB[delay_1ms]
 3A8  19401                         SUB s4, 01
 3A9  363A7                         JUMP NZ, 3A7[wait_100ms]
 3AA  25000                         RETURN 
 3AB                                ;
 3AB                                ; Registers used s0, s1, s2 and s3.
 3AB                                ;
 3AB  01300              delay_1ms: LOAD s3, 00                          ; clear cycle counter
 3AC  01200                         LOAD s2, 00
 3AD  203BA               wait_1ms: CALL 3BA[delay_1us]
 3AE  11201                         ADD s2, 01                           ; increment cycle counter
 3AF  13300                         ADDCY s3, 00
 3B0  1D2E8                         COMPARE s2, E8[count_1000_lsb]       ; test for 1000us
 3B1  363AD                         JUMP NZ, 3AD[wait_1ms]
 3B2  1D303                         COMPARE s3, 03[count_1000_msb]
 3B3  363AD                         JUMP NZ, 3AD[wait_1ms]
 3B4  25000                         RETURN 
 3B5                                ;
 3B5                                ; Delay of approximately 50us required by LCD display
 3B5                                ;
 3B5                                ; Registers used s0 and s1.
 3B5                                ;
 3B5  01132             delay_50us: LOAD s1, 32[50'd]                    ; repeat 1us delay 50 times
 3B6  203BA              wait_50us: CALL 3BA[delay_1us]
 3B7  19101                         SUB s1, 01
 3B8  363B6                         JUMP NZ, 3B6[wait_50us]
 3B9  25000                         RETURN 
 3BA                                ; Delay of approximately 1us used to provide timing reference for
 3BA                                ; LCD operations. This must be adjusted to reflect the clock
 3BA                                ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 3BA                                ;
 3BA                                ; The software delay loop is formed using register s0. This register
 3BA                                ; must be loaded with an integer value close to the result of....
 3BA                                ;
 3BA                                ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 3BA                                ;
 3BA                                ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 3BA                                ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 3BA                                ; operation will become lower than the 100KHz target intended.
 3BA                                ;
 3BA                                ; Register used s0.
 3BA                                ;
 3BA  0100C              delay_1us: LOAD s0, 0C[delay_1us_constant]      ; delay value of 12 decimal for a 50MHz clock
 3BB  19001               wait_1us: SUB s0, 01
 3BC  363BB                         JUMP NZ, 3BB[wait_1us]
 3BD  25000                         RETURN 
 3BE                                ;
 3BE                                ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\home\gnaylor\Dropbox\N3SysGen\UserPico.psm



List of defined constants

 CONSTANT name        Value        Source PSM File

 timestamp_hours      19'd         
 timestamp_minutes    57'd         
 timestamp_seconds    52'd         
 datestamp_year       17'd         
 datestamp_month      9'd          
 datestamp_day        06'd         
 NUL                  00           
 BEL                  07           
 BS                   08           
 HT                   09           
 LF                   0A           
 VT                   0B           
 CR                   0D           
 ESC                  1B           
 DEL                  7F           
 DCS                  90           
 ST                   9C           
 Versionno            0C           UserPico.psm
 InitialVolume        133'd        UserPico.psm
 MinoxrVersionno      EE           UserPico.psm
 Bmode                00           UserPico.psm
 AGCupperRX           32           UserPico.psm
 AGClowerRX           12           UserPico.psm
 AGCupperTX           30           UserPico.psm
 AGClowerTX           12           UserPico.psm
 delay_1us_constant   12'd         UserPico.psm
 WREN                 06           UserPico.psm
 FAST_READ            0B           UserPico.psm
 BERASE               C7           UserPico.psm
 SER                  D8           UserPico.psm
 RDID                 9F           UserPico.psm
 PP                   02           UserPico.psm
 RDSR                 05           UserPico.psm
 Latch7               16'd         UserPico.psm
 LastDSPbyte          17'd         UserPico.psm
 Mode                 18'd         UserPico.psm
 ADCstate             19'd         UserPico.psm
 SelectScratch        20'd         UserPico.psm
 ADCLevel             21'd         UserPico.psm
 ADCgain              22'd         UserPico.psm
 TX_F_MSB             23'd         UserPico.psm
 TX_F_LSB             24'd         UserPico.psm
 ADCAGCUpperThreshold 25'd         UserPico.psm
 ADCAGCLowerThreshold 26'd         UserPico.psm
 ADCGainTX            27'd         UserPico.psm
 ADCGainRX            28'd         UserPico.psm
 peteTXMode           40'd         UserPico.psm
 Uart_rx              00           UserPico.psm
 Uart_status          01           UserPico.psm
 BattMon              4'd          UserPico.psm
 ArchiveDataLSB       2'd          UserPico.psm
 ArchiveDataMSB       3'd          UserPico.psm
 DSPcmd               4'd          UserPico.psm
 BTcmd                5'd          UserPico.psm
 KPcmd                6'd          UserPico.psm
 TDcmd                7'd          UserPico.psm
 DSPRAMrdbkMSB        9'd          UserPico.psm
 DSPRAMrdbkLSB        10'd         UserPico.psm
 BTRAMrdbkMSB         11'd         UserPico.psm
 BTRAMrdbkLSB         12'd         UserPico.psm
 KPRAMrdbkMSB         13'd         UserPico.psm
 KPRAMrdbkLSB         14'd         UserPico.psm
 ADCSignalLevel       15'd         UserPico.psm
 CMD2DSP              00           UserPico.psm
 UART_TX              01           UserPico.psm
 GainPD               02           UserPico.psm
 Instructiona         03           UserPico.psm
 Instructionb         04           UserPico.psm
 Instructionc         05           UserPico.psm
 ProgramL             06           UserPico.psm
 ProgramM             07           UserPico.psm
 EnArchive            64'd         UserPico.psm
 TX_HIGH              128'd        UserPico.psm
 SelectArchiveSource  8'd          UserPico.psm
 Configure            9'd          UserPico.psm
 RXFreqMSB            10'd         UserPico.psm
 RXFreqLSB            11'd         UserPico.psm
 AudioVolume          12'd         UserPico.psm
 Tone                 13'd         UserPico.psm
 Acknowledge          14'd         UserPico.psm
 DSPFifo              16'd         UserPico.psm
 BTFifo               32'd         UserPico.psm
 KPFifo               64'd         UserPico.psm
 TDFifo               128'd        UserPico.psm
 FlashData            17'd         UserPico.psm
 ADCstate_port        19'd         UserPico.psm
 LoranBlank           16'd         UserPico.psm
 AudioOutSelect       32'd         UserPico.psm
 AnalogueChannel      64'd         UserPico.psm
 CMD2BT               20'd         UserPico.psm
 CMD2KP               21'd         UserPico.psm
 RAMDataMSB           22'd         UserPico.psm
 RAMDataLSB           23'd         UserPico.psm
 RAMwriteControl      25'd         UserPico.psm
 TRANSMIT_ON          14           UserPico.psm
 TRANSMIT_OFF         15           UserPico.psm
 count_1000_lsb       E8           UserPico.psm
 count_1000_msb       03           UserPico.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "06 Sep 2017"  
 timestamp$        "19:57:52"     



List of line labels

   Label                   Addr  Source PSM File

 * boot                    000   UserPico.psm
 * start                   001   UserPico.psm
   reboot                  001   UserPico.psm
   DoUserProg              007   UserPico.psm
   GetProg                 00A   UserPico.psm
   GetByte                 01B   UserPico.psm
   cold_start              021   UserPico.psm
   ProgDSP                 022   UserPico.psm
   ScratchClear            023   UserPico.psm
   init                    028   UserPico.psm
   startLoop               041   UserPico.psm
   loop                    042   UserPico.psm
   SendADCToARM            061   UserPico.psm
   CheckADClevel           06F   UserPico.psm
   nofive                  07E   UserPico.psm
   First                   081   UserPico.psm
   Second                  084   UserPico.psm
   Third                   087   UserPico.psm
   Fourth                  08A   UserPico.psm
   Fifth                   08D   UserPico.psm
   ToLCD                   091   UserPico.psm
 * Tempskip                091   UserPico.psm
   ReduceADCgain           099   UserPico.psm
   IncreaseADCgain         0A2   UserPico.psm
   checkMsgFromTD          0AB   UserPico.psm
   checkMsgFromTDloop      0AC   UserPico.psm
   checkrqst               0B5   UserPico.psm
   SendToARM               0B8   UserPico.psm
   waitForKey              0B9   UserPico.psm
 * setEarthAntennas        0BF   UserPico.psm
 * setLoopAntennas         0C4   UserPico.psm
 * checkRXmode             0C9   UserPico.psm
   RX                      0D0   UserPico.psm
 * checkTXmode             0D7   UserPico.psm
   setTXmodeARM            0DE   UserPico.psm
   setTXmode               0E0   UserPico.psm
   TX                      0F2   UserPico.psm
   setRXmodeARM            0F9   UserPico.psm
   setRXmode               0FB   UserPico.psm
   SetAnGain               11A   UserPico.psm
   interpcommand           125   UserPico.psm
 * interploop              126   UserPico.psm
   MsgFromARM              146   UserPico.psm
   isS                     151   UserPico.psm
   isG                     163   UserPico.psm
   isSA                    175   UserPico.psm
   isSB                    17F   UserPico.psm
   isSK                    186   UserPico.psm
   isSL                    18A   UserPico.psm
   setLoranBlank           18F   UserPico.psm
   isSKS                   195   UserPico.psm
 * isSS                    196   UserPico.psm
   isSU                    1A0   UserPico.psm
   isSW                    1A5   UserPico.psm
   isSSloop                1B3   UserPico.psm
   nowsend2flashback       1BB   UserPico.psm
 * nowsend2flash           1C3   UserPico.psm
   isSR                    1C5   UserPico.psm
   isST                    1CB   UserPico.psm
   isSAS                   1CF   UserPico.psm
   isSAG                   1D3   UserPico.psm
   isSAI                   1DA   UserPico.psm
   setADC                  1DF   UserPico.psm
   isSAO                   1E5   UserPico.psm
   setAudioOut             1EA   UserPico.psm
   isSRF                   1F0   UserPico.psm
   isSRM                   1F5   UserPico.psm
   isSTM                   1F7   UserPico.psm
   isGG                    1F9   UserPico.psm
   isGS                    202   UserPico.psm
   isGB                    20B   UserPico.psm
   isGC                    213   UserPico.psm
   isGK                    216   UserPico.psm
   isGL                    21C   UserPico.psm
   isGKT                   228   UserPico.psm
   isGKV                   231   UserPico.psm
   isGA                    23A   UserPico.psm
   isGV                    23C   UserPico.psm
   TripleTwotone           240   UserPico.psm
   StartTones              242   UserPico.psm
   Confidence              259   UserPico.psm
 * Confidenceloop          25B   UserPico.psm
   TurnOffWarble           274   UserPico.psm
 * TurnOffWarbleloop       276   UserPico.psm
   Warble                  2A2   UserPico.psm
   Stoptones               2A4   UserPico.psm
   Warbleloop              2A5   UserPico.psm
   WarbleFlushFIFO         2B5   UserPico.psm
 * WarbleFlushFIFOLF       2BA   UserPico.psm
 * WarbleFlushFIFOLFLoop   2BD   UserPico.psm
 * WarbleFlushFIFOLFDone   2C1   UserPico.psm
   BeaconBeep              2C6   UserPico.psm
 * Beaconloop              2C8   UserPico.psm
 * cancelbeacon            2CD   UserPico.psm
   SendWatchdogReply       2D1   UserPico.psm
 * SendTurnOffToKeypad     2DC   UserPico.psm
   SendToKeypad            2DD   UserPico.psm
   getUARTchar             2E1   UserPico.psm
   sendDSP2Terminal        2E7   UserPico.psm
 * sendBT2Terminal         2EC   UserPico.psm
 * sendKP2Terminal         2F1   UserPico.psm
 * sendTD2Terminal         2F6   UserPico.psm
   Check4CmdfromDSP        2FB   UserPico.psm
   Check4CmdfromBT         300   UserPico.psm
   Check4CmdfromKP         304   UserPico.psm
   Check4CmdfromTD         309   UserPico.psm
   GetDSPFifoChar          30E   UserPico.psm
   GetBTFifoChar           314   UserPico.psm
   GetKPFifoChar           31A   UserPico.psm
   GetTDFifoChar           320   UserPico.psm
   Chars2Byte              326   UserPico.psm
   Get4bits                331   UserPico.psm
   char0_9                 336   UserPico.psm
   Byte2Chars              339   UserPico.psm
   GetChar                 345   UserPico.psm
   is_0_9                  349   UserPico.psm
   SendArchive             34C   UserPico.psm
   SendAloop               34F   UserPico.psm
   ArchiveSource           35F   UserPico.psm
   EnableArchive           366   UserPico.psm
   DisableArchive          36B   UserPico.psm
   getnextscratchchar      374   UserPico.psm
   getnextvalue            378   UserPico.psm
   CheckUartRx             37F   UserPico.psm
   Send2UartTX             383   UserPico.psm
   Byte2UART               389   UserPico.psm
   SendCRLF                38E   UserPico.psm
 * SendSPACE               393   UserPico.psm
 * delay_1s                396   UserPico.psm
   wait_1s                 398   UserPico.psm
   delay500ms              3A0   UserPico.psm
 * delay_300ms             3A2   UserPico.psm
 * delay_200ms             3A3   UserPico.psm
   delay_100ms             3A6   UserPico.psm
   wait_100ms              3A7   UserPico.psm
   delay_1ms               3AB   UserPico.psm
   wait_1ms                3AD   UserPico.psm
   delay_50us              3B5   UserPico.psm
   wait_50us               3B6   UserPico.psm
   delay_1us               3BA   UserPico.psm
   wait_1us                3BB   UserPico.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            171
 STAR              -

 AND              41
 OR               16
 XOR               -

 ADD              20
 ADDCY             4
 SUB               9
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          83
 COMPARECY         -

 SL0               6
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               5
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT            19
 OUTPUT           89
 OUTPUTK           -

 STORE            37
 FETCH            37

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP            113
 JUMP@             -
 CALL            238
 CALL@             -
 RETURN           67
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
