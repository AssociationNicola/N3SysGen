KCPSM6 Assembler log file for program 'Z:\home\graham\Dropbox\N3workingG\TE0722Rebuild\N3SysGen\UserPico.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 16 Jul 2016
Assembly timestamp: 17:39:13

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 38D hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 910
Memory locations available: 3186


Assembly listing

 Addr Code                         Instruction

 000                               ;GV08 lower audio volume control to about 0.8V (Prod7)
 000                               ;GV07 correct incorrect data archive and demod peak display problem (MSB/LSB mixup!)
 000                               ;GV06 Increase output amplitude of SSB in DSPpico on TX
 000                               ;GV05 Modified frequencies (MMCM and KeypadPico values) to work with 33.333MHz clock for production model (Apr 2012)
 000                               ;GV04 Now using mic preamp so need to fix AGCs
 000                               ;GV03 Mods to DSP to try and get volume load and saturate OutAmp properly
 000                               ;GV02 Halved AGC thresholds to avoid clipping SysGen v1.18
 000                               ;GV01 add redirect command SW for UART to patch through to BT module
 000                               ;GV01 Reduce Speaker volume AGC on startup
 000                               ;GV00 Reset GV to 0 for new TE0722 working version
 000                               ;GVA5 for TE0722, with RX/TX frequencies adjusted for 32.768MHz
 000                               ;GVA4 corrected DSPprog to not crash (AGC suddenly dropping)
 000                               ;GVA2 send demod level to LCD display
 000                               ;GVA0 Add temporary measures around line 510 to transmit values from DSPpico (of tone demod levels as ascii characters on to the LCD)
 000                               ;GV9A, correct Earth Loop setting incorrect and make immediate.
 000                               ; GV99 corrected Attenuator not adding 30 on level display in TX mode, add turn on pad and entenna select
 000                               ; GV98 More BT mic boost
 000                               ; GV97 corrected BT combination
 000                               ; GV96 drop ADC gain RX to 70% and TX to 50%
 000                               ; GV95 Frequency now set from keypad pico
 000                               ; GV94  24 Feb 2015 Pete  -  re-enable BT commands and add scratchpad clear
 000                               ; GV93 add code in KP pico and firmware to display ADC and demod level
 000                               ; GV92 add Pete's new BTcode with shorter inquiry time - but hadn't put in the script at the end of model propertes to get the correct mem files from Pete
 000                               ; line407 disable loran blank for 31kHz
 000                               ; GV91 increased ADC level 10dB by increasing RXAGClevel
 000                               ; GV90 Version to run at 31.008kHz so use 1323 ($52B) for TX and 10925 ($2AAD) for RX
 000                               ; GV51 Use DSP 51 to only attenuate on receive (which had clipping - but transmit was OK)
 000                               ; GV50 Adjusted DSP AGC back down as there was still clipping
 000                               ; GV4F Adjusted AGC thresholds in SP3E and DSPprogN3GV47 to improve clarity of speech
 000                               ; GV4D PMOD2 now used to control extra attenuation (~30dB)
 000                               ; GV4C back to TX_LOW but PMOD1 held low
 000                               ; GV4B For proto D with TX_high  output instead of TX_LOW
 000                               ; GV4A For ProtoD with new keypad
 000                               ; GV48 changed CheckADClevel routine - but still need to change display (KP pico code) to display signal level and gain value. No Beacon
 000                               ; GV46 BT present cuts audio - modified BT detect logic
 000                               ; GV45 Corrected resetting of AveSignalMSB to middle value so as to avoid double jump and increased allowable rang to avoid unnecessary jumps
 000                               ; GV44 Add SU command to set UART output streaming
 000                               ; GV43 Correct beacon phase wander in DSP pico code
 000                               ; GV42 As 41 but with UART testing bits removed
 000                               ; GV41 send DSP data to UART in normal loop and streaming loop
 000                               ; GV40 correct streaming mode bits and shift beacon mode check to end of loop
 000                               ; GV3F  Add UART streaming command for transmit - SS<xx> where xx is hex value of number of bits to shift the values Add GL command to get Loran blank rate
 000                               ; GV3E some work on AGCcounter to include sinewave addition, but mainly add command GS to get AveSignalMSB
 000                               ; GV3D change the way the AGC works in the DSP pico to speed up increasing attenuation if the signal is very strong
 000                               ; GV3C change pincode in BTText to 1234 for HFP profile
 000                               ; GV3A send prompt to DSPcore to grab AGCvalue and store just before the EOT warble + store ADCgain (lower 4 bits) for TX and RX modes (that will be used by CALL SetAnGain )
 000                               ; GV39 Includes Pete's BT code and new DSP AGC stuff (from GV38)
 000                               ; GV36 reduce initial ADC gain on tranmit (reduce mic gain)
 000                               ; GV35 Uses nw I_Q demodulator
 000                               ; GV33 Add delay to audio stream (reduce fdbk?) and use phase incrementing on TX.
 000                               ; GV32 Adjust AGCs
 000                               ; GV31 Now starting to use LPF in DSPprogN3WithLPF and has SL command to set Loran Blanking (SL01)
 000                               ; GV30 reduce RX ADC gain and increase TX (mic) gain.
 000                               ; GV27 Default Loran Blanking on
 000                               ; GV26 for N2 with Higher gain on DSP RF output and shorter beacon period
 000                               ; GV24 for N2
 000                               ; GV23 Corrected some of the RAM block writing issues
 000                               ; GV22 Correct loop not completing when no character! Now displays ADC gain setting on
 000                               ; GV21 use with keypad prog to inhibit pad scan and here send adc level info (should auto gain on ADC to keep between 30 and 100 ie ~$20 and ~$60)
 000                               ; GV20 Corrected non switching of ADC input to MIC!
 000                               ; GV1F Normal orientation of ADC inputs with auto BT audio switching
 000                               ; GV1E temporarily switch ADC input channel as op amp blown!
 000                               ; GV1D Heyphone but for prototype 2 (using TX_HIGH!!)
 000                               ; GV1C For HeyPhone
 000                               ; GV1A Correct flash writing errors to point to right memory address
 000                               ; GV1A
 000                               ; GV19 corrected phase interpretation of SSB encoding
 000                               ; GV18 Try dirac input
 000                               ; GV17 Add STT command to send test sinewave for transmit - Now removed March 2012
 000                               ; GV16 Worked on Beacon lockup, now starts with beacon, press button for ~6secs
 000                               ; GV14 try beacon again at startup
 000                               ; GV15 try to fix not stopping beacon issue (don't start with beacon!) - display mode value on LCD (send to KPpico)
 000                               ; GV13 no beacon
 000                               ; GV11 fix beacon mode so that DSP is blocked at frequency offset and fixed amp for ~1s when ending TX mode - also set Beacon mode on power up which stops when button pressed
 000                               ; Set ADC gain in initialisation properly to calibrate aswell.
 000                               ; GV10 Add ADC signal level monitoring and try phase SSB encoding again with 2x phase to SSB module
 000                               ; Command GL in version GV10 allows the signal level to be returned from the ADC
 000                               ; GV0F Use phase encoding
 000                               ; GV0E full 16 bit frequency coding of TX 29/8/11
 000                               ; GV0D With Beacon
 000                               ; GV0C add BT mic input
 000                               ; GV09 stopped sending r/T t seria; port an adjusted reading from KPfifo
 000                               ; GV08 Added facility to switch RX/TX from keypad
 000                               ; GV07  Increased sensitivity of touch pads June 11
 000                               ; May 26- try and modify so that it starts correctly when powerred up with user program
 000                               ; MayA 11 use PMOD 2 to switch serial port and activate keypad
 000                               ; May 11, add SAO command to set audio channel (00, for BT, 01 for radio transceiver)
 000                               ; March 2011 testing SPI interface:
 000                               ; commands
 000                               ; WREN $06 (enable writing)
 000                               ; WRDI $04 (disable writing)
 000                               ; FAST_READ $0B followed by 3 address bytes, 1 dummy byte and then n bytes to feed back data and leave last 2 values for readback
 000                               ; BERASE  $C7 (bulk erase) - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                               ; SE     $D8 (sector erase) followed by 3 address bytes, - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                               ; PP     $02 (page program) followed by 3 address bytes,  then n bytes of data to be written (need then to pulse Send2Flash by writing 16 to ProgramM)
 000                               ;
 000                               ; Example commands:
 000                               ; SMW0102030405060708090A     -writes values 1-10 to flash addresses from 800000
 000                               ; SMR800002 should read the bytes 03 and 02 ??
 000                               ; Now for Godil Board
 000                               ; Version for multi pico boot with shifted bit offsets on oport
 000                               CONSTANT Versionno, 08               ; 1 July 2016
 000                               CONSTANT InitialVolume, 133'd        ;lowerred volume
 000                               CONSTANT MinorVersionno, EE          ; Pete
 000                               ; CONSTANT TXType,       7E                 ; $7E for N2 and $80 for Heyphone
 000                               ; CONSTANT RXType,       46                 ; $46 for N2 and 55 for Heyphone)
 000                               CONSTANT Bmode, 00
 000                               ; Set thresholds for AGC
 000                               CONSTANT AGCupperRX, 32              ; Increased factor 2 on RX and TX with signal level monitor - increased RX 3 again from $18 (24 to 72, ie $48)
 000                               CONSTANT AGClowerRX, 12              ; was $0C, increased to 36=$24
 000                               CONSTANT AGCupperTX, 10
 000                               CONSTANT AGClowerTX, 06
 000                               ; SAI Set analogue input SAI<xx>  xx=00 or 01
 000                               ; SAO Set audio Output source
 000                               ; SAS Set archive source SAS<xx>
 000                               ; SAG Set analogue gain SAG<xx>
 000                               ; SB set beacon mode
 000                               ; SRM set receive mode
 000                               ; SRF set receive frequency
 000                               ; STM set transmit mode
 000                               ; STF set transmit frequency
 000                               ; SAG   Set analogue gain, use: 51-5E + automatic calibration
 000                               ; SAS <value> - set archive source (0 or 1)
 000                               ; GA get archive
 000                               ; GT get status of touch
 000                               ; GV get version
 000                               ; GP get response from DSP
 000                               ; GB get response from BT
 000                               ; GKT get touch response from KP
 000                               ; March 2009, now using loading over BT, implement server commands
 000                               ; Dec 2008 - implementing on SSBN3.mdl
 000                               ; Test Spartan 3e board May 2007
 000                               ; Program for user interface: Pico 1
 000                               ; Load SP3E with bit file - spartan3e_adcrx_tx_cw.bit using USB download cable (+ImpacT)
 000                               ; Connect serial lead and send file for test program from Matlab using somethng like
 000                               ; LCDtestprog=getpblazidefile('LCDUartS3e.mem');
 000                               ; Send6bitInstructionsPico1
 000                               ;
 000                               ; Addresses of latched data
 000                               ; 0 Cmd Control Pico2
 000                               ; 1 UartTx
 000                               ; 2 Gain ChA (bits 0-2)
 000                               ; Gain ChB(bits 4-6)
 000                               ; 3 Instruction first 6bits (MSB)
 000                               ; 4 Instruction 2nd 6 bits
 000                               ; 5 Instruction 3rd 6 bits
 000                               ; 6 Program Address LSB
 000                               ; 7 Program Address upper 2 bits
 000                               ;  bit 2,3 and 4 decoded to either Write ROM1,Write ROM2,Write ROM3,Write ROM4 or reset picos
 000                               ;  bit 5-Enable archive
 000                               ;  bit 6-Select archive source
 000                               ;  bit 7 TX_HIGH
 000                               ; 10 Set_RXFreq LSbyte
 000                               ; 11 Set_RXFreq USbyte
 000                               ; 12 Set_TXFreq LSbyte
 000                               ; 13 Set_TXFreq USbyte
 000                               ; 14 Message character 1 -***Note these data ports are for writing characters at the address bus to the message RAM!!
 000                               ; 15 Message character 2
 000                               ; 16 Message character 3 - RAM is written on write to this port (last 6 bit character)
 000                               ; 17 Relay ctrl
 000                               ; 18 Battery monitor
 000                               CONSTANT delay_1us_constant, 12'd    ; Now 49.152MHz Value (13)19 or 12? decimal suitable for 50MHz clock or about 6 for 33MHz?
 000                               CONSTANT WREN, 06                    ; (enable writing)
 000                               CONSTANT FAST_READ, 0B               ; followed by 3 address bytes, 1 dummy byte and then n bytes to feed back data and leave last 2 values for readback
 000                               CONSTANT BERASE, C7                  ; (bulk erase) - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                               CONSTANT SER, D8                     ; (sector erase) followed by 3 address bytes, - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                               CONSTANT RDID, 9F
 000                               CONSTANT PP, 02                      ; (page program) followed by 3 address bytes,  then n bytes of data to be written (need then to pulse Send2Flash by writing 16 to CMD2DSP)
 000                               CONSTANT RDSR, 05
 000                               ; Registers
 000                               ;counter             EQU       sC                  ; Counter - for Acquisitions
 000                               ;ScratchPointer      EQU       sB                  ; pointer for decoding command in scratch memory
 000                               NAMEREG sC, counter                  ; Counter - for Acquisitions
 000                               NAMEREG sB, ScratchPointer           ; pointer for decoding command in scratch memory
 000                               ; Scratch pad
 000                               ; Locations 0-15 reserved for incoming command
 000                               CONSTANT Latch7, 16'd                ; This is the current value of an output control register (ProgramM) - used to control writing etc.
 000                               CONSTANT LastDSPbyte, 17'd
 000                               CONSTANT Mode, 18'd                  ; N3 status: bit 0 Beacon mode, bit 1 RX/TX mode, bit 2 Uart streaming mode (TX), bit 3 RX to UART streaming, bit 4 to set loop antenna input
 000                               CONSTANT ADCstate, 19'd              ; saves ADC state
 000                               CONSTANT SelectScratch, 20'd         ; used to store selections (archive source etc.)
 000                               CONSTANT ADCLevel, 21'd
 000                               CONSTANT ADCgain, 22'd               ; 0 means no output, 0E is max gain of 128. Upper 4 bits contain ADC config data
 000                               CONSTANT TX_F_MSB, 23'd              ; Store TX req (16 bits)
 000                               CONSTANT TX_F_LSB, 24'd
 000                               CONSTANT ADCAGCUpperThreshold, 25'd  ; Sets value for AGC on RAW input
 000                               CONSTANT ADCAGCLowerThreshold, 26'd  ; Sets value for AGC on RAW input
 000                               CONSTANT ADCGainTX, 27'd             ; Analogue gain for TX
 000                               CONSTANT ADCGainRX, 28'd             ; Analogue gain for RX
 000                               ;removed Attenuator state
 000                               CONSTANT BluetoothXmit, 43           ; from Pete's build - assumes large scratchpad
 000                               ; Input port
 000                               CONSTANT Uart_rx, 00
 000                               CONSTANT Uart_status, 01             ; Uart RX data bit0, Uart TX half full bit 1
 000                               ; bits 2:
 000                               ; Bit 2 BattMon comparator
 000                               ; Offsets:
 000                               CONSTANT BattMon, 4'd
 000                               CONSTANT ArchiveDataLSB, 2'd
 000                               CONSTANT ArchiveDataMSB, 3'd
 000                               CONSTANT DSPcmd, 4'd                 ; message from DSP unit
 000                               CONSTANT BTcmd, 5'd                  ; message from BT unit   TEMP - DataReadback from Flash
 000                               CONSTANT KPcmd, 6'd                  ; message from KeyPad unit TEMP - DataReadback_1 from Flash
 000                               CONSTANT DataReadback, 7'd           ; message from BT unit   TEMP - DataReadback from Flash
 000                               CONSTANT DataReadback_1, 8'd         ; message from KeyPad unit TEMP - DataReadback_1 from Flash
 000                               CONSTANT DSPRAMrdbkMSB, 9'd
 000                               CONSTANT DSPRAMrdbkLSB, 10'd
 000                               CONSTANT BTRAMrdbkMSB, 11'd
 000                               CONSTANT BTRAMrdbkLSB, 12'd
 000                               CONSTANT KPRAMrdbkMSB, 13'd
 000                               CONSTANT KPRAMrdbkLSB, 14'd
 000                               CONSTANT ADCSignalLevel, 15'd
 000                               ; Output ports
 000                               CONSTANT CMD2DSP, 00                 ; ALSO USED for data to write to SPI flash (sends write automatically)
 000                               CONSTANT UART_TX, 01
 000                               CONSTANT GainPD, 02                  ; Lower 4 bits: 1=0 gain to E=gain 128, bits 4-6 should be 101 and bit 7 is for calibration
 000                               ; Lower 4 bits gain, bits 4-6 for PD0-2 - PD bits should be set to 0101 (ie 5 hex) to enable everything
 000                               CONSTANT Instructiona, 03
 000                               CONSTANT Instructionb, 04
 000                               CONSTANT Instructionc, 05
 000                               CONSTANT ProgramL, 06
 000                               CONSTANT ProgramM, 07
 000                               ; bits 0 and 1 for address, subsequent 4 bits to select which pico to write (bits 2,3,4,5 decoded) - these 3 bits are decoded such that:
 000                               ; if bits 2:5 represent:
 000                               ; 1 - Write Inst1 (User pico instruction) - ie MSB of address should be ORed with 4.
 000                               ; 2 - Write Inst2 (DSP pico instruction) - ie MSB of address should be ORed with 8.
 000                               ; 3 - Write Inst3 (BT pico instruction) - ie MSB of address should be ORed with $0C.
 000                               ; 4 - Write Inst4 (KP pico instruction)
 000                               ; 5 - Write DSP RAM
 000                               ; 6 - Write BT RAM
 000                               ; 7 - Reset other picos
 000                               ; 8 - Write KP RAM
 000                               ; 9 - Send Flash fifo contents (written to on FlashDATA port) to FLASH chip
 000                               ; bit 6 enable archive, and bit 7 TXhigh
 000                               ;
 000                               CONSTANT EnArchive, 64'd
 000                               CONSTANT TX_HIGH, 128'd              ; bit 7
 000                               CONSTANT SelectArchiveSource, 8'd
 000                               CONSTANT Configure, 9'd
 000                               CONSTANT RXFreqMSB, 10'd             ; 769A for 88.956kHz ie 86.956kHz carrier and allow range up to 154kHz
 000                               CONSTANT RXFreqLSB, 11'd
 000                               CONSTANT AudioVolume, 12'd           ; Initialy 141
 000                               CONSTANT Tone, 13'd                  ; Carrier increment to cause a tone modulation on TX
 000                               CONSTANT Acknowledge, 14'd
 000                               ; offsets:
 000                               CONSTANT DSPFifo, 16'd
 000                               CONSTANT BTFifo, 32'd
 000                               CONSTANT KPFifo, 64'd
 000                               ; Set bit 4,5,6 to acknowledge FIFO of DSP,BT or Keypad (ie write 16,32 or 64)
 000                               CONSTANT FlashData, 17'd
 000                               ; CONSTANT BatteryMon,   18'd
 000                               CONSTANT ADCstate_port, 19'd         ; Lower 5 bits are not used, bit 6 indictes which ADC channel is read
 000                               ; offset of port 19
 000                               CONSTANT LoranBlank, 16'd            ; $10
 000                               CONSTANT AudioOutSelect, 32'd
 000                               CONSTANT AnalogueChannel, 64'd       ; bit 6
 000                               CONSTANT CMD2BT, 20'd
 000                               CONSTANT CMD2KP, 21'd
 000                               CONSTANT RAMDataMSB, 22'd            ; To send to KP, DSP or BT picos
 000                               CONSTANT RAMDataLSB, 23'd            ; To send to KP, DSP or BT picos
 000                               CONSTANT RAMwriteControl, 25'd
 000                               ; ;; Pete - Bluetooth
 000                               CONSTANT TRANSMIT_ON, 14             ; BT -> User
 000                               CONSTANT TRANSMIT_OFF, 15            ; BT -> User
 000                               ;GenerateCode        MEM       "S3eUser_interface.mem"
 000                               ; Start of test program Must send $40,$50 over serial port to initiate if not re-programming!
 000  22021                  boot: JUMP 021[cold_start]
 001  2001B                reboot: CALL 01B[GetByte]
 002  1D140                        COMPARE s1, 40[64'd]                 ; do we have for start byte (64 )
 003  32007                        JUMP Z, 007[DoUserProg]
 004  1D141                        COMPARE s1, 41[65'd]
 005  3E022                        JUMP NC, 022[ProgDSP]                ; This will actually write DSP or other prog (start byte =65 or greater) aargh 27/8/10 - was JUMP Z....
 006  22001                        JUMP 001[reboot]
 007  01704            DoUserProg: LOAD s7, 04
 008  01220                        LOAD s2, 20[32'd]
 009  01300                        LOAD s3, 00                          ; s2 (LSB),s3(USB) of prog counter of first address of new program!
 00A  2001B               GetProg: CALL 01B[GetByte]
 00B  1D150                        COMPARE s1, 50[80'd]                 ; 80 ($50) indicates end of program
 00C  32021                        JUMP Z, 021[cold_start]              ; When end of prog byte 80 is received
 00D  2D103                        OUTPUT s1, 03[Instructiona]
 00E  2001B                        CALL 01B[GetByte]
 00F  2D104                        OUTPUT s1, 04[Instructionb]
 010  2001B                        CALL 01B[GetByte]
 011  2D105                        OUTPUT s1, 05[Instructionc]          ; write 3x 6bits to latches ready for instruction write
 012  2D206                        OUTPUT s2, 06[ProgramL]
 013  2D307                        OUTPUT s3, 07[ProgramM]              ; Load memory address to write (starting from 32!)
 014  00470                        LOAD s4, s7                          ; Set bit 2 to perform write to RAM 1 or bit 3 to write RAM 2 depending whether start byte was 64 or 65
 015  2D419                        OUTPUT s4, 19[RAMwriteControl]
 016  01400                        LOAD s4, 00
 017  2D419                        OUTPUT s4, 19[RAMwriteControl]       ; Set write line back to zero
 018  11201                        ADD s2, 01
 019  13300                        ADDCY s3, 00                         ; Increment program counter
 01A  2200A                        JUMP 00A[GetProg]                    ; Get next instruction
 01B  09001               GetByte: INPUT s0, 01[Uart_status]            ; Is there a byte available?
 01C  03001                        AND s0, 01
 01D  1D001                        COMPARE s0, 01
 01E  3601B                        JUMP NZ, 01B[GetByte]                ; until there is a byte in the input buffer!
 01F  09100                        INPUT s1, 00[Uart_rx]
 020  25000                        RETURN 
 021  01000            cold_start: LOAD s0, 00                          ; Note the label 'ProgDSP' is only to allow re-boot to work!
 022                      ProgDSP: 
 022                               ; need to clear scratchpad
 022  01100                        LOAD s1, 00
 023                 ScratchClear: 
 023  2E010                        STORE s0, (s1)                       ; zero location
 024  11101                        ADD s1, 01                           ; next
 025  1D100                        COMPARE s1, 00                       ; do all 256 bytes
 026  36023                        JUMP NZ, 023[ScratchClear]           ;
 027  01B00                  init: LOAD sB[ScratchPointer], 00
 028  2F010                        STORE s0, 10[Latch7]                 ; initialise latch 7 bits!
 029  01553                        LOAD s5, 53                          ; gain to lowish
 02A  2F516                        STORE s5, 16[ADCgain]                ; save initial value
 02B  2F51C                        STORE s5, 1C[ADCGainRX]              ; save initial value for RX
 02C  200EA                        CALL 0EA[SetAnGain]                  ; set gain and calibrate
 02D  01559                        LOAD s5, 59                          ; gain to lowish
 02E  2F51B                        STORE s5, 1B[ADCGainTX]              ; save initial value forTX
 02F                               ;Frequency of TX/RX now set by keypad pico
 02F  01032                        LOAD s0, 32[AGCupperRX]
 030  2F019                        STORE s0, 19[ADCAGCUpperThreshold]
 031  01012                        LOAD s0, 12[AGClowerRX]
 032  2F01A                        STORE s0, 1A[ADCAGCLowerThreshold]
 033  2021A                        CALL 21A[RX]                         ; set receive mode
 034  01100                        LOAD s1, 00
 035  20330                        CALL 330[ArchiveSource]
 036  20337                        CALL 337[EnableArchive]
 037  01085                        LOAD s0, 85[InitialVolume]           ;set lowish audio volume
 038  2D00C                        OUTPUT s0, 0C[AudioVolume]
 039  20376                        CALL 376[delay_100ms]
 03A  01020                        LOAD s0, 20[AudioOutSelect]          ; + 16; normal ADC channel, AudioOUtSelect doesn't do anything here! The 16also sets Loran Blanking if in firmware.
 03B  2F013                        STORE s0, 13[ADCstate]               ; save
 03C  2D013                        OUTPUT s0, 13[ADCstate_port]         ; Also sets analogue input to 0
 03D  2005D                  loop: CALL 05D[CheckADClevel]
 03E  0B012                        FETCH s0, 12[Mode]
 03F  03004                        AND s0, 04                           ; look at streaming bit
 040  1D004                        COMPARE s0, 04
 041  321D6                        JUMP Z, 1D6[isSSloop]                ; if streaming TX mode, then send a Uart character and return (but will not be able to interpret any command so is stuck!)
 042  0B012                        FETCH s0, 12[Mode]
 043  03008                        AND s0, 08                           ; look at streaming RX bit
 044  1D008                        COMPARE s0, 08
 045  302D6                        CALL Z, 2D6[Check4CmdfromDSP]        ; If fifo character then send to terminal !!!!!!!!!!!!!!!!!!!! reinstate this 9/7/2013
 046  202E0                        CALL 2E0[Check4CmdfromKP]
 047  1D680                        COMPARE s6, 80[128'd]
 048  3809B                        CALL C, 09B[checkrqst]
 049                               ; Re-enable Beacon mode
 049  0B012                        FETCH s0, 12[Mode]
 04A                               ;      OUTPUT    s0,CMD2KP      ;send value to LCD for display - send adc level data instead
 04A  03001                        AND s0, 01                           ; only interrested in bit0
 04B  1D001                        COMPARE s0, 01                       ; Is it beacon mode?
 04C  30290                        CALL Z, 290[BeaconBeep]
 04D                               ; Pete  enabled 24 Feb 2015
 04D  202DB                        CALL 2DB[Check4CmdfromBT]            ; receive from BT and echo to terminal
 04E  3A2A7                        JUMP C, 2A7[HandleBTCommand]         ; If less than 128 there is a value to give back and display.
 04F         HandleBTCommand_Done: 
 04F                               ; pete end
 04F  202C1                        CALL 2C1[getUARTchar]
 050  1D620                        COMPARE s6, 20[32'd]
 051  3203D                        JUMP Z, 03D[loop]                    ; If a space then skip
 052                               ; Had mistankenly changed the next line!
 052  1D6FF                        COMPARE s6, FF
 053  3203D                        JUMP Z, 03D[loop]                    ; If no character then skip-MAKE SURE ANYTHINGTO BE PERFORMED REGULARLY IS DONE BEFORE THIS POINT
 054  1D60D                        COMPARE s6, 0D[13'd]
 055  320F5                        JUMP Z, 0F5[interpcommand]           ; This is end of command character
 056  1D60A                        COMPARE s6, 0A[10'd]
 057  3203D                        JUMP Z, 03D[loop]                    ; If LF ignore
 058  1DB10                        COMPARE sB[ScratchPointer], 10[16'd] ; Check we are not writing too many characters to the scratchpad
 059  3E03D                        JUMP NC, 03D[loop]                   ; don't write to scratch if Pointer (counter) 16 or above
 05A  2E6B0                        STORE s6, (sB[ScratchPointer])       ; Save command character
 05B  11B01                        ADD sB[ScratchPointer], 01           ; is a command char so increment
 05C  2203D                        JUMP 03D[loop]
 05D  0900F         CheckADClevel: INPUT s0, 0F[ADCSignalLevel]
 05E  0B115                        FETCH s1, 15[ADCLevel]
 05F  1C010                        COMPARE s0, s1
 060  31000                        RETURN Z                             ; return if the value is still the same (ie wait for new value)
 061                               ;__________________________________________________
 061                               ;TEMPORARY SKIP to TEMPskip:  (values will be redirected directly from DSP to KP in
 061                               ;      JUMP  Tempskip NOTnow 19 sep 2015
 061                               ;____________________________________________________
 061  0117F                        LOAD s1, 7F                          ; Note top bit is not received! Send command to expect signal level
 062  2D115                        OUTPUT s1, 15[CMD2KP]                ; send ADCgain value to LCD for display
 063  2F015                        STORE s0, 15[ADCLevel]               ; save new value of ADClevel
 064                               ; Code to send a value for display as 2 decimal digits in the range 00 to 74 (~42dB) representing the broad band signal strength (5 units per gain step, 1 unit per 8 units of ADC level
 064                               ; assuming ADClevel kept betweeen $18 and $40, signal level within range covers ~8dB, display about 1.7 x value in dB in steps of 2 (~1.2dB)
 064  0B116                        FETCH s1, 16[ADCgain]
 065  0310F                        AND s1, 0F                           ; Gain level just in lower 4 bits
 066  0120E                        LOAD s2, 0E
 067  18210                        SUB s2, s1                           ; Invert gain level to signal level ie highest gain of $E becomes zero
 068  01100                        LOAD s1, 00                          ; use this as counter for lower decimal digit
 069  1420E                        SR0 s2                               ; half the value and send half to the carry flag (to add 5)
 06A  3E06C                        JUMP NC, 06C[nofive]                 ; only add 5 to lower digit if carry set
 06B  01105                        LOAD s1, 05[5'd]
 06C  1D010                nofive: COMPARE s0, 10[16'd]                 ; skip if below first step (about 1.2dB)
 06D  3A06F                        JUMP C, 06F[First]
 06E  11102                        ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 06F  1D012                 First: COMPARE s0, 12[18'd]                 ; skip if below second step (about 1.2dB)
 070  3A072                        JUMP C, 072[Second]
 071  11102                        ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 072  1D015                Second: COMPARE s0, 15[21'd]                 ; skip if below third step (about 1.2dB)
 073  3A075                        JUMP C, 075[Third]
 074  11102                        ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 075  1D018                 Third: COMPARE s0, 18[24'd]                 ; skip if below
 076  3A078                        JUMP C, 078[Fourth]
 077  11102                        ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 078  1D01C                Fourth: COMPARE s0, 1C[28'd]                 ; skip if below
 079  3A07B                        JUMP C, 07B[Fifth]
 07A  11102                        ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 07B                               ; now check if s1 (lower decimal digit) is above 9
 07B  1D10A                 Fifth: COMPARE s1, 0A[10'd]
 07C  3A07F                        JUMP C, 07F[ToLCD]
 07D  11201                        ADD s2, 01[1'd]                      ; Add 1 to first decimal digit
 07E  1910A                        SUB s1, 0A[10'd]                     ; subtract 10 from lower digit
 07F                               ;Deleted part that tried to apply attenuator
 07F  2D215                 ToLCD: OUTPUT s2, 15[CMD2KP]                ; Send first decimal digit (as binary value 0-7)
 080  2D115                        OUTPUT s1, 15[CMD2KP]                ; send second decimal digit (as binary value for 0-9)
 081                               ; s0 should hoperfully still have ADCsignal level!
 081                               ;_______________________________
 081                               ;Temp bit
 081                     Tempskip: 
 081                               ;_____________________________________
 081                               ; LOAD      s5, s0
 081                               ;      CALL      Byte2UART    ;and echo to UART  - not now!
 081  0B119                        FETCH s1, 19[ADCAGCUpperThreshold]
 082  0B015                        FETCH s0, 15[ADCLevel]               ; had lost the s0 value at this point!
 083  1C010                        COMPARE s0, s1                       ; aim to keep value around $15? - need to drop this further! Needs to be lower for transmission??
 084  3C089                        CALL NC, 089[ReduceADCgain]
 085  0B11A                        FETCH s1, 1A[ADCAGCLowerThreshold]
 086  1C010                        COMPARE s0, s1                       ; aim to keep value around $15? -
 087  38092                        CALL C, 092[IncreaseADCgain]
 088  25000                        RETURN 
 089  0B016         ReduceADCgain: FETCH s0, 16[ADCgain]
 08A  00100                        LOAD s1, s0
 08B  0310F                        AND s1, 0F                           ; mask lower 4 bits
 08C  1D101                        COMPARE s1, 01                       ; don't drop to zero!
 08D  31000                        RETURN Z
 08E  19001                        SUB s0, 01[1'd]
 08F  2F016                        STORE s0, 16[ADCgain]
 090  2D002                        OUTPUT s0, 02[GainPD]                ; set ADC pre-amp
 091                               ; OUTPUT       s0, CMD2KP          ; send value to LCD for display - don't bother
 091  25000                        RETURN 
 092  0B016       IncreaseADCgain: FETCH s0, 16[ADCgain]
 093  00100                        LOAD s1, s0
 094  0310F                        AND s1, 0F                           ; mask lower 4 bits
 095  1D10E                        COMPARE s1, 0E                       ; don't go past $0E!
 096  31000                        RETURN Z
 097  11001                        ADD s0, 01[1'd]
 098  2F016                        STORE s0, 16[ADCgain]
 099  2D002                        OUTPUT s0, 02[GainPD]                ; set ADC pre-amp
 09A                               ; OUTPUT       s0, CMD2KP          ; send value to LCD for display
 09A  25000                        RETURN 
 09B                               ;Delete setting and resetting Attenuator (March 2016)
 09B  1D672             checkrqst: COMPARE s6, 72["r"]                  ;character_r
 09C  300AE                        CALL Z, 0AE[checkRXmode]
 09D  1D674                        COMPARE s6, 74["t"]                  ;character_t
 09E  300B7                        CALL Z, 0B7[checkTXmode]
 09F  1D665                        COMPARE s6, 65["e"]                  ;character_e
 0A0  300A4                        CALL Z, 0A4[setEarthAntennas]
 0A1  1D66C                        COMPARE s6, 6C["l"]                  ; character_l
 0A2  300A9                        CALL Z, 0A9[setLoopAntennas]
 0A3  25000                        RETURN 
 0A4  0B012      setEarthAntennas: FETCH s0, 12[Mode]
 0A5  030EF                        AND s0, EF[239'd]                    ; 255-16  ;reset bit 4
 0A6  2F012                        STORE s0, 12[Mode]
 0A7  200BD                        CALL 0BD[setRXmode]                  ;Make active and return to RX
 0A8  25000                        RETURN 
 0A9  0B012       setLoopAntennas: FETCH s0, 12[Mode]
 0AA  05010                        OR s0, 10[16'd]                      ;set bit 4
 0AB  2F012                        STORE s0, 12[Mode]
 0AC  200BD                        CALL 0BD[setRXmode]
 0AD  25000                        RETURN 
 0AE                  checkRXmode: 
 0AE                               ; ;; Pete added for Bluetooth (temp)
 0AE  0B043                        FETCH s0, 43[BluetoothXmit]
 0AF  11000                        ADD s0, 00
 0B0  35000                        RETURN NZ                            ; do nothing if BT transmitting
 0B1                               ; ;; end Pete added for BT
 0B1  0B012                        FETCH s0, 12[Mode]
 0B2  03002                        AND s0, 02                           ; mask bit 1
 0B3  1D002                        COMPARE s0, 02                       ; is it set ie currently in TX mode?
 0B4  35000                        RETURN NZ                            ; return if already in RX mode return
 0B5  200BD                        CALL 0BD[setRXmode]                  ; so go ahead and set up RX mode
 0B6  25000                        RETURN 
 0B7  0B012           checkTXmode: FETCH s0, 12[Mode]
 0B8  03002                        AND s0, 02                           ; mask bit 1 here 2 means TX mode 0 RX mode
 0B9  1D000                        COMPARE s0, 00                       ; is it not set ie currently in RX mode?
 0BA  35000                        RETURN NZ                            ; return if already in TX mode
 0BB  200D7                        CALL 0D7[setTXmode]                  ; so go ahead and set up TX mode
 0BC  25000                        RETURN 
 0BD                               ; need to set scratch pad mode, set RX freq to 86.95 (SRF769A or for 87kHz need 76AB), input channel with equivalent of SAI00 and send receive mode command to DSP, set analog gain to 8
 0BD  01532             setRXmode: LOAD s5, 32[50'd]                    ; Ascii code for '2' - DSP to grap the AGCvalue before the warble
 0BE  2D500                        OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 0BF  0B516                        FETCH s5, 16[ADCgain]                ; gain used during TX mode
 0C0  2F51B                        STORE s5, 1B[ADCGainTX]              ; Save for next TX mode
 0C1  2027F                        CALL 27F[Warble]                     ; send warble beep before returning!
 0C2  0B012                        FETCH s0, 12[Mode]
 0C3  030FC                        AND s0, FC[252'd]                    ;255 - 3         ; reset TX bit AND becon on bit
 0C4  2F012                        STORE s0, 12[Mode]
 0C5                               ; LOAD      s0, 2A             ; $75 for new demodulator   Don't need this from GV95 as keypad sets the frequency
 0C5                               ; OUTPUT       s0, RXFreqMSB
 0C5                               ; LOAD      s0, AD          ; $ N2 or Heyphone)
 0C5                               ; OUTPUT       s0, RXFreqLSB
 0C5                               ;Set ADC channel depending on whether using loop or earth wires (Mode bit 4 set for loop)
 0C5  0B012                        FETCH s0, 12[Mode]
 0C6  03010                        AND s0, 10[16'd]                     ;antenna input select bit (4)
 0C7  14006                        SL0 s0
 0C8  14006                        SL0 s0                               ;to affect bit 6
 0C9  0B113                        FETCH s1, 13[ADCstate]
 0CA  031BF                        AND s1, BF[191'd]                    ; 255 - 64        ; reset  bit 6
 0CB  04100                        OR s1, s0                            ;now affect bit 6 = Mode bit 4 setting
 0CC  2F113                        STORE s1, 13[ADCstate]               ; save
 0CD  2D113                        OUTPUT s1, 13[ADCstate_port]         ; set port to new ADC channel
 0CE  0B51C                        FETCH s5, 1C[ADCGainRX]              ; gain to last value used for RX
 0CF  2F516                        STORE s5, 16[ADCgain]                ; this value is tracked
 0D0  200EA                        CALL 0EA[SetAnGain]                  ; set analogue gain to moderate
 0D1  01032                        LOAD s0, 32[AGCupperRX]
 0D2  2F019                        STORE s0, 19[ADCAGCUpperThreshold]
 0D3  01012                        LOAD s0, 12[AGClowerRX]
 0D4  2F01A                        STORE s0, 1A[ADCAGCLowerThreshold]
 0D5  2021A                        CALL 21A[RX]
 0D6  25000                        RETURN 
 0D7                               ; need to set scratch pad mode, set RX freq to 0 (SRF0155), et TX freq to 86.95 STF0E7E, input channel with equivalent of SAI01 and send transmit mode command to DSP
 0D7  0B012             setTXmode: FETCH s0, 12[Mode]
 0D8  05002                        OR s0, 02                            ; set TX bit
 0D9  030FE                        AND s0, FE                           ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 0DA  2F012                        STORE s0, 12[Mode]
 0DB                               ; LOAD      s0, 01      Don't need this is keypad is sorting it!
 0DB                               ; OUTPUT       s0, RXFreqMSB
 0DB                               ; LOAD      s0, 55
 0DB                               ; OUTPUT       s0, RXFreqLSB       ; drop detection to baseband (for when using wired mic)
 0DB  0B013                        FETCH s0, 13[ADCstate]
 0DC  05040                        OR s0, 40[AnalogueChannel]           ; set bit 6 (SAI01) - Channel 1 in Matlab GUI
 0DD  2F013                        STORE s0, 13[ADCstate]               ; save
 0DE  2D013                        OUTPUT s0, 13[ADCstate_port]         ; set port to new ADC channel
 0DF  0B516                        FETCH s5, 16[ADCgain]                ; get gain used for RX
 0E0  2F51C                        STORE s5, 1C[ADCGainRX]              ; this value is tracked
 0E1  0B51B                        FETCH s5, 1B[ADCGainTX]              ; gain to last value used for TX
 0E2  2F516                        STORE s5, 16[ADCgain]                ; and make current ADCgain value
 0E3  200EA                        CALL 0EA[SetAnGain]                  ; set analogue gain to moderate
 0E4  01010                        LOAD s0, 10[AGCupperTX]
 0E5  2F019                        STORE s0, 19[ADCAGCUpperThreshold]
 0E6  01006                        LOAD s0, 06[AGClowerTX]
 0E7  2F01A                        STORE s0, 1A[ADCAGCLowerThreshold]
 0E8  20223                        CALL 223[TX]
 0E9  25000                        RETURN 
 0EA                               ; set gain to 32 or is it 48?, enter with gain value in s5 (ie $DA for transmit)
 0EA  0350F             SetAnGain: AND s5, 0F                           ; only affect lower 4 bits
 0EB  0B016                        FETCH s0, 16[ADCgain]
 0EC  030F0                        AND s0, F0                           ; keep upper bits
 0ED  04500                        OR s5, s0                            ; combine
 0EE  2F516                        STORE s5, 16[ADCgain]                ; save new value (includes all bits)
 0EF  05580                        OR s5, 80                            ; set bit 7 to start calibration
 0F0  2D502                        OUTPUT s5, 02[GainPD]
 0F1  2037B                        CALL 37B[delay_1ms]                  ; wait for calib
 0F2  0357F                        AND s5, 7F[127'd]                    ; reset bit 7
 0F3  2D502                        OUTPUT s5, 02[GainPD]
 0F4  25000                        RETURN 
 0F5                               ; Now interpret the command in the Scratch buffer and return to init
 0F5  01900         interpcommand: LOAD s9, 00                          ; counter through scratchpad addresses.
 0F6  1C9B0            interploop: COMPARE s9, sB[ScratchPointer]
 0F7  32027                        JUMP Z, 027[init]                    ; break out of loop after reading final character command.
 0F8  20345                        CALL 345[getnextscratchchar]
 0F9  1D053                        COMPARE s0, 53[83'd]                 ; is this a S?
 0FA  32100                        JUMP Z, 100[isS]
 0FB  1D047                        COMPARE s0, 47[71'd]                 ; is this a G?
 0FC  32114                        JUMP Z, 114[isG]
 0FD                               ;      COMPARE      s0, 77'd              ; is this a M?
 0FD                               ; JUMP      Z, isM
 0FD  1D05A                        COMPARE s0, 5A[90'd]                 ; is this a Z?
 0FE  32001                        JUMP Z, 001[reboot]                  ; then go to reboot code (ie to reboot need to send Z<CR>, then do Prog...)
 0FF  220F6                        JUMP 0F6[interploop]
 100  20345                   isS: CALL 345[getnextscratchchar]
 101  1D042                        COMPARE s0, 42[66'd]                 ; is this a B?
 102  32130                        JUMP Z, 130[isSB]                    ;
 103  1D041                        COMPARE s0, 41[65'd]                 ; is this a A?
 104  32126                        JUMP Z, 126[isSA]
 105  1D052                        COMPARE s0, 52[82'd]                 ; is this a R?
 106  321E8                        JUMP Z, 1E8[isSR]
 107  1D054                        COMPARE s0, 54[84'd]                 ; is this a T?
 108  321EE                        JUMP Z, 1EE[isST]
 109  1D04B                        COMPARE s0, 4B[75'd]                 ; is this a K?
 10A  32137                        JUMP Z, 137[isSK]                    ;
 10B  1D04C                        COMPARE s0, 4C[76'd]                 ; is this a L?
 10C  3213B                        JUMP Z, 13B[isSL]                    ; Set Loran Blanking
 10D  1D04D                        COMPARE s0, 4D[77'd]                 ; is this a M?
 10E  32147                        JUMP Z, 147[isSM]                    ;
 10F                               ;      COMPARE      s0, 83'd              ; is this a S?
 10F                               ; JUMP      Z, isSS             ;
 10F  1D055                        COMPARE s0, 55[85'd]                 ; is this a U
 110  321C3                        JUMP Z, 1C3[isSU]
 111  1D057                        COMPARE s0, 57[87'd]                 ; is this a W
 112  321C8                        JUMP Z, 1C8[isSW]
 113  22027                        JUMP 027[init]
 114  20345                   isG: CALL 345[getnextscratchchar]
 115  1D041                        COMPARE s0, 41[65'd]                 ; is this a A?
 116  3226C                        JUMP Z, 26C[isGA]
 117  1D042                        COMPARE s0, 42[66'd]                 ; is this a B?
 118  3223D                        JUMP Z, 23D[isGB]
 119  1D043                        COMPARE s0, 43[67'd]                 ; is this a C?
 11A  32245                        JUMP Z, 245[isGC]
 11B  1D04B                        COMPARE s0, 4B[75'd]                 ; is this a K?
 11C  32248                        JUMP Z, 248[isGK]
 11D  1D04C                        COMPARE s0, 4C[76'd]                 ; is this a L?
 11E  3224E                        JUMP Z, 24E[isGL]
 11F  1D056                        COMPARE s0, 56[86'd]                 ; is this a V?
 120  3226E                        JUMP Z, 26E[isGV]
 121  1D047                        COMPARE s0, 47[71'd]                 ; is this a G?
 122  3222B                        JUMP Z, 22B[isGG]
 123  1D053                        COMPARE s0, 53[83'd]                 ; is this a S?
 124  32234                        JUMP Z, 234[isGS]
 125  22027                        JUMP 027[init]
 126  20345                  isSA: CALL 345[getnextscratchchar]
 127  1D053                        COMPARE s0, 53[83'd]                 ; is this a S?
 128  321F2                        JUMP Z, 1F2[isSAS]                   ;
 129  1D047                        COMPARE s0, 47[71'd]                 ; is this a G?
 12A  321F6                        JUMP Z, 1F6[isSAG]                   ;
 12B  1D04F                        COMPARE s0, 4F[79'd]                 ; is this a O?
 12C  32208                        JUMP Z, 208[isSAO]                   ;
 12D  1D049                        COMPARE s0, 49[73'd]                 ; is this a I?
 12E  321FD                        JUMP Z, 1FD[isSAI]                   ;
 12F  22027                        JUMP 027[init]
 130                               ; SB - set beacon mode (SB<xx>
 130  2034A                  isSB: CALL 34A[getnextvalue]
 131  03501                        AND s5, 01                           ; Mask bit 0
 132  0B012                        FETCH s0, 12[Mode]
 133  030FE                        AND s0, FE[254'd]                    ; reset bit 0
 134  04050                        OR s0, s5                            ; affect bit 0
 135  2F012                        STORE s0, 12[Mode]
 136  22027                        JUMP 027[init]
 137                               ; Commands for keypad pico
 137  20345                  isSK: CALL 345[getnextscratchchar]
 138  1D053                        COMPARE s0, 53[83'd]                 ; is this a S?
 139  32146                        JUMP Z, 146[isSKS]                   ;
 13A  22027                        JUMP 027[init]
 13B  2034A                  isSL: CALL 34A[getnextvalue]
 13C  01400                        LOAD s4, 00
 13D  1D501                        COMPARE s5, 01                       ; is it 1
 13E  36140                        JUMP NZ, 140[setLoranBlank]
 13F  01410                        LOAD s4, 10[LoranBlank]
 140  0B013         setLoranBlank: FETCH s0, 13[ADCstate]
 141  030EF                        AND s0, EF[~LoranBlank]              ; reset bit for Loran blanking
 142  04040                        OR s0, s4                            ; affect this bit
 143  2F013                        STORE s0, 13[ADCstate]               ; save
 144  2D013                        OUTPUT s0, 13[ADCstate_port]         ; set port to new ADC channel
 145  22027                        JUMP 027[init]
 146                        isSKS: ; LOAD      s0, 83'd              ; letter S
 146                               ; OUTPUT       s0, CMD2KP          ; send S to KP
 146                               ; CALL      getnextscratchchar
 146                               ; SUB       s0, 48'd
 146                               ; OUTPUT       s0, CMD2KP          ; send select value as binary value to KP
 146  22027                        JUMP 027[init]
 147                               ; Testmemory TEMP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! -memory instructions
 147  20345                  isSM: CALL 345[getnextscratchchar]
 148  1D057                        COMPARE s0, 57[87'd]                 ; is this a W?
 149  32151                        JUMP Z, 151[isSMW]                   ;
 14A  1D052                        COMPARE s0, 52[82'd]                 ; is this a R?
 14B  32179                        JUMP Z, 179[isSMR]                   ;
 14C  1D044                        COMPARE s0, 44[68'd]                 ; is this a D?
 14D  32196                        JUMP Z, 196[isSMD]                   ;
 14E  1D053                        COMPARE s0, 53[83'd]                 ; is this a S?
 14F  321A7                        JUMP Z, 1A7[isSMS]                   ;
 150  22027                        JUMP 027[init]
 151                               ; Testmemory TEMP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 151                               ; write data to flash
 151  01506                 isSMW: LOAD s5, 06[WREN]
 152  2D511                        OUTPUT s5, 11[FlashData]
 153  201DE                        CALL 1DE[nowsend2flashback]          ; write this bit already and come back here!
 154  2038A                        CALL 38A[delay_1us]                  ; wait to complete (maybe 1us enough?)
 155  015D8                        LOAD s5, D8[SER]                     ; sector erase
 156  2D511                        OUTPUT s5, 11[FlashData]
 157  01504                        LOAD s5, 04                          ; load address to erase (part way through memory)
 158  2D511                        OUTPUT s5, 11[FlashData]
 159  01500                        LOAD s5, 00                          ; load address to write to
 15A  2D511                        OUTPUT s5, 11[FlashData]
 15B  01500                        LOAD s5, 00                          ; load address to write to
 15C  2D511                        OUTPUT s5, 11[FlashData]
 15D  201DE                        CALL 1DE[nowsend2flashback]          ; write this bit already and come back here!
 15E  20368                        CALL 368[delay_1s]                   ; wait to complete
 15F  20368                        CALL 368[delay_1s]
 160  20368                        CALL 368[delay_1s]                   ; TO be OPTIMIZED!!!!!!!!!!!!!!!!!!!!!!!
 161  01506                        LOAD s5, 06[WREN]
 162  2D511                        OUTPUT s5, 11[FlashData]
 163  201DE                        CALL 1DE[nowsend2flashback]          ; write this bit already and come back here!
 164  2038A                        CALL 38A[delay_1us]                  ; wait to complete sending serial bits out!
 165  2038A                        CALL 38A[delay_1us]                  ; wait to complete (maybe 1us enough?)
 166  2038A                        CALL 38A[delay_1us]                  ; wait to complete sending serial bits out!
 167  2038A                        CALL 38A[delay_1us]                  ; wait to complete (maybe 1us enough?)
 168  2038A                        CALL 38A[delay_1us]                  ; wait to complete sending serial bits out!
 169  2038A                        CALL 38A[delay_1us]                  ; wait to complete (maybe 1us enough?)
 16A  2038A                        CALL 38A[delay_1us]                  ; wait to complete (maybe 1us enough?)
 16B  201A9                        CALL 1A9[Status]
 16C  01502                        LOAD s5, 02[PP]                      ; write page command
 16D  2D511                        OUTPUT s5, 11[FlashData]
 16E  01504                        LOAD s5, 04                          ; load address to write to (part way through memory)
 16F  2D511                        OUTPUT s5, 11[FlashData]
 170  01500                        LOAD s5, 00                          ; load address to write to
 171  2D511                        OUTPUT s5, 11[FlashData]
 172  01500                        LOAD s5, 00                          ; load address to write to
 173  2D511                        OUTPUT s5, 11[FlashData]
 174  1C9B0             isSMWloop: COMPARE s9, sB[ScratchPointer]       ; break out of loop after reading final character command.
 175  321E6                        JUMP Z, 1E6[nowsend2flash]           ; if so write to flash and break out
 176  2034A                        CALL 34A[getnextvalue]
 177  2D511                        OUTPUT s5, 11[FlashData]
 178  22174                        JUMP 174[isSMWloop]                  ; loop back to get next data value
 179                               ; FAST_READ
 179  0150B                 isSMR: LOAD s5, 0B[FAST_READ]
 17A  2D511                        OUTPUT s5, 11[FlashData]
 17B  2034A                        CALL 34A[getnextvalue]               ; load address to write to (about half way through memory ~10)
 17C  2D511                        OUTPUT s5, 11[FlashData]
 17D  2034A                        CALL 34A[getnextvalue]
 17E  2D511                        OUTPUT s5, 11[FlashData]
 17F  2034A                        CALL 34A[getnextvalue]
 180  2D511                        OUTPUT s5, 11[FlashData]
 181                               ; now send dummy bytes to get 2 byte values
 181  01500                        LOAD s5, 00                          ; dummy
 182  2D511                        OUTPUT s5, 11[FlashData]
 183  01500                        LOAD s5, 00                          ; dummy byte
 184  2D511                        OUTPUT s5, 11[FlashData]
 185  01500                        LOAD s5, 00                          ; dummy byte
 186  2D511                        OUTPUT s5, 11[FlashData]
 187  01524                        LOAD s5, 24[36'd]                    ; was 16 should be 9x4=36
 188  2D507                        OUTPUT s5, 07[ProgramM]              ; initiates flash write - may take some time for pp command!
 189  01500                        LOAD s5, 00                          ; reset
 18A  2D507                        OUTPUT s5, 07[ProgramM]              ;
 18B  2038A                        CALL 38A[delay_1us]                  ; wait to complete sending serial bits out!
 18C  2038A                        CALL 38A[delay_1us]                  ; wait to complete (maybe 1us enough?)
 18D  2038A                        CALL 38A[delay_1us]                  ; wait to complete sending serial bits out!
 18E  2038A                        CALL 38A[delay_1us]                  ; wait to complete (maybe 1us enough?)
 18F  2038A                        CALL 38A[delay_1us]                  ; wait to complete sending serial bits out!
 190  2038A                        CALL 38A[delay_1us]                  ; wait to complete (maybe 1us enough?)
 191  09508                        INPUT s5, 08[DataReadback_1]
 192  2035B                        CALL 35B[Byte2UART]                  ; echo values as 2 ascii codes back to terminal
 193  09507                        INPUT s5, 07[DataReadback]
 194  2035B                        CALL 35B[Byte2UART]
 195  22027                        JUMP 027[init]                       ; loop back
 196                               ; READ DID
 196  0159F                 isSMD: LOAD s5, 9F[RDID]
 197  2D511                        OUTPUT s5, 11[FlashData]
 198                               ; now send dummy bytes to get 2 byte values
 198  01500                        LOAD s5, 00                          ; dummy
 199  2D511                        OUTPUT s5, 11[FlashData]
 19A  01500                        LOAD s5, 00                          ; dummy byte
 19B  2D511                        OUTPUT s5, 11[FlashData]
 19C                               ; LOAD      s5, 0               ; dummy byte
 19C                               ; OUTPUT       s5, FlashData
 19C  01524                        LOAD s5, 24[36'd]                    ; was 16 should be 9x4=36
 19D  2D507                        OUTPUT s5, 07[ProgramM]              ; initiates flash write
 19E  01500                        LOAD s5, 00                          ; reset
 19F  2D507                        OUTPUT s5, 07[ProgramM]              ;
 1A0  2038A                        CALL 38A[delay_1us]                  ; wait to complete sending serial bits out!
 1A1  2038A                        CALL 38A[delay_1us]                  ; wait to complete
 1A2  09508                        INPUT s5, 08[DataReadback_1]         ; first value
 1A3  2035B                        CALL 35B[Byte2UART]                  ; echo values as 2 ascii codes back to terminal
 1A4  09507                        INPUT s5, 07[DataReadback]           ; second value
 1A5  2035B                        CALL 35B[Byte2UART]
 1A6  22027                        JUMP 027[init]                       ; loop back
 1A7                               ; Read status register
 1A7  201A9                 isSMS: CALL 1A9[Status]
 1A8  22027                        JUMP 027[init]                       ; loop back
 1A9  01505                Status: LOAD s5, 05[RDSR]
 1AA  2D511                        OUTPUT s5, 11[FlashData]
 1AB                               ; now send dummy bytes to get 2 byte values
 1AB  01500                        LOAD s5, 00                          ; dummy
 1AC  2D511                        OUTPUT s5, 11[FlashData]
 1AD  01500                        LOAD s5, 00                          ; dummy byte
 1AE  2D511                        OUTPUT s5, 11[FlashData]
 1AF  201DE                        CALL 1DE[nowsend2flashback]
 1B0  2038A                        CALL 38A[delay_1us]                  ; wait to complete sending serial bits out!
 1B1  2038A                        CALL 38A[delay_1us]                  ; wait to complete
 1B2  20360                        CALL 360[SendCRLF]
 1B3  09508                        INPUT s5, 08[DataReadback_1]         ; first value
 1B4  2035B                        CALL 35B[Byte2UART]                  ; echo values as 2 ascii codes back to terminal
 1B5  09507                        INPUT s5, 07[DataReadback]           ; second value
 1B6  2035B                        CALL 35B[Byte2UART]
 1B7  20360                        CALL 360[SendCRLF]
 1B8  25000                        RETURN 
 1B9                               ; This streams from UART data to DSP to TX and never exits!
 1B9  20345                  isSS: CALL 345[getnextscratchchar]         ; get beacon offset in s0
 1BA  01533                        LOAD s5, 33[51'd]                    ; Ascii code for '3' - set stream mode -NO ESCAPE!
 1BB  2D500                        OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 1BC  2D000                        OUTPUT s0, 00[CMD2DSP]               ; send raw data byte of bit offset
 1BD  20223                        CALL 223[TX]
 1BE  0B012                        FETCH s0, 12[Mode]
 1BF  05004                        OR s0, 04                            ; set 'Streaming TX' bit
 1C0  030FE                        AND s0, FE                           ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 1C1  2F012                        STORE s0, 12[Mode]
 1C2  2203D                        JUMP 03D[loop]                       ;
 1C3                               ; Stream RX data to UART
 1C3  0B012                  isSU: FETCH s0, 12[Mode]
 1C4  05008                        OR s0, 08                            ; set 'Streaming TX' bit
 1C5  030FE                        AND s0, FE                           ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 1C6  2F012                        STORE s0, 12[Mode]
 1C7  22027                        JUMP 027[init]                       ;
 1C8                               ; Redirect Serial to and from BT module
 1C8  01654                  isSW: LOAD s6, 54["T"]
 1C9  20355                        CALL 355[Send2UartTX]
 1CA  0164F                        LOAD s6, 4F["O"]
 1CB  20355                        CALL 355[Send2UartTX]
 1CC  01620                        LOAD s6, 20                          ;Space character
 1CD  20355                        CALL 355[Send2UartTX]
 1CE  01642                        LOAD s6, 42["B"]
 1CF  20355                        CALL 355[Send2UartTX]
 1D0  01654                        LOAD s6, 54["T"]
 1D1  20355                        CALL 355[Send2UartTX]
 1D2  20360                        CALL 360[SendCRLF]
 1D3  01001                        LOAD s0, 01
 1D4  2D009                        OUTPUT s0, 09[Configure]
 1D5  22027                        JUMP 027[init]                       ;
 1D6                               ; Now get a raw UART byte
 1D6  20351              isSSloop: CALL 351[CheckUartRx]
 1D7  361D6                        JUMP NZ, 1D6[isSSloop]               ; loop if nothing in UART buffer
 1D8  09500                        INPUT s5, 00[Uart_rx]                ; get byte
 1D9  2030A                        CALL 30A[Byte2Chars]
 1DA  2D600                        OUTPUT s6, 00[CMD2DSP]               ; Send audio MSBbyte to DSP
 1DB  2D700                        OUTPUT s7, 00[CMD2DSP]               ; Send audio LSBbyte to DSP
 1DC  202D6                        CALL 2D6[Check4CmdfromDSP]           ; If fifo character then send to terminal !!!!!!!!!!!!!!!!!!!! reinstate this 15/5/2013
 1DD  2203D                        JUMP 03D[loop]                       ; Try making this a called routine, sending 1 value per loop
 1DE                               ; this is same as following routine except it returns rather than jumping to init
 1DE  01524     nowsend2flashback: LOAD s5, 24[36'd]                    ; was 16 should be 9x4=36
 1DF  2D507                        OUTPUT s5, 07[ProgramM]              ; initiates flash write - may take some time for pp command!
 1E0  2037B                        CALL 37B[delay_1ms]                  ; wait to complete
 1E1  2037B                        CALL 37B[delay_1ms]
 1E2  2037B                        CALL 37B[delay_1ms]                  ; TO be OPTIMIZED!!!!!!!!!!!!!!!!!!!!!!!
 1E3  01500                        LOAD s5, 00                          ; reset send2flash
 1E4  2D507                        OUTPUT s5, 07[ProgramM]              ; initiates flash write - may take some time for pp command!
 1E5  25000                        RETURN 
 1E6  201DE         nowsend2flash: CALL 1DE[nowsend2flashback]
 1E7  22027                        JUMP 027[init]
 1E8  20345                  isSR: CALL 345[getnextscratchchar]
 1E9  1D046                        COMPARE s0, 46[70'd]                 ; is this a F?
 1EA  32213                        JUMP Z, 213[isSRF]                   ;
 1EB  1D04D                        COMPARE s0, 4D[77'd]                 ; is this a M?
 1EC  32218                        JUMP Z, 218[isSRM]                   ;
 1ED  22027                        JUMP 027[init]
 1EE                               ; Testmemory TEMP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END
 1EE  20345                  isST: CALL 345[getnextscratchchar]
 1EF                               ;                    COMPARE      s0, 70'd              ; is this a F?
 1EF                               ;                   JUMP      Z, isSTF            ;
 1EF  1D04D                        COMPARE s0, 4D[77'd]                 ; is this a M?
 1F0  32221                        JUMP Z, 221[isSTM]                   ;
 1F1  22027                        JUMP 027[init]
 1F2                               ; SAS - set archive source
 1F2  2034A                 isSAS: CALL 34A[getnextvalue]
 1F3  00150                        LOAD s1, s5
 1F4  20330                        CALL 330[ArchiveSource]
 1F5  22027                        JUMP 027[init]
 1F6                               ; SAG   Set analogue gain
 1F6  2034A                 isSAG: CALL 34A[getnextvalue]
 1F7  05580                        OR s5, 80[128'd]                     ; set bit 7
 1F8  2D502                        OUTPUT s5, 02[GainPD]
 1F9  2037B                        CALL 37B[delay_1ms]                  ; wait for calib
 1FA  0357F                        AND s5, 7F[127'd]                    ; reset bit 7
 1FB  2D502                        OUTPUT s5, 02[GainPD]
 1FC  22027                        JUMP 027[init]
 1FD  2034A                 isSAI: CALL 34A[getnextvalue]
 1FE  01400                        LOAD s4, 00
 1FF  1D501                        COMPARE s5, 01                       ; is it 1
 200  36202                        JUMP NZ, 202[setADC]
 201  01440                        LOAD s4, 40[64'd]
 202  0B013                setADC: FETCH s0, 13[ADCstate]
 203  030BF                        AND s0, BF[191'd]                    ; reset bit 6
 204  04040                        OR s0, s4                            ; affect bit 6
 205  2F013                        STORE s0, 13[ADCstate]               ; save
 206  2D013                        OUTPUT s0, 13[ADCstate_port]         ; set port to new ADC channel
 207  22027                        JUMP 027[init]
 208  2034A                 isSAO: CALL 34A[getnextvalue]
 209  01400                        LOAD s4, 00
 20A  1D501                        COMPARE s5, 01                       ; is it 1
 20B  3620D                        JUMP NZ, 20D[setAudioOut]
 20C  01420                        LOAD s4, 20[32'd]
 20D  0B013           setAudioOut: FETCH s0, 13[ADCstate]
 20E  030DF                        AND s0, DF[223'd]                    ; 255 - 32        ; reset bit5
 20F  04040                        OR s0, s4                            ; affect bit 5
 210  2F013                        STORE s0, 13[ADCstate]               ; save
 211  2D013                        OUTPUT s0, 13[ADCstate_port]         ; set port to new audio channel
 212  22027                        JUMP 027[init]
 213                               ; SRF - set receive frequency (gets 4 hex digits
 213  2034A                 isSRF: CALL 34A[getnextvalue]               ; get byte represented by 2 digits
 214  2D50A                        OUTPUT s5, 0A[RXFreqMSB]
 215  2034A                        CALL 34A[getnextvalue]
 216  2D50B                        OUTPUT s5, 0B[RXFreqLSB]
 217  22027                        JUMP 027[init]
 218                               ; set receive mode
 218  200BD                 isSRM: CALL 0BD[setRXmode]                  ; used to be RX, but that doesn't change mode and frequency etc.
 219  22027                        JUMP 027[init]
 21A                               ; Routine to set receive mode - just basic function ie doesn't set mode etc.
 21A  01530                    RX: LOAD s5, 30[48'd]                    ; Ascii code for '0' - set receive mode
 21B  2D500                        OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 21C  0B510                        FETCH s5, 10[Latch7]
 21D  0357F                        AND s5, 7F[~TX_HIGH]                 ; reset bit 7
 21E  2F510                        STORE s5, 10[Latch7]
 21F  2D507                        OUTPUT s5, 07[ProgramM]
 220  25000                        RETURN 
 221                               ; set Tranmit mode
 221  200D7                 isSTM: CALL 0D7[setTXmode]                  ; used to be TX 20/5/2013
 222  22027                        JUMP 027[init]
 223                               ; routine to set transmit mode
 223  01531                    TX: LOAD s5, 31[49'd]                    ; Ascii code for '1' - set transmit mode
 224  2D500                        OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 225  0B510                        FETCH s5, 10[Latch7]
 226  05580                        OR s5, 80[TX_HIGH]                   ; set bit 7
 227  2F510                        STORE s5, 10[Latch7]
 228  2D507                        OUTPUT s5, 07[ProgramM]
 229  20272                        CALL 272[Twotone]                    ; added to give start of message beep
 22A  25000                        RETURN 
 22B                               ; STF - set transmit frequency (gets 4 hex digits -Frequency now set by Keypad
 22B                               ;isSTF:              CALL      getnextvalue        ; get byte represented by 2 digits
 22B                               ;                   OUTPUT       s5, TXFreqMSB
 22B                               ;                  CALL      getnextvalue
 22B                               ;                 OUTPUT       s5, TXFreqLSB
 22B                               ;                JUMP      init
 22B                               ; GET AGC value from DSP
 22B  01047                  isGG: LOAD s0, 47[71'd]                    ; letter G
 22C  2D000                        OUTPUT s0, 00[CMD2DSP]               ; send G to DSP
 22D  20360                        CALL 360[SendCRLF]
 22E  2037B                        CALL 37B[delay_1ms]
 22F  202D6                        CALL 2D6[Check4CmdfromDSP]           ; if character send to terminal
 230  202D6                        CALL 2D6[Check4CmdfromDSP]           ; if character send to terminal
 231  202D6                        CALL 2D6[Check4CmdfromDSP]           ; if character send to terminal
 232  202D6                        CALL 2D6[Check4CmdfromDSP]           ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 233                               ;      CALL      SendCRLF
 233  22027                        JUMP 027[init]
 234                               ; Get AVEsignal level from DSP
 234  01053                  isGS: LOAD s0, 53[83'd]                    ; letter S
 235  2D000                        OUTPUT s0, 00[CMD2DSP]               ; send S to DSP
 236  20360                        CALL 360[SendCRLF]
 237  2037B                        CALL 37B[delay_1ms]
 238  202D6                        CALL 2D6[Check4CmdfromDSP]           ; if character send to terminal
 239  202D6                        CALL 2D6[Check4CmdfromDSP]           ; if character send to terminal
 23A  202D6                        CALL 2D6[Check4CmdfromDSP]           ; if character send to terminal
 23B  202D6                        CALL 2D6[Check4CmdfromDSP]           ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 23C                               ;      CALL      SendCRLF
 23C  22027                        JUMP 027[init]
 23D                               ; send test command to BT pico
 23D  01047                  isGB: LOAD s0, 47[71'd]                    ; letter G
 23E  2D014                        OUTPUT s0, 14[CMD2BT]                ; send G to BT
 23F                               ;      CALL      SendCRLF
 23F  2037B                        CALL 37B[delay_1ms]
 240  202DB                        CALL 2DB[Check4CmdfromBT]            ; if character send to terminal
 241  202DB                        CALL 2DB[Check4CmdfromBT]            ; if character send to terminal
 242  202DB                        CALL 2DB[Check4CmdfromBT]            ; if character send to terminal
 243  202DB                        CALL 2DB[Check4CmdfromBT]            ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 244                               ;      CALL      SendCRLF
 244  22027                        JUMP 027[init]
 245                               ; Return Loran inhibit rate
 245  09508                  isGC: INPUT s5, 08
 246  2035B                        CALL 35B[Byte2UART]
 247  25000                        RETURN 
 248                               ; Request from keypad pico
 248  20345                  isGK: CALL 345[getnextscratchchar]
 249  1D054                        COMPARE s0, 54[84'd]                 ; is this a T?
 24A  3225A                        JUMP Z, 25A[isGKT]
 24B  1D056                        COMPARE s0, 56[86'd]                 ; is this a V?
 24C  32263                        JUMP Z, 263[isGKV]
 24D  22027                        JUMP 027[init]
 24E                               ; report signal level from the ADC
 24E  0B515                  isGL: FETCH s5, 15[ADCLevel]
 24F  2035B                        CALL 35B[Byte2UART]
 250  01620                        LOAD s6, 20                          ; space
 251  20355                        CALL 355[Send2UartTX]
 252  0950F                        INPUT s5, 0F[ADCSignalLevel]
 253  2035B                        CALL 35B[Byte2UART]
 254  01620                        LOAD s6, 20                          ; space
 255  20355                        CALL 355[Send2UartTX]
 256  0B516                        FETCH s5, 16[ADCgain]
 257  2035B                        CALL 35B[Byte2UART]
 258  20360                        CALL 360[SendCRLF]
 259  22027                        JUMP 027[init]
 25A                               ; send test command to KP pico
 25A  01054                 isGKT: LOAD s0, 54[84'd]                    ; letter T
 25B  2D015                        OUTPUT s0, 15[CMD2KP]                ; send T to KP
 25C  20360                        CALL 360[SendCRLF]
 25D  2037B                        CALL 37B[delay_1ms]
 25E  202E0                        CALL 2E0[Check4CmdfromKP]            ; if character send to terminal
 25F  202E0                        CALL 2E0[Check4CmdfromKP]            ; if character send to terminal
 260  202E0                        CALL 2E0[Check4CmdfromKP]            ; if character send to terminal
 261  202E0                        CALL 2E0[Check4CmdfromKP]            ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 262                               ;      CALL      SendCRLF
 262  22027                        JUMP 027[init]
 263  01056                 isGKV: LOAD s0, 56[86'd]                    ; letter V
 264  2D015                        OUTPUT s0, 15[CMD2KP]                ; send V to KP
 265  20360                        CALL 360[SendCRLF]
 266  2037B                        CALL 37B[delay_1ms]
 267  202E0                        CALL 2E0[Check4CmdfromKP]            ; if character send to terminal
 268  202E0                        CALL 2E0[Check4CmdfromKP]            ; if character send to terminal
 269  202E0                        CALL 2E0[Check4CmdfromKP]            ; if character send to terminal
 26A  202E0                        CALL 2E0[Check4CmdfromKP]            ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 26B                               ;      CALL      SendCRLF
 26B  22027                        JUMP 027[init]
 26C  2031D                  isGA: CALL 31D[SendArchive]
 26D  22027                        JUMP 027[init]
 26E  01508                  isGV: LOAD s5, 08[Versionno]
 26F  2035B                        CALL 35B[Byte2UART]
 270  20360                        CALL 360[SendCRLF]                   ; added to allow get line to read OK
 271  22027                        JUMP 027[init]
 272  01042               Twotone: LOAD s0, 42[66'd]                    ; Block DSPpico
 273  2D000                        OUTPUT s0, 00[CMD2DSP]               ; send B to DSP to block it
 274                               ; need to output TX freq carrier plus 30 then 40 and then return to carrier - now simply as an increment
 274  01035                        LOAD s0, 35[53'd]
 275  2D00D                        OUTPUT s0, 0D[Tone]
 276  20376                        CALL 376[delay_100ms]
 277  01023                        LOAD s0, 23[35'd]
 278  2D00D                        OUTPUT s0, 0D[Tone]
 279  20376                        CALL 376[delay_100ms]
 27A  01000                        LOAD s0, 00
 27B  2D00D                        OUTPUT s0, 0D[Tone]                  ; and send value to SSB modulatorto reset to normal frequency
 27C  01052                        LOAD s0, 52[82'd]                    ; Un Block DSPpico
 27D  2D000                        OUTPUT s0, 00[CMD2DSP]               ; send R to DSP (release)
 27E  25000                        RETURN 
 27F  01500                Warble: LOAD s5, 00
 280  01042            Warbleloop: LOAD s0, 42[66'd]                    ; Block DSPpico
 281  2D000                        OUTPUT s0, 00[CMD2DSP]               ; send B to DSP to block it
 282                               ; need to output TX freq carrier plus 30 then 40 and then return to carrier - now simply as an increment
 282  0101E                        LOAD s0, 1E[30'd]
 283  2D00D                        OUTPUT s0, 0D[Tone]
 284  20376                        CALL 376[delay_100ms]
 285  01028                        LOAD s0, 28[40'd]
 286  2D00D                        OUTPUT s0, 0D[Tone]
 287  20376                        CALL 376[delay_100ms]
 288  11501                        ADD s5, 01
 289  1D504                        COMPARE s5, 04                       ; Do this 4 times
 28A  36280                        JUMP NZ, 280[Warbleloop]
 28B  01000                        LOAD s0, 00
 28C  2D00D                        OUTPUT s0, 0D[Tone]                  ; and send value to SSB modulatorto reset to normal frequency
 28D  01052                        LOAD s0, 52[82'd]                    ; Un Block DSPpico
 28E  2D000                        OUTPUT s0, 00[CMD2DSP]               ; send R to DSP (release)
 28F  25000                        RETURN 
 290  20223            BeaconBeep: CALL 223[TX]
 291  01700                        LOAD s7, 00
 292  2027F            Beaconloop: CALL 27F[Warble]
 293                               ; Keep checking fifo for a character to keep it clear!
 293  202E0                        CALL 2E0[Check4CmdfromKP]
 294  1D674                        COMPARE s6, 74["t"]                  ; character_t
 295  322A3                        JUMP Z, 2A3[cancelbeacon]            ; Escape if is key pressed - changed this 2/5/13 to speed up beacon cancel
 296  11701                        ADD s7, 01
 297  1D703                        COMPARE s7, 03
 298  36292                        JUMP NZ, 292[Beaconloop]             ; do warble 3 times
 299  2021A                        CALL 21A[RX]
 29A  20368                        CALL 368[delay_1s]
 29B                               ; Keep checking fifo for a character to keep it clear!
 29B  202E0                        CALL 2E0[Check4CmdfromKP]
 29C  1D674                        COMPARE s6, 74["t"]                  ; character_t
 29D  322A3                        JUMP Z, 2A3[cancelbeacon]            ; Escape if is key pressed
 29E  20368                        CALL 368[delay_1s]
 29F                               ; Keep checking fifo for a character to keep it clear!
 29F  202E0                        CALL 2E0[Check4CmdfromKP]
 2A0  1D674                        COMPARE s6, 74["t"]                  ; character_t
 2A1  322A3                        JUMP Z, 2A3[cancelbeacon]            ; Escape if is key pressed
 2A2                               ; 6/7/12 reduced receive period to 2s
 2A2  25000                        RETURN 
 2A3  0B012          cancelbeacon: FETCH s0, 12[Mode]
 2A4  030FE                        AND s0, FE[254'd]                    ; cancel beaon mode
 2A5  2F012                        STORE s0, 12[Mode]                   ; Hah - had forgotton to update the mode! 20/5/13
 2A6  25000                        RETURN 
 2A7                               ; ;;Pete
 2A7                               ; ;;Pete
 2A7                               ; ;;Pete
 2A7              HandleBTCommand: 
 2A7                               ; ;;LOAD      s6, 'A'             ; get character
 2A7                               ; ;;CALL      Send2UartTX         ; and echo back to terminal
 2A7  0307F                        AND s0, 7F                           ; mask off top bit
 2A8                               ; need to interpret commands from BT Here
 2A8  1D014                        COMPARE s0, 14[TRANSMIT_ON]
 2A9  322AD                        JUMP Z, 2AD[FromBT_XMIT]             ; Bluetooth Headset transmit
 2AA  1D015                        COMPARE s0, 15[TRANSMIT_OFF]
 2AB  322B7                        JUMP Z, 2B7[FromBT_RECEIVE]          ; Bluetooth Headset stop transmit
 2AC                               ; ;;COMPARE      s0, FLASH_WRITE
 2AC                               ; ;;JUMP      Z, FromBT_WRITE     ; PC has sent a WRITE to Flash request
 2AC                               ; ;;COMPARE      s0, FLASH_WRITE_PAGE
 2AC                               ; ;;JUMP      Z, FromBT_WRITE_PAGE; PC has sent a WRITE PAGE to Flash request
 2AC                               ; ;;COMPARE      s0, FLASH_ERASE
 2AC                               ; ;;JUMP      Z, FromBT_ERASE     ; PC has sent a Erase the Write message
 2AC                               ; ;;COMPARE      s0, FLASH_READ
 2AC                               ; ;;JUMP      Z, FromBT_READ      ; PC has sent a Read request
 2AC                               ; ;;COMPARE      s0, FLASH_READ_PAGE
 2AC                               ; ;;JUMP      Z, FromBT_READ_PAGE ; PC has sent a Read Page request
 2AC                               ; ;;COMPARE      s0, FLASH_WRITE_TEXT
 2AC                               ; ;;JUMP      Z, FromBT_WRITE_TEXT; PC has sent a WRITE TEXT to Flash request
 2AC                               ; LOAD      s0, 2F             ; send message back
 2AC                               ; OUTPUT       s0, CMD2BT          ; send Go to BT
 2AC                               ; CALL      SendCharToBT
 2AC  2204F                        JUMP 04F[HandleBTCommand_Done]
 2AD                  FromBT_XMIT: 
 2AD  20360                        CALL 360[SendCRLF]
 2AE  01654                        LOAD s6, 54["T"]
 2AF  20355                        CALL 355[Send2UartTX]                ; and echo back to terminal. Message mode
 2B0  01678                        LOAD s6, 78["x"]
 2B1  20355                        CALL 355[Send2UartTX]                ; and echo back to terminal. Message mode
 2B2  200D7                        CALL 0D7[setTXmode]
 2B3  20360                        CALL 360[SendCRLF]
 2B4  01001                        LOAD s0, 01
 2B5  2F043                        STORE s0, 43[BluetoothXmit]
 2B6  2204F                        JUMP 04F[HandleBTCommand_Done]
 2B7               FromBT_RECEIVE: 
 2B7  20360                        CALL 360[SendCRLF]
 2B8  01652                        LOAD s6, 52["R"]
 2B9  20355                        CALL 355[Send2UartTX]                ; and echo back to terminal. Message mode
 2BA  01663                        LOAD s6, 63["c"]
 2BB  20355                        CALL 355[Send2UartTX]                ; and echo back to terminal. Message mode
 2BC  200BD                        CALL 0BD[setRXmode]
 2BD  20360                        CALL 360[SendCRLF]
 2BE  01000                        LOAD s0, 00
 2BF  2F043                        STORE s0, 43[BluetoothXmit]
 2C0  2204F                        JUMP 04F[HandleBTCommand_Done]
 2C1                               ; ;; end Pete
 2C1                               ; ;; end Pete
 2C1                               ; ;; end Pete
 2C1  016FF           getUARTchar: LOAD s6, FF                          ; Return FF if no character
 2C2  20351                        CALL 351[CheckUartRx]
 2C3  35000                        RETURN NZ                            ; Return if no character with s6=$FF
 2C4  09600                        INPUT s6, 00[Uart_rx]                ; get character
 2C5  0367F                        AND s6, 7F
 2C6                               ; CALL      Send2UartTX         ; and echo back to terminal. - SHOULD USE Send2UartTX (not in message mode)
 2C6  25000                        RETURN 
 2C7                               ; returns fifo character in s6 assuming present
 2C7  202E5      sendDSP2Terminal: CALL 2E5[GetDSPFifoChar]
 2C8  01600                        LOAD s6, 00                          ; get character
 2C9  0367F                        AND s6, 7F                           ; top bit is for empty fifo flag!
 2CA                               ;Send to keypad pico (LCD) instead
 2CA                               ;                    CALL      Send2UartTX         ; and echo back to terminal.
 2CA  2D615                        OUTPUT s6, 15[CMD2KP]                ; send code 0-7F (normally ascii, but $7F would tell it to expect a value to display at a particular place)
 2CB  25000                        RETURN 
 2CC                               ; returns BT fifo character in s6 assuming present
 2CC  202EB       sendBT2Terminal: CALL 2EB[GetBTFifoChar]
 2CD  00600                        LOAD s6, s0                          ; get character
 2CE  0367F                        AND s6, 7F
 2CF  20355                        CALL 355[Send2UartTX]                ; and echo back to terminal.
 2D0  25000                        RETURN 
 2D1                               ; returns KP fifo character in s6 assuming present
 2D1  202F1       sendKP2Terminal: CALL 2F1[GetKPFifoChar]
 2D2  00600                        LOAD s6, s0                          ; get character
 2D3  0367F                        AND s6, 7F
 2D4  20355                        CALL 355[Send2UartTX]                ; and echo back to terminal.
 2D5  25000                        RETURN 
 2D6                               ; checks for command from DSP pico, if present in s6 and echo to terminal - otherwise s6>127
 2D6  09104      Check4CmdfromDSP: INPUT s1, 04[DSPcmd]                 ; Get character from DSP picoblaze (if present should be less than 128)
 2D7  00610                        LOAD s6, s1
 2D8  1D180                        COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 2D9  382C7                        CALL C, 2C7[sendDSP2Terminal]        ; If less than 128 there is a value to give back and display.
 2DA  25000                        RETURN 
 2DB                               ; checks for command from BTpico, if present in s6 and echo to terminal - otherwise s6>127
 2DB  09105       Check4CmdfromBT: INPUT s1, 05[BTcmd]                  ; Get character from BT picoblaze (if present should be less than 128)
 2DC  00610                        LOAD s6, s1
 2DD  1D180                        COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 2DE  382CC                        CALL C, 2CC[sendBT2Terminal]         ; If less than 128 there is a value to give back and display.
 2DF  25000                        RETURN 
 2E0                               ; checks for command from KPpico, if present in s6  - otherwise s6>127
 2E0  09106       Check4CmdfromKP: INPUT s1, 06[KPcmd]                  ; Get character from BT picoblaze (if present should be less than 128)
 2E1  00610                        LOAD s6, s1
 2E2  1D180                        COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 2E3  382F1                        CALL C, 2F1[GetKPFifoChar]
 2E4  25000                        RETURN 
 2E5                               ; Routine to recover a byte, (character?) from the FIFO in s0
 2E5  01010        GetDSPFifoChar: LOAD s0, 10[DSPFifo]
 2E6  2D00E                        OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 2E7  01010                        LOAD s0, 10[DSPFifo]                 ; dummy, wait a bit longer for character to present itself
 2E8  09004                        INPUT s0, 04[DSPcmd]                 ; now get my character
 2E9  0307F                        AND s0, 7F                           ; mask off top bit
 2EA  25000                        RETURN 
 2EB                               ; Routine to recover a character from the BTFIFO in s0
 2EB  01020         GetBTFifoChar: LOAD s0, 20[BTFifo]
 2EC  2D00E                        OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 2ED  01020                        LOAD s0, 20[BTFifo]                  ; dummy, wait a bit longer for character to present itself
 2EE  09005                        INPUT s0, 05[BTcmd]                  ; now get my character
 2EF  0307F                        AND s0, 7F                           ; mask off top bit
 2F0  25000                        RETURN 
 2F1                               ; Routine to recover a character from the KPFIFO in s6
 2F1  01040         GetKPFifoChar: LOAD s0, 40[KPFifo]
 2F2  2D00E                        OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 2F3  01040                        LOAD s0, 40[KPFifo]                  ; dummy, wait a bit longer for character to present itself
 2F4  09606                        INPUT s6, 06[KPcmd]                  ; now get my character
 2F5  0367F                        AND s6, 7F                           ; mask off top bit
 2F6  25000                        RETURN 
 2F7                               ; sayOK:              CALL      SendCRLF
 2F7                               ; LOAD      s6, 79
 2F7                               ; CALL      Send2UartTX
 2F7                               ; LOAD      s6, 75
 2F7                               ; CALL      Send2UartTX
 2F7                               ; CALL      SendCRLF
 2F7                               ; RETURN
 2F7                               ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 2F7  00860            Chars2Byte: LOAD s8, s6
 2F8  20302                        CALL 302[Get4bits]
 2F9  00580                        LOAD s5, s8
 2FA  14506                        SL0 s5
 2FB  14506                        SL0 s5
 2FC  14506                        SL0 s5
 2FD  14506                        SL0 s5                               ; put these 4 bits to MSBs
 2FE  00870                        LOAD s8, s7
 2FF  20302                        CALL 302[Get4bits]
 300  10580                        ADD s5, s8
 301  25000                        RETURN 
 302                               ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 302  1D83C              Get4bits: COMPARE s8, 3C[60'd]                 ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 303  3A307                        JUMP C, 307[char0_9]
 304  19837                        SUB s8, 37[55'd]                     ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 305  0380F                        AND s8, 0F                           ; make sure only return 4 bits
 306  25000                        RETURN 
 307  19830               char0_9: SUB s8, 30[48'd]
 308  0380F                        AND s8, 0F                           ; make sure only return 4 bits
 309  25000                        RETURN 
 30A                               ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 30A  00850            Byte2Chars: LOAD s8, s5                          ; assumes 8 bit data is in s5
 30B  1450E                        SR0 s5
 30C  1450E                        SR0 s5
 30D  1450E                        SR0 s5
 30E  1450E                        SR0 s5                               ; get first hex character
 30F  20316                        CALL 316[GetChar]
 310  00650                        LOAD s6, s5                          ; first ascii char
 311  00580                        LOAD s5, s8
 312  0350F                        AND s5, 0F
 313  20316                        CALL 316[GetChar]                    ;
 314  00750                        LOAD s7, s5                          ; second ascii char
 315  25000                        RETURN 
 316                               ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 316  1950A               GetChar: SUB s5, 0A[10'd]                     ; Test if s5 greater than 9
 317  3A31A                        JUMP C, 31A[is_0_9]                  ; Hex character is 0_9
 318  11541                        ADD s5, 41[65'd]                     ; offset for Ascii code 'A'
 319  25000                        RETURN 
 31A  1150A                is_0_9: ADD s5, 0A[10'd]                     ; return to range 0-9
 31B  11530                        ADD s5, 30[48'd]                     ; offset to Ascii code for '0'
 31C  25000                        RETURN 
 31D                               ; To send to Uart, simply use: OUTPUT       s3, UART_TX         ; Sends value in s3 to Uart Tx
 31D                               ; Dump archive RAM to RS232 port as 4 Ascii codes per data value followed by carriage return and line feed.
 31D  2033C           SendArchive: CALL 33C[DisableArchive]             ; Stop archiving
 31E  01000                        LOAD s0, 00
 31F  01100                        LOAD s1, 00
 320  0B410             SendAloop: FETCH s4, 10[Latch7]
 321  034FC                        AND s4, FC[252'd]                    ; set top 2 address bits to zero
 322  2D006                        OUTPUT s0, 06[ProgramL]
 323  04410                        OR s4, s1                            ; patch in top 2 address bits
 324  2D407                        OUTPUT s4, 07[ProgramM]              ; and send to the output port
 325  09503                        INPUT s5, 03[ArchiveDataMSB]
 326  2035B                        CALL 35B[Byte2UART]
 327  09502                        INPUT s5, 02[ArchiveDataLSB]         ; grab bottom byte
 328  2035B                        CALL 35B[Byte2UART]
 329  11001                        ADD s0, 01
 32A  13100                        ADDCY s1, 00
 32B  20360                        CALL 360[SendCRLF]
 32C  1D104                        COMPARE s1, 04
 32D  36320                        JUMP NZ, 320[SendAloop]
 32E  20337                        CALL 337[EnableArchive]              ; Restart archiving
 32F  25000                        RETURN 
 330                               ; Select Archiving source, if s1 is 0 then raw 16bit ADC data is archived, or if s1=1 then 16bit data from the DSP picoblaze (DATA2Archve) is archived at 6kHz
 330  03103         ArchiveSource: AND s1, 03
 331  0B014                        FETCH s0, 14[SelectScratch]          ; get current value of selections
 332  030FC                        AND s0, FC[252'd]                    ; first reset first 2 bits
 333  04010                        OR s0, s1                            ; affect bits 0-1
 334  2D008                        OUTPUT s0, 08[SelectArchiveSource]   ; update archive control port
 335  2F014                        STORE s0, 14[SelectScratch]          ; Update scratchpad
 336                               ;      LOAD   s5,s0
 336                               ;      CALL   Byte2Chars
 336  25000                        RETURN 
 337                               ; Enable Archiving
 337  0B010         EnableArchive: FETCH s0, 10[Latch7]                 ; get current value of control port
 338  05040                        OR s0, 40[EnArchive]                 ; set bit 5
 339  2D007                        OUTPUT s0, 07[ProgramM]
 33A  2F010                        STORE s0, 10[Latch7]                 ; get current value of control port
 33B  25000                        RETURN 
 33C                               ; Disable Archiving
 33C  00600        DisableArchive: LOAD s6, s0
 33D  20385                        CALL 385[delay_50us]                 ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 33E  2037B                        CALL 37B[delay_1ms]                  ; wait for a bit more archiving first!
 33F  0B010                        FETCH s0, 10[Latch7]                 ; get current value of control port
 340  030BF                        AND s0, BF[~EnArchive]               ; reset bit 5
 341  2D007                        OUTPUT s0, 07[ProgramM]
 342  2F010                        STORE s0, 10[Latch7]                 ; get current value of control port
 343  00060                        LOAD s0, s6                          ; restore s0 value
 344  25000                        RETURN 
 345                               ; Character parsing:
 345                               ; returns next command character in s0
 345  0A090    getnextscratchchar: FETCH s0, (s9)
 346  11901                        ADD s9, 01                           ; increment pointer
 347  00600                        LOAD s6, s0
 348  20355                        CALL 355[Send2UartTX]                ; and echo back to terminal. Message mode
 349  25000                        RETURN 
 34A                               ; Reads 2 ascii codes and returns the byte represented in hex as binary value in s5
 34A  20345          getnextvalue: CALL 345[getnextscratchchar]
 34B  00400                        LOAD s4, s0
 34C  20345                        CALL 345[getnextscratchchar]
 34D  00700                        LOAD s7, s0
 34E  00640                        LOAD s6, s4
 34F  202F7                        CALL 2F7[Chars2Byte]                 ; return byte in s5
 350  25000                        RETURN 
 351                               ; UART control
 351  09001           CheckUartRx: INPUT s0, 01[Uart_status]            ; Check if there is RX data
 352  03001                        AND s0, 01
 353  1D001                        COMPARE s0, 01
 354  25000                        RETURN 
 355                               ; send character in s6 to Uart - also uses s8!
 355  09801           Send2UartTX: INPUT s8, 01[Uart_status]            ; Check if TX buffer is full
 356  03802                        AND s8, 02
 357  1D802                        COMPARE s8, 02                       ; if 2 then wait
 358  32355                        JUMP Z, 355[Send2UartTX]
 359  2D601                        OUTPUT s6, 01[UART_TX]
 35A  25000                        RETURN 
 35B                               ; Convert byte in s5 into 2 ascii codes in hexadecimal and send to the serial port.
 35B  2030A             Byte2UART: CALL 30A[Byte2Chars]
 35C  20355                        CALL 355[Send2UartTX]
 35D  00670                        LOAD s6, s7
 35E  20355                        CALL 355[Send2UartTX]
 35F  25000                        RETURN 
 360  0160D              SendCRLF: LOAD s6, 0D
 361  20355                        CALL 355[Send2UartTX]
 362  0160A                        LOAD s6, 0A
 363  20355                        CALL 355[Send2UartTX]
 364  25000                        RETURN 
 365  01620             SendSPACE: LOAD s6, 20
 366  20355                        CALL 355[Send2UartTX]
 367  25000                        RETURN 
 368                               CONSTANT count_1000_lsb, E8          ; lower 8-bits of 1000 count value
 368                               CONSTANT count_1000_msb, 03          ; upper 8-bits of 1000 count value
 368                               ; Registers used s0, s1, s2, s3, s4 and s5.
 368                               ;
 368  01500              delay_1s: LOAD s5, 00                          ; clear cycle counter
 369  01400                        LOAD s4, 00
 36A  2037B               wait_1s: CALL 37B[delay_1ms]
 36B  11401                        ADD s4, 01                           ; increment cycle counter
 36C  13500                        ADDCY s5, 00
 36D  1D4E8                        COMPARE s4, E8[count_1000_lsb]       ; test for 1000ms
 36E  3636A                        JUMP NZ, 36A[wait_1s]
 36F  1D503                        COMPARE s5, 03[count_1000_msb]
 370  3636A                        JUMP NZ, 36A[wait_1s]
 371  25000                        RETURN 
 372                               ;
 372                               ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 372                               ;
 372                               ;
 372                               ; Registers used s0, s1, s2, s3 and s4.
 372                               ;
 372  20376           delay_300ms: CALL 376[delay_100ms]
 373  20376           delay_200ms: CALL 376[delay_100ms]
 374  20376                        CALL 376[delay_100ms]
 375  25000                        RETURN 
 376                               ;
 376                               ; Delay of approximately 100ms used for switch debounce
 376                               ;
 376                               ; Registers used s0, s1, s2, s3 and s4.
 376                               ;
 376  01464           delay_100ms: LOAD s4, 64                          ; repeat 1ms delay 100 times
 377  2037B            wait_100ms: CALL 37B[delay_1ms]
 378  19401                        SUB s4, 01
 379  36377                        JUMP NZ, 377[wait_100ms]
 37A  25000                        RETURN 
 37B                               ;
 37B                               ; Registers used s0, s1, s2 and s3.
 37B                               ;
 37B  01300             delay_1ms: LOAD s3, 00                          ; clear cycle counter
 37C  01200                        LOAD s2, 00
 37D  2038A              wait_1ms: CALL 38A[delay_1us]
 37E  11201                        ADD s2, 01                           ; increment cycle counter
 37F  13300                        ADDCY s3, 00
 380  1D2E8                        COMPARE s2, E8[count_1000_lsb]       ; test for 1000us
 381  3637D                        JUMP NZ, 37D[wait_1ms]
 382  1D303                        COMPARE s3, 03[count_1000_msb]
 383  3637D                        JUMP NZ, 37D[wait_1ms]
 384  25000                        RETURN 
 385                               ;
 385                               ; Delay of approximately 50us required by LCD display
 385                               ;
 385                               ; Registers used s0 and s1.
 385                               ;
 385  01132            delay_50us: LOAD s1, 32[50'd]                    ; repeat 1us delay 50 times
 386  2038A             wait_50us: CALL 38A[delay_1us]
 387  19101                        SUB s1, 01
 388  36386                        JUMP NZ, 386[wait_50us]
 389  25000                        RETURN 
 38A                               ; Delay of approximately 1us used to provide timing reference for
 38A                               ; LCD operations. This must be adjusted to reflect the clock
 38A                               ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 38A                               ;
 38A                               ; The software delay loop is formed using register s0. This register
 38A                               ; must be loaded with an integer value close to the result of....
 38A                               ;
 38A                               ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 38A                               ;
 38A                               ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 38A                               ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 38A                               ; operation will become lower than the 100KHz target intended.
 38A                               ;
 38A                               ; Register used s0.
 38A                               ;
 38A  0100C             delay_1us: LOAD s0, 0C[delay_1us_constant]      ; delay value of 12 decimal for a 50MHz clock
 38B  19001              wait_1us: SUB s0, 01
 38C  3638B                        JUMP NZ, 38B[wait_1us]
 38D  25000                        RETURN 
 38E                               ;
 38E                               ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\home\graham\Dropbox\N3workingG\TE0722Rebuild\N3SysGen\UserPico.psm



List of defined constants

 CONSTANT name        Value        Source PSM File

 timestamp_hours      17'd         
 timestamp_minutes    39'd         
 timestamp_seconds    13'd         
 datestamp_year       16'd         
 datestamp_month      7'd          
 datestamp_day        16'd         
 NUL                  00           
 BEL                  07           
 BS                   08           
 HT                   09           
 LF                   0A           
 VT                   0B           
 CR                   0D           
 ESC                  1B           
 DEL                  7F           
 DCS                  90           
 ST                   9C           
 Versionno            08           UserPico.psm
 InitialVolume        133'd        UserPico.psm
 MinorVersionno       EE           UserPico.psm
 Bmode                00           UserPico.psm
 AGCupperRX           32           UserPico.psm
 AGClowerRX           12           UserPico.psm
 AGCupperTX           10           UserPico.psm
 AGClowerTX           06           UserPico.psm
 delay_1us_constant   12'd         UserPico.psm
 WREN                 06           UserPico.psm
 FAST_READ            0B           UserPico.psm
 BERASE               C7           UserPico.psm
 SER                  D8           UserPico.psm
 RDID                 9F           UserPico.psm
 PP                   02           UserPico.psm
 RDSR                 05           UserPico.psm
 Latch7               16'd         UserPico.psm
 LastDSPbyte          17'd         UserPico.psm
 Mode                 18'd         UserPico.psm
 ADCstate             19'd         UserPico.psm
 SelectScratch        20'd         UserPico.psm
 ADCLevel             21'd         UserPico.psm
 ADCgain              22'd         UserPico.psm
 TX_F_MSB             23'd         UserPico.psm
 TX_F_LSB             24'd         UserPico.psm
 ADCAGCUpperThreshold 25'd         UserPico.psm
 ADCAGCLowerThreshold 26'd         UserPico.psm
 ADCGainTX            27'd         UserPico.psm
 ADCGainRX            28'd         UserPico.psm
 BluetoothXmit        43           UserPico.psm
 Uart_rx              00           UserPico.psm
 Uart_status          01           UserPico.psm
 BattMon              4'd          UserPico.psm
 ArchiveDataLSB       2'd          UserPico.psm
 ArchiveDataMSB       3'd          UserPico.psm
 DSPcmd               4'd          UserPico.psm
 BTcmd                5'd          UserPico.psm
 KPcmd                6'd          UserPico.psm
 DataReadback         7'd          UserPico.psm
 DataReadback_1       8'd          UserPico.psm
 DSPRAMrdbkMSB        9'd          UserPico.psm
 DSPRAMrdbkLSB        10'd         UserPico.psm
 BTRAMrdbkMSB         11'd         UserPico.psm
 BTRAMrdbkLSB         12'd         UserPico.psm
 KPRAMrdbkMSB         13'd         UserPico.psm
 KPRAMrdbkLSB         14'd         UserPico.psm
 ADCSignalLevel       15'd         UserPico.psm
 CMD2DSP              00           UserPico.psm
 UART_TX              01           UserPico.psm
 GainPD               02           UserPico.psm
 Instructiona         03           UserPico.psm
 Instructionb         04           UserPico.psm
 Instructionc         05           UserPico.psm
 ProgramL             06           UserPico.psm
 ProgramM             07           UserPico.psm
 EnArchive            64'd         UserPico.psm
 TX_HIGH              128'd        UserPico.psm
 SelectArchiveSource  8'd          UserPico.psm
 Configure            9'd          UserPico.psm
 RXFreqMSB            10'd         UserPico.psm
 RXFreqLSB            11'd         UserPico.psm
 AudioVolume          12'd         UserPico.psm
 Tone                 13'd         UserPico.psm
 Acknowledge          14'd         UserPico.psm
 DSPFifo              16'd         UserPico.psm
 BTFifo               32'd         UserPico.psm
 KPFifo               64'd         UserPico.psm
 FlashData            17'd         UserPico.psm
 ADCstate_port        19'd         UserPico.psm
 LoranBlank           16'd         UserPico.psm
 AudioOutSelect       32'd         UserPico.psm
 AnalogueChannel      64'd         UserPico.psm
 CMD2BT               20'd         UserPico.psm
 CMD2KP               21'd         UserPico.psm
 RAMDataMSB           22'd         UserPico.psm
 RAMDataLSB           23'd         UserPico.psm
 RAMwriteControl      25'd         UserPico.psm
 TRANSMIT_ON          14           UserPico.psm
 TRANSMIT_OFF         15           UserPico.psm
 count_1000_lsb       E8           UserPico.psm
 count_1000_msb       03           UserPico.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "16 Jul 2016"  
 timestamp$        "17:39:13"     



List of line labels

   Label                  Addr  Source PSM File

 * boot                   000   UserPico.psm
   reboot                 001   UserPico.psm
   DoUserProg             007   UserPico.psm
   GetProg                00A   UserPico.psm
   GetByte                01B   UserPico.psm
   cold_start             021   UserPico.psm
   ProgDSP                022   UserPico.psm
   ScratchClear           023   UserPico.psm
   init                   027   UserPico.psm
   loop                   03D   UserPico.psm
   HandleBTCommand_Done   04F   UserPico.psm
   CheckADClevel          05D   UserPico.psm
   nofive                 06C   UserPico.psm
   First                  06F   UserPico.psm
   Second                 072   UserPico.psm
   Third                  075   UserPico.psm
   Fourth                 078   UserPico.psm
   Fifth                  07B   UserPico.psm
   ToLCD                  07F   UserPico.psm
 * Tempskip               081   UserPico.psm
   ReduceADCgain          089   UserPico.psm
   IncreaseADCgain        092   UserPico.psm
   checkrqst              09B   UserPico.psm
   setEarthAntennas       0A4   UserPico.psm
   setLoopAntennas        0A9   UserPico.psm
   checkRXmode            0AE   UserPico.psm
   checkTXmode            0B7   UserPico.psm
   setRXmode              0BD   UserPico.psm
   setTXmode              0D7   UserPico.psm
   SetAnGain              0EA   UserPico.psm
   interpcommand          0F5   UserPico.psm
   interploop             0F6   UserPico.psm
   isS                    100   UserPico.psm
   isG                    114   UserPico.psm
   isSA                   126   UserPico.psm
   isSB                   130   UserPico.psm
   isSK                   137   UserPico.psm
   isSL                   13B   UserPico.psm
   setLoranBlank          140   UserPico.psm
   isSKS                  146   UserPico.psm
   isSM                   147   UserPico.psm
   isSMW                  151   UserPico.psm
   isSMWloop              174   UserPico.psm
   isSMR                  179   UserPico.psm
   isSMD                  196   UserPico.psm
   isSMS                  1A7   UserPico.psm
   Status                 1A9   UserPico.psm
 * isSS                   1B9   UserPico.psm
   isSU                   1C3   UserPico.psm
   isSW                   1C8   UserPico.psm
   isSSloop               1D6   UserPico.psm
   nowsend2flashback      1DE   UserPico.psm
   nowsend2flash          1E6   UserPico.psm
   isSR                   1E8   UserPico.psm
   isST                   1EE   UserPico.psm
   isSAS                  1F2   UserPico.psm
   isSAG                  1F6   UserPico.psm
   isSAI                  1FD   UserPico.psm
   setADC                 202   UserPico.psm
   isSAO                  208   UserPico.psm
   setAudioOut            20D   UserPico.psm
   isSRF                  213   UserPico.psm
   isSRM                  218   UserPico.psm
   RX                     21A   UserPico.psm
   isSTM                  221   UserPico.psm
   TX                     223   UserPico.psm
   isGG                   22B   UserPico.psm
   isGS                   234   UserPico.psm
   isGB                   23D   UserPico.psm
   isGC                   245   UserPico.psm
   isGK                   248   UserPico.psm
   isGL                   24E   UserPico.psm
   isGKT                  25A   UserPico.psm
   isGKV                  263   UserPico.psm
   isGA                   26C   UserPico.psm
   isGV                   26E   UserPico.psm
   Twotone                272   UserPico.psm
   Warble                 27F   UserPico.psm
   Warbleloop             280   UserPico.psm
   BeaconBeep             290   UserPico.psm
   Beaconloop             292   UserPico.psm
   cancelbeacon           2A3   UserPico.psm
   HandleBTCommand        2A7   UserPico.psm
   FromBT_XMIT            2AD   UserPico.psm
   FromBT_RECEIVE         2B7   UserPico.psm
   getUARTchar            2C1   UserPico.psm
   sendDSP2Terminal       2C7   UserPico.psm
   sendBT2Terminal        2CC   UserPico.psm
 * sendKP2Terminal        2D1   UserPico.psm
   Check4CmdfromDSP       2D6   UserPico.psm
   Check4CmdfromBT        2DB   UserPico.psm
   Check4CmdfromKP        2E0   UserPico.psm
   GetDSPFifoChar         2E5   UserPico.psm
   GetBTFifoChar          2EB   UserPico.psm
   GetKPFifoChar          2F1   UserPico.psm
   Chars2Byte             2F7   UserPico.psm
   Get4bits               302   UserPico.psm
   char0_9                307   UserPico.psm
   Byte2Chars             30A   UserPico.psm
   GetChar                316   UserPico.psm
   is_0_9                 31A   UserPico.psm
   SendArchive            31D   UserPico.psm
   SendAloop              320   UserPico.psm
   ArchiveSource          330   UserPico.psm
   EnableArchive          337   UserPico.psm
   DisableArchive         33C   UserPico.psm
   getnextscratchchar     345   UserPico.psm
   getnextvalue           34A   UserPico.psm
   CheckUartRx            351   UserPico.psm
   Send2UartTX            355   UserPico.psm
   Byte2UART              35B   UserPico.psm
   SendCRLF               360   UserPico.psm
 * SendSPACE              365   UserPico.psm
   delay_1s               368   UserPico.psm
   wait_1s                36A   UserPico.psm
 * delay_300ms            372   UserPico.psm
 * delay_200ms            373   UserPico.psm
   delay_100ms            376   UserPico.psm
   wait_100ms             377   UserPico.psm
   delay_1ms              37B   UserPico.psm
   wait_1ms               37D   UserPico.psm
   delay_50us             385   UserPico.psm
   wait_50us              386   UserPico.psm
   delay_1us              38A   UserPico.psm
   wait_1us               38B   UserPico.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            134
 STAR              -

 AND              44
 OR               17
 XOR               -

 ADD              21
 ADDCY             4
 SUB               9
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          88
 COMPARECY         -

 SL0               6
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               5
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT            23
 OUTPUT           90
 OUTPUTK           -

 STORE            41
 FETCH            41

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP            120
 JUMP@             -
 CALL            206
 CALL@             -
 RETURN           61
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
