KCPSM6 Assembler log file for program 'Z:\home\graham\Dropbox\N3workingG\TE0722Rebuild\N3SysGen\UserPico.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 06 Dec 2016
Assembly timestamp: 19:36:32

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 329 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 810
Memory locations available: 3286


Assembly listing

 Addr Code                         Instruction

 000                               ;GV09 changed terminator caracter to LF rather than CR
 000                               ;GV08 lower audio volume control to about 0.8V (Prod7)
 000                               ;GV07 correct incorrect data archive and demod peak display problem (MSB/LSB mixup!)
 000                               ;GV06 Increase output amplitude of SSB in DSPpico on TX
 000                               ;GV05 Modified frequencies (MMCM and KeypadPico values) to work with 33.333MHz clock for production model (Apr 2012)
 000                               ;GV04 Now using mic preamp so need to fix AGCs
 000                               ;GV03 Mods to DSP to try and get volume load and saturate OutAmp properly
 000                               ;GV02 Halved AGC thresholds to avoid clipping SysGen v1.18
 000                               ;GV01 add redirect command SW for UART to patch through to BT module
 000                               ;GV01 Reduce Speaker volume AGC on startup
 000                               ;GV00 Reset GV to 0 for new TE0722 working version
 000                               ;GVA5 for TE0722, with RX/TX frequencies adjusted for 32.768MHz
 000                               ;GVA4 corrected DSPprog to not crash (AGC suddenly dropping)
 000                               ;GVA2 send demod level to LCD display
 000                               ;GVA0 Add temporary measures around line 510 to transmit values from DSPpico (of tone demod levels as ascii characters on to the LCD)
 000                               ;GV9A, correct Earth Loop setting incorrect and make immediate.
 000                               ; GV99 corrected Attenuator not adding 30 on level display in TX mode, add turn on pad and entenna select
 000                               ; GV98 More BT mic boost
 000                               ; GV97 corrected BT combination
 000                               ; GV96 drop ADC gain RX to 70% and TX to 50%
 000                               ; GV95 Frequency now set from keypad pico
 000                               ; GV94  24 Feb 2015 Pete  -  re-enable BT commands and add scratchpad clear
 000                               ; GV93 add code in KP pico and firmware to display ADC and demod level
 000                               ; GV92 add Pete's new BTcode with shorter inquiry time - but hadn't put in the script at the end of model propertes to get the correct mem files from Pete
 000                               ; line407 disable loran blank for 31kHz
 000                               ; GV91 increased ADC level 10dB by increasing RXAGClevel
 000                               ; GV90 Version to run at 31.008kHz so use 1323 ($52B) for TX and 10925 ($2AAD) for RX
 000                               ; GV51 Use DSP 51 to only attenuate on receive (which had clipping - but transmit was OK)
 000                               ; GV50 Adjusted DSP AGC back down as there was still clipping
 000                               ; GV4F Adjusted AGC thresholds in SP3E and DSPprogN3GV47 to improve clarity of speech
 000                               ; GV4D PMOD2 now used to control extra attenuation (~30dB)
 000                               ; GV4C back to TX_LOW but PMOD1 held low
 000                               ; GV4B For proto D with TX_high  output instead of TX_LOW
 000                               ; GV4A For ProtoD with new keypad
 000                               ; GV48 changed CheckADClevel routine - but still need to change display (KP pico code) to display signal level and gain value. No Beacon
 000                               ; GV46 BT present cuts audio - modified BT detect logic
 000                               ; GV45 Corrected resetting of AveSignalMSB to middle value so as to avoid double jump and increased allowable rang to avoid unnecessary jumps
 000                               ; GV44 Add SU command to set UART output streaming
 000                               ; GV43 Correct beacon phase wander in DSP pico code
 000                               ; GV42 As 41 but with UART testing bits removed
 000                               ; GV41 send DSP data to UART in normal loop and streaming loop
 000                               ; GV40 correct streaming mode bits and shift beacon mode check to end of loop
 000                               ; GV3F  Add UART streaming command for transmit - SS<xx> where xx is hex value of number of bits to shift the values Add GL command to get Loran blank rate
 000                               ; GV3E some work on AGCcounter to include sinewave addition, but mainly add command GS to get AveSignalMSB
 000                               ; GV3D change the way the AGC works in the DSP pico to speed up increasing attenuation if the signal is very strong
 000                               ; GV3C change pincode in BTText to 1234 for HFP profile
 000                               ; GV3A send prompt to DSPcore to grab AGCvalue and store just before the EOT warble + store ADCgain (lower 4 bits) for TX and RX modes (that will be used by CALL SetAnGain )
 000                               ; GV39 Includes Pete's BT code and new DSP AGC stuff (from GV38)
 000                               ; GV36 reduce initial ADC gain on tranmit (reduce mic gain)
 000                               ; GV35 Uses nw I_Q demodulator
 000                               ; GV33 Add delay to audio stream (reduce fdbk?) and use phase incrementing on TX.
 000                               ; GV32 Adjust AGCs
 000                               ; GV31 Now starting to use LPF in DSPprogN3WithLPF and has SL command to set Loran Blanking (SL01)
 000                               ; GV30 reduce RX ADC gain and increase TX (mic) gain.
 000                               ; GV27 Default Loran Blanking on
 000                               ; GV26 for N2 with Higher gain on DSP RF output and shorter beacon period
 000                               ; GV24 for N2
 000                               ; GV23 Corrected some of the RAM block writing issues
 000                               ; GV22 Correct loop not completing when no character! Now displays ADC gain setting on
 000                               ; GV21 use with keypad prog to inhibit pad scan and here send adc level info (should auto gain on ADC to keep between 30 and 100 ie ~$20 and ~$60)
 000                               ; GV20 Corrected non switching of ADC input to MIC!
 000                               ; GV1F Normal orientation of ADC inputs with auto BT audio switching
 000                               ; GV1E temporarily switch ADC input channel as op amp blown!
 000                               ; GV1D Heyphone but for prototype 2 (using TX_HIGH!!)
 000                               ; GV1C For HeyPhone
 000                               ; GV1A Correct flash writing errors to point to right memory address
 000                               ; GV1A
 000                               ; GV19 corrected phase interpretation of SSB encoding
 000                               ; GV18 Try dirac input
 000                               ; GV17 Add STT command to send test sinewave for transmit - Now removed March 2012
 000                               ; GV16 Worked on Beacon lockup, now starts with beacon, press button for ~6secs
 000                               ; GV14 try beacon again at startup
 000                               ; GV15 try to fix not stopping beacon issue (don't start with beacon!) - display mode value on LCD (send to KPpico)
 000                               ; GV13 no beacon
 000                               ; GV11 fix beacon mode so that DSP is blocked at frequency offset and fixed amp for ~1s when ending TX mode - also set Beacon mode on power up which stops when button pressed
 000                               ; Set ADC gain in initialisation properly to calibrate aswell.
 000                               ; GV10 Add ADC signal level monitoring and try phase SSB encoding again with 2x phase to SSB module
 000                               ; Command GL in version GV10 allows the signal level to be returned from the ADC
 000                               ; GV0F Use phase encoding
 000                               ; GV0E full 16 bit frequency coding of TX 29/8/11
 000                               ; GV0D With Beacon
 000                               ; GV0C add BT mic input
 000                               ; GV09 stopped sending r/T t seria; port an adjusted reading from KPfifo
 000                               ; GV08 Added facility to switch RX/TX from keypad
 000                               ; GV07  Increased sensitivity of touch pads June 11
 000                               ; May 26- try and modify so that it starts correctly when powerred up with user program
 000                               ; MayA 11 use PMOD 2 to switch serial port and activate keypad
 000                               ; May 11, add SAO command to set audio channel (00, for BT, 01 for radio transceiver)
 000                               ; March 2011 testing SPI interface:
 000                               ; commands
 000                               ; WREN $06 (enable writing)
 000                               ; WRDI $04 (disable writing)
 000                               ; FAST_READ $0B followed by 3 address bytes, 1 dummy byte and then n bytes to feed back data and leave last 2 values for readback
 000                               ; BERASE  $C7 (bulk erase) - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                               ; SE     $D8 (sector erase) followed by 3 address bytes, - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                               ; PP     $02 (page program) followed by 3 address bytes,  then n bytes of data to be written (need then to pulse Send2Flash by writing 16 to ProgramM)
 000                               ;
 000                               ; Example commands:
 000                               ; SMW0102030405060708090A     -writes values 1-10 to flash addresses from 800000
 000                               ; SMR800002 should read the bytes 03 and 02 ??
 000                               ; Now for Godil Board
 000                               ; Version for multi pico boot with shifted bit offsets on oport
 000                               CONSTANT Versionno, 09               ; Dec 2016
 000                               CONSTANT InitialVolume, 133'd        ;lowerred volume
 000                               CONSTANT MinorVersionno, EE          ; Pete
 000                               ; CONSTANT TXType,       7E                 ; $7E for N2 and $80 for Heyphone
 000                               ; CONSTANT RXType,       46                 ; $46 for N2 and 55 for Heyphone)
 000                               CONSTANT Bmode, 00
 000                               ; Set thresholds for AGC
 000                               CONSTANT AGCupperRX, 32              ; Increased factor 2 on RX and TX with signal level monitor - increased RX 3 again from $18 (24 to 72, ie $48)
 000                               CONSTANT AGClowerRX, 12              ; was $0C, increased to 36=$24
 000                               CONSTANT AGCupperTX, 10
 000                               CONSTANT AGClowerTX, 06
 000                               ; SAI Set analogue input SAI<xx>  xx=00 or 01
 000                               ; SAO Set audio Output source
 000                               ; SAS Set archive source SAS<xx>
 000                               ; SAG Set analogue gain SAG<xx>
 000                               ; SB set beacon mode
 000                               ; SRM set receive mode
 000                               ; SRF set receive frequency
 000                               ; STM set transmit mode
 000                               ; STF set transmit frequency
 000                               ; SAG   Set analogue gain, use: 51-5E + automatic calibration
 000                               ; SAS <value> - set archive source (0 or 1)
 000                               ; GA get archive
 000                               ; GT get status of touch
 000                               ; GV get version
 000                               ; GP get response from DSP
 000                               ; GB get response from BT
 000                               ; GKT get touch response from KP
 000                               ; March 2009, now using loading over BT, implement server commands
 000                               ; Dec 2008 - implementing on SSBN3.mdl
 000                               ; Test Spartan 3e board May 2007
 000                               ; Program for user interface: Pico 1
 000                               ; Load SP3E with bit file - spartan3e_adcrx_tx_cw.bit using USB download cable (+ImpacT)
 000                               ; Connect serial lead and send file for test program from Matlab using somethng like
 000                               ; LCDtestprog=getpblazidefile('LCDUartS3e.mem');
 000                               ; Send6bitInstructionsPico1
 000                               ;
 000                               ; Addresses of latched data
 000                               ; 0 Cmd Control Pico2
 000                               ; 1 UartTx
 000                               ; 2 Gain ChA (bits 0-2)
 000                               ; Gain ChB(bits 4-6)
 000                               ; 3 Instruction first 6bits (MSB)
 000                               ; 4 Instruction 2nd 6 bits
 000                               ; 5 Instruction 3rd 6 bits
 000                               ; 6 Program Address LSB
 000                               ; 7 Program Address upper 2 bits
 000                               ;  bit 2,3 and 4 decoded to either Write ROM1,Write ROM2,Write ROM3,Write ROM4 or reset picos
 000                               ;  bit 5-Enable archive
 000                               ;  bit 6-Select archive source
 000                               ;  bit 7 TX_HIGH
 000                               ; 10 Set_RXFreq LSbyte
 000                               ; 11 Set_RXFreq USbyte
 000                               ; 12 Set_TXFreq LSbyte
 000                               ; 13 Set_TXFreq USbyte
 000                               ; 14 Message character 1 -***Note these data ports are for writing characters at the address bus to the message RAM!!
 000                               ; 15 Message character 2
 000                               ; 16 Message character 3 - RAM is written on write to this port (last 6 bit character)
 000                               ; 17 Relay ctrl
 000                               ; 18 Battery monitor
 000                               CONSTANT delay_1us_constant, 12'd    ; Now 49.152MHz Value (13)19 or 12? decimal suitable for 50MHz clock or about 6 for 33MHz?
 000                               CONSTANT WREN, 06                    ; (enable writing)
 000                               CONSTANT FAST_READ, 0B               ; followed by 3 address bytes, 1 dummy byte and then n bytes to feed back data and leave last 2 values for readback
 000                               CONSTANT BERASE, C7                  ; (bulk erase) - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                               CONSTANT SER, D8                     ; (sector erase) followed by 3 address bytes, - note need to set all bits to 1 before writing!!!!!!!!!!!!!
 000                               CONSTANT RDID, 9F
 000                               CONSTANT PP, 02                      ; (page program) followed by 3 address bytes,  then n bytes of data to be written (need then to pulse Send2Flash by writing 16 to CMD2DSP)
 000                               CONSTANT RDSR, 05
 000                               ; Registers
 000                               ;counter             EQU       sC                  ; Counter - for Acquisitions
 000                               ;ScratchPointer      EQU       sB                  ; pointer for decoding command in scratch memory
 000                               NAMEREG sC, counter                  ; Counter - for Acquisitions
 000                               NAMEREG sB, ScratchPointer           ; pointer for decoding command in scratch memory
 000                               ; Scratch pad
 000                               ; Locations 0-15 reserved for incoming command
 000                               CONSTANT Latch7, 16'd                ; This is the current value of an output control register (ProgramM) - used to control writing etc.
 000                               CONSTANT LastDSPbyte, 17'd
 000                               CONSTANT Mode, 18'd                  ; N3 status: bit 0 Beacon mode, bit 1 RX/TX mode, bit 2 Uart streaming mode (TX), bit 3 RX to UART streaming, bit 4 to set loop antenna input
 000                               CONSTANT ADCstate, 19'd              ; saves ADC state
 000                               CONSTANT SelectScratch, 20'd         ; used to store selections (archive source etc.)
 000                               CONSTANT ADCLevel, 21'd
 000                               CONSTANT ADCgain, 22'd               ; 0 means no output, 0E is max gain of 128. Upper 4 bits contain ADC config data
 000                               CONSTANT TX_F_MSB, 23'd              ; Store TX req (16 bits)
 000                               CONSTANT TX_F_LSB, 24'd
 000                               CONSTANT ADCAGCUpperThreshold, 25'd  ; Sets value for AGC on RAW input
 000                               CONSTANT ADCAGCLowerThreshold, 26'd  ; Sets value for AGC on RAW input
 000                               CONSTANT ADCGainTX, 27'd             ; Analogue gain for TX
 000                               CONSTANT ADCGainRX, 28'd             ; Analogue gain for RX
 000                               ;removed Attenuator state
 000                               CONSTANT BluetoothXmit, 43           ; from Pete's build - assumes large scratchpad
 000                               ; Input port
 000                               CONSTANT Uart_rx, 00
 000                               CONSTANT Uart_status, 01             ; Uart RX data bit0, Uart TX half full bit 1
 000                               ; bits 2:
 000                               ; Bit 2 BattMon comparator
 000                               ; Offsets:
 000                               CONSTANT BattMon, 4'd
 000                               CONSTANT ArchiveDataLSB, 2'd
 000                               CONSTANT ArchiveDataMSB, 3'd
 000                               CONSTANT DSPcmd, 4'd                 ; message from DSP unit
 000                               CONSTANT BTcmd, 5'd                  ; message from BT unit
 000                               CONSTANT KPcmd, 6'd                  ; message from KeyPad unit
 000                               CONSTANT TDcmd, 7'd                  ; message from Tone detect
 000                               ;CONSTANT DataReadback_1,  8'd                   ; message from KeyPad unit TEMP - DataReadback_1 from Flash
 000                               CONSTANT DSPRAMrdbkMSB, 9'd
 000                               CONSTANT DSPRAMrdbkLSB, 10'd
 000                               CONSTANT BTRAMrdbkMSB, 11'd
 000                               CONSTANT BTRAMrdbkLSB, 12'd
 000                               CONSTANT KPRAMrdbkMSB, 13'd
 000                               CONSTANT KPRAMrdbkLSB, 14'd
 000                               CONSTANT ADCSignalLevel, 15'd
 000                               ; Output ports
 000                               CONSTANT CMD2DSP, 00                 ; ALSO USED for data to write to SPI flash (sends write automatically)
 000                               CONSTANT UART_TX, 01
 000                               CONSTANT GainPD, 02                  ; Lower 4 bits: 1=0 gain to E=gain 128, bits 4-6 should be 101 and bit 7 is for calibration
 000                               ; Lower 4 bits gain, bits 4-6 for PD0-2 - PD bits should be set to 0101 (ie 5 hex) to enable everything
 000                               CONSTANT Instructiona, 03
 000                               CONSTANT Instructionb, 04
 000                               CONSTANT Instructionc, 05
 000                               CONSTANT ProgramL, 06
 000                               CONSTANT ProgramM, 07
 000                               ; bits 0 and 1 for address, subsequent 4 bits to select which pico to write (bits 2,3,4,5 decoded) - these 3 bits are decoded such that:
 000                               ; if bits 2:5 represent:
 000                               ; 1 - Write Inst1 (User pico instruction) - ie MSB of address should be ORed with 4.
 000                               ; 2 - Write Inst2 (DSP pico instruction) - ie MSB of address should be ORed with 8.
 000                               ; 3 - Write Inst3 (BT pico instruction) - ie MSB of address should be ORed with $0C.
 000                               ; 4 - Write Inst4 (KP pico instruction)
 000                               ; 5 - Write DSP RAM
 000                               ; 6 - Write BT RAM
 000                               ; 7 - Reset other picos
 000                               ; 8 - Write KP RAM
 000                               ; 9 - Send Flash fifo contents (written to on FlashDATA port) to FLASH chip
 000                               ; bit 6 enable archive, and bit 7 TXhigh
 000                               ;
 000                               CONSTANT EnArchive, 64'd
 000                               CONSTANT TX_HIGH, 128'd              ; bit 7
 000                               CONSTANT SelectArchiveSource, 8'd
 000                               CONSTANT Configure, 9'd
 000                               CONSTANT RXFreqMSB, 10'd             ; 769A for 88.956kHz ie 86.956kHz carrier and allow range up to 154kHz
 000                               CONSTANT RXFreqLSB, 11'd
 000                               CONSTANT AudioVolume, 12'd           ; Initialy 141
 000                               CONSTANT Tone, 13'd                  ; Carrier increment to cause a tone modulation on TX
 000                               CONSTANT Acknowledge, 14'd
 000                               ; offsets:
 000                               CONSTANT DSPFifo, 16'd
 000                               CONSTANT BTFifo, 32'd
 000                               CONSTANT KPFifo, 64'd
 000                               CONSTANT TDFifo, 128'd
 000                               ; Set bit 4,5,6,7 to acknowledge FIFO of DSP,BT, Keypad, Tone Detect (ie write 16,32, 64 or 128)
 000                               CONSTANT FlashData, 17'd
 000                               ; CONSTANT BatteryMon,   18'd
 000                               CONSTANT ADCstate_port, 19'd         ; Lower 5 bits are not used, bit 6 indictes which ADC channel is read
 000                               ; offset of port 19
 000                               CONSTANT LoranBlank, 16'd            ; $10
 000                               CONSTANT AudioOutSelect, 32'd
 000                               CONSTANT AnalogueChannel, 64'd       ; bit 6
 000                               CONSTANT CMD2BT, 20'd
 000                               CONSTANT CMD2KP, 21'd
 000                               CONSTANT RAMDataMSB, 22'd            ; To send to KP, DSP or BT picos
 000                               CONSTANT RAMDataLSB, 23'd            ; To send to KP, DSP or BT picos
 000                               CONSTANT RAMwriteControl, 25'd
 000                               ; ;; Pete - Bluetooth
 000                               CONSTANT TRANSMIT_ON, 14             ; BT -> User
 000                               CONSTANT TRANSMIT_OFF, 15            ; BT -> User
 000                               ;GenerateCode        MEM       "S3eUser_interface.mem"
 000                               ; Start of test program Must send $40,$50 over serial port to initiate if not re-programming!
 000  22021                  boot: JUMP 021[cold_start]
 001  2001B                reboot: CALL 01B[GetByte]
 002  1D140                        COMPARE s1, 40[64'd]                 ; do we have for start byte (64 )
 003  32007                        JUMP Z, 007[DoUserProg]
 004  1D141                        COMPARE s1, 41[65'd]
 005  3E022                        JUMP NC, 022[ProgDSP]                ; This will actually write DSP or other prog (start byte =65 or greater) aargh 27/8/10 - was JUMP Z....
 006  22001                        JUMP 001[reboot]
 007  01704            DoUserProg: LOAD s7, 04
 008  01220                        LOAD s2, 20[32'd]
 009  01300                        LOAD s3, 00                          ; s2 (LSB),s3(USB) of prog counter of first address of new program!
 00A  2001B               GetProg: CALL 01B[GetByte]
 00B  1D150                        COMPARE s1, 50[80'd]                 ; 80 ($50) indicates end of program
 00C  32021                        JUMP Z, 021[cold_start]              ; When end of prog byte 80 is received
 00D  2D103                        OUTPUT s1, 03[Instructiona]
 00E  2001B                        CALL 01B[GetByte]
 00F  2D104                        OUTPUT s1, 04[Instructionb]
 010  2001B                        CALL 01B[GetByte]
 011  2D105                        OUTPUT s1, 05[Instructionc]          ; write 3x 6bits to latches ready for instruction write
 012  2D206                        OUTPUT s2, 06[ProgramL]
 013  2D307                        OUTPUT s3, 07[ProgramM]              ; Load memory address to write (starting from 32!)
 014  00470                        LOAD s4, s7                          ; Set bit 2 to perform write to RAM 1 or bit 3 to write RAM 2 depending whether start byte was 64 or 65
 015  2D419                        OUTPUT s4, 19[RAMwriteControl]
 016  01400                        LOAD s4, 00
 017  2D419                        OUTPUT s4, 19[RAMwriteControl]       ; Set write line back to zero
 018  11201                        ADD s2, 01
 019  13300                        ADDCY s3, 00                         ; Increment program counter
 01A  2200A                        JUMP 00A[GetProg]                    ; Get next instruction
 01B  09001               GetByte: INPUT s0, 01[Uart_status]            ; Is there a byte available?
 01C  03001                        AND s0, 01
 01D  1D001                        COMPARE s0, 01
 01E  3601B                        JUMP NZ, 01B[GetByte]                ; until there is a byte in the input buffer!
 01F  09100                        INPUT s1, 00[Uart_rx]
 020  25000                        RETURN 
 021  01000            cold_start: LOAD s0, 00                          ; Note the label 'ProgDSP' is only to allow re-boot to work!
 022                      ProgDSP: 
 022                               ; need to clear scratchpad
 022  01100                        LOAD s1, 00
 023                 ScratchClear: 
 023  2E010                        STORE s0, (s1)                       ; zero location
 024  11101                        ADD s1, 01                           ; next
 025  1D100                        COMPARE s1, 00                       ; do all 256 bytes
 026  36023                        JUMP NZ, 023[ScratchClear]           ;
 027  01B00                  init: LOAD sB[ScratchPointer], 00
 028  01000                        LOAD s0, 00
 029  2F010                        STORE s0, 10[Latch7]                 ; initialise latch 7 bits!
 02A  01553                        LOAD s5, 53                          ; gain to lowish
 02B  2F516                        STORE s5, 16[ADCgain]                ; save initial value
 02C  2F51C                        STORE s5, 1C[ADCGainRX]              ; save initial value for RX
 02D  200EA                        CALL 0EA[SetAnGain]                  ; set gain and calibrate
 02E  01559                        LOAD s5, 59                          ; gain to lowish
 02F  2F51B                        STORE s5, 1B[ADCGainTX]              ; save initial value forTX
 030                               ;Frequency of TX/RX now set by keypad pico
 030  01032                        LOAD s0, 32[AGCupperRX]
 031  2F019                        STORE s0, 19[ADCAGCUpperThreshold]
 032  01012                        LOAD s0, 12[AGClowerRX]
 033  2F01A                        STORE s0, 1A[ADCAGCLowerThreshold]
 034  201A6                        CALL 1A6[RX]                         ; set receive mode
 035  01100                        LOAD s1, 00
 036  202CC                        CALL 2CC[ArchiveSource]
 037  202D3                        CALL 2D3[EnableArchive]
 038  01085                        LOAD s0, 85[InitialVolume]           ;set lowish audio volume
 039  2D00C                        OUTPUT s0, 0C[AudioVolume]
 03A  20312                        CALL 312[delay_100ms]
 03B  01020                        LOAD s0, 20[AudioOutSelect]          ; + 16; normal ADC channel, AudioOUtSelect doesn't do anything here! The 16also sets Loran Blanking if in firmware.
 03C  2F013                        STORE s0, 13[ADCstate]               ; save
 03D  2D013                        OUTPUT s0, 13[ADCstate_port]         ; Also sets analogue input to 0
 03E  2005D                  loop: CALL 05D[CheckADClevel]
 03F  0B012                        FETCH s0, 12[Mode]
 040  03004                        AND s0, 04                           ; look at streaming bit
 041  1D004                        COMPARE s0, 04
 042  32162                        JUMP Z, 162[isSSloop]                ; if streaming TX mode, then send a Uart character and return (but will not be able to interpret any command so is stuck!)
 043  0B012                        FETCH s0, 12[Mode]
 044  03008                        AND s0, 08                           ; look at streaming RX bit
 045  1D008                        COMPARE s0, 08
 046  30267                        CALL Z, 267[Check4CmdfromDSP]        ; If fifo character then send to terminal !!!!!!!!!!!!!!!!!!!! reinstate this 9/7/2013
 047  30276                        CALL Z, 276[Check4CmdfromTD]         ; If fifo character then send to terminal
 048  20271                        CALL 271[Check4CmdfromKP]
 049  1D680                        COMPARE s6, 80[128'd]
 04A  3809B                        CALL C, 09B[checkrqst]
 04B                               ; Re-enable Beacon mode
 04B  0B012                        FETCH s0, 12[Mode]
 04C                               ;      OUTPUT    s0,CMD2KP      ;send value to LCD for display - send adc level data instead
 04C  03001                        AND s0, 01                           ; only interrested in bit0
 04D  1D001                        COMPARE s0, 01                       ; Is it beacon mode?
 04E  3021C                        CALL Z, 21C[BeaconBeep]
 04F                               ; Pete  enabled 24 Feb 2015 - inhibit in tonedetect
 04F                               ;                    CALL      Check4CmdfromBT     ; receive from BT and echo to terminal
 04F                               ;                    JUMP      C, HandleBTCommand  ; If less than 128 there is a value to give back and display.
 04F         HandleBTCommand_Done: 
 04F                               ; pete end
 04F  2024D                        CALL 24D[getUARTchar]
 050  1D620                        COMPARE s6, 20[32'd]
 051  3203E                        JUMP Z, 03E[loop]                    ; If a space then skip
 052                               ; Had mistankenly changed the next line!
 052  1D6FF                        COMPARE s6, FF
 053  3203E                        JUMP Z, 03E[loop]                    ; If no character then skip-MAKE SURE ANYTHINGTO BE PERFORMED REGULARLY IS DONE BEFORE THIS POINT
 054  1D60A                        COMPARE s6, 0A[10'd]
 055  320F5                        JUMP Z, 0F5[interpcommand]           ; This is end of command character (LF now! as of Dec 2016)
 056  1D60D                        COMPARE s6, 0D[13'd]
 057  3203E                        JUMP Z, 03E[loop]                    ; If CR ignore
 058  1DB10                        COMPARE sB[ScratchPointer], 10[16'd] ; Check we are not writing too many characters to the scratchpad
 059  3E03E                        JUMP NC, 03E[loop]                   ; don't write to scratch if Pointer (counter) 16 or above
 05A  2E6B0                        STORE s6, (sB[ScratchPointer])       ; Save command character
 05B  11B01                        ADD sB[ScratchPointer], 01           ; is a command char so increment
 05C  2203E                        JUMP 03E[loop]
 05D  0900F         CheckADClevel: INPUT s0, 0F[ADCSignalLevel]
 05E  0B115                        FETCH s1, 15[ADCLevel]
 05F  1C010                        COMPARE s0, s1
 060  31000                        RETURN Z                             ; return if the value is still the same (ie wait for new value)
 061                               ;__________________________________________________
 061                               ;TEMPORARY SKIP to TEMPskip:  (values will be redirected directly from DSP to KP in
 061                               ;      JUMP  Tempskip NOTnow 19 sep 2015
 061                               ;____________________________________________________
 061  0117F                        LOAD s1, 7F                          ; Note top bit is not received! Send command to expect signal level
 062  2D115                        OUTPUT s1, 15[CMD2KP]                ; send ADCgain value to LCD for display
 063  2F015                        STORE s0, 15[ADCLevel]               ; save new value of ADClevel
 064                               ; Code to send a value for display as 2 decimal digits in the range 00 to 74 (~42dB) representing the broad band signal strength (5 units per gain step, 1 unit per 8 units of ADC level
 064                               ; assuming ADClevel kept betweeen $18 and $40, signal level within range covers ~8dB, display about 1.7 x value in dB in steps of 2 (~1.2dB)
 064  0B116                        FETCH s1, 16[ADCgain]
 065  0310F                        AND s1, 0F                           ; Gain level just in lower 4 bits
 066  0120E                        LOAD s2, 0E
 067  18210                        SUB s2, s1                           ; Invert gain level to signal level ie highest gain of $E becomes zero
 068  01100                        LOAD s1, 00                          ; use this as counter for lower decimal digit
 069  1420E                        SR0 s2                               ; half the value and send half to the carry flag (to add 5)
 06A  3E06C                        JUMP NC, 06C[nofive]                 ; only add 5 to lower digit if carry set
 06B  01105                        LOAD s1, 05[5'd]
 06C  1D010                nofive: COMPARE s0, 10[16'd]                 ; skip if below first step (about 1.2dB)
 06D  3A06F                        JUMP C, 06F[First]
 06E  11102                        ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 06F  1D012                 First: COMPARE s0, 12[18'd]                 ; skip if below second step (about 1.2dB)
 070  3A072                        JUMP C, 072[Second]
 071  11102                        ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 072  1D015                Second: COMPARE s0, 15[21'd]                 ; skip if below third step (about 1.2dB)
 073  3A075                        JUMP C, 075[Third]
 074  11102                        ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 075  1D018                 Third: COMPARE s0, 18[24'd]                 ; skip if below
 076  3A078                        JUMP C, 078[Fourth]
 077  11102                        ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 078  1D01C                Fourth: COMPARE s0, 1C[28'd]                 ; skip if below
 079  3A07B                        JUMP C, 07B[Fifth]
 07A  11102                        ADD s1, 02[2'd]                      ; add 2 units (~1.2dB)
 07B                               ; now check if s1 (lower decimal digit) is above 9
 07B  1D10A                 Fifth: COMPARE s1, 0A[10'd]
 07C  3A07F                        JUMP C, 07F[ToLCD]
 07D  11201                        ADD s2, 01[1'd]                      ; Add 1 to first decimal digit
 07E  1910A                        SUB s1, 0A[10'd]                     ; subtract 10 from lower digit
 07F                               ;Deleted part that tried to apply attenuator
 07F  2D215                 ToLCD: OUTPUT s2, 15[CMD2KP]                ; Send first decimal digit (as binary value 0-7)
 080  2D115                        OUTPUT s1, 15[CMD2KP]                ; send second decimal digit (as binary value for 0-9)
 081                               ; s0 should hoperfully still have ADCsignal level!
 081                               ;_______________________________
 081                               ;Temp bit
 081                     Tempskip: 
 081                               ;_____________________________________
 081                               ; LOAD      s5, s0
 081                               ;      CALL      Byte2UART    ;and echo to UART  - not now!
 081  0B119                        FETCH s1, 19[ADCAGCUpperThreshold]
 082  0B015                        FETCH s0, 15[ADCLevel]               ; had lost the s0 value at this point!
 083  1C010                        COMPARE s0, s1                       ; aim to keep value around $15? - need to drop this further! Needs to be lower for transmission??
 084  3C089                        CALL NC, 089[ReduceADCgain]
 085  0B11A                        FETCH s1, 1A[ADCAGCLowerThreshold]
 086  1C010                        COMPARE s0, s1                       ; aim to keep value around $15? -
 087  38092                        CALL C, 092[IncreaseADCgain]
 088  25000                        RETURN 
 089  0B016         ReduceADCgain: FETCH s0, 16[ADCgain]
 08A  00100                        LOAD s1, s0
 08B  0310F                        AND s1, 0F                           ; mask lower 4 bits
 08C  1D101                        COMPARE s1, 01                       ; don't drop to zero!
 08D  31000                        RETURN Z
 08E  19001                        SUB s0, 01[1'd]
 08F  2F016                        STORE s0, 16[ADCgain]
 090  2D002                        OUTPUT s0, 02[GainPD]                ; set ADC pre-amp
 091                               ; OUTPUT       s0, CMD2KP          ; send value to LCD for display - don't bother
 091  25000                        RETURN 
 092  0B016       IncreaseADCgain: FETCH s0, 16[ADCgain]
 093  00100                        LOAD s1, s0
 094  0310F                        AND s1, 0F                           ; mask lower 4 bits
 095  1D10E                        COMPARE s1, 0E                       ; don't go past $0E!
 096  31000                        RETURN Z
 097  11001                        ADD s0, 01[1'd]
 098  2F016                        STORE s0, 16[ADCgain]
 099  2D002                        OUTPUT s0, 02[GainPD]                ; set ADC pre-amp
 09A                               ; OUTPUT       s0, CMD2KP          ; send value to LCD for display
 09A  25000                        RETURN 
 09B                               ;Delete setting and resetting Attenuator (March 2016)
 09B  1D672             checkrqst: COMPARE s6, 72["r"]                  ;character_r
 09C  300AE                        CALL Z, 0AE[checkRXmode]
 09D  1D674                        COMPARE s6, 74["t"]                  ;character_t
 09E  300B7                        CALL Z, 0B7[checkTXmode]
 09F  1D665                        COMPARE s6, 65["e"]                  ;character_e
 0A0  300A4                        CALL Z, 0A4[setEarthAntennas]
 0A1  1D66C                        COMPARE s6, 6C["l"]                  ; character_l
 0A2  300A9                        CALL Z, 0A9[setLoopAntennas]
 0A3  25000                        RETURN 
 0A4  0B012      setEarthAntennas: FETCH s0, 12[Mode]
 0A5  030EF                        AND s0, EF[239'd]                    ; 255-16  ;reset bit 4
 0A6  2F012                        STORE s0, 12[Mode]
 0A7  200BD                        CALL 0BD[setRXmode]                  ;Make active and return to RX
 0A8  25000                        RETURN 
 0A9  0B012       setLoopAntennas: FETCH s0, 12[Mode]
 0AA  05010                        OR s0, 10[16'd]                      ;set bit 4
 0AB  2F012                        STORE s0, 12[Mode]
 0AC  200BD                        CALL 0BD[setRXmode]
 0AD  25000                        RETURN 
 0AE                  checkRXmode: 
 0AE                               ; ;; Pete added for Bluetooth (temp)
 0AE  0B043                        FETCH s0, 43[BluetoothXmit]
 0AF  11000                        ADD s0, 00
 0B0  35000                        RETURN NZ                            ; do nothing if BT transmitting
 0B1                               ; ;; end Pete added for BT
 0B1  0B012                        FETCH s0, 12[Mode]
 0B2  03002                        AND s0, 02                           ; mask bit 1
 0B3  1D002                        COMPARE s0, 02                       ; is it set ie currently in TX mode?
 0B4  35000                        RETURN NZ                            ; return if already in RX mode return
 0B5  200BD                        CALL 0BD[setRXmode]                  ; so go ahead and set up RX mode
 0B6  25000                        RETURN 
 0B7  0B012           checkTXmode: FETCH s0, 12[Mode]
 0B8  03002                        AND s0, 02                           ; mask bit 1 here 2 means TX mode 0 RX mode
 0B9  1D000                        COMPARE s0, 00                       ; is it not set ie currently in RX mode?
 0BA  35000                        RETURN NZ                            ; return if already in TX mode
 0BB  200D7                        CALL 0D7[setTXmode]                  ; so go ahead and set up TX mode
 0BC  25000                        RETURN 
 0BD                               ; need to set scratch pad mode, set RX freq to 86.95 (SRF769A or for 87kHz need 76AB), input channel with equivalent of SAI00 and send receive mode command to DSP, set analog gain to 8
 0BD  01532             setRXmode: LOAD s5, 32[50'd]                    ; Ascii code for '2' - DSP to grap the AGCvalue before the warble
 0BE  2D500                        OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 0BF  0B516                        FETCH s5, 16[ADCgain]                ; gain used during TX mode
 0C0  2F51B                        STORE s5, 1B[ADCGainTX]              ; Save for next TX mode
 0C1  2020B                        CALL 20B[Warble]                     ; send warble beep before returning!
 0C2  0B012                        FETCH s0, 12[Mode]
 0C3  030FC                        AND s0, FC[252'd]                    ;255 - 3         ; reset TX bit AND becon on bit
 0C4  2F012                        STORE s0, 12[Mode]
 0C5                               ; LOAD      s0, 2A             ; $75 for new demodulator   Don't need this from GV95 as keypad sets the frequency
 0C5                               ; OUTPUT       s0, RXFreqMSB
 0C5                               ; LOAD      s0, AD          ; $ N2 or Heyphone)
 0C5                               ; OUTPUT       s0, RXFreqLSB
 0C5                               ;Set ADC channel depending on whether using loop or earth wires (Mode bit 4 set for loop)
 0C5  0B012                        FETCH s0, 12[Mode]
 0C6  03010                        AND s0, 10[16'd]                     ;antenna input select bit (4)
 0C7  14006                        SL0 s0
 0C8  14006                        SL0 s0                               ;to affect bit 6
 0C9  0B113                        FETCH s1, 13[ADCstate]
 0CA  031BF                        AND s1, BF[191'd]                    ; 255 - 64        ; reset  bit 6
 0CB  04100                        OR s1, s0                            ;now affect bit 6 = Mode bit 4 setting
 0CC  2F113                        STORE s1, 13[ADCstate]               ; save
 0CD  2D113                        OUTPUT s1, 13[ADCstate_port]         ; set port to new ADC channel
 0CE  0B51C                        FETCH s5, 1C[ADCGainRX]              ; gain to last value used for RX
 0CF  2F516                        STORE s5, 16[ADCgain]                ; this value is tracked
 0D0  200EA                        CALL 0EA[SetAnGain]                  ; set analogue gain to moderate
 0D1  01032                        LOAD s0, 32[AGCupperRX]
 0D2  2F019                        STORE s0, 19[ADCAGCUpperThreshold]
 0D3  01012                        LOAD s0, 12[AGClowerRX]
 0D4  2F01A                        STORE s0, 1A[ADCAGCLowerThreshold]
 0D5  201A6                        CALL 1A6[RX]
 0D6  25000                        RETURN 
 0D7                               ; need to set scratch pad mode, set RX freq to 0 (SRF0155), et TX freq to 86.95 STF0E7E, input channel with equivalent of SAI01 and send transmit mode command to DSP
 0D7  0B012             setTXmode: FETCH s0, 12[Mode]
 0D8  05002                        OR s0, 02                            ; set TX bit
 0D9  030FE                        AND s0, FE                           ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 0DA  2F012                        STORE s0, 12[Mode]
 0DB                               ; LOAD      s0, 01      Don't need this is keypad is sorting it!
 0DB                               ; OUTPUT       s0, RXFreqMSB
 0DB                               ; LOAD      s0, 55
 0DB                               ; OUTPUT       s0, RXFreqLSB       ; drop detection to baseband (for when using wired mic)
 0DB  0B013                        FETCH s0, 13[ADCstate]
 0DC  05040                        OR s0, 40[AnalogueChannel]           ; set bit 6 (SAI01) - Channel 1 in Matlab GUI
 0DD  2F013                        STORE s0, 13[ADCstate]               ; save
 0DE  2D013                        OUTPUT s0, 13[ADCstate_port]         ; set port to new ADC channel
 0DF  0B516                        FETCH s5, 16[ADCgain]                ; get gain used for RX
 0E0  2F51C                        STORE s5, 1C[ADCGainRX]              ; this value is tracked
 0E1  0B51B                        FETCH s5, 1B[ADCGainTX]              ; gain to last value used for TX
 0E2  2F516                        STORE s5, 16[ADCgain]                ; and make current ADCgain value
 0E3  200EA                        CALL 0EA[SetAnGain]                  ; set analogue gain to moderate
 0E4  01010                        LOAD s0, 10[AGCupperTX]
 0E5  2F019                        STORE s0, 19[ADCAGCUpperThreshold]
 0E6  01006                        LOAD s0, 06[AGClowerTX]
 0E7  2F01A                        STORE s0, 1A[ADCAGCLowerThreshold]
 0E8  201AF                        CALL 1AF[TX]
 0E9  25000                        RETURN 
 0EA                               ; set gain to 32 or is it 48?, enter with gain value in s5 (ie $DA for transmit)
 0EA  0350F             SetAnGain: AND s5, 0F                           ; only affect lower 4 bits
 0EB  0B016                        FETCH s0, 16[ADCgain]
 0EC  030F0                        AND s0, F0                           ; keep upper bits
 0ED  04500                        OR s5, s0                            ; combine
 0EE  2F516                        STORE s5, 16[ADCgain]                ; save new value (includes all bits)
 0EF  05580                        OR s5, 80                            ; set bit 7 to start calibration
 0F0  2D502                        OUTPUT s5, 02[GainPD]
 0F1  20317                        CALL 317[delay_1ms]                  ; wait for calib
 0F2  0357F                        AND s5, 7F[127'd]                    ; reset bit 7
 0F3  2D502                        OUTPUT s5, 02[GainPD]
 0F4  25000                        RETURN 
 0F5                               ; Now interpret the command in the Scratch buffer and return to init
 0F5  01900         interpcommand: LOAD s9, 00                          ; counter through scratchpad addresses.
 0F6  1C9B0            interploop: COMPARE s9, sB[ScratchPointer]
 0F7  32027                        JUMP Z, 027[init]                    ; break out of loop after reading final character command.
 0F8  202E1                        CALL 2E1[getnextscratchchar]
 0F9  1D053                        COMPARE s0, 53[83'd]                 ; is this a S?
 0FA  32100                        JUMP Z, 100[isS]
 0FB  1D047                        COMPARE s0, 47[71'd]                 ; is this a G?
 0FC  32112                        JUMP Z, 112[isG]
 0FD                               ;      COMPARE      s0, 77'd              ; is this a M?
 0FD                               ; JUMP      Z, isM
 0FD  1D05A                        COMPARE s0, 5A[90'd]                 ; is this a Z?
 0FE  32001                        JUMP Z, 001[reboot]                  ; then go to reboot code (ie to reboot need to send Z<CR>, then do Prog...)
 0FF  220F6                        JUMP 0F6[interploop]
 100  202E1                   isS: CALL 2E1[getnextscratchchar]
 101  1D042                        COMPARE s0, 42[66'd]                 ; is this a B?
 102  3212E                        JUMP Z, 12E[isSB]                    ;
 103  1D041                        COMPARE s0, 41[65'd]                 ; is this a A?
 104  32124                        JUMP Z, 124[isSA]
 105  1D052                        COMPARE s0, 52[82'd]                 ; is this a R?
 106  32174                        JUMP Z, 174[isSR]
 107  1D054                        COMPARE s0, 54[84'd]                 ; is this a T?
 108  3217A                        JUMP Z, 17A[isST]
 109  1D04B                        COMPARE s0, 4B[75'd]                 ; is this a K?
 10A  32135                        JUMP Z, 135[isSK]                    ;
 10B  1D04C                        COMPARE s0, 4C[76'd]                 ; is this a L?
 10C  32139                        JUMP Z, 139[isSL]                    ; Set Loran Blanking
 10D                               ;      COMPARE      s0, 83'd              ; is this a S?
 10D                               ; JUMP      Z, isSS             ;
 10D  1D055                        COMPARE s0, 55[85'd]                 ; is this a U
 10E  3214F                        JUMP Z, 14F[isSU]
 10F  1D057                        COMPARE s0, 57[87'd]                 ; is this a W
 110  32154                        JUMP Z, 154[isSW]
 111  22027                        JUMP 027[init]
 112  202E1                   isG: CALL 2E1[getnextscratchchar]
 113  1D041                        COMPARE s0, 41[65'd]                 ; is this a A?
 114  321F8                        JUMP Z, 1F8[isGA]
 115  1D042                        COMPARE s0, 42[66'd]                 ; is this a B?
 116  321C9                        JUMP Z, 1C9[isGB]
 117  1D043                        COMPARE s0, 43[67'd]                 ; is this a C?
 118  321D1                        JUMP Z, 1D1[isGC]
 119  1D04B                        COMPARE s0, 4B[75'd]                 ; is this a K?
 11A  321D4                        JUMP Z, 1D4[isGK]
 11B  1D04C                        COMPARE s0, 4C[76'd]                 ; is this a L?
 11C  321DA                        JUMP Z, 1DA[isGL]
 11D  1D056                        COMPARE s0, 56[86'd]                 ; is this a V?
 11E  321FA                        JUMP Z, 1FA[isGV]
 11F  1D047                        COMPARE s0, 47[71'd]                 ; is this a G?
 120  321B7                        JUMP Z, 1B7[isGG]
 121  1D053                        COMPARE s0, 53[83'd]                 ; is this a S?
 122  321C0                        JUMP Z, 1C0[isGS]
 123  22027                        JUMP 027[init]
 124  202E1                  isSA: CALL 2E1[getnextscratchchar]
 125  1D053                        COMPARE s0, 53[83'd]                 ; is this a S?
 126  3217E                        JUMP Z, 17E[isSAS]                   ;
 127  1D047                        COMPARE s0, 47[71'd]                 ; is this a G?
 128  32182                        JUMP Z, 182[isSAG]                   ;
 129  1D04F                        COMPARE s0, 4F[79'd]                 ; is this a O?
 12A  32194                        JUMP Z, 194[isSAO]                   ;
 12B  1D049                        COMPARE s0, 49[73'd]                 ; is this a I?
 12C  32189                        JUMP Z, 189[isSAI]                   ;
 12D  22027                        JUMP 027[init]
 12E                               ; SB - set beacon mode (SB<xx>
 12E  202E6                  isSB: CALL 2E6[getnextvalue]
 12F  03501                        AND s5, 01                           ; Mask bit 0
 130  0B012                        FETCH s0, 12[Mode]
 131  030FE                        AND s0, FE[254'd]                    ; reset bit 0
 132  04050                        OR s0, s5                            ; affect bit 0
 133  2F012                        STORE s0, 12[Mode]
 134  22027                        JUMP 027[init]
 135                               ; Commands for keypad pico
 135  202E1                  isSK: CALL 2E1[getnextscratchchar]
 136  1D053                        COMPARE s0, 53[83'd]                 ; is this a S?
 137  32144                        JUMP Z, 144[isSKS]                   ;
 138  22027                        JUMP 027[init]
 139  202E6                  isSL: CALL 2E6[getnextvalue]
 13A  01400                        LOAD s4, 00
 13B  1D501                        COMPARE s5, 01                       ; is it 1
 13C  3613E                        JUMP NZ, 13E[setLoranBlank]
 13D  01410                        LOAD s4, 10[LoranBlank]
 13E  0B013         setLoranBlank: FETCH s0, 13[ADCstate]
 13F  030EF                        AND s0, EF[~LoranBlank]              ; reset bit for Loran blanking
 140  04040                        OR s0, s4                            ; affect this bit
 141  2F013                        STORE s0, 13[ADCstate]               ; save
 142  2D013                        OUTPUT s0, 13[ADCstate_port]         ; set port to new ADC channel
 143  22027                        JUMP 027[init]
 144                        isSKS: ; LOAD      s0, 83'd              ; letter S
 144                               ; OUTPUT       s0, CMD2KP          ; send S to KP
 144                               ; CALL      getnextscratchchar
 144                               ; SUB       s0, 48'd
 144                               ; OUTPUT       s0, CMD2KP          ; send select value as binary value to KP
 144  22027                        JUMP 027[init]
 145                               ; This streams from UART data to DSP to TX and never exits!
 145  202E1                  isSS: CALL 2E1[getnextscratchchar]         ; get beacon offset in s0
 146  01533                        LOAD s5, 33[51'd]                    ; Ascii code for '3' - set stream mode -NO ESCAPE!
 147  2D500                        OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 148  2D000                        OUTPUT s0, 00[CMD2DSP]               ; send raw data byte of bit offset
 149  201AF                        CALL 1AF[TX]
 14A  0B012                        FETCH s0, 12[Mode]
 14B  05004                        OR s0, 04                            ; set 'Streaming TX' bit
 14C  030FE                        AND s0, FE                           ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 14D  2F012                        STORE s0, 12[Mode]
 14E  2203E                        JUMP 03E[loop]                       ;
 14F                               ; Stream RX data to UART
 14F  0B012                  isSU: FETCH s0, 12[Mode]
 150  05008                        OR s0, 08                            ; set 'Streaming TX' bit
 151  030FE                        AND s0, FE                           ; reset bit 0 to cancel beacon mode (useful to stop initial beacon setting)
 152  2F012                        STORE s0, 12[Mode]
 153  22027                        JUMP 027[init]                       ;
 154                               ; Redirect Serial to and from BT module
 154  01654                  isSW: LOAD s6, 54["T"]
 155  202F1                        CALL 2F1[Send2UartTX]
 156  0164F                        LOAD s6, 4F["O"]
 157  202F1                        CALL 2F1[Send2UartTX]
 158  01620                        LOAD s6, 20                          ;Space character
 159  202F1                        CALL 2F1[Send2UartTX]
 15A  01642                        LOAD s6, 42["B"]
 15B  202F1                        CALL 2F1[Send2UartTX]
 15C  01654                        LOAD s6, 54["T"]
 15D  202F1                        CALL 2F1[Send2UartTX]
 15E  202FC                        CALL 2FC[SendCRLF]
 15F  01001                        LOAD s0, 01
 160  2D009                        OUTPUT s0, 09[Configure]
 161  22027                        JUMP 027[init]                       ;
 162                               ; Now get a raw UART byte
 162  202ED              isSSloop: CALL 2ED[CheckUartRx]
 163  36162                        JUMP NZ, 162[isSSloop]               ; loop if nothing in UART buffer
 164  09500                        INPUT s5, 00[Uart_rx]                ; get byte
 165  202A6                        CALL 2A6[Byte2Chars]
 166  2D600                        OUTPUT s6, 00[CMD2DSP]               ; Send audio MSBbyte to DSP
 167  2D700                        OUTPUT s7, 00[CMD2DSP]               ; Send audio LSBbyte to DSP
 168  20267                        CALL 267[Check4CmdfromDSP]           ; If fifo character then send to terminal !!!!!!!!!!!!!!!!!!!! reinstate this 15/5/2013
 169  2203E                        JUMP 03E[loop]                       ; Try making this a called routine, sending 1 value per loop
 16A                               ; this is same as following routine except it returns rather than jumping to init
 16A  01524     nowsend2flashback: LOAD s5, 24[36'd]                    ; was 16 should be 9x4=36
 16B  2D507                        OUTPUT s5, 07[ProgramM]              ; initiates flash write - may take some time for pp command!
 16C  20317                        CALL 317[delay_1ms]                  ; wait to complete
 16D  20317                        CALL 317[delay_1ms]
 16E  20317                        CALL 317[delay_1ms]                  ; TO be OPTIMIZED!!!!!!!!!!!!!!!!!!!!!!!
 16F  01500                        LOAD s5, 00                          ; reset send2flash
 170  2D507                        OUTPUT s5, 07[ProgramM]              ; initiates flash write - may take some time for pp command!
 171  25000                        RETURN 
 172  2016A         nowsend2flash: CALL 16A[nowsend2flashback]
 173  22027                        JUMP 027[init]
 174  202E1                  isSR: CALL 2E1[getnextscratchchar]
 175  1D046                        COMPARE s0, 46[70'd]                 ; is this a F?
 176  3219F                        JUMP Z, 19F[isSRF]                   ;
 177  1D04D                        COMPARE s0, 4D[77'd]                 ; is this a M?
 178  321A4                        JUMP Z, 1A4[isSRM]                   ;
 179  22027                        JUMP 027[init]
 17A                               ; Testmemory TEMP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END
 17A  202E1                  isST: CALL 2E1[getnextscratchchar]
 17B                               ;                    COMPARE      s0, 70'd              ; is this a F?
 17B                               ;                   JUMP      Z, isSTF            ;
 17B  1D04D                        COMPARE s0, 4D[77'd]                 ; is this a M?
 17C  321AD                        JUMP Z, 1AD[isSTM]                   ;
 17D  22027                        JUMP 027[init]
 17E                               ; SAS - set archive source
 17E  202E6                 isSAS: CALL 2E6[getnextvalue]
 17F  00150                        LOAD s1, s5
 180  202CC                        CALL 2CC[ArchiveSource]
 181  22027                        JUMP 027[init]
 182                               ; SAG   Set analogue gain
 182  202E6                 isSAG: CALL 2E6[getnextvalue]
 183  05580                        OR s5, 80[128'd]                     ; set bit 7
 184  2D502                        OUTPUT s5, 02[GainPD]
 185  20317                        CALL 317[delay_1ms]                  ; wait for calib
 186  0357F                        AND s5, 7F[127'd]                    ; reset bit 7
 187  2D502                        OUTPUT s5, 02[GainPD]
 188  22027                        JUMP 027[init]
 189  202E6                 isSAI: CALL 2E6[getnextvalue]
 18A  01400                        LOAD s4, 00
 18B  1D501                        COMPARE s5, 01                       ; is it 1
 18C  3618E                        JUMP NZ, 18E[setADC]
 18D  01440                        LOAD s4, 40[64'd]
 18E  0B013                setADC: FETCH s0, 13[ADCstate]
 18F  030BF                        AND s0, BF[191'd]                    ; reset bit 6
 190  04040                        OR s0, s4                            ; affect bit 6
 191  2F013                        STORE s0, 13[ADCstate]               ; save
 192  2D013                        OUTPUT s0, 13[ADCstate_port]         ; set port to new ADC channel
 193  22027                        JUMP 027[init]
 194  202E6                 isSAO: CALL 2E6[getnextvalue]
 195  01400                        LOAD s4, 00
 196  1D501                        COMPARE s5, 01                       ; is it 1
 197  36199                        JUMP NZ, 199[setAudioOut]
 198  01420                        LOAD s4, 20[32'd]
 199  0B013           setAudioOut: FETCH s0, 13[ADCstate]
 19A  030DF                        AND s0, DF[223'd]                    ; 255 - 32        ; reset bit5
 19B  04040                        OR s0, s4                            ; affect bit 5
 19C  2F013                        STORE s0, 13[ADCstate]               ; save
 19D  2D013                        OUTPUT s0, 13[ADCstate_port]         ; set port to new audio channel
 19E  22027                        JUMP 027[init]
 19F                               ; SRF - set receive frequency (gets 4 hex digits
 19F  202E6                 isSRF: CALL 2E6[getnextvalue]               ; get byte represented by 2 digits
 1A0  2D50A                        OUTPUT s5, 0A[RXFreqMSB]
 1A1  202E6                        CALL 2E6[getnextvalue]
 1A2  2D50B                        OUTPUT s5, 0B[RXFreqLSB]
 1A3  22027                        JUMP 027[init]
 1A4                               ; set receive mode
 1A4  200BD                 isSRM: CALL 0BD[setRXmode]                  ; used to be RX, but that doesn't change mode and frequency etc.
 1A5  22027                        JUMP 027[init]
 1A6                               ; Routine to set receive mode - just basic function ie doesn't set mode etc.
 1A6  01530                    RX: LOAD s5, 30[48'd]                    ; Ascii code for '0' - set receive mode
 1A7  2D500                        OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 1A8  0B510                        FETCH s5, 10[Latch7]
 1A9  0357F                        AND s5, 7F[~TX_HIGH]                 ; reset bit 7
 1AA  2F510                        STORE s5, 10[Latch7]
 1AB  2D507                        OUTPUT s5, 07[ProgramM]
 1AC  25000                        RETURN 
 1AD                               ; set Tranmit mode
 1AD  200D7                 isSTM: CALL 0D7[setTXmode]                  ; used to be TX 20/5/2013
 1AE  22027                        JUMP 027[init]
 1AF                               ; routine to set transmit mode
 1AF  01531                    TX: LOAD s5, 31[49'd]                    ; Ascii code for '1' - set transmit mode
 1B0  2D500                        OUTPUT s5, 00[CMD2DSP]               ; send command to DSP
 1B1  0B510                        FETCH s5, 10[Latch7]
 1B2  05580                        OR s5, 80[TX_HIGH]                   ; set bit 7
 1B3  2F510                        STORE s5, 10[Latch7]
 1B4  2D507                        OUTPUT s5, 07[ProgramM]
 1B5  201FE                        CALL 1FE[Twotone]                    ; added to give start of message beep
 1B6  25000                        RETURN 
 1B7                               ; STF - set transmit frequency (gets 4 hex digits -Frequency now set by Keypad
 1B7                               ;isSTF:              CALL      getnextvalue        ; get byte represented by 2 digits
 1B7                               ;                   OUTPUT       s5, TXFreqMSB
 1B7                               ;                  CALL      getnextvalue
 1B7                               ;                 OUTPUT       s5, TXFreqLSB
 1B7                               ;                JUMP      init
 1B7                               ; GET AGC value from DSP
 1B7  01047                  isGG: LOAD s0, 47[71'd]                    ; letter G
 1B8  2D000                        OUTPUT s0, 00[CMD2DSP]               ; send G to DSP
 1B9  202FC                        CALL 2FC[SendCRLF]
 1BA  20317                        CALL 317[delay_1ms]
 1BB  20267                        CALL 267[Check4CmdfromDSP]           ; if character send to terminal
 1BC  20267                        CALL 267[Check4CmdfromDSP]           ; if character send to terminal
 1BD  20267                        CALL 267[Check4CmdfromDSP]           ; if character send to terminal
 1BE  20267                        CALL 267[Check4CmdfromDSP]           ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 1BF                               ;      CALL      SendCRLF
 1BF  22027                        JUMP 027[init]
 1C0                               ; Get AVEsignal level from DSP
 1C0  01053                  isGS: LOAD s0, 53[83'd]                    ; letter S
 1C1  2D000                        OUTPUT s0, 00[CMD2DSP]               ; send S to DSP
 1C2  202FC                        CALL 2FC[SendCRLF]
 1C3  20317                        CALL 317[delay_1ms]
 1C4  20267                        CALL 267[Check4CmdfromDSP]           ; if character send to terminal
 1C5  20267                        CALL 267[Check4CmdfromDSP]           ; if character send to terminal
 1C6  20267                        CALL 267[Check4CmdfromDSP]           ; if character send to terminal
 1C7  20267                        CALL 267[Check4CmdfromDSP]           ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 1C8                               ;      CALL      SendCRLF
 1C8  22027                        JUMP 027[init]
 1C9                               ; send test command to BT pico
 1C9  01047                  isGB: LOAD s0, 47[71'd]                    ; letter G
 1CA  2D014                        OUTPUT s0, 14[CMD2BT]                ; send G to BT
 1CB                               ;      CALL      SendCRLF
 1CB  20317                        CALL 317[delay_1ms]
 1CC  2026C                        CALL 26C[Check4CmdfromBT]            ; if character send to terminal
 1CD  2026C                        CALL 26C[Check4CmdfromBT]            ; if character send to terminal
 1CE  2026C                        CALL 26C[Check4CmdfromBT]            ; if character send to terminal
 1CF  2026C                        CALL 26C[Check4CmdfromBT]            ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 1D0                               ;      CALL      SendCRLF
 1D0  22027                        JUMP 027[init]
 1D1                               ; Return Loran inhibit rate
 1D1  09508                  isGC: INPUT s5, 08
 1D2  202F7                        CALL 2F7[Byte2UART]
 1D3  25000                        RETURN 
 1D4                               ; Request from keypad pico
 1D4  202E1                  isGK: CALL 2E1[getnextscratchchar]
 1D5  1D054                        COMPARE s0, 54[84'd]                 ; is this a T?
 1D6  321E6                        JUMP Z, 1E6[isGKT]
 1D7  1D056                        COMPARE s0, 56[86'd]                 ; is this a V?
 1D8  321EF                        JUMP Z, 1EF[isGKV]
 1D9  22027                        JUMP 027[init]
 1DA                               ; report signal level from the ADC
 1DA  0B515                  isGL: FETCH s5, 15[ADCLevel]
 1DB  202F7                        CALL 2F7[Byte2UART]
 1DC  01620                        LOAD s6, 20                          ; space
 1DD  202F1                        CALL 2F1[Send2UartTX]
 1DE  0950F                        INPUT s5, 0F[ADCSignalLevel]
 1DF  202F7                        CALL 2F7[Byte2UART]
 1E0  01620                        LOAD s6, 20                          ; space
 1E1  202F1                        CALL 2F1[Send2UartTX]
 1E2  0B516                        FETCH s5, 16[ADCgain]
 1E3  202F7                        CALL 2F7[Byte2UART]
 1E4  202FC                        CALL 2FC[SendCRLF]
 1E5  22027                        JUMP 027[init]
 1E6                               ; send test command to KP pico
 1E6  01054                 isGKT: LOAD s0, 54[84'd]                    ; letter T
 1E7  2D015                        OUTPUT s0, 15[CMD2KP]                ; send T to KP
 1E8  202FC                        CALL 2FC[SendCRLF]
 1E9  20317                        CALL 317[delay_1ms]
 1EA  20271                        CALL 271[Check4CmdfromKP]            ; if character send to terminal
 1EB  20271                        CALL 271[Check4CmdfromKP]            ; if character send to terminal
 1EC  20271                        CALL 271[Check4CmdfromKP]            ; if character send to terminal
 1ED  20271                        CALL 271[Check4CmdfromKP]            ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 1EE                               ;      CALL      SendCRLF
 1EE  22027                        JUMP 027[init]
 1EF  01056                 isGKV: LOAD s0, 56[86'd]                    ; letter V
 1F0  2D015                        OUTPUT s0, 15[CMD2KP]                ; send V to KP
 1F1  202FC                        CALL 2FC[SendCRLF]
 1F2  20317                        CALL 317[delay_1ms]
 1F3  20271                        CALL 271[Check4CmdfromKP]            ; if character send to terminal
 1F4  20271                        CALL 271[Check4CmdfromKP]            ; if character send to terminal
 1F5  20271                        CALL 271[Check4CmdfromKP]            ; if character send to terminal
 1F6  20271                        CALL 271[Check4CmdfromKP]            ; if character send to terminal (should be 4 characters (2 hex + CRLF)
 1F7                               ;      CALL      SendCRLF
 1F7  22027                        JUMP 027[init]
 1F8  202B9                  isGA: CALL 2B9[SendArchive]
 1F9  22027                        JUMP 027[init]
 1FA  01509                  isGV: LOAD s5, 09[Versionno]
 1FB  202F7                        CALL 2F7[Byte2UART]
 1FC  202FC                        CALL 2FC[SendCRLF]                   ; added to allow get line to read OK
 1FD  22027                        JUMP 027[init]
 1FE  01042               Twotone: LOAD s0, 42[66'd]                    ; Block DSPpico
 1FF  2D000                        OUTPUT s0, 00[CMD2DSP]               ; send B to DSP to block it
 200                               ; need to output TX freq carrier plus 30 then 40 and then return to carrier - now simply as an increment
 200  01035                        LOAD s0, 35[53'd]
 201  2D00D                        OUTPUT s0, 0D[Tone]
 202  20312                        CALL 312[delay_100ms]
 203  01023                        LOAD s0, 23[35'd]
 204  2D00D                        OUTPUT s0, 0D[Tone]
 205  20312                        CALL 312[delay_100ms]
 206  01000                        LOAD s0, 00
 207  2D00D                        OUTPUT s0, 0D[Tone]                  ; and send value to SSB modulatorto reset to normal frequency
 208  01052                        LOAD s0, 52[82'd]                    ; Un Block DSPpico
 209  2D000                        OUTPUT s0, 00[CMD2DSP]               ; send R to DSP (release)
 20A  25000                        RETURN 
 20B  01500                Warble: LOAD s5, 00
 20C  01042            Warbleloop: LOAD s0, 42[66'd]                    ; Block DSPpico
 20D  2D000                        OUTPUT s0, 00[CMD2DSP]               ; send B to DSP to block it
 20E                               ; need to output TX freq carrier plus 30 then 40 and then return to carrier - now simply as an increment
 20E  0101E                        LOAD s0, 1E[30'd]
 20F  2D00D                        OUTPUT s0, 0D[Tone]
 210  20312                        CALL 312[delay_100ms]
 211  01028                        LOAD s0, 28[40'd]
 212  2D00D                        OUTPUT s0, 0D[Tone]
 213  20312                        CALL 312[delay_100ms]
 214  11501                        ADD s5, 01
 215  1D504                        COMPARE s5, 04                       ; Do this 4 times
 216  3620C                        JUMP NZ, 20C[Warbleloop]
 217  01000                        LOAD s0, 00
 218  2D00D                        OUTPUT s0, 0D[Tone]                  ; and send value to SSB modulatorto reset to normal frequency
 219  01052                        LOAD s0, 52[82'd]                    ; Un Block DSPpico
 21A  2D000                        OUTPUT s0, 00[CMD2DSP]               ; send R to DSP (release)
 21B  25000                        RETURN 
 21C  201AF            BeaconBeep: CALL 1AF[TX]
 21D  01700                        LOAD s7, 00
 21E  2020B            Beaconloop: CALL 20B[Warble]
 21F                               ; Keep checking fifo for a character to keep it clear!
 21F  20271                        CALL 271[Check4CmdfromKP]
 220  1D674                        COMPARE s6, 74["t"]                  ; character_t
 221  3222F                        JUMP Z, 22F[cancelbeacon]            ; Escape if is key pressed - changed this 2/5/13 to speed up beacon cancel
 222  11701                        ADD s7, 01
 223  1D703                        COMPARE s7, 03
 224  3621E                        JUMP NZ, 21E[Beaconloop]             ; do warble 3 times
 225  201A6                        CALL 1A6[RX]
 226  20304                        CALL 304[delay_1s]
 227                               ; Keep checking fifo for a character to keep it clear!
 227  20271                        CALL 271[Check4CmdfromKP]
 228  1D674                        COMPARE s6, 74["t"]                  ; character_t
 229  3222F                        JUMP Z, 22F[cancelbeacon]            ; Escape if is key pressed
 22A  20304                        CALL 304[delay_1s]
 22B                               ; Keep checking fifo for a character to keep it clear!
 22B  20271                        CALL 271[Check4CmdfromKP]
 22C  1D674                        COMPARE s6, 74["t"]                  ; character_t
 22D  3222F                        JUMP Z, 22F[cancelbeacon]            ; Escape if is key pressed
 22E                               ; 6/7/12 reduced receive period to 2s
 22E  25000                        RETURN 
 22F  0B012          cancelbeacon: FETCH s0, 12[Mode]
 230  030FE                        AND s0, FE[254'd]                    ; cancel beaon mode
 231  2F012                        STORE s0, 12[Mode]                   ; Hah - had forgotton to update the mode! 20/5/13
 232  25000                        RETURN 
 233                               ; ;;Pete
 233                               ; ;;Pete
 233                               ; ;;Pete
 233              HandleBTCommand: 
 233                               ; ;;LOAD      s6, 'A'             ; get character
 233                               ; ;;CALL      Send2UartTX         ; and echo back to terminal
 233  0307F                        AND s0, 7F                           ; mask off top bit
 234                               ; need to interpret commands from BT Here
 234  1D014                        COMPARE s0, 14[TRANSMIT_ON]
 235  32239                        JUMP Z, 239[FromBT_XMIT]             ; Bluetooth Headset transmit
 236  1D015                        COMPARE s0, 15[TRANSMIT_OFF]
 237  32243                        JUMP Z, 243[FromBT_RECEIVE]          ; Bluetooth Headset stop transmit
 238                               ; ;;COMPARE      s0, FLASH_WRITE
 238                               ; ;;JUMP      Z, FromBT_WRITE     ; PC has sent a WRITE to Flash request
 238                               ; ;;COMPARE      s0, FLASH_WRITE_PAGE
 238                               ; ;;JUMP      Z, FromBT_WRITE_PAGE; PC has sent a WRITE PAGE to Flash request
 238                               ; ;;COMPARE      s0, FLASH_ERASE
 238                               ; ;;JUMP      Z, FromBT_ERASE     ; PC has sent a Erase the Write message
 238                               ; ;;COMPARE      s0, FLASH_READ
 238                               ; ;;JUMP      Z, FromBT_READ      ; PC has sent a Read request
 238                               ; ;;COMPARE      s0, FLASH_READ_PAGE
 238                               ; ;;JUMP      Z, FromBT_READ_PAGE ; PC has sent a Read Page request
 238                               ; ;;COMPARE      s0, FLASH_WRITE_TEXT
 238                               ; ;;JUMP      Z, FromBT_WRITE_TEXT; PC has sent a WRITE TEXT to Flash request
 238                               ; LOAD      s0, 2F             ; send message back
 238                               ; OUTPUT       s0, CMD2BT          ; send Go to BT
 238                               ; CALL      SendCharToBT
 238  2204F                        JUMP 04F[HandleBTCommand_Done]
 239                  FromBT_XMIT: 
 239  202FC                        CALL 2FC[SendCRLF]
 23A  01654                        LOAD s6, 54["T"]
 23B  202F1                        CALL 2F1[Send2UartTX]                ; and echo back to terminal. Message mode
 23C  01678                        LOAD s6, 78["x"]
 23D  202F1                        CALL 2F1[Send2UartTX]                ; and echo back to terminal. Message mode
 23E  200D7                        CALL 0D7[setTXmode]
 23F  202FC                        CALL 2FC[SendCRLF]
 240  01001                        LOAD s0, 01
 241  2F043                        STORE s0, 43[BluetoothXmit]
 242  2204F                        JUMP 04F[HandleBTCommand_Done]
 243               FromBT_RECEIVE: 
 243  202FC                        CALL 2FC[SendCRLF]
 244  01652                        LOAD s6, 52["R"]
 245  202F1                        CALL 2F1[Send2UartTX]                ; and echo back to terminal. Message mode
 246  01663                        LOAD s6, 63["c"]
 247  202F1                        CALL 2F1[Send2UartTX]                ; and echo back to terminal. Message mode
 248  200BD                        CALL 0BD[setRXmode]
 249  202FC                        CALL 2FC[SendCRLF]
 24A  01000                        LOAD s0, 00
 24B  2F043                        STORE s0, 43[BluetoothXmit]
 24C  2204F                        JUMP 04F[HandleBTCommand_Done]
 24D                               ; ;; end Pete
 24D                               ; ;; end Pete
 24D                               ; ;; end Pete
 24D  016FF           getUARTchar: LOAD s6, FF                          ; Return FF if no character
 24E  202ED                        CALL 2ED[CheckUartRx]
 24F  35000                        RETURN NZ                            ; Return if no character with s6=$FF
 250  09600                        INPUT s6, 00[Uart_rx]                ; get character
 251  0367F                        AND s6, 7F
 252                               ; CALL      Send2UartTX         ; and echo back to terminal. - SHOULD USE Send2UartTX (not in message mode)
 252  25000                        RETURN 
 253                               ; returns fifo character in s6 assuming present
 253  2027B      sendDSP2Terminal: CALL 27B[GetDSPFifoChar]
 254  01600                        LOAD s6, 00                          ; get character
 255  0367F                        AND s6, 7F                           ; top bit is for empty fifo flag!
 256                               ;Send to keypad pico (LCD) instead
 256                               ;                    CALL      Send2UartTX         ; and echo back to terminal.
 256  2D615                        OUTPUT s6, 15[CMD2KP]                ; send code 0-7F (normally ascii, but $7F would tell it to expect a value to display at a particular place)
 257  25000                        RETURN 
 258                               ; returns BT fifo character in s6 assuming present
 258  20281       sendBT2Terminal: CALL 281[GetBTFifoChar]
 259  00600                        LOAD s6, s0                          ; get character
 25A  0367F                        AND s6, 7F
 25B  202F1                        CALL 2F1[Send2UartTX]                ; and echo back to terminal.
 25C  25000                        RETURN 
 25D                               ; returns KP fifo character in s6 assuming present
 25D  20287       sendKP2Terminal: CALL 287[GetKPFifoChar]
 25E  00600                        LOAD s6, s0                          ; get character
 25F  0367F                        AND s6, 7F
 260  202F1                        CALL 2F1[Send2UartTX]                ; and echo back to terminal.
 261  25000                        RETURN 
 262                               ; returns KP fifo character in s6 assuming present
 262  2028D       sendTD2Terminal: CALL 28D[GetTDFifoChar]
 263  00600                        LOAD s6, s0                          ; get character
 264  0367F                        AND s6, 7F
 265  202F1                        CALL 2F1[Send2UartTX]                ; and echo back to terminal.
 266  25000                        RETURN 
 267                               ; checks for command from DSP pico, if present in s6 and echo to terminal - otherwise s6>127
 267  09104      Check4CmdfromDSP: INPUT s1, 04[DSPcmd]                 ; Get character from DSP picoblaze (if present should be less than 128)
 268  00610                        LOAD s6, s1
 269  1D180                        COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 26A  38253                        CALL C, 253[sendDSP2Terminal]        ; If less than 128 there is a value to give back and display.
 26B  25000                        RETURN 
 26C                               ; checks for command from BTpico, if present in s6 and echo to terminal - otherwise s6>127
 26C  09105       Check4CmdfromBT: INPUT s1, 05[BTcmd]                  ; Get character from BT picoblaze (if present should be less than 128)
 26D  00610                        LOAD s6, s1
 26E  1D180                        COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 26F  38258                        CALL C, 258[sendBT2Terminal]         ; If less than 128 there is a value to give back and display.
 270  25000                        RETURN 
 271                               ; checks for command from KPpico, if present in s6  - otherwise s6>127
 271  09106       Check4CmdfromKP: INPUT s1, 06[KPcmd]                  ; Get character from BT picoblaze (if present should be less than 128)
 272  00610                        LOAD s6, s1
 273  1D180                        COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 274  38287                        CALL C, 287[GetKPFifoChar]
 275  25000                        RETURN 
 276                               ; checks for command from TDpico, if present in s6  - otherwise s6>127
 276  09107       Check4CmdfromTD: INPUT s1, 07[TDcmd]                  ; Get character from BT picoblaze (if present should be less than 128)
 277  00610                        LOAD s6, s1
 278  1D180                        COMPARE s1, 80[128'd]                ; Is the fifo empty though? (if greater than 127) - could use routine like in DSPpico!
 279  3828D                        CALL C, 28D[GetTDFifoChar]
 27A  25000                        RETURN 
 27B                               ; Routine to recover a byte, (character?) from the FIFO in s0
 27B  01010        GetDSPFifoChar: LOAD s0, 10[DSPFifo]
 27C  2D00E                        OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 27D  01010                        LOAD s0, 10[DSPFifo]                 ; dummy, wait a bit longer for character to present itself
 27E  09004                        INPUT s0, 04[DSPcmd]                 ; now get my character
 27F  0307F                        AND s0, 7F                           ; mask off top bit
 280  25000                        RETURN 
 281                               ; Routine to recover a character from the BTFIFO in s0
 281  01020         GetBTFifoChar: LOAD s0, 20[BTFifo]
 282  2D00E                        OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 283  01020                        LOAD s0, 20[BTFifo]                  ; dummy, wait a bit longer for character to present itself
 284  09005                        INPUT s0, 05[BTcmd]                  ; now get my character
 285  0307F                        AND s0, 7F                           ; mask off top bit
 286  25000                        RETURN 
 287                               ; Routine to recover a character from the KPFIFO in s6
 287  01040         GetKPFifoChar: LOAD s0, 40[KPFifo]
 288  2D00E                        OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 289  01040                        LOAD s0, 40[KPFifo]                  ; dummy, wait a bit longer for character to present itself
 28A  09606                        INPUT s6, 06[KPcmd]                  ; now get my character
 28B  0367F                        AND s6, 7F                           ; mask off top bit
 28C  25000                        RETURN 
 28D                               ; Routine to recover a character from the TDFIFO in s6
 28D  01080         GetTDFifoChar: LOAD s0, 80[TDFifo]
 28E  2D00E                        OUTPUT s0, 0E[Acknowledge]           ; read next fifo character - this sends a read pulse to the FIFO
 28F  01040                        LOAD s0, 40[KPFifo]                  ; dummy, wait a bit longer for character to present itself
 290  09607                        INPUT s6, 07[TDcmd]                  ; now get my character
 291  0367F                        AND s6, 7F                           ; mask off top bit
 292  25000                        RETURN 
 293                               ; sayOK:              CALL      SendCRLF
 293                               ; LOAD      s6, 79
 293                               ; CALL      Send2UartTX
 293                               ; LOAD      s6, 75
 293                               ; CALL      Send2UartTX
 293                               ; CALL      SendCRLF
 293                               ; RETURN
 293                               ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 293  00860            Chars2Byte: LOAD s8, s6
 294  2029E                        CALL 29E[Get4bits]
 295  00580                        LOAD s5, s8
 296  14506                        SL0 s5
 297  14506                        SL0 s5
 298  14506                        SL0 s5
 299  14506                        SL0 s5                               ; put these 4 bits to MSBs
 29A  00870                        LOAD s8, s7
 29B  2029E                        CALL 29E[Get4bits]
 29C  10580                        ADD s5, s8
 29D  25000                        RETURN 
 29E                               ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 29E  1D83C              Get4bits: COMPARE s8, 3C[60'd]                 ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 29F  3A2A3                        JUMP C, 2A3[char0_9]
 2A0  19837                        SUB s8, 37[55'd]                     ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 2A1  0380F                        AND s8, 0F                           ; make sure only return 4 bits
 2A2  25000                        RETURN 
 2A3  19830               char0_9: SUB s8, 30[48'd]
 2A4  0380F                        AND s8, 0F                           ; make sure only return 4 bits
 2A5  25000                        RETURN 
 2A6                               ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 2A6  00850            Byte2Chars: LOAD s8, s5                          ; assumes 8 bit data is in s5
 2A7  1450E                        SR0 s5
 2A8  1450E                        SR0 s5
 2A9  1450E                        SR0 s5
 2AA  1450E                        SR0 s5                               ; get first hex character
 2AB  202B2                        CALL 2B2[GetChar]
 2AC  00650                        LOAD s6, s5                          ; first ascii char
 2AD  00580                        LOAD s5, s8
 2AE  0350F                        AND s5, 0F
 2AF  202B2                        CALL 2B2[GetChar]                    ;
 2B0  00750                        LOAD s7, s5                          ; second ascii char
 2B1  25000                        RETURN 
 2B2                               ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 2B2  1950A               GetChar: SUB s5, 0A[10'd]                     ; Test if s5 greater than 9
 2B3  3A2B6                        JUMP C, 2B6[is_0_9]                  ; Hex character is 0_9
 2B4  11541                        ADD s5, 41[65'd]                     ; offset for Ascii code 'A'
 2B5  25000                        RETURN 
 2B6  1150A                is_0_9: ADD s5, 0A[10'd]                     ; return to range 0-9
 2B7  11530                        ADD s5, 30[48'd]                     ; offset to Ascii code for '0'
 2B8  25000                        RETURN 
 2B9                               ; To send to Uart, simply use: OUTPUT       s3, UART_TX         ; Sends value in s3 to Uart Tx
 2B9                               ; Dump archive RAM to RS232 port as 4 Ascii codes per data value followed by carriage return and line feed.
 2B9  202D8           SendArchive: CALL 2D8[DisableArchive]             ; Stop archiving
 2BA  01000                        LOAD s0, 00
 2BB  01100                        LOAD s1, 00
 2BC  0B410             SendAloop: FETCH s4, 10[Latch7]
 2BD  034FC                        AND s4, FC[252'd]                    ; set top 2 address bits to zero
 2BE  2D006                        OUTPUT s0, 06[ProgramL]
 2BF  04410                        OR s4, s1                            ; patch in top 2 address bits
 2C0  2D407                        OUTPUT s4, 07[ProgramM]              ; and send to the output port
 2C1  09503                        INPUT s5, 03[ArchiveDataMSB]
 2C2  202F7                        CALL 2F7[Byte2UART]
 2C3  09502                        INPUT s5, 02[ArchiveDataLSB]         ; grab bottom byte
 2C4  202F7                        CALL 2F7[Byte2UART]
 2C5  11001                        ADD s0, 01
 2C6  13100                        ADDCY s1, 00
 2C7  202FC                        CALL 2FC[SendCRLF]
 2C8  1D104                        COMPARE s1, 04
 2C9  362BC                        JUMP NZ, 2BC[SendAloop]
 2CA  202D3                        CALL 2D3[EnableArchive]              ; Restart archiving
 2CB  25000                        RETURN 
 2CC                               ; Select Archiving source, if s1 is 0 then raw 16bit ADC data is archived, or if s1=1 then 16bit data from the DSP picoblaze (DATA2Archve) is archived at 6kHz
 2CC  03103         ArchiveSource: AND s1, 03
 2CD  0B014                        FETCH s0, 14[SelectScratch]          ; get current value of selections
 2CE  030FC                        AND s0, FC[252'd]                    ; first reset first 2 bits
 2CF  04010                        OR s0, s1                            ; affect bits 0-1
 2D0  2D008                        OUTPUT s0, 08[SelectArchiveSource]   ; update archive control port
 2D1  2F014                        STORE s0, 14[SelectScratch]          ; Update scratchpad
 2D2                               ;      LOAD   s5,s0
 2D2                               ;      CALL   Byte2Chars
 2D2  25000                        RETURN 
 2D3                               ; Enable Archiving
 2D3  0B010         EnableArchive: FETCH s0, 10[Latch7]                 ; get current value of control port
 2D4  05040                        OR s0, 40[EnArchive]                 ; set bit 5
 2D5  2D007                        OUTPUT s0, 07[ProgramM]
 2D6  2F010                        STORE s0, 10[Latch7]                 ; get current value of control port
 2D7  25000                        RETURN 
 2D8                               ; Disable Archiving
 2D8  00600        DisableArchive: LOAD s6, s0
 2D9  20321                        CALL 321[delay_50us]                 ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA                               ; CALL      delay_1ms           ; wait for a bit more archiving first!
 2DA  20317                        CALL 317[delay_1ms]                  ; wait for a bit more archiving first!
 2DB  0B010                        FETCH s0, 10[Latch7]                 ; get current value of control port
 2DC  030BF                        AND s0, BF[~EnArchive]               ; reset bit 5
 2DD  2D007                        OUTPUT s0, 07[ProgramM]
 2DE  2F010                        STORE s0, 10[Latch7]                 ; get current value of control port
 2DF  00060                        LOAD s0, s6                          ; restore s0 value
 2E0  25000                        RETURN 
 2E1                               ; Character parsing:
 2E1                               ; returns next command character in s0
 2E1  0A090    getnextscratchchar: FETCH s0, (s9)
 2E2  11901                        ADD s9, 01                           ; increment pointer
 2E3  00600                        LOAD s6, s0
 2E4  202F1                        CALL 2F1[Send2UartTX]                ; and echo back to terminal. Message mode
 2E5  25000                        RETURN 
 2E6                               ; Reads 2 ascii codes and returns the byte represented in hex as binary value in s5
 2E6  202E1          getnextvalue: CALL 2E1[getnextscratchchar]
 2E7  00400                        LOAD s4, s0
 2E8  202E1                        CALL 2E1[getnextscratchchar]
 2E9  00700                        LOAD s7, s0
 2EA  00640                        LOAD s6, s4
 2EB  20293                        CALL 293[Chars2Byte]                 ; return byte in s5
 2EC  25000                        RETURN 
 2ED                               ; UART control
 2ED  09001           CheckUartRx: INPUT s0, 01[Uart_status]            ; Check if there is RX data
 2EE  03001                        AND s0, 01
 2EF  1D001                        COMPARE s0, 01
 2F0  25000                        RETURN 
 2F1                               ; send character in s6 to Uart - also uses s8!
 2F1  09801           Send2UartTX: INPUT s8, 01[Uart_status]            ; Check if TX buffer is full
 2F2  03802                        AND s8, 02
 2F3  1D802                        COMPARE s8, 02                       ; if 2 then wait
 2F4  322F1                        JUMP Z, 2F1[Send2UartTX]
 2F5  2D601                        OUTPUT s6, 01[UART_TX]
 2F6  25000                        RETURN 
 2F7                               ; Convert byte in s5 into 2 ascii codes in hexadecimal and send to the serial port.
 2F7  202A6             Byte2UART: CALL 2A6[Byte2Chars]
 2F8  202F1                        CALL 2F1[Send2UartTX]
 2F9  00670                        LOAD s6, s7
 2FA  202F1                        CALL 2F1[Send2UartTX]
 2FB  25000                        RETURN 
 2FC  0160D              SendCRLF: LOAD s6, 0D
 2FD  202F1                        CALL 2F1[Send2UartTX]
 2FE  0160A                        LOAD s6, 0A
 2FF  202F1                        CALL 2F1[Send2UartTX]
 300  25000                        RETURN 
 301  01620             SendSPACE: LOAD s6, 20
 302  202F1                        CALL 2F1[Send2UartTX]
 303  25000                        RETURN 
 304                               CONSTANT count_1000_lsb, E8          ; lower 8-bits of 1000 count value
 304                               CONSTANT count_1000_msb, 03          ; upper 8-bits of 1000 count value
 304                               ; Registers used s0, s1, s2, s3, s4 and s5.
 304                               ;
 304  01500              delay_1s: LOAD s5, 00                          ; clear cycle counter
 305  01400                        LOAD s4, 00
 306  20317               wait_1s: CALL 317[delay_1ms]
 307  11401                        ADD s4, 01                           ; increment cycle counter
 308  13500                        ADDCY s5, 00
 309  1D4E8                        COMPARE s4, E8[count_1000_lsb]       ; test for 1000ms
 30A  36306                        JUMP NZ, 306[wait_1s]
 30B  1D503                        COMPARE s5, 03[count_1000_msb]
 30C  36306                        JUMP NZ, 306[wait_1s]
 30D  25000                        RETURN 
 30E                               ;
 30E                               ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 30E                               ;
 30E                               ;
 30E                               ; Registers used s0, s1, s2, s3 and s4.
 30E                               ;
 30E  20312           delay_300ms: CALL 312[delay_100ms]
 30F  20312           delay_200ms: CALL 312[delay_100ms]
 310  20312                        CALL 312[delay_100ms]
 311  25000                        RETURN 
 312                               ;
 312                               ; Delay of approximately 100ms used for switch debounce
 312                               ;
 312                               ; Registers used s0, s1, s2, s3 and s4.
 312                               ;
 312  01464           delay_100ms: LOAD s4, 64                          ; repeat 1ms delay 100 times
 313  20317            wait_100ms: CALL 317[delay_1ms]
 314  19401                        SUB s4, 01
 315  36313                        JUMP NZ, 313[wait_100ms]
 316  25000                        RETURN 
 317                               ;
 317                               ; Registers used s0, s1, s2 and s3.
 317                               ;
 317  01300             delay_1ms: LOAD s3, 00                          ; clear cycle counter
 318  01200                        LOAD s2, 00
 319  20326              wait_1ms: CALL 326[delay_1us]
 31A  11201                        ADD s2, 01                           ; increment cycle counter
 31B  13300                        ADDCY s3, 00
 31C  1D2E8                        COMPARE s2, E8[count_1000_lsb]       ; test for 1000us
 31D  36319                        JUMP NZ, 319[wait_1ms]
 31E  1D303                        COMPARE s3, 03[count_1000_msb]
 31F  36319                        JUMP NZ, 319[wait_1ms]
 320  25000                        RETURN 
 321                               ;
 321                               ; Delay of approximately 50us required by LCD display
 321                               ;
 321                               ; Registers used s0 and s1.
 321                               ;
 321  01132            delay_50us: LOAD s1, 32[50'd]                    ; repeat 1us delay 50 times
 322  20326             wait_50us: CALL 326[delay_1us]
 323  19101                        SUB s1, 01
 324  36322                        JUMP NZ, 322[wait_50us]
 325  25000                        RETURN 
 326                               ; Delay of approximately 1us used to provide timing reference for
 326                               ; LCD operations. This must be adjusted to reflect the clock
 326                               ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 326                               ;
 326                               ; The software delay loop is formed using register s0. This register
 326                               ; must be loaded with an integer value close to the result of....
 326                               ;
 326                               ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 326                               ;
 326                               ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 326                               ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 326                               ; operation will become lower than the 100KHz target intended.
 326                               ;
 326                               ; Register used s0.
 326                               ;
 326  0100C             delay_1us: LOAD s0, 0C[delay_1us_constant]      ; delay value of 12 decimal for a 50MHz clock
 327  19001              wait_1us: SUB s0, 01
 328  36327                        JUMP NZ, 327[wait_1us]
 329  25000                        RETURN 
 32A                               ;
 32A                               ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\home\graham\Dropbox\N3workingG\TE0722Rebuild\N3SysGen\UserPico.psm



List of defined constants

 CONSTANT name        Value        Source PSM File

 timestamp_hours      19'd         
 timestamp_minutes    36'd         
 timestamp_seconds    32'd         
 datestamp_year       16'd         
 datestamp_month      12'd         
 datestamp_day        06'd         
 NUL                  00           
 BEL                  07           
 BS                   08           
 HT                   09           
 LF                   0A           
 VT                   0B           
 CR                   0D           
 ESC                  1B           
 DEL                  7F           
 DCS                  90           
 ST                   9C           
 Versionno            09           UserPico.psm
 InitialVolume        133'd        UserPico.psm
 MinorVersionno       EE           UserPico.psm
 Bmode                00           UserPico.psm
 AGCupperRX           32           UserPico.psm
 AGClowerRX           12           UserPico.psm
 AGCupperTX           10           UserPico.psm
 AGClowerTX           06           UserPico.psm
 delay_1us_constant   12'd         UserPico.psm
 WREN                 06           UserPico.psm
 FAST_READ            0B           UserPico.psm
 BERASE               C7           UserPico.psm
 SER                  D8           UserPico.psm
 RDID                 9F           UserPico.psm
 PP                   02           UserPico.psm
 RDSR                 05           UserPico.psm
 Latch7               16'd         UserPico.psm
 LastDSPbyte          17'd         UserPico.psm
 Mode                 18'd         UserPico.psm
 ADCstate             19'd         UserPico.psm
 SelectScratch        20'd         UserPico.psm
 ADCLevel             21'd         UserPico.psm
 ADCgain              22'd         UserPico.psm
 TX_F_MSB             23'd         UserPico.psm
 TX_F_LSB             24'd         UserPico.psm
 ADCAGCUpperThreshold 25'd         UserPico.psm
 ADCAGCLowerThreshold 26'd         UserPico.psm
 ADCGainTX            27'd         UserPico.psm
 ADCGainRX            28'd         UserPico.psm
 BluetoothXmit        43           UserPico.psm
 Uart_rx              00           UserPico.psm
 Uart_status          01           UserPico.psm
 BattMon              4'd          UserPico.psm
 ArchiveDataLSB       2'd          UserPico.psm
 ArchiveDataMSB       3'd          UserPico.psm
 DSPcmd               4'd          UserPico.psm
 BTcmd                5'd          UserPico.psm
 KPcmd                6'd          UserPico.psm
 TDcmd                7'd          UserPico.psm
 DSPRAMrdbkMSB        9'd          UserPico.psm
 DSPRAMrdbkLSB        10'd         UserPico.psm
 BTRAMrdbkMSB         11'd         UserPico.psm
 BTRAMrdbkLSB         12'd         UserPico.psm
 KPRAMrdbkMSB         13'd         UserPico.psm
 KPRAMrdbkLSB         14'd         UserPico.psm
 ADCSignalLevel       15'd         UserPico.psm
 CMD2DSP              00           UserPico.psm
 UART_TX              01           UserPico.psm
 GainPD               02           UserPico.psm
 Instructiona         03           UserPico.psm
 Instructionb         04           UserPico.psm
 Instructionc         05           UserPico.psm
 ProgramL             06           UserPico.psm
 ProgramM             07           UserPico.psm
 EnArchive            64'd         UserPico.psm
 TX_HIGH              128'd        UserPico.psm
 SelectArchiveSource  8'd          UserPico.psm
 Configure            9'd          UserPico.psm
 RXFreqMSB            10'd         UserPico.psm
 RXFreqLSB            11'd         UserPico.psm
 AudioVolume          12'd         UserPico.psm
 Tone                 13'd         UserPico.psm
 Acknowledge          14'd         UserPico.psm
 DSPFifo              16'd         UserPico.psm
 BTFifo               32'd         UserPico.psm
 KPFifo               64'd         UserPico.psm
 TDFifo               128'd        UserPico.psm
 FlashData            17'd         UserPico.psm
 ADCstate_port        19'd         UserPico.psm
 LoranBlank           16'd         UserPico.psm
 AudioOutSelect       32'd         UserPico.psm
 AnalogueChannel      64'd         UserPico.psm
 CMD2BT               20'd         UserPico.psm
 CMD2KP               21'd         UserPico.psm
 RAMDataMSB           22'd         UserPico.psm
 RAMDataLSB           23'd         UserPico.psm
 RAMwriteControl      25'd         UserPico.psm
 TRANSMIT_ON          14           UserPico.psm
 TRANSMIT_OFF         15           UserPico.psm
 count_1000_lsb       E8           UserPico.psm
 count_1000_msb       03           UserPico.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "06 Dec 2016"  
 timestamp$        "19:36:32"     



List of line labels

   Label                  Addr  Source PSM File

 * boot                   000   UserPico.psm
   reboot                 001   UserPico.psm
   DoUserProg             007   UserPico.psm
   GetProg                00A   UserPico.psm
   GetByte                01B   UserPico.psm
   cold_start             021   UserPico.psm
   ProgDSP                022   UserPico.psm
   ScratchClear           023   UserPico.psm
   init                   027   UserPico.psm
   loop                   03E   UserPico.psm
   HandleBTCommand_Done   04F   UserPico.psm
   CheckADClevel          05D   UserPico.psm
   nofive                 06C   UserPico.psm
   First                  06F   UserPico.psm
   Second                 072   UserPico.psm
   Third                  075   UserPico.psm
   Fourth                 078   UserPico.psm
   Fifth                  07B   UserPico.psm
   ToLCD                  07F   UserPico.psm
 * Tempskip               081   UserPico.psm
   ReduceADCgain          089   UserPico.psm
   IncreaseADCgain        092   UserPico.psm
   checkrqst              09B   UserPico.psm
   setEarthAntennas       0A4   UserPico.psm
   setLoopAntennas        0A9   UserPico.psm
   checkRXmode            0AE   UserPico.psm
   checkTXmode            0B7   UserPico.psm
   setRXmode              0BD   UserPico.psm
   setTXmode              0D7   UserPico.psm
   SetAnGain              0EA   UserPico.psm
   interpcommand          0F5   UserPico.psm
   interploop             0F6   UserPico.psm
   isS                    100   UserPico.psm
   isG                    112   UserPico.psm
   isSA                   124   UserPico.psm
   isSB                   12E   UserPico.psm
   isSK                   135   UserPico.psm
   isSL                   139   UserPico.psm
   setLoranBlank          13E   UserPico.psm
   isSKS                  144   UserPico.psm
 * isSS                   145   UserPico.psm
   isSU                   14F   UserPico.psm
   isSW                   154   UserPico.psm
   isSSloop               162   UserPico.psm
   nowsend2flashback      16A   UserPico.psm
 * nowsend2flash          172   UserPico.psm
   isSR                   174   UserPico.psm
   isST                   17A   UserPico.psm
   isSAS                  17E   UserPico.psm
   isSAG                  182   UserPico.psm
   isSAI                  189   UserPico.psm
   setADC                 18E   UserPico.psm
   isSAO                  194   UserPico.psm
   setAudioOut            199   UserPico.psm
   isSRF                  19F   UserPico.psm
   isSRM                  1A4   UserPico.psm
   RX                     1A6   UserPico.psm
   isSTM                  1AD   UserPico.psm
   TX                     1AF   UserPico.psm
   isGG                   1B7   UserPico.psm
   isGS                   1C0   UserPico.psm
   isGB                   1C9   UserPico.psm
   isGC                   1D1   UserPico.psm
   isGK                   1D4   UserPico.psm
   isGL                   1DA   UserPico.psm
   isGKT                  1E6   UserPico.psm
   isGKV                  1EF   UserPico.psm
   isGA                   1F8   UserPico.psm
   isGV                   1FA   UserPico.psm
   Twotone                1FE   UserPico.psm
   Warble                 20B   UserPico.psm
   Warbleloop             20C   UserPico.psm
   BeaconBeep             21C   UserPico.psm
   Beaconloop             21E   UserPico.psm
   cancelbeacon           22F   UserPico.psm
 * HandleBTCommand        233   UserPico.psm
   FromBT_XMIT            239   UserPico.psm
   FromBT_RECEIVE         243   UserPico.psm
   getUARTchar            24D   UserPico.psm
   sendDSP2Terminal       253   UserPico.psm
   sendBT2Terminal        258   UserPico.psm
 * sendKP2Terminal        25D   UserPico.psm
 * sendTD2Terminal        262   UserPico.psm
   Check4CmdfromDSP       267   UserPico.psm
   Check4CmdfromBT        26C   UserPico.psm
   Check4CmdfromKP        271   UserPico.psm
   Check4CmdfromTD        276   UserPico.psm
   GetDSPFifoChar         27B   UserPico.psm
   GetBTFifoChar          281   UserPico.psm
   GetKPFifoChar          287   UserPico.psm
   GetTDFifoChar          28D   UserPico.psm
   Chars2Byte             293   UserPico.psm
   Get4bits               29E   UserPico.psm
   char0_9                2A3   UserPico.psm
   Byte2Chars             2A6   UserPico.psm
   GetChar                2B2   UserPico.psm
   is_0_9                 2B6   UserPico.psm
   SendArchive            2B9   UserPico.psm
   SendAloop              2BC   UserPico.psm
   ArchiveSource          2CC   UserPico.psm
   EnableArchive          2D3   UserPico.psm
   DisableArchive         2D8   UserPico.psm
   getnextscratchchar     2E1   UserPico.psm
   getnextvalue           2E6   UserPico.psm
   CheckUartRx            2ED   UserPico.psm
   Send2UartTX            2F1   UserPico.psm
   Byte2UART              2F7   UserPico.psm
   SendCRLF               2FC   UserPico.psm
 * SendSPACE              301   UserPico.psm
   delay_1s               304   UserPico.psm
   wait_1s                306   UserPico.psm
 * delay_300ms            30E   UserPico.psm
 * delay_200ms            30F   UserPico.psm
   delay_100ms            312   UserPico.psm
   wait_100ms             313   UserPico.psm
   delay_1ms              317   UserPico.psm
   wait_1ms               319   UserPico.psm
   delay_50us             321   UserPico.psm
   wait_50us              322   UserPico.psm
   delay_1us              326   UserPico.psm
   wait_1us               327   UserPico.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            115
 STAR              -

 AND              46
 OR               17
 XOR               -

 ADD              21
 ADDCY             4
 SUB               9
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          83
 COMPARECY         -

 SL0               6
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               5
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT            19
 OUTPUT           63
 OUTPUTK           -

 STORE            41
 FETCH            41

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP            108
 JUMP@             -
 CALL            169
 CALL@             -
 RETURN           63
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
