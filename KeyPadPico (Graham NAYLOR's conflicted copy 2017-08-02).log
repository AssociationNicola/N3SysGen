KCPSM6 Assembler log file for program 'Z:\home\gnaylor\Dropbox\N3SysGen\KeyPadPico.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 04 Mar 2017
Assembly timestamp: 17:00:54

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 127 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 296
Memory locations available: 3800


Assembly listing

 Addr Code                        Instruction

 000                              ;Modified for 49.162MHz clock
 000                              ;A0 is version to get start and stop tone levels for speaker switching.
 000                              ;
 000                              ;99 - add latch on button facility so don't need handset plugged in.
 000                              ;Now display signal level and gain setting
 000                              ;Switch off key pad oscillation and
 000                              ;Mod to read key pad and display
 000                              ;Version using CoutA
 000                              ;Need to mod to send TX request to User when touchdown active
 000                              ;May 10
 000                              ;
 000                              ; KeyPad routine for SSB picoblaze
 000                              ;
 000                              CONSTANT delay_1us_constant, 06  ; Value (13)19 or 12? decimal suitable for 50MHz clock – about 6 for 33MHz?
 000                              CONSTANT count_1000_lsb, E8      ; hex lower 8-bits of 1000 count value
 000                              CONSTANT count_1000_msb, 03      ; hex upper 8-bits of 1000 count value
 000                              ; Input port - port numbering changed June 11
 000                              CONSTANT Command, 0'd            ; From main pico
 000                              CONSTANT PTT, 1'd                ;This is PTT and default frequency in bits 1 and 2
 000                              CONSTANT RAMdataInLSB, 2'd
 000                              CONSTANT RAMdataInMSB, 3'd
 000                              CONSTANT KP2userbufferFull, 4'd  ;Bit 0 KP2User buffer full, Bit 1 Touch counter running
 000                              CONSTANT TouchSignal2, 5'd       ;This is keypad Bit 0 On, Bit 1 Select, Bit 2 Down, Bit 3 Up
 000                              ;TouchSignal2=0E is On, 0D = Select, 0B = Down, 07= Up
 000                              CONSTANT ADCpeak, 6'd
 000                              CONSTANT DemodPeak, 7'd
 000                              ;CONSTANT SignalLevel,   8'd
 000                              CONSTANT StartToneA, 8'd
 000                              CONSTANT StartToneALong, 9'd
 000                              CONSTANT StartToneB, 10'd
 000                              CONSTANT StartToneBLong, 11'd
 000                              CONSTANT StopToneA, 12'd
 000                              CONSTANT StopToneALong, 13'd
 000                              CONSTANT StopToneB, 14'd
 000                              CONSTANT StopToneBLong, 15'd
 000                              ; Output ports
 000                              CONSTANT CmdToUser, 0'd
 000                              CONSTANT LCD_data_port, 1'd
 000                              CONSTANT LCD_control_port, 2'd
 000                              CONSTANT LCDcontrast, 3'd
 000                              CONSTANT Data2ArchiveMSB, 4'd
 000                              CONSTANT Data2ArchiveLSB, 5'd
 000                              CONSTANT Controlbits, 6'd
 000                              ;Bit offsets:
 000                              CONSTANT AckFIFO, 32'd           ;   bit 5 Acknowledge FIFO (present character)
 000                              CONSTANT RAM_ADD_MSB, 7'd        ;Bits 0 and 1 top too address bits, bit 2 write RAM
 000                              ;Bit offsets:
 000                              CONSTANT WriteKPRAM, 4'd
 000                              CONSTANT RAM_ADD_LSB, 8'd
 000                              CONSTANT LatchOn, 9'd
 000                              CONSTANT RXFreqMSB, 10'd         ; 7546 for 87.956kHz ie 86.956kHz carrier and allow range up to 154kHz 7555 Heyphone
 000                              CONSTANT RXFreqLSB, 11'd
 000                              CONSTANT TXFreqMSB, 12'd         ; 3710  with 49.152MHz clock, with 49.162MHz - need 3709 for N2 and 3711 for Heyphone
 000                              CONSTANT TXFreqLSB, 13'd
 000                              ;TX frequencies:
 000                              ;For 49.152MHz!
 000                              ;Heyphone - 0e80
 000                              ;N2 -       0e7e
 000                              ;N3_31 -    052b
 000                              ;RX frequencies:
 000                              ;Heyphone  - $7555
 000                              ;N2  -       $7546
 000                              ;N3_31  -    $2aad
 000                              ;But for 49.162MHz:
 000                              ;Heyphone - 0e7F
 000                              ;N2 -       0e7d
 000                              ;N3_31 -    052a
 000                              ;RX frequencies:
 000                              ;Heyphone  - $754F
 000                              ;N2  -       $753E
 000                              ;N3_31  -    $2953
 000                              ; Scratchpad registers
 000                              CONSTANT TouchUpLevel, 0'd
 000                              CONSTANT TouchDownLevel, 1'd
 000                              CONSTANT TouchSelectLevel, 2'd
 000                              CONSTANT TX_F_MSB, 3'd
 000                              CONSTANT TX_F_LSB, 4'd
 000                              CONSTANT RX_F_MSB, 5'd
 000                              CONSTANT RX_F_LSB, 6'd
 000                              CONSTANT Freq2Set, 7'd           ; values 0 nothing to set, 1>Hy, 2>N2, 3>N3 (31kHz)
 000                              CONSTANT PreviousKeyState, 10    ; 16d
 000                              CONSTANT PreviousPTTState, 11    ; 17d
 000                              CONSTANT KEYS_PRESSED, 12        ; 18d
 000                              CONSTANT KeyPressTimer, 13       ; 19d
 000                              CONSTANT KeyPressFast, 14        ; 20d
 000                              CONSTANT KeyPressFastLeadIn, 15  ; 20d
 000                              ;;;GenerateCode        MEM       "KeyPadProg.mem"
 000                  cold_start: 
 000             welcome_message: 
 000  01000           initialise: LOAD s0, 00                      ;This is now used to drive LatchOn which latches the device on!!
 001  2D009                       OUTPUT s0, 09[LatchOn]           ;Latch On if 1
 002  2F010                       STORE s0, 10[PreviousKeyState]   ; initial state
 003  2F011                       STORE s0, 11[PreviousPTTState]   ; initial state
 004  2F012                       STORE s0, 12[KEYS_PRESSED]
 005  2F013                       STORE s0, 13[KeyPressTimer]
 006  2F014                       STORE s0, 14[KeyPressFast]
 007  20100                       CALL 100[delay_1s]               ;Wait so it doesn't detect as turn off
 008                              ;LOAD      s5, "&"   ; key event flag
 008                              ;OUTPUT    s5, CmdToUser  ; write to user pico and onto ARM
 008                              ;FETCH   s5, KEYS_PRESSED ; get the keys pressed mask
 008                              ;ADD     s5, "P"   ; convert to appropriate character for key on
 008                              ;OUTPUT    s5, CmdToUser  ; write to user pico and onto ARM
 008                              ;set values for Hey by default
 008  09001                       INPUT s0, 01[PTT]                ;This is PTT but also has set default frequency bits in bits 1 and 2
 009  1400E                       SR0 s0
 00A  03003                       AND s0, 03
 00B                              ;   LOAD    s0,01   ;use 1 for Hey, 2 for N2 freq, 3 for 37kHz
 00B  2F007                       STORE s0, 07[Freq2Set]
 00C  2009A                       CALL 09A[UpdateFreqRegisters]
 00D                              ;Wait and check if ON still pressed
 00D  20100                       CALL 100[delay_1s]
 00E  09505                       INPUT s5, 05[TouchSignal2]
 00F  0350F                       AND s5, 0F
 010  1D50E                       COMPARE s5, 0E                   ;is 'ON' pressed
 011  36016                       JUMP NZ, 016[loop]               ;if not ON button, skip
 012  01001                       LOAD s0, 01                      ;This is now used to drive PMOD1 which latches the device on!!
 013  2D009                       OUTPUT s0, 09[LatchOn]           ;Latch On
 014  20100                       CALL 100[delay_1s]               ;Wait so it doesn't detect as turn off!
 015  20100                       CALL 100[delay_1s]               ;Wait so it doesn't detect as turn off!
 016                        loop: 
 016  2010E                       CALL 10E[delay_50msecs]          ; period between checks
 017                              ;CALL   delay_1s    ;Wait so it doesn't detect as turn off!
 017  09000                       INPUT s0, 00[Command]            ;Check if FIFO character present
 018  1D080                       COMPARE s0, 80[128'd]            ; is there a character?
 019  3809F                       CALL C, 09F[Respond2Fifo]        ;this should now receive value of mode from user pico and display on LCD
 01A  09105                       INPUT s1, 05[TouchSignal2]       ; read the keys touched register
 01B  071FF                       XOR s1, FF                       ; invert so ON is a 1
 01C  0310F                       AND s1, 0F                       ; mask to the key press bits
 01D                              ;LOAD      s5, "&"   ; key event flag
 01D                              ;OUTPUT    s5, CmdToUser  ; write to user pico and onto ARM
 01D                              ;LOAD      s5, s1
 01D                              ;ADD     s5, "@"   ; convert to appropriate character for key on
 01D                              ;ADD     s5, 60   ; temp should get a through h
 01D                              ;OUTPUT    s5, CmdToUser  ; write to user pico and onto ARM
 01D                              ;JUMP      CheckPTT
 01D  0B510                       FETCH s5, 10[PreviousKeyState]   ; get last key pressed state
 01E  1C150                       COMPARE s1, s5
 01F                              ;JUMP      Z, CheckPTT      ; skip if input state not changed
 01F  32031                       JUMP Z, 031[KeyNotChanged]       ; skip if input state not changed
 020  2F110                       STORE s1, 10[PreviousKeyState]   ; remember new state
 021  0B512                       FETCH s5, 12[KEYS_PRESSED]       ; get the keys pressed mask
 022  04510                       OR s5, s1                        ; remember which keys have been pressed
 023  2F512                       STORE s5, 12[KEYS_PRESSED]       ; remember new state
 024  1D100                       COMPARE s1, 00                   ; are there any keys pressed now?
 025  36031                       JUMP NZ, 031[KeyNotChanged]      ; skip if keys still pressed
 026                              ;JUMP      nz, CheckPTT          ; skip if keys still pressed
 026  01526                       LOAD s5, 26["&"]                 ; key event flag
 027  2D500                       OUTPUT s5, 00[CmdToUser]         ; write to user pico and onto ARM
 028  0B512                       FETCH s5, 12[KEYS_PRESSED]       ; get the keys pressed mask
 029  11540                       ADD s5, 40["@"]                  ; convert to appropriate character
 02A  2D500                       OUTPUT s5, 00[CmdToUser]         ; write to user pico and onto ARM
 02B                              ;#define KEY_UP  'H'  // up = 08
 02B                              ;#define KEY_DOWN 'D'  // down = 04
 02B                              ;#define KEY_RIGHT 'B'  // right = 02
 02B                              ;#define KEY_LEFT 'A'  // left = 01
 02B                              ;#define KEY_UPLEFT 'I'  // 08 + 01
 02B                              ;#define KEY_PTT_ON  '0'
 02B                              ;#define KEY_PTT_OFF '1'
 02B  01000                       LOAD s0, 00                      ; reset the keys pressed
 02C  2F012                       STORE s0, 12[KEYS_PRESSED]
 02D  2F013                       STORE s0, 13[KeyPressTimer]
 02E  2F014                       STORE s0, 14[KeyPressFast]
 02F  2F015                       STORE s0, 15[KeyPressFastLeadIn]
 030  2204D                       JUMP 04D[CheckPTT]
 031                              ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 031               KeyNotChanged: 
 031                              ;;; check for key pressed for a period and tell ARM if so
 031  0B112                       FETCH s1, 12[KEYS_PRESSED]       ; get the keys pressed mask
 032  1D100                       COMPARE s1, 00                   ; any keys pressed
 033  3204D                       JUMP Z, 04D[CheckPTT]            ; if not then do not time
 034  0B214                       FETCH s2, 14[KeyPressFast]       ; has key been pressed a while?
 035  1D200                       COMPARE s2, 00                   ;
 036  3203D                       JUMP Z, 03D[SlowPress]           ; skip if slow presses
 037                   FastPress: 
 037  0B213                       FETCH s2, 13[KeyPressTimer]
 038  11201                       ADD s2, 01                       ; increment by approx loop time (50 milli sec?)
 039  2F213                       STORE s2, 13[KeyPressTimer]
 03A  03207                       AND s2, 07                       ; if key pressed for .3 secs approx (32 ticks)
 03B  3604D                       JUMP NZ, 04D[CheckPTT]           ; if not then no message
 03C  22042                       JUMP 042[SlowPressSend]
 03D                   SlowPress: 
 03D  0B213                       FETCH s2, 13[KeyPressTimer]
 03E  11201                       ADD s2, 01                       ; increment by approx loop time (50 milli sec?)
 03F  2F213                       STORE s2, 13[KeyPressTimer]
 040  0320F                       AND s2, 0F                       ; if key pressed for 1.5 secs approx (32 ticks)
 041  3604D                       JUMP NZ, 04D[CheckPTT]           ; if not then no message
 042               SlowPressSend: 
 042  01526                       LOAD s5, 26["&"]                 ; key event flag
 043  2D500                       OUTPUT s5, 00[CmdToUser]         ; write to user pico and onto ARM
 044  0B512                       FETCH s5, 12[KEYS_PRESSED]       ; get the keys pressed mask
 045  11550                       ADD s5, 50["P"]                  ; convert to appropriate character for key on
 046  2D500                       OUTPUT s5, 00[CmdToUser]         ; write to user pico and onto ARM
 047  0B215                       FETCH s2, 15[KeyPressFastLeadIn]
 048  11201                       ADD s2, 01                       ; increment by approx loop time (50 milli sec?)
 049  2F215                       STORE s2, 15[KeyPressFastLeadIn]
 04A  1D204                       COMPARE s2, 04                   ; approx 2 seconds?
 04B  3604D                       JUMP NZ, 04D[CheckPTT]           ; keep slow presses till then
 04C  2F214                       STORE s2, 14[KeyPressFast]       ; start fast key press
 04D                              ;;; now check PTT
 04D                    CheckPTT: 
 04D  09101                       INPUT s1, 01[PTT]                ;Read PTT register
 04E  03101                       AND s1, 01                       ;Mask lowest bit
 04F  0B511                       FETCH s5, 11[PreviousPTTState]
 050  1C150                       COMPARE s1, s5                   ; has it changed
 051  32016                       JUMP Z, 016[loop]                ; loop back if not
 052  2F111                       STORE s1, 11[PreviousPTTState]
 053                              ; send PTT state -
 053                              ;  0 = PTT pressed   1 = PTT released
 053  01526                       LOAD s5, 26["&"]
 054  2D500                       OUTPUT s5, 00[CmdToUser]
 055  11130                       ADD s1, 30["0"]                  ; PTT pressed = '0'; PTT released = '1'
 056  2D100                       OUTPUT s1, 00[CmdToUser]
 057                              ;COMPARE    s1, 00 ; debug
 057                              ;JUMP       Z, PTTOFF ; debug
 057                              ; debug      LOAD   s5, "r"
 057                              ; debug      OUTPUT    s5, CmdToUser
 057  22016                       JUMP 016[loop]
 058                              ;PTTOFF:
 058                              ; debug      LOAD   s5, "t"
 058                              ; debug      OUTPUT    s5, CmdToUser
 058                              ;                   JUMP   loop
 058  20100                       CALL 100[delay_1s]
 059  09505                       INPUT s5, 05[TouchSignal2]
 05A  0350F                       AND s5, 0F
 05B  1D50F                       COMPARE s5, 0F                   ;not $F if pressed
 05C  31000                       RETURN Z                         ;return if key not still pressed
 05D  3005E                       CALL Z, 05E[TurnOff]
 05E                              ;Note key pad bits are: bit3 = On, bit 2 = up, bit 1 = select, bit 0 = down
 05E  01000              TurnOff: LOAD s0, 00                      ;This is now used to drive PMOD1 which latches the device on!!
 05F  2D009                       OUTPUT s0, 09[LatchOn]           ;Latch On if 1
 060  25000                       RETURN 
 061  0B007               upFreq: FETCH s0, 07[Freq2Set]
 062  11001                       ADD s0, 01
 063  03003                       AND s0, 03
 064  2F007                       STORE s0, 07[Freq2Set]
 065  2206B                       JUMP 06B[CheckWhichFreq]
 066  0B007             DownFreq: FETCH s0, 07[Freq2Set]
 067  19001                       SUB s0, 01
 068  03003                       AND s0, 03
 069  2F007                       STORE s0, 07[Freq2Set]
 06A  2206B                       JUMP 06B[CheckWhichFreq]
 06B  1D000       CheckWhichFreq: COMPARE s0, 00
 06C  30074                       CALL Z, 074[ClearFreq]           ;clear set display
 06D  1D001                       COMPARE s0, 01
 06E  30077                       CALL Z, 077[SetHeyphoneFreq]     ;set Hy freq and return
 06F  1D002                       COMPARE s0, 02
 070  30084                       CALL Z, 084[SetN2Freq]
 071  1D003                       COMPARE s0, 03
 072  3008F                       CALL Z, 08F[SetN3_31Freq]
 073  25000                       RETURN 
 074  01B20            ClearFreq: LOAD sB, 20[" "]                 ; character_space
 075  01C20                       LOAD sC, 20[" "]                 ; character_space
 076  25000                       RETURN 
 077                              ;TX frequencies:
 077                              ;for 49.162MHz!:
 077                              ;Heyphone - 0e7F
 077                              ;N2 -       0e7d
 077                              ;N3_31 -    052a
 077                              ;RX frequencies:
 077                              ;Heyphone  - $754F
 077                              ;N2  -       $753E
 077                              ;N3_31  -    $2953
 077                              ; with 49.162MHzMHz!
 077  0110E      SetHeyphoneFreq: LOAD s1, 0E
 078  2F103                       STORE s1, 03[TX_F_MSB]
 079  0117F                       LOAD s1, 7F
 07A  2F104                       STORE s1, 04[TX_F_LSB]
 07B  01175                       LOAD s1, 75
 07C  2F105                       STORE s1, 05[RX_F_MSB]
 07D  0114F                       LOAD s1, 4F
 07E  2F106                       STORE s1, 06[RX_F_LSB]
 07F                              ;LOAD   sB,"h"  ; character_h
 07F                              ;LOAD   sC,"y"  ; character_y
 07F  01526                       LOAD s5, 26["&"]                 ; key event flag
 080  2D500                       OUTPUT s5, 00[CmdToUser]         ; write to user pico and onto ARM
 081  01577                       LOAD s5, 77["w"]                 ; key event flag
 082  2D500                       OUTPUT s5, 00[CmdToUser]         ; write to user pico and onto ARM
 083  25000                       RETURN 
 084                              ;For N3 5565 (15BD) TX and  45032 (AFE8) RX with 32.768MHz!
 084  0110E            SetN2Freq: LOAD s1, 0E
 085  2F103                       STORE s1, 03[TX_F_MSB]
 086  0117D                       LOAD s1, 7D
 087  2F104                       STORE s1, 04[TX_F_LSB]
 088  01175                       LOAD s1, 75
 089  2F105                       STORE s1, 05[RX_F_MSB]
 08A  0113E                       LOAD s1, 3E
 08B  2F106                       STORE s1, 06[RX_F_LSB]
 08C  01B6E                       LOAD sB, 6E["n"]                 ; character_n
 08D  01C32                       LOAD sC, 32["2"]                 ; character_2
 08E  25000                       RETURN 
 08F                              ;For 31kH 1984 TX (07C0)    16384 for RX (4000 hex) with 32.768MHz!
 08F  01105         SetN3_31Freq: LOAD s1, 05
 090  2F103                       STORE s1, 03[TX_F_MSB]
 091  0112A                       LOAD s1, 2A
 092  2F104                       STORE s1, 04[TX_F_LSB]
 093  01129                       LOAD s1, 29
 094  2F105                       STORE s1, 05[RX_F_MSB]
 095  01153                       LOAD s1, 53
 096  2F106                       STORE s1, 06[RX_F_LSB]
 097  01B33                       LOAD sB, 33["3"]                 ; character_3
 098  01C31                       LOAD sC, 31["1"]                 ; character_1
 099  25000                       RETURN 
 09A         UpdateFreqRegisters: 
 09A                              ;CALL    SetHeyphoneFreq    ;set Hy freq and return
 09A  0B007                       FETCH s0, 07[Freq2Set]
 09B  2006B                       CALL 06B[CheckWhichFreq]
 09C  200B4                       CALL 0B4[SetTxFreq]
 09D  200B9                       CALL 0B9[SetRxFreq]
 09E  25000                       RETURN 
 09F                              ;Get fifo command and act on it. Echo ascii value to LCD
 09F                Respond2Fifo: ;CALL LCD_cursor_back
 09F  200C1                       CALL 0C1[GetFifoChar]
 0A0               Respond2FifoW: 
 0A0  09000                       INPUT s0, 00[Command]            ;Check if FIFO character present
 0A1  1D080                       COMPARE s0, 80[128'd]            ; is there a character?
 0A2  3E0A0                       JUMP NC, 0A0[Respond2FifoW]      ;this should now receive value of mode from user pico and display on LCD
 0A3  200C1                       CALL 0C1[GetFifoChar]
 0A4  1D05A                       COMPARE s0, 5A["Z"]              ; Z = turn off
 0A5  3005E                       CALL Z, 05E[TurnOff]
 0A6  1D079                       COMPARE s0, 79["y"]              ; y - turn on LCD
 0A7  300AD                       CALL Z, 0AD[TurnLCDOn]
 0A8  1D059                       COMPARE s0, 59["Y"]              ; Y - turn off LCD
 0A9  300B0                       CALL Z, 0B0[TurnLCDOff]
 0AA  1D004                       COMPARE s0, 04                   ;character T (request for info from userpico) ->LESS TOP BIT WHICH IS NOT SENT!
 0AB  300BE                       CALL Z, 0BE[SendParamBack]
 0AC  25000                       RETURN 
 0AD                   TurnLCDOn: 
 0AD  01001                       LOAD s0, 01
 0AE  2D003                       OUTPUT s0, 03[LCDcontrast]       ;
 0AF  25000                       RETURN 
 0B0                  TurnLCDOff: 
 0B0  01000                       LOAD s0, 00
 0B1  2D003                       OUTPUT s0, 03[LCDcontrast]       ;
 0B2  25000                       RETURN 
 0B3                              ; Added code to display ADC and demod peak values
 0B3  25000                       RETURN 
 0B4                              ;Enter with s0 - LSB, s1 - MSB
 0B4  0B003            SetTxFreq: FETCH s0, 03[TX_F_MSB]           ; Value for TX frequency being used
 0B5  2D00C                       OUTPUT s0, 0C[TXFreqMSB]
 0B6  0B004                       FETCH s0, 04[TX_F_LSB]
 0B7  2D00D                       OUTPUT s0, 0D[TXFreqLSB]         ; and send value to SSB modulator
 0B8  25000                       RETURN 
 0B9  0B005            SetRxFreq: FETCH s0, 05[RX_F_MSB]           ; Value for RX frequency being used
 0BA  2D00A                       OUTPUT s0, 0A[RXFreqMSB]
 0BB  0B006                       FETCH s0, 06[RX_F_LSB]
 0BC  2D00B                       OUTPUT s0, 0B[RXFreqLSB]         ; and send value to SSB demodulator
 0BD  25000                       RETURN 
 0BE                              ;Select:   CALL GetFifoChar
 0BE                              ;     OUT  s0,ChooseTouchKey
 0BE                              ;     RETURN
 0BE  09501        SendParamBack: INPUT s5, 01[PTT]                ;********************TEST reading touch***********************************
 0BF  200C7                       CALL 0C7[Export2User]
 0C0  25000                       RETURN 
 0C1                              ; Routine to recover a character from the FIFO in s0
 0C1  01020          GetFifoChar: LOAD s0, 20[AckFIFO]
 0C2  2D006                       OUTPUT s0, 06[Controlbits]
 0C3  01020                       LOAD s0, 20[AckFIFO]             ;Wait
 0C4  09000                       INPUT s0, 00[Command]            ; now get my character
 0C5  0307F                       AND s0, 7F                       ; mask of top bit
 0C6  25000                       RETURN 
 0C7                              ; Takes value in s5 and converts to 2 ascii codes which are sent to the user picoblaze.
 0C7  200ED          Export2User: CALL 0ED[Byte2Chars]
 0C8  2D600                       OUTPUT s6, 00[CmdToUser]
 0C9  2D700                       OUTPUT s7, 00[CmdToUser]
 0CA  0100D                       LOAD s0, 0D[13'd]                ;terminate with CR
 0CB  2D000                       OUTPUT s0, 00[CmdToUser]
 0CC  0100A                       LOAD s0, 0A[10'd]                ;and with LF
 0CD  2D000                       OUTPUT s0, 00[CmdToUser]
 0CE  25000                       RETURN 
 0CF                              ; routine to look at command input and recover 2 characters and return the byte they represent in s5.
 0CF  09600            Get2Chars: INPUT s6, 00[Command]
 0D0  1D680                       COMPARE s6, 80[128'd]            ; if greater than 128, then no character
 0D1  3E0CF                       JUMP NC, 0CF[Get2Chars]
 0D2  200C1                       CALL 0C1[GetFifoChar]
 0D3  00600                       LOAD s6, s0
 0D4  09700           Get2ndChar: INPUT s7, 00[Command]
 0D5  1D780                       COMPARE s7, 80[128'd]            ; if greater than 128, then no character
 0D6  3E0D4                       JUMP NC, 0D4[Get2ndChar]
 0D7  200C1                       CALL 0C1[GetFifoChar]
 0D8  00700                       LOAD s7, s0
 0D9  220DA                       JUMP 0DA[Chars2Byte]
 0DA                              ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 0DA  00860           Chars2Byte: LOAD s8, s6
 0DB  200E5                       CALL 0E5[Get4bits]
 0DC  00580                       LOAD s5, s8
 0DD  14506                       SL0 s5
 0DE  14506                       SL0 s5
 0DF  14506                       SL0 s5
 0E0  14506                       SL0 s5                           ; put these 4 bits to MSBs
 0E1  00870                       LOAD s8, s7
 0E2  200E5                       CALL 0E5[Get4bits]
 0E3  10580                       ADD s5, s8
 0E4  25000                       RETURN 
 0E5                              ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 0E5  1D83C             Get4bits: COMPARE s8, 3C[60'd]             ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 0E6  3A0EA                       JUMP C, 0EA[char0_9]
 0E7  19837                       SUB s8, 37[55'd]                 ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 0E8  0380F                       AND s8, 0F                       ; make sure only return 4 bits
 0E9  25000                       RETURN 
 0EA  19830              char0_9: SUB s8, 30[48'd]
 0EB  0380F                       AND s8, 0F                       ; make sure only return 4 bits
 0EC  25000                       RETURN 
 0ED                              ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 0ED  00850           Byte2Chars: LOAD s8, s5                      ; assumes 8 bit data is in s5
 0EE  1450E                       SR0 s5
 0EF  1450E                       SR0 s5
 0F0  1450E                       SR0 s5
 0F1  1450E                       SR0 s5                           ; get first hex character
 0F2  200F9                       CALL 0F9[GetChar]
 0F3  00650                       LOAD s6, s5                      ; first ascii char
 0F4  00580                       LOAD s5, s8
 0F5  0350F                       AND s5, 0F
 0F6  200F9                       CALL 0F9[GetChar]                ; send to LCD or UART
 0F7  00750                       LOAD s7, s5                      ; second ascii char
 0F8  25000                       RETURN 
 0F9                              ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 0F9  1950A              GetChar: SUB s5, 0A[10'd]                 ; Test if s5 greater than 9
 0FA  3A0FD                       JUMP C, 0FD[is_0_9]              ; Hex character is 0_9
 0FB  11541                       ADD s5, 41[65'd]                 ; offset for Ascii code 'A'
 0FC  25000                       RETURN 
 0FD  1150A               is_0_9: ADD s5, 0A[10'd]                 ; return to range 0-9
 0FE  11530                       ADD s5, 30[48'd]                 ; offset to Ascii code for '0'
 0FF  25000                       RETURN 
 100                              ; Registers used s0, s1, s2, s3, s4 and s5.
 100                              ;
 100  01500             delay_1s: LOAD s5, 00                      ; clear cycle counter
 101  01400                       LOAD s4, 00
 102  20115              wait_1s: CALL 115[delay_1ms]
 103  11401                       ADD s4, 01                       ; increment cycle counter
 104  13500                       ADDCY s5, 00
 105  1D4E8                       COMPARE s4, E8[count_1000_lsb]   ; test for 1000ms
 106  36102                       JUMP NZ, 102[wait_1s]
 107  1D503                       COMPARE s5, 03[count_1000_msb]
 108  36102                       JUMP NZ, 102[wait_1s]
 109  25000                       RETURN 
 10A                              ;
 10A                              ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 10A                              ;
 10A                              ;
 10A                              ; Registers used s0, s1, s2, s3 and s4.
 10A                              ;
 10A  20110          delay_300ms: CALL 110[delay_100ms]
 10B  20110          delay_200ms: CALL 110[delay_100ms]
 10C  20110                       CALL 110[delay_100ms]
 10D  25000                       RETURN 
 10E                              ;
 10E                              ; Delay of approximately 100ms used for switch debounce
 10E                              ;
 10E                              ; Registers used s0, s1, s2, s3 and s4.
 10E                              ;
 10E  01432        delay_50msecs: LOAD s4, 32                      ; repeat 1ms delay 100 times
 10F  22111                       JUMP 111[wait_100ms]
 110  01464          delay_100ms: LOAD s4, 64                      ; repeat 1ms delay 100 times
 111  20115           wait_100ms: CALL 115[delay_1ms]
 112  19401                       SUB s4, 01
 113  36111                       JUMP NZ, 111[wait_100ms]
 114  25000                       RETURN 
 115                              ;
 115                              ; Delay of approximately 1ms required by LCD display
 115                              ;
 115                              ; Registers used s0, s1, s2 and s3.
 115                              ;
 115  01300            delay_1ms: LOAD s3, 00                      ; clear cycle counter
 116  01200                       LOAD s2, 00
 117  20124             wait_1ms: CALL 124[delay_1us]
 118  11201                       ADD s2, 01                       ; increment cycle counter
 119  13300                       ADDCY s3, 00
 11A  1D2E8                       COMPARE s2, E8[count_1000_lsb]   ; test for 1000us
 11B  36117                       JUMP NZ, 117[wait_1ms]
 11C  1D303                       COMPARE s3, 03[count_1000_msb]
 11D  36117                       JUMP NZ, 117[wait_1ms]
 11E  25000                       RETURN 
 11F                              ;
 11F                              ; Delay of approximately 50us required by LCD display
 11F                              ;
 11F                              ; Registers used s0 and s1.
 11F                              ;
 11F  01132           delay_50us: LOAD s1, 32[50'd]                ; repeat 1us delay 50 times
 120  20124            wait_50us: CALL 124[delay_1us]
 121  19101                       SUB s1, 01
 122  36120                       JUMP NZ, 120[wait_50us]
 123  25000                       RETURN 
 124                              ; Delay of approximately 1us used to provide timing reference for
 124                              ; LCD operations. This must be adjusted to reflect the clock
 124                              ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 124                              ;
 124                              ; The software delay loop is formed using register s0. This register
 124                              ; must be loaded with an integer value close to the result of....
 124                              ;
 124                              ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 124                              ;
 124                              ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 124                              ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 124                              ; operation will become lower than the 100KHz target intended.
 124                              ;
 124                              ; Register used s0.
 124                              ;
 124  01006            delay_1us: LOAD s0, 06[delay_1us_constant]  ; delay value of 12 decimal for a 50MHz clock
 125  19001             wait_1us: SUB s0, 01
 126  36125                       JUMP NZ, 125[wait_1us]
 127  25000                       RETURN 
 128                              ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\home\gnaylor\Dropbox\N3SysGen\KeyPadPico.psm



List of defined constants

 CONSTANT name      Value        Source PSM File

 timestamp_hours    17'd         
 timestamp_minutes  00'd         
 timestamp_seconds  54'd         
 datestamp_year     17'd         
 datestamp_month    3'd          
 datestamp_day      04'd         
 NUL                00           
 BEL                07           
 BS                 08           
 HT                 09           
 LF                 0A           
 VT                 0B           
 CR                 0D           
 ESC                1B           
 DEL                7F           
 DCS                90           
 ST                 9C           
 delay_1us_constant 06           KeyPadPico.psm
 count_1000_lsb     E8           KeyPadPico.psm
 count_1000_msb     03           KeyPadPico.psm
 Command            0'd          KeyPadPico.psm
 PTT                1'd          KeyPadPico.psm
 RAMdataInLSB       2'd          KeyPadPico.psm
 RAMdataInMSB       3'd          KeyPadPico.psm
 KP2userbufferFull  4'd          KeyPadPico.psm
 TouchSignal2       5'd          KeyPadPico.psm
 ADCpeak            6'd          KeyPadPico.psm
 DemodPeak          7'd          KeyPadPico.psm
 StartToneA         8'd          KeyPadPico.psm
 StartToneALong     9'd          KeyPadPico.psm
 StartToneB         10'd         KeyPadPico.psm
 StartToneBLong     11'd         KeyPadPico.psm
 StopToneA          12'd         KeyPadPico.psm
 StopToneALong      13'd         KeyPadPico.psm
 StopToneB          14'd         KeyPadPico.psm
 StopToneBLong      15'd         KeyPadPico.psm
 CmdToUser          0'd          KeyPadPico.psm
 LCD_data_port      1'd          KeyPadPico.psm
 LCD_control_port   2'd          KeyPadPico.psm
 LCDcontrast        3'd          KeyPadPico.psm
 Data2ArchiveMSB    4'd          KeyPadPico.psm
 Data2ArchiveLSB    5'd          KeyPadPico.psm
 Controlbits        6'd          KeyPadPico.psm
 AckFIFO            32'd         KeyPadPico.psm
 RAM_ADD_MSB        7'd          KeyPadPico.psm
 WriteKPRAM         4'd          KeyPadPico.psm
 RAM_ADD_LSB        8'd          KeyPadPico.psm
 LatchOn            9'd          KeyPadPico.psm
 RXFreqMSB          10'd         KeyPadPico.psm
 RXFreqLSB          11'd         KeyPadPico.psm
 TXFreqMSB          12'd         KeyPadPico.psm
 TXFreqLSB          13'd         KeyPadPico.psm
 TouchUpLevel       0'd          KeyPadPico.psm
 TouchDownLevel     1'd          KeyPadPico.psm
 TouchSelectLevel   2'd          KeyPadPico.psm
 TX_F_MSB           3'd          KeyPadPico.psm
 TX_F_LSB           4'd          KeyPadPico.psm
 RX_F_MSB           5'd          KeyPadPico.psm
 RX_F_LSB           6'd          KeyPadPico.psm
 Freq2Set           7'd          KeyPadPico.psm
 PreviousKeyState   10           KeyPadPico.psm
 PreviousPTTState   11           KeyPadPico.psm
 KEYS_PRESSED       12           KeyPadPico.psm
 KeyPressTimer      13           KeyPadPico.psm
 KeyPressFast       14           KeyPadPico.psm
 KeyPressFastLeadIn 15           KeyPadPico.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "04 Mar 2017"  
 timestamp$        "17:00:54"     



List of line labels

   Label                 Addr  Source PSM File

 * cold_start            000   KeyPadPico.psm
 * welcome_message       000   KeyPadPico.psm
 * initialise            000   KeyPadPico.psm
   loop                  016   KeyPadPico.psm
   KeyNotChanged         031   KeyPadPico.psm
 * FastPress             037   KeyPadPico.psm
   SlowPress             03D   KeyPadPico.psm
   SlowPressSend         042   KeyPadPico.psm
   CheckPTT              04D   KeyPadPico.psm
   TurnOff               05E   KeyPadPico.psm
 * upFreq                061   KeyPadPico.psm
 * DownFreq              066   KeyPadPico.psm
   CheckWhichFreq        06B   KeyPadPico.psm
   ClearFreq             074   KeyPadPico.psm
   SetHeyphoneFreq       077   KeyPadPico.psm
   SetN2Freq             084   KeyPadPico.psm
   SetN3_31Freq          08F   KeyPadPico.psm
   UpdateFreqRegisters   09A   KeyPadPico.psm
   Respond2Fifo          09F   KeyPadPico.psm
   Respond2FifoW         0A0   KeyPadPico.psm
   TurnLCDOn             0AD   KeyPadPico.psm
   TurnLCDOff            0B0   KeyPadPico.psm
   SetTxFreq             0B4   KeyPadPico.psm
   SetRxFreq             0B9   KeyPadPico.psm
   SendParamBack         0BE   KeyPadPico.psm
   GetFifoChar           0C1   KeyPadPico.psm
   Export2User           0C7   KeyPadPico.psm
   Get2Chars             0CF   KeyPadPico.psm
   Get2ndChar            0D4   KeyPadPico.psm
   Chars2Byte            0DA   KeyPadPico.psm
   Get4bits              0E5   KeyPadPico.psm
   char0_9               0EA   KeyPadPico.psm
   Byte2Chars            0ED   KeyPadPico.psm
   GetChar               0F9   KeyPadPico.psm
   is_0_9                0FD   KeyPadPico.psm
   delay_1s              100   KeyPadPico.psm
   wait_1s               102   KeyPadPico.psm
 * delay_300ms           10A   KeyPadPico.psm
 * delay_200ms           10B   KeyPadPico.psm
   delay_50msecs         10E   KeyPadPico.psm
   delay_100ms           110   KeyPadPico.psm
   wait_100ms            111   KeyPadPico.psm
   delay_1ms             115   KeyPadPico.psm
   wait_1ms              117   KeyPadPico.psm
 * delay_50us            11F   KeyPadPico.psm
   wait_50us             120   KeyPadPico.psm
   delay_1us             124   KeyPadPico.psm
   wait_1us              125   KeyPadPico.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             50
 STAR              -

 AND              13
 OR                1
 XOR               1

 ADD              13
 ADDCY             2
 SUB               7
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          25
 COMPARECY         -

 SL0               4
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               5
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT            11
 OUTPUT           22
 OUTPUTK           -

 STORE            17
 FETCH            17

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             28
 JUMP@             -
 CALL             37
 CALL@             -
 RETURN           29
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
