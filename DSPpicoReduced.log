KCPSM6 Assembler log file for program 'Z:\home\graham\Dropbox\N3workingG\TE0722Rebuild\N3SysGen\DSPpicoReduced.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 11 Jul 2016
Assembly timestamp: 22:47:45

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 2AA hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 683
Memory locations available: 3413


Assembly listing

 Addr Code                           Instruction

 000                                 ;GV07 correct incorrect data archive and demod peak display problem (MSB/LSB mixup!)
 000                                 ;GV06 increase SSB amplitude on TX
 000                                 ;GV03 corrected OutAmp doubling and increased speaker volume
 000                                 ;GV02 Halved AGC thresholds to avoid clipping
 000                                 ;GV01 Reduce Speaker volume by increasing AGC value to 63 on startup
 000                                 ;GV00 return counter to zero for new Zynq design
 000                                 ;GVA5 for TE0722, with RX/TX frequencies adjusted for 32.768MHz (mod in Keypad assembler)
 000                                 ;GVA4 correct bad setting of AvesignalMSB instead of USB (caused crashing)
 000                                 ;GVA2 BT input from mic is taken externally in logic - also removed audio double so as not to saturate voice on transmission (but will drop volume on handset ~6dB)
 000                                 ;AND over haul AGC to use 24 bit average level registering so level is monitored with AveSignalUSB
 000                                 ;GVA1 Try to implement tone detect parts
 000                                 ;GVA0 Project to get AGC to act on external MUX, but still use last 4 bits for decrease 3dB and 1.5dB in the Pico
 000                                 ;GV9B to do - mods to detect start and end tones
 000                                 ;GV96 readjust AGC settings and bit offsets
 000                                 ;GV93add back divide by 2 on transmit line 567
 000                                 ; GV51 remove level divide by 2 on transmit to compensate for drop in AGC level (so only reduces level for receive)
 000                                 ;GV50, drop DSP AGC levels back to just below as in GV45
 000                                 ;GV47 increase DSP AGC thresholds
 000                                 ;GV46 added further double on RF out amplitude
 000                                 ;GV45 Corrected resetting of AveSignalMSB to middle value so as to avoid double jump and increased allowable rang to avoid unnecessary jumps (abd corrected AGC wrapping in GV44 when limiting if greater than 44 rather than to 44 ie CALL Z not CALL NC !!!)
 000                                 ;GV44 add 1_5dB decrease - still need to correct AGC range (increase another factor 2) and decrease limits
 000                                 ;GV43 correct beacon phase wander
 000                                 ;GV42 disable UART streaming
 000                                 ;GV3F Add streaming over UART on TX (State bit 2 set)
 000                                 ;GV3E try adding small sine wave - not yet implemented
 000                                 ;For GV3D, need to add further routines, increaseAGC2 and increaseAGC4 that increase attenuation 6dB and 12dB respectively (within limits) - look at how AveSignalMSB is reset.
 000                                 ;For GV3B try to correct incorrect AGC operation with twice as many values
 000                                 ;store TX AGCvalue before warble (or when stable) and add 3dB steps to AGCvalue
 000                                 ;31/1/13 Added 12dB to BT mic level using Audiodouble
 000                                 ;GV38 Use audio double on transmitpath
 000                                 ;For GV37 Adjusted AGC thresholds and increased time constant a factor 8.
 000                                 ;31/12/12 increase volume and transmitted power by increasing AGC setting a factor of 2 (from 4,12 to 8,24 - AGCupp/lowthreshold). Also set AGCvalue to 06 INITIALY (may need to be adjusted) recall last AGCvalue when switch mode. Line 439 increase TX modulation.
 000                                 ;removed LPF
 000                                 ;Increased AGC setting -36 OK, 72 too high (bad clipping noise)
 000                                 ;Slow saturation of SSBamp
 000                                 ;Added BT signal not present flag (16/1/12)
 000                                 ;Try to fix failure to un-block DSP problem (18/11/11 in DSPblock routine)
 000                                 ;Uses phase representation of TX audio - works in study OK 18/11/11
 000                                 ;29/8/11 Increased audio frequency resolution to 16 bits
 000                                 ;19/8/11, tweaked audio scaling of TX
 000                                 ;Modified vor BT input
 000                                 ;This needs to be modified for COTS version at 49.152MHz - in particular calibration of audio frequency output to SSB modulator has been modified see line 398
 000                                 ; Inputs sine wave as audio
 000                                 ; 20/7 updated input and output ports for multipico version
 000                                 ; Feb 09 Start testing AGC part of streamed signal
 000                                 ; Now implementing on SSBN.mdl
 000                                 ;
 000                                 ; DSP routine for SSB picoblaze
 000                                 ;
 000                                 ; Implemented commands:
 000                                 ; 0 = RX mode
 000                                 CONSTANT AGClowthreshold, 3'd                  ;;These are thresholds for the measured signal
 000                                 CONSTANT AGClowthreshold2, 1'd                 ;;These are thresholds for the measured signal
 000                                 CONSTANT AGCInitial, 4'd                       ;;This is mid way between thresholds
 000                                 CONSTANT AGCuppthreshold, 5'd
 000                                 CONSTANT AGCuppthreshold2, 8'd                 ;3dB above first threshold
 000                                 CONSTANT AGCuppthreshold4, 11'd
 000                                 CONSTANT delay_1us_constant, 06                ; Value (13)19 or 12? decimal suitable for 50MHz clock – about 6 for 33MHz?
 000                                 CONSTANT m, 8'd                                ; No. of iterations for cordic
 000                                 CONSTANT m_plus_1, 9'd                         ; No. of iterations for cordic
 000                                 CONSTANT count_1000_lsb, E8                    ; lower 8-bits of 1000 count value
 000                                 CONSTANT count_1000_msb, 03                    ; upper 8-bits of 1000 count value
 000                                 CONSTANT half_pi_LSB, 00                       ;
 000                                 CONSTANT half_pi_MSB, 40                       ; 360 degrees = $10000
 000                                 CONSTANT audioTest, 2'd                        ; Frequency 2=800Hz, 3=1200Hz, 4=1.6kHz 7=2.8kHz
 000                                 ;Frequency values for start and stop tones
 000                                 CONSTANT StrtToneAInc, 9F
 000                                 CONSTANT StrtToneBInc, 69
 000                                 CONSTANT StopToneAInc, 5A
 000                                 CONSTANT StopToneBInc, 78
 000                                 ; FIR coefficients for 0 and 90 degree filterred signals, these are SIGNED values!!
 000                                 CONSTANT coeffI0MSB, F6                        ; Smallest coefficient (negative value!)
 000                                 CONSTANT coeffI0LSB, 92
 000                                 CONSTANT coeffI1MSB, F4
 000                                 CONSTANT coeffI1LSB, 8A
 000                                 CONSTANT coeffI2MSB, F2
 000                                 CONSTANT coeffI2LSB, CC
 000                                 CONSTANT coeffI3MSB, F1
 000                                 CONSTANT coeffI3LSB, 77
 000                                 CONSTANT coeffI4MSB, F0
 000                                 CONSTANT coeffI4LSB, A1
 000                                 CONSTANT coeffI5MSB, 40                        ; Actualy half value of peak
 000                                 CONSTANT coeffI5LSB, 00
 000                                 ; Q values are still signed but are all positive
 000                                 CONSTANT coeffQ0MSB, 00                        ; Smallest coefficient
 000                                 CONSTANT coeffQ0LSB, A7
 000                                 CONSTANT coeffQ1MSB, 05
 000                                 CONSTANT coeffQ1LSB, 2D
 000                                 CONSTANT coeffQ2MSB, 0C
 000                                 CONSTANT coeffQ2LSB, 83
 000                                 CONSTANT coeffQ3MSB, 1B
 000                                 CONSTANT coeffQ3LSB, 4F
 000                                 CONSTANT coeffQ4MSB, 5C
 000                                 CONSTANT coeffQ4LSB, 2F
 000                                 ; Registers
 000                                 NAMEREG sF, AveSignalUSB                       ; In fact average of magnitude
 000                                 NAMEREG sE, AveSignalMSB
 000                                 NAMEREG sD, AveSignalLSB
 000                                 ;NAMEREG  sD, BaselineMSB                  ; In fact average of signed signal
 000                                 ;NAMEREG  sC, BaselineLSB
 000                                 NAMEREG sC, SineCtr                            ;Aargh sB is used by the Cordic!! - but not used now
 000                                 ; registers sA-sD are used for longish term storage...!
 000                                 ; sA used for cordic calcs and FIR work for relative pos of roving ptr
 000                                 ; Scratch pad
 000                                 ; registers 0-8 used for cordic table:
 000                                 ; reg 0=45degrees
 000                                 ; ..
 000                                 ; reg 7=0.44761degrees
 000                                 ; Input port
 000                                 CONSTANT AudioMSB, 0'd
 000                                 CONSTANT AudioLSB, 1'd
 000                                 CONSTANT Strobe, 2'd                           ;     bit0=6kHz square wave - the rest are now zeros
 000                                 CONSTANT Command, 3'd                          ; From interface pico
 000                                 CONSTANT MltplyMSB, 4'd                        ; Top significant byte of multiplier output
 000                                 CONSTANT MltplyLSB, 5'd                        ; (only 16 bits retained)
 000                                 CONSTANT BTaudioMSB, 6'd                       ; Input from headset micro
 000                                 CONSTANT BTaudioLSB, 7'd                       ;
 000                                 CONSTANT RAMdataMSB, 8'd                       ;Data from variable storage RAM
 000                                 CONSTANT RAMdataLSB, 9'd
 000                                 CONSTANT Status, 10'd                          ;bit 0 is DSP2user fifo full, bit 1 is no BT audio stream from headset microphone, bit 2 is TX_high
 000                                 ; Output ports
 000                                 CONSTANT MSBAudio, 0'd
 000                                 CONSTANT LSBAudio, 1'd
 000                                 CONSTANT SSBAmp, 2'd
 000                                 CONSTANT CmdToUser, 3'd
 000                                 CONSTANT CoeffMSB, 4'd
 000                                 CONSTANT CoeffLSB, 5'd
 000                                 CONSTANT SignalMSB, 6'd
 000                                 CONSTANT SignalLSB, 7'd
 000                                 CONSTANT Data2archiveMSB, 10'd
 000                                 CONSTANT Data2archiveLSB, 11'd
 000                                 CONSTANT Controlbits, 12'd                     ; BIT OFFSETS:
 000                                 ; Bit offsets:
 000                                 CONSTANT EnMult, 1'd
 000                                 CONSTANT AckFIFO, 32'd                         ;   5 Acknowledge FIFO (present character)
 000                                 CONSTANT PhaseIncrement, 13'd
 000                                 CONSTANT AudioFreqLSB, 14'd
 000                                 CONSTANT AudioPhaseMSB, 15'd
 000                                 CONSTANT AudioPhaseLSB, 16'd
 000                                 CONSTANT EnableSpeaker, 17'd
 000                                 CONSTANT MUXport, 18'd                         ;New port to drive AGC MUX
 000                                 CONSTANT StartToneA, 19'd
 000                                 CONSTANT StartToneALong, 20'd
 000                                 CONSTANT StartToneB, 21'd
 000                                 CONSTANT StartToneBLong, 22'd
 000                                 CONSTANT StopToneA, 23'd
 000                                 CONSTANT StopToneALong, 24'd
 000                                 CONSTANT StopToneB, 25'd
 000                                 CONSTANT StopToneBLong, 26'd
 000                                 CONSTANT MSBBTAudio, 27'd
 000                                 CONSTANT LSBBTAudio, 28'd
 000                                 ; Scratchpad registers
 000                                 ; 0-8 used for Cordic Table!
 000                                 CONSTANT AmpMSB, 10'd
 000                                 CONSTANT AmpLSB, 11'd                          ; Bit 0 toggles at 16kHz
 000                                 CONSTANT PhaseMSB, 12'd
 000                                 CONSTANT PhaseLSB, 13'd                        ; Is this necessary?
 000                                 CONSTANT AGCvalue, 14'd                        ; Two times number of bits to shift (250-11) ie -6 (FA -wk signal) to 11 (0B -Strong signal)
 000                                 CONSTANT VolSetting, 15'd
 000                                 CONSTANT OldPhaseMSB, 16'd
 000                                 CONSTANT AudioScratch, 17'd
 000                                 CONSTANT State, 18'd                           ; Bit 1 0=RX, 1=TX (TX_high), Bit 2 set is streaming TX data from UART
 000                                 ;CONSTANT NormalisedSignalMSB,   19'd                  ; Current signal MSB after AGC
 000                                 CONSTANT LVPtr, 20'd                           ; From HistoryStart to HistoryStart+41 (place to store most recent signal value)
 000                                 CONSTANT IaccuMSB, 21'd
 000                                 CONSTANT IaccuLSB, 22'd
 000                                 CONSTANT QaccuMSB, 23'd
 000                                 CONSTANT QaccuLSB, 24'd
 000                                 CONSTANT OldPhaseLSB, 25'd
 000                                 ; Scratch pad 30-69 used for sinewave - 20 values for sinewave, 40 for dirac
 000                                 CONSTANT startsine, 30'd
 000                                 CONSTANT endsine, 45'd
 000                                 CONSTANT HistoryStart, 70'd                    ; 2 bytes per historical sample - 21 2byte history values
 000                                 CONSTANT HistoryStart42, 112'd                 ; 2 bytes per historical sample - 21 2byte history values
 000                                 ; History values up to and including 111
 000                                 CONSTANT AGCvalueTX, 112'd
 000                                 CONSTANT AGCvalueRX, 113'd
 000                                 CONSTANT AGCcounter, 114'd                     ;store counter 0 to 255 to only perform AGC calc every 1 in 4 audio samples and sinewave increment every 8 samples
 000                                 CONSTANT UARTBitshift, 115'd
 000                                 ;Register values for tone detection part
 000                                 CONSTANT AveStrtToneAMSB_I, 116'd
 000                                 CONSTANT AveStrtToneALSB_I, 117'd
 000                                 CONSTANT AveStrtToneBMSB_I, 118'd
 000                                 CONSTANT AveStrtToneBLSB_I, 119'd
 000                                 CONSTANT AveStopToneAMSB_I, 120'd
 000                                 CONSTANT AveStopToneALSB_I, 121'd
 000                                 CONSTANT AveStopToneBMSB_I, 122'd
 000                                 CONSTANT AveStopToneBLSB_I, 123'd
 000                                 CONSTANT LongAveStrtToneAMSB_I, 124'd
 000                                 CONSTANT LongAveStrtToneALSB_I, 125'd
 000                                 CONSTANT LongAveStrtToneBMSB_I, 126'd
 000                                 CONSTANT LongAveStrtToneBLSB_I, 127'd
 000                                 CONSTANT LongAveStopToneAMSB_I, 128'd
 000                                 CONSTANT LongAveStopToneALSB_I, 129'd
 000                                 CONSTANT LongAveStopToneBMSB_I, 130'd
 000                                 CONSTANT LongAveStopToneBLSB_I, 131'd
 000                                 CONSTANT AveStrtToneAMSB_Q, 132'd
 000                                 CONSTANT AveStrtToneALSB_Q, 133'd
 000                                 CONSTANT AveStrtToneBMSB_Q, 134'd
 000                                 CONSTANT AveStrtToneBLSB_Q, 135'd
 000                                 CONSTANT AveStopToneAMSB_Q, 136'd
 000                                 CONSTANT AveStopToneALSB_Q, 137'd
 000                                 CONSTANT AveStopToneBMSB_Q, 138'd
 000                                 CONSTANT AveStopToneBLSB_Q, 139'd
 000                                 CONSTANT LongAveStrtToneAMSB_Q, 140'd
 000                                 CONSTANT LongAveStrtToneALSB_Q, 141'd
 000                                 CONSTANT LongAveStrtToneBMSB_Q, 142'd
 000                                 CONSTANT LongAveStrtToneBLSB_Q, 143'd
 000                                 CONSTANT LongAveStopToneAMSB_Q, 144'd
 000                                 CONSTANT LongAveStopToneALSB_Q, 145'd
 000                                 CONSTANT LongAveStopToneBMSB_Q, 146'd
 000                                 CONSTANT LongAveStopToneBLSB_Q, 147'd
 000                                 ;Pointers for tones in sinewave - use 4 bits for actual ptr in scratchpad (bottom 2bits of MSB and top 2 bits of LSB)
 000                                 CONSTANT StrtToneAPtrMSB, 148'd
 000                                 CONSTANT StrtToneAPtrLSB, 149'd
 000                                 CONSTANT StrtToneBPtrMSB, 150'd
 000                                 CONSTANT StrtToneBPtrLSB, 151'd
 000                                 CONSTANT StopToneAPtrMSB, 152'd
 000                                 CONSTANT StopToneAPtrLSB, 153'd
 000                                 CONSTANT StopToneBPtrMSB, 154'd
 000                                 CONSTANT StopToneBPtrLSB, 155'd
 000                                 CONSTANT FirstToneInc, 156'd                   ;4 Locations to store tone increments (actually there are 4 unused registers here as well)
 000                                 CONSTANT FirstToneInc02, 158'd                 ;4 Locations to store tone increments (actually there are 4 unused registers here as well)
 000                                 CONSTANT FirstToneInc04, 160'd                 ;4 Locations to store tone increments (actually there are 4 unused registers here as well)
 000                                 CONSTANT FirstToneInc06, 162'd                 ;4 Locations to store tone increments (actually there are 4 unused registers here as well)
 000                                 CONSTANT NormalisedMagMSB, 164'd               ;Absolute value of current signal
 000                                 CONSTANT NormalisedMagLSB, 165'd               ;Absolute value of current signal
 000                                 ;GenerateCode        MEM       "S3eDSPprog.mem"
 000                                 ;start:              JUMP      cold_start       -Try without jump to $20 offset - should work!?
 000                                 ; Start of program (Jump instruction in preloaded memory!)
 000                                 ;                   ORG       $20
 000                                 ; pre-load scratchpad with cordic table.. 360 degrees is $0800 - then *32=$10000
 000  010FF              cold_start: LOAD s0, FF[255'd]                             ; phase for 45 degrees- actually a bit less!
 001  2F000                          STORE s0, 00
 002  01097                          LOAD s0, 97[151'd]                             ; phase for 26.565 degrees
 003  2F001                          STORE s0, 01
 004  01050                          LOAD s0, 50[80'd]                              ; phase for 14.036 degrees
 005  2F002                          STORE s0, 02
 006  01029                          LOAD s0, 29[41'd]                              ; phase for 7.125 degrees
 007  2F003                          STORE s0, 03
 008  01014                          LOAD s0, 14[20'd]                              ; phase for 3.576 degrees
 009  2F004                          STORE s0, 04
 00A  0100A                          LOAD s0, 0A[10'd]                              ; phase for 1.79 degrees
 00B  2F005                          STORE s0, 05
 00C  01005                          LOAD s0, 05[5'd]                               ; phase for 0.895 degrees
 00D  2F006                          STORE s0, 06
 00E  01003                          LOAD s0, 03[3'd]                               ; phase for 0.448 degrees
 00F  2F007                          STORE s0, 07
 010  01001                          LOAD s0, 01[1'd]                               ; phase for 0.224 degrees
 011  2F008                          STORE s0, 08
 012  01010                          LOAD s0, 10[16'd]
 013  2F070                          STORE s0, 70[AGCvalueTX]
 014  0103F                          LOAD s0, 3F[63'd]
 015  2F071                          STORE s0, 71[AGCvalueRX]                       ;set to low value for RX
 016                                 ; LOAD      s1, 30'd
 016                                 ; LOAD      s0, 0
 016                                 ; diracload:          STORE     s0, s1
 016                                 ; ADD       s1, 1
 016                                 ; COMP      s1, 69'd
 016                                 ; JUMP      NZ, diracload
 016                                 ; LOAD      s0, 75'd
 016                                 ; STORE     s0, 69'd
 016                                 ;Sinewave table: Step through this 1 in 8 loops to give 62.5Hz sinewave on transmission
 016  01002                          LOAD s0, 02[2'd]                               ; 1st element of sinewave
 017  2F01E                          STORE s0, 1E[30'd]
 018  01003                          LOAD s0, 03[3'd]                               ; 2nd element of sinewave
 019  2F01F                          STORE s0, 1F[31'd]
 01A  01004                          LOAD s0, 04[4'd]                               ; 3rd element of sinewave
 01B  2F020                          STORE s0, 20[32'd]
 01C  01004                          LOAD s0, 04[4'd]                               ; etc
 01D  2F021                          STORE s0, 21[33'd]
 01E  01004                          LOAD s0, 04[4'd]                               ; etc
 01F  2F022                          STORE s0, 22[34'd]
 020  01003                          LOAD s0, 03[3'd]                               ;
 021  2F023                          STORE s0, 23[35'd]
 022  01002                          LOAD s0, 02[2'd]                               ; etc
 023  2F024                          STORE s0, 24[36'd]
 024  01000                          LOAD s0, 00[0'd]                               ; etc
 025  2F025                          STORE s0, 25[37'd]
 026  010FE                          LOAD s0, FE[254'd]                             ; etc
 027  2F026                          STORE s0, 26[38'd]
 028  010FD                          LOAD s0, FD[253'd]                             ;
 029  2F027                          STORE s0, 27[39'd]
 02A  010FC                          LOAD s0, FC[252'd]                             ; etc
 02B  2F028                          STORE s0, 28[40'd]
 02C  010FC                          LOAD s0, FC[252'd]                             ; etc
 02D  2F029                          STORE s0, 29[41'd]
 02E  010FC                          LOAD s0, FC[252'd]                             ; etc
 02F  2F02A                          STORE s0, 2A[42'd]
 030  010FD                          LOAD s0, FD[253'd]                             ;
 031  2F02B                          STORE s0, 2B[43'd]
 032  010FE                          LOAD s0, FE[254'd]                             ; etc
 033  2F02C                          STORE s0, 2C[44'd]
 034  01000                          LOAD s0, 00[0'd]                               ; etc
 035  2F02D                          STORE s0, 2D[45'd]
 036                                 ;                LOAD      s0, 254'd             ; etc
 036                                 ;                   STORE     s0, 46'd
 036                                 ;                  LOAD      s0, 0'd             ;
 036                                 ;                 STORE     s0, 47'd
 036                                 ;                LOAD      s0, 247'd             ; etc
 036                                 ;               STORE     s0, 48'd
 036                                 ;              LOAD      s0, 0'd               ; etc
 036                                 ;             STORE     s0, 49'd
 036  0109F                          LOAD s0, 9F[StrtToneAInc]
 037  2F09C                          STORE s0, 9C[FirstToneInc]
 038  01069                          LOAD s0, 69[StrtToneBInc]
 039  2F09E                          STORE s0, 9E[FirstToneInc02]
 03A  0105A                          LOAD s0, 5A[StopToneAInc]
 03B  2F0A0                          STORE s0, A0[FirstToneInc04]
 03C  01078                          LOAD s0, 78[StopToneBInc]
 03D  2F0A2                          STORE s0, A2[FirstToneInc06]
 03E  0102A                          LOAD s0, 2A[42'd]
 03F  2D002                          OUTPUT s0, 02[SSBAmp]
 040  01000                          LOAD s0, 00
 041  2F012                          STORE s0, 12[State]                            ; Set state to 0 ie receive
 042  01C1E                          LOAD sC[SineCtr], 1E[startsine]                ; reset SineCtr
 043  01046                          LOAD s0, 46[HistoryStart]                      ;aargh - had commented this out!!!! May2013
 044  2F014                          STORE s0, 14[LVPtr]
 045                                 ; Initialise AGC
 045  010FF                          LOAD s0, FF[255'd]                             ; - 1
 046  2F00F                          STORE s0, 0F[VolSetting]
 047  0103F                          LOAD s0, 3F[63'd]                              ;Start with hig attenuation (max 63) value for external AGC MUX version
 048  2F00E                          STORE s0, 0E[AGCvalue]                         ;maybe start with 16 (was 8)?
 049  01F04                          LOAD sF[AveSignalUSB], 04[AGCInitial]          ; set signal averager to moderate level
 04A                                 ;                    LOAD      AveSignalUSB, AGClowthreshold       ; set signal averager to moderate level
 04A                                 ;                    ADD       AveSignalUSB, AGCuppthreshold       ; set signal averager to moderate level
 04A                                 ;     SR0       AveSignalUSB
 04A                                 ;                    LOAD   BaselineMSB,0
 04A                                 ; routine to take signal in s0,s1,s2 (MSB-LSB) and return 16bit signal in s0,s1 using AGC and volume settings
 04A                                 ; TO DOOOOOOOOOOOO
 04A                                 ; Routine to look at lowest bit of Strobe to detect rising edge.
 04A  09002           AwaitAudioVal: INPUT s0, 02[Strobe]
 04B  03001                          AND s0, 01                                     ; look only at lowest bit
 04C  1D001                          COMPARE s0, 01
 04D  3204A                          JUMP Z, 04A[AwaitAudioVal]                     ; if 1 wait...
 04E  09002               AwaitRise: INPUT s0, 02[Strobe]
 04F  03001                          AND s0, 01                                     ; look only at lowest bit
 050  1D000                          COMPARE s0, 00
 051  3204E                          JUMP Z, 04E[AwaitRise]                         ; if 0 still, wait a bit more...
 052  09001                          INPUT s0, 01[AudioLSB]                         ; Now have the new value (different addresses from before!)
 053  09100                          INPUT s1, 00[AudioMSB]
 054                                 ;      INPUT    s2,AudioUSB    ;not when using external MUX for AGC
 054                                 ; perform automatic gain contrl
 054  0B30E                          FETCH s3, 0E[AGCvalue]
 055  20113                          CALL 113[AGC]                                  ;Now with external MUX to adjust AGC
 056  200E8                          CALL 0E8[Abs16Val]
 057  2F3A4                          STORE s3, A4[NormalisedMagMSB]
 058  2F2A5                          STORE s2, A5[NormalisedMagLSB]
 059                                 ;Now check if we are transmitting this value!
 059  0B212                          FETCH s2, 12[State]
 05A  03202                          AND s2, 02
 05B  1D202                          COMPARE s2, 02                                 ; Check if transmit mode
 05C  320BC                          JUMP Z, 0BC[TransmitAudio]
 05D                                 ; This section will only be performed in receive mode
 05D  2009D                          CALL 09D[AudioDouble]                          ;increase volume 12 dB! Add 2 of these 26/2/15
 05E  2009D                          CALL 09D[AudioDouble]                          ;increase volume 12 dB! stop March 16
 05F  2D100                          OUTPUT s1, 00[MSBAudio]
 060  2D001                          OUTPUT s0, 01[LSBAudio]
 061                                 ;Display demodulated values only in receive
 061  2D10A                          OUTPUT s1, 0A[Data2archiveMSB]                 ;This is received demodulated data
 062  2D00B                          OUTPUT s0, 0B[Data2archiveLSB]
 063  2009D                          CALL 09D[AudioDouble]                          ;increase volume 6 dB! Add may 16
 064  2D11B                          OUTPUT s1, 1B[MSBBTAudio]
 065  2D01C                          OUTPUT s0, 1C[LSBBTAudio]
 066  14000                          SLA s0                                         ;shift top bit into carry
 067  13100                          ADDCY s1, 00                                   ;s1 now rounded value of upper 8 bits (but s0 wasted!)
 068                                 ; Check if there is a command from the User, return here with JUMP command from TransmitAudio macro
 068  09003    BackfromTransmitting: INPUT s0, 03[Command]                          ; Check if FIFO character present
 069  1D080                          COMPARE s0, 80[128'd]                          ; is there a character?
 06A  3823A                          CALL C, 23A[Respond2Fifo]
 06B                                 ; Accumulate magnitude
 06B                                 ;__________________________________________________________________________________________
 06B                                 ;Only do this 1 in 4 (8) times -add this part to Pete's Jan 2013 code - should give 1s time constant on AGC to try and reduce gain ramping up during quiet speech parts
 06B  0B372                          FETCH s3, 72[AGCcounter]
 06C  11301                          ADD s3, 01
 06D  2F372                          STORE s3, 72[AGCcounter]
 06E                                 ;NOW do it every time!
 06E                                 ;_____________________________________________________________________________________________
 06E                                 ;Need to overhaul this !! Oct2015
 06E                                 ;So do this bit at 8kHz rate - so has about a 1s time constant
 06E                                 ; Add 1/32 x abs(new normalised value - which is 256 times smaller than averaged value)
 06E  0920A                          INPUT s2, 0A[Status]
 06F  03206                          AND s2, 06                                     ;look at bit 1 and 2
 070                                 ;In this version switching to BT input is through external multiplexer to go through emphasis filter
 070  1D204                          COMPARE s2, 04                                 ;True if BT signal present and TX_high
 071  3204A                          JUMP Z, 04A[AwaitAudioVal]                     ;Don't do anything if on BT and TX_high
 072  0B3A4                          FETCH s3, A4[NormalisedMagMSB]
 073  0B2A5                          FETCH s2, A5[NormalisedMagLSB]                 ;These are absolute values
 074  20093                          CALL 093[Divide32]
 075  10D20                          ADD sD[AveSignalLSB], s2
 076  12E30                          ADDCY sE[AveSignalMSB], s3
 077  13F00                          ADDCY sF[AveSignalUSB], 00
 078                                 ; now subtract 1/8192 of current value of average
 078  003F0                          LOAD s3, sF[AveSignalUSB]
 079  002E0                          LOAD s2, sE[AveSignalMSB]                      ; These should be positive values!
 07A  20093                          CALL 093[Divide32]
 07B  18D20                          SUB sD[AveSignalLSB], s2
 07C  1AE30                          SUBCY sE[AveSignalMSB], s3
 07D  1BF00                          SUBCY sF[AveSignalUSB], 00
 07E                                 ; Accumulate signed value - try to get DC offset - but apparently not used
 07E                                 ;TEMP DISPLAY of AveSignalMSB!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 07E  003F0                          LOAD s3, sF[AveSignalUSB]                      ;AveSignalMSB is actually a register!
 07F  2D318                          OUTPUT s3, 18[StopToneALong]
 080  003E0                          LOAD s3, sE[AveSignalMSB]                      ;AveSignalMSB is actually a register!
 081  2D319                          OUTPUT s3, 19[StopToneB]
 082  003D0                          LOAD s3, sD[AveSignalLSB]                      ;AveSignalMSB is actually a register!
 083  2D31A                          OUTPUT s3, 1A[StopToneBLong]
 084  0B30E                          FETCH s3, 0E[AGCvalue]
 085  2D317                          OUTPUT s3, 17[StopToneA]                       ;TEMP !!!!!!!!!!!!!!!! send AGC value to this position
 086                                 ; Now adjust AGC value if necessary
 086  0B30E                          FETCH s3, 0E[AGCvalue]
 087  1DF0B                          COMPARE sF[AveSignalUSB], 0B[AGCuppthreshold4] ;Is really big? ie at threshold or above
 088  3C106                          CALL NC, 106[increaseAGC4]                     ; signal too big, increase attenuation by 12dB
 089  1DF08                          COMPARE sF[AveSignalUSB], 08[AGCuppthreshold2] ;Is pretty big
 08A  3C101                          CALL NC, 101[increaseAGC2]                     ; signal too big, increase attenuation by 6dB
 08B  1DF05                          COMPARE sF[AveSignalUSB], 05[AGCuppthreshold]  ;or 18 or 9
 08C  3C0FC                          CALL NC, 0FC[increaseAGC]                      ; signal slightly too big, increase attenuation by 1_5dB
 08D  1DF01                          COMPARE sF[AveSignalUSB], 01[AGClowthreshold2] ;
 08E  3810E                          CALL C, 10E[decreaseAGC2]                      ;ie below threshold2 (4 or below)
 08F  1DF03                          COMPARE sF[AveSignalUSB], 03[AGClowthreshold]  ; ie below threshold (7 or less)
 090  38109                          CALL C, 109[decreaseAGC]
 091  2F30E                          STORE s3, 0E[AGCvalue]
 092  2204A                          JUMP 04A[AwaitAudioVal]
 093                                 ; -------------This is end of main loop--------------------------------
 093                                 ;Routine to take 16 bit value in s3,s2 and shift right by 5 to divide by 32 and leave value in s3,s2
 093                                 ;Assumes this is an unsigned numbers - normally used on a magnitude.
 093  20098                Divide32: CALL 098[Divide4]
 094  20098                          CALL 098[Divide4]
 095  1430E                          SR0 s3
 096  14208                          SRA s2
 097  25000                          RETURN 
 098  1430E                 Divide4: SR0 s3
 099  14208                          SRA s2
 09A  1430E                          SR0 s3
 09B  14208                          SRA s2
 09C  25000                          RETURN 
 09D                                 ;This routine aims to double the signed analoge value in s0,s1 by finding sign of the value and doubling if small, increasing magnitude by 32 if less than 95 but more than 32 then limiting to 127 if more than 95
 09D  1D180             AudioDouble: COMPARE s1, 80[128'd]
 09E  3A0AC                          JUMP C, 0AC[Posvalue]
 09F                                 ;otherwise must be negative
 09F  1D1E1                Negvalue: COMPARE s1, E1[225'd]                          ;256-31
 0A0  3A0A4                          JUMP C, 0A4[islessthanneg31]
 0A1  14006                          SL0 s0
 0A2  14100                          SLA s1                                         ;double value
 0A3  25000                          RETURN 
 0A4  1D1C1         islessthanneg31: COMPARE s1, C1[193'd]                          ;256-63
 0A5  3A0A8                          JUMP C, 0A8[islessthanneg63]
 0A6  19120                          SUB s1, 20[32'd]
 0A7  25000                          RETURN 
 0A8  1410A         islessthanneg63: SRX s1
 0A9  14008                          SRA s0                                         ;half value
 0AA  19140                          SUB s1, 40[64'd]
 0AB  25000                          RETURN 
 0AC  1D120                Posvalue: COMPARE s1, 20[32'd]
 0AD  3E0B1                          JUMP NC, 0B1[ismorethan31]
 0AE  14006                          SL0 s0
 0AF  14100                          SLA s1                                         ;double value
 0B0  25000                          RETURN 
 0B1  1D140            ismorethan31: COMPARE s1, 40[64'd]
 0B2  3E0B5                          JUMP NC, 0B5[ismorethan63]                     ;positive and 64 or greater
 0B3  11120                          ADD s1, 20[32'd]
 0B4  25000                          RETURN 
 0B5  1410A            ismorethan63: SRX s1                                         ;sign extension should be zero!
 0B6  14008                          SRA s0
 0B7  11140                          ADD s1, 40[64'd]
 0B8  25000                          RETURN 
 0B9                                 ;-----------End Audio double
 0B9                                 ;Divides 16 bit signed value in s0,s1 by 2.
 0B9  1410A                 Divide2: SRX s1
 0BA  14008                          SRA s0
 0BB  25000                          RETURN 
 0BC                  TransmitAudio: 
 0BC                                 ;In this version switching to BT input is through external multiplexer to go through emphasis filter
 0BC                                 ;Nov 2014 - have reduced DSP AGC level, so shouldn't need to do this? -reinstate Feb2015
 0BC  1410A                          SRX s1                                         ;halve value before FIR to keep I and Q below $30 limit after FIR for CORDIC
 0BD  14008                          SRA s0
 0BE  20144                          CALL 144[PerformFIR]
 0BF                                 ;This should have decreased amplitude by about 6dB
 0BF  2D10A                          OUTPUT s1, 0A[Data2archiveMSB]
 0C0  2D00B                          OUTPUT s0, 0B[Data2archiveLSB]
 0C1                                 ;need to make sure that s3/s2 and s1/s0 DO NOT EXCEED $3000, ie 48 in the MSBs!
 0C1  201CF                          CALL 1CF[cordic]                               ;This is upsettng the AGC when sinectr used sB!
 0C2  200DC                          CALL 0DC[TryAndDouble]                         ;Bump amplitude to saturate! (Jan 2016)
 0C3  200DC                          CALL 0DC[TryAndDouble]
 0C4  200DC                          CALL 0DC[TryAndDouble]
 0C5  200DC                          CALL 0DC[TryAndDouble]
 0C6  200DC                          CALL 0DC[TryAndDouble]                         ;try add for upgrade of production code
 0C7  2D102                  OutAmp: OUTPUT s1, 02[SSBAmp]                          ;********************disable for beacon tests
 0C8  0B310                          FETCH s3, 10[OldPhaseMSB]
 0C9  0B219                          FETCH s2, 19[OldPhaseLSB]
 0CA  2F510                          STORE s5, 10[OldPhaseMSB]
 0CB  2F419                          STORE s4, 19[OldPhaseLSB]                      ;s2,3 old phase, s4,5 new phase
 0CC  2D30F                          OUTPUT s3, 0F[AudioPhaseMSB]                   ;send old phase directly
 0CD  2D210                          OUTPUT s2, 10[AudioPhaseLSB]                   ;send old phase directly
 0CE  18420                          SUB s4, s2
 0CF  1A530                          SUBCY s5, s3                                   ;New phase-old phase
 0D0  1450A                          SRX s5
 0D1  00350                          LOAD s3, s5                                    ;divide MSB by2 and copy
 0D2  1430A                          SRX s3
 0D3  1430A                          SRX s3                                         ;s5/4
 0D4  10530                          ADD s5, s3
 0D5  1430A                          SRX s3
 0D6  1430A                          SRX s3                                         ;s5/16, s5 should now be 4/3rds of Phase shift/2^9, or 2/3rds of phase shift/2^8 (should be 2/3rds of s5/2^11) so need further 2^3 attenuaion)
 0D7  10530                          ADD s5, s3
 0D8  2D50D                          OUTPUT s5, 0D[PhaseIncrement]
 0D9  0B30E                          FETCH s3, 0E[AGCvalue]
 0DA  2D317                          OUTPUT s3, 17[StopToneA]                       ;TEMP !!!!!!!!!!!!!!!! send AGC value to this position when transmitting
 0DB  22068                          JUMP 068[BackfromTransmitting]
 0DC  1D140            TryAndDouble: COMPARE s1, 40[64'd]                           ;see if it is not too big already
 0DD  3E0E1                          JUMP NC, 0E1[BiggerThan63]                     ;Skip if too big
 0DE  14006                          SL0 s0                                         ;add 6dB 4/10/11
 0DF  14100                          SLA s1
 0E0  25000                          RETURN 
 0E1  1D181            BiggerThan63: COMPARE s1, 81[129'd]
 0E2  3E0E5                          JUMP NC, 0E5[BiggerThan128]
 0E3  11140                          ADD s1, 40[64'd]
 0E4  25000                          RETURN 
 0E5  1410E           BiggerThan128: SR0 s1                                         ;half value (127 max value)
 0E6  11180                          ADD s1, 80[128'd]                              ;add 128 (gives 255 max)
 0E7  25000                          RETURN 
 0E8                                 ;Enter with signed 16 bit value in s1,s0 and return magnitude in s3,s2
 0E8  00310                Abs16Val: LOAD s3, s1
 0E9  00200                          LOAD s2, s0
 0EA  1D180                          COMPARE s1, 80[128'd]
 0EB  39000                          RETURN C
 0EC  01300                          LOAD s3, 00
 0ED  01200                          LOAD s2, 00
 0EE  18200                          SUB s2, s0
 0EF  1A310                          SUBCY s3, s1
 0F0  25000                          RETURN 
 0F1  1D380                  absval: COMPARE s3, 80[128'd]
 0F2  3C0F4                          CALL NC, 0F4[makeposval]
 0F3  25000                          RETURN 
 0F4                                 ; Turn negative value in s3 into a positive one (well will actualy make a positive value negative as well).
 0F4  01400              makeposval: LOAD s4, 00
 0F5  18430                          SUB s4, s3
 0F6  00340                          LOAD s3, s4
 0F7  25000                          RETURN 
 0F8                                 ;invert value - actually same as makeposval, but works on s1
 0F8  01400               invertval: LOAD s4, 00
 0F9  18410                          SUB s4, s1
 0FA  00140                          LOAD s1, s4
 0FB  25000                          RETURN 
 0FC                                 ;Feb 2013 icrease number of AGC steps factor 2 and another factor 2 July 2013 (now granularity 1.5dB)
 0FC                                 ; increment attenuation
 0FC  1D33F             increaseAGC: COMPARE s3, 3F[63'd]                           ; was44
 0FD  31000                          RETURN Z                                       ; don't do anything if already 63 (was 44 (was 22, before that 11))
 0FE  01F04                          LOAD sF[AveSignalUSB], 04[AGCInitial]          ; set signal averager to moderate level
 0FF  11301                          ADD s3, 01[1'd]                                ; so yes signal really has been too big for too long!
 100  25000                          RETURN 
 101                                 ;increase AGCvalue by 4 to give extra 6dB
 101  200FC            increaseAGC2: CALL 0FC[increaseAGC]
 102  200FC                          CALL 0FC[increaseAGC]
 103  200FC                          CALL 0FC[increaseAGC]
 104  200FC                          CALL 0FC[increaseAGC]
 105  25000                          RETURN 
 106  20101            increaseAGC4: CALL 101[increaseAGC2]
 107  20101                          CALL 101[increaseAGC2]
 108  25000                          RETURN 
 109                                 ; decrement attenuation
 109  1D300             decreaseAGC: COMPARE s3, 00                                 ; was232
 10A  31000                          RETURN Z                                       ; don't do anything if already  0   (was 232 ie -24 (was 244, before that 250 ie -6) )
 10B  01F04                          LOAD sF[AveSignalUSB], 04[AGCInitial]          ; set signal averager to moderate level
 10C  19301                          SUB s3, 01                                     ; so yes signal realy has been too small for too long!
 10D                                 ; LOAD      s5, s3
 10D                                 ; CALL      Export2User
 10D  25000                          RETURN 
 10E  20109            decreaseAGC2: CALL 109[decreaseAGC]
 10F  20109                          CALL 109[decreaseAGC]
 110  20109                          CALL 109[decreaseAGC]
 111  20109                          CALL 109[decreaseAGC]
 112  25000                          RETURN 
 113                                 ; AGC takes 16 bit value, MSB in s1, LSB in s0 and returns normalised 16 bit value in s1,s0 using AGC value from s3, using external MUX for coarse control
 113                                 ;AGC value in s3 should vary  0-63 in this version - higher value is higher attenuation so use higher significant bits on input MUX (4 bits - 16 inputs)
 113                                 ; This routine can also be use for the volume setting if value put in s3 ????????
 113  0920A                     AGC: INPUT s2, 0A[Status]
 114  03206                          AND s2, 06                                     ;look at bit 1 and 2
 115                                 ;In this version switching to BT input is through external multiplexer to go through emphasis filter
 115  1D204                          COMPARE s2, 04                                 ;True if BT signal present and TX_high
 116  31000                          RETURN Z                                       ;Don't do anything if on BT and TX_high
 117  1430A                          SRX s3                                         ;divide s3 by 2 to get last AGC and put last bit into carry
 118  3812C                          CALL C, 12C[decrease1_5dB]                     ;if last bit set then reduce by 3dB
 119  1430A                          SRX s3                                         ;divide s3 by 2 to get old AGC and put last bit into carry
 11A  3811D                          CALL C, 11D[decrease3dB]                       ;if last bit set then reduce by 3dB
 11B  2D312                          OUTPUT s3, 12[MUXport]                         ;Now simply use remaining 4 bits to drive the MUX
 11C  25000                          RETURN 
 11D                                 ;this decreases value in (not s2),s1,s0 by factor 0.6875 (roughly 1/sqrt(2)) s2 not used with external MUX
 11D  1410A             decrease3dB: SRX s1
 11E  14008                          SRA s0
 11F  00400                          LOAD s4, s0
 120  00510                          LOAD s5, s1
 121  1450A                          SRX s5
 122  14408                          SRA s4
 123  1450A                          SRX s5
 124  14408                          SRA s4
 125  10040                          ADD s0, s4
 126  12150                          ADDCY s1, s5
 127  1450A                          SRX s5
 128  14408                          SRA s4
 129  10040                          ADD s0, s4
 12A  12150                          ADDCY s1, s5
 12B  25000                          RETURN 
 12C                                 ;multiply by 0.875 - modified for using only s1,s0
 12C  1410A           decrease1_5dB: SRX s1
 12D  14008                          SRA s0
 12E  00400                          LOAD s4, s0
 12F  00510                          LOAD s5, s1
 130  1450A                          SRX s5
 131  14408                          SRA s4
 132  10040                          ADD s0, s4
 133  12150                          ADDCY s1, s5
 134  1450A                          SRX s5
 135  14408                          SRA s4
 136  10040                          ADD s0, s4
 137  12150                          ADDCY s1, s5
 138  25000                          RETURN 
 139                                 ;This is never called???????????????????
 139  01308                 AGCtest: LOAD s3, 08
 13A  00010                          LOAD s0, s1
 13B  00120                          LOAD s1, s2
 13C  25000                          RETURN 
 13D                                 ;This is never called???????????????????
 13D  1D300              AGClooptst: COMPARE s3, 00
 13E  31000                          RETURN Z                                       ; escape if AGC value zero
 13F  1420A                          SRX s2
 140  14108                          SRA s1
 141  14008                          SRA s0
 142  19301                          SUB s3, 01
 143  2213D                          JUMP 13D[AGClooptst]
 144                                 ; Routine to perform FIR takes new signal value in s1,s0 (s1 is MSB) and puts into scratch buffer and then outputs new filterred values for I in s1,s0 and Q in s3,s2
 144                                 ; First store latest value then increment LVptr
 144                                 ;OK Sept 2010
 144                                 ;reasonable match between I and Q components (within ~1dB), but about 6dB attenuation from input - OK.
 144  2D106              PerformFIR: OUTPUT s1, 06[SignalMSB]
 145  2D007                          OUTPUT s0, 07[SignalLSB]
 146  0B414                          FETCH s4, 14[LVPtr]                            ; value of the previous latest value
 147  11402                          ADD s4, 02                                     ; advance LVptr
 148  1D470                          COMPARE s4, 70[HistoryStart42]                 ; + 42
 149  3C1B0                          CALL NC, 1B0[resetLVptr]                       ; if gone past end of buffer reset pointer to start
 14A  2F414                          STORE s4, 14[LVPtr]                            ; update incremented value of LVptr (by step +2)
 14B  2E140                          STORE s1, (s4)                                 ; Store signalMSB at LVptr in scratch
 14C  11401                          ADD s4, 01
 14D  2E040                          STORE s0, (s4)                                 ; Store signalLSB at LVptr+1 in scratch
 14E  19401                          SUB s4, 01                                     ; return to LVptr
 14F  01A00                          LOAD sA, 00                                    ; Reset the register used for the difference between LVptr and Rptr (diff)
 150  2FA16                          STORE sA, 16[IaccuLSB]
 151  2FA15                          STORE sA, 15[IaccuMSB]
 152  2FA18                          STORE sA, 18[QaccuLSB]
 153  2FA17                          STORE sA, 17[QaccuMSB]                         ; Reset all accumulators
 154                                 ; now start filter with roving pointer in s5 starting at LVptr
 154                                 ; LOAD      s5, s4
 154  201B5                          CALL 1B5[UpdateRptr]                           ; this should be equivalent to previous line!
 155  017F6                          LOAD s7, F6[coeffI0MSB]                        ; Smallest coefficients of I FIR - load values to go to multiplier input.
 156  01692                          LOAD s6, 92[coeffI0LSB]
 157  2017B                          CALL 17B[Ibussiness]
 158  01700                          LOAD s7, 00[coeffQ0MSB]                        ; Smallest coefficients of Q FIR
 159  016A7                          LOAD s6, A7[coeffQ0LSB]
 15A  20181                          CALL 181[Qbussiness]
 15B  017F4                          LOAD s7, F4[coeffI1MSB]                        ; coefficient of I FIR
 15C  0168A                          LOAD s6, 8A[coeffI1LSB]
 15D  2017B                          CALL 17B[Ibussiness]
 15E  01705                          LOAD s7, 05[coeffQ1MSB]                        ; coefficient of Q FIR
 15F  0162D                          LOAD s6, 2D[coeffQ1LSB]
 160  20181                          CALL 181[Qbussiness]
 161  017F2                          LOAD s7, F2[coeffI2MSB]                        ; coefficient of I FIR
 162  016CC                          LOAD s6, CC[coeffI2LSB]
 163  2017B                          CALL 17B[Ibussiness]
 164  0170C                          LOAD s7, 0C[coeffQ2MSB]                        ; coefficient of Q FIR
 165  01683                          LOAD s6, 83[coeffQ2LSB]
 166  20181                          CALL 181[Qbussiness]
 167  017F1                          LOAD s7, F1[coeffI3MSB]                        ; coefficient of I FIR
 168  01677                          LOAD s6, 77[coeffI3LSB]
 169  2017B                          CALL 17B[Ibussiness]
 16A  0171B                          LOAD s7, 1B[coeffQ3MSB]                        ; coefficient of Q FIR
 16B  0164F                          LOAD s6, 4F[coeffQ3LSB]
 16C  20181                          CALL 181[Qbussiness]
 16D  017F0                          LOAD s7, F0[coeffI4MSB]                        ; coefficient of I FIR
 16E  016A1                          LOAD s6, A1[coeffI4LSB]
 16F  2017B                          CALL 17B[Ibussiness]
 170  0175C                          LOAD s7, 5C[coeffQ4MSB]                        ; coefficient of Q FIR
 171  0162F                          LOAD s6, 2F[coeffQ4LSB]
 172  20181                          CALL 181[Qbussiness]
 173  01740                          LOAD s7, 40[coeffI5MSB]                        ; half of middle coefficient of I FIR
 174  01600                          LOAD s6, 00[coeffI5LSB]
 175  2017B                          CALL 17B[Ibussiness]                           ; Roving pointer is advanced an 11th time but is reset before being used!
 176  0B016                          FETCH s0, 16[IaccuLSB]
 177  0B115                          FETCH s1, 15[IaccuMSB]
 178  0B218                          FETCH s2, 18[QaccuLSB]
 179  0B317                          FETCH s3, 17[QaccuMSB]
 17A  25000                          RETURN                                         ; return from PerformFIR
 17B                                 ; These assume coefficient is in s6,7 (LSB,MSB)
 17B  20187              Ibussiness: CALL 187[doIplus]
 17C  201BB                          CALL 1BB[conjugateDiff]                        ; Roving, difference pointer in sA sent to conjugate value and update roving pointer s5
 17D  20187                          CALL 187[doIplus]
 17E  201BB                          CALL 1BB[conjugateDiff]                        ; Return difference pointer in sA from its conjugate value
 17F  201B2                          CALL 1B2[AdvanceRptr]                          ; This is relative shift to roving pointer (0->10 x2 ie 20)
 180  25000                          RETURN 
 181  2018F              Qbussiness: CALL 18F[doQplus]
 182  201BB                          CALL 1BB[conjugateDiff]                        ; Roving, difference pointer in sA sent to conjugate value, also update roving pointer.
 183  20197                          CALL 197[doQminus]
 184  201BB                          CALL 1BB[conjugateDiff]                        ; Roving, difference pointer in sA sent to conjugate value, should go back to value before calling this function.
 185  201B2                          CALL 1B2[AdvanceRptr]                          ; This uses relative shift to roving pointer (0->10x2 ie 20), sA used for difference value.
 186  25000                          RETURN 
 187                                 ; These assume coefficient is in s6,7 (LSB,MSB) for doMult, so make sure it doesn't pollute it for the next time!
 187  2019F                 doIplus: CALL 19F[doMult]
 188  0B016                          FETCH s0, 16[IaccuLSB]
 189  0B115                          FETCH s1, 15[IaccuMSB]
 18A  10080                          ADD s0, s8
 18B  12190                          ADDCY s1, s9
 18C  2F016                          STORE s0, 16[IaccuLSB]
 18D  2F115                          STORE s1, 15[IaccuMSB]
 18E  25000                          RETURN 
 18F  2019F                 doQplus: CALL 19F[doMult]
 190  0B018                          FETCH s0, 18[QaccuLSB]
 191  0B117                          FETCH s1, 17[QaccuMSB]
 192  10080                          ADD s0, s8
 193  12190                          ADDCY s1, s9
 194  2F018                          STORE s0, 18[QaccuLSB]
 195  2F117                          STORE s1, 17[QaccuMSB]
 196  25000                          RETURN 
 197  2019F                doQminus: CALL 19F[doMult]
 198  0B018                          FETCH s0, 18[QaccuLSB]
 199  0B117                          FETCH s1, 17[QaccuMSB]
 19A  18080                          SUB s0, s8
 19B  1A190                          SUBCY s1, s9
 19C  2F018                          STORE s0, 18[QaccuLSB]
 19D  2F117                          STORE s1, 17[QaccuMSB]
 19E  25000                          RETURN 
 19F                                 ; History signal is first output to SignalMSB and SignalLSB, the signal is then multiplied by the coefficient (provided in s6,7 - LSB,MSB) and the result is returned in s8,9 (LSB,MSB)
 19F  201AB                  doMult: CALL 1AB[GetRovingHistoryValues]
 1A0  2D106                          OUTPUT s1, 06[SignalMSB]
 1A1  2D007                          OUTPUT s0, 07[SignalLSB]                       ; Historical signal sent to multiplier
 1A2  2D704                          OUTPUT s7, 04[CoeffMSB]
 1A3  2D605                          OUTPUT s6, 05[CoeffLSB]
 1A4  01000                          LOAD s0, 00
 1A5  01000                          LOAD s0, 00
 1A6  01000                          LOAD s0, 00                                    ; wait a bit (8 clock cycles enough?)
 1A7  01000                          LOAD s0, 00
 1A8  09904                          INPUT s9, 04[MltplyMSB]
 1A9  09805                          INPUT s8, 05[MltplyLSB]
 1AA  25000                          RETURN 
 1AB  0A150  GetRovingHistoryValues: FETCH s1, (s5)                                 ; Historical SignalMSB
 1AC  11501                          ADD s5, 01
 1AD  0A050                          FETCH s0, (s5)                                 ; Historical SignalLSB
 1AE  19501                          SUB s5, 01                                     ; return s5 vlue as there will be another mult before updating s5!!
 1AF  25000                          RETURN 
 1B0                                 ; To reset LVptr to start of history rolling buffer space. LVptr is 'Last Value Pointer'
 1B0  01446              resetLVptr: LOAD s4, 46[HistoryStart]
 1B1  25000                          RETURN 
 1B2                                 ; and Rptr (Rptr is 'Roving Pointer'), next value (back 2 places), using advance of diff (sA) diff takes even values 0-40 inclusive (10 steps, ie 11 values, should never go beyond!, at each value conjugate point is also used. 11 value is diff=20 repeats itself at conjugate point)
 1B2  11A02             AdvanceRptr: ADD sA, 02                                     ; advance diff (goes from 0 to 20)
 1B3  201B5                          CALL 1B5[UpdateRptr]
 1B4  25000                          RETURN 
 1B5                                 ; uses value of diff to update value of Rptr
 1B5  00540              UpdateRptr: LOAD s5, s4                                    ; put LVptr in Rptr
 1B6  185A0                          SUB s5, sA                                     ; take off value of diff (sA)
 1B7  1D546                          COMPARE s5, 46[HistoryStart]
 1B8  3D000                          RETURN NC                                      ; if not gone below bottom of buffer return!, else....
 1B9  1152A                          ADD s5, 2A[42'd]                               ; send up again
 1BA  25000                          RETURN 
 1BB                                 ; - acts on diff (sA)
 1BB  01028           conjugateDiff: LOAD s0, 28[40'd]
 1BC  180A0                          SUB s0, sA                                     ; 40-sA
 1BD  00A00                          LOAD sA, s0                                    ; so sA is conjugate eg: 0->40,40->0, 20->20 etc
 1BE  201B5                          CALL 1B5[UpdateRptr]                           ; calculate corresponding Rptr
 1BF  25000                          RETURN 
 1C0                                 ; the negative case means when the roving ptr is less than LVptr - is it done OK above 10 lines? diff is always positive (Rptr less than LVptr)
 1C0                                 ; conjugateneg:
 1C0                                 ; RET
 1C0                                 ; Takes value in s5 and converts to 2 ascii codes which are sent to the user picoblaze.
 1C0  20272             Export2User: CALL 272[Byte2Chars]
 1C1  2D603                          OUTPUT s6, 03[CmdToUser]
 1C2  2D703                          OUTPUT s7, 03[CmdToUser]
 1C3  0100D                          LOAD s0, 0D[13'd]                              ; terminate with CR
 1C4  2D003                          OUTPUT s0, 03[CmdToUser]
 1C5  0100A                          LOAD s0, 0A[10'd]                              ; and with LF
 1C6  2D003                          OUTPUT s0, 03[CmdToUser]
 1C7  25000                          RETURN 
 1C8                                 ; Takes 16 bit value in s6,s7 (MSB,LSB) and outputs to the archive memory (write enabled and selected by user picoblaze)
 1C8  2D60B             ArchiveData: OUTPUT s6, 0B[Data2archiveLSB]
 1C9  2D70A                          OUTPUT s7, 0A[Data2archiveMSB]
 1CA  25000                          RETURN 
 1CB                                 ; Frequency works out the phase increment - (this is to ~7 bit precission, but using LSB could get 8 bit?)
 1CB                                 ; Takes phase in s4 (and s5) and uses old phase value from scratchpad (which is then updated). The phase increment is returned in s4.
 1CB  0B010               Frequency: FETCH s0, 10[OldPhaseMSB]
 1CC  2F410                          STORE s4, 10[OldPhaseMSB]
 1CD  18400                          SUB s4, s0
 1CE  25000                          RETURN 
 1CF                                 ; CORDIC  Takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
 1CF                                 ; Useable range is for I and Q up to about +/-$3000
 1CF  01400                  cordic: LOAD s4, 00
 1D0  01500                          LOAD s5, 00
 1D1  1D180                          COMPARE s1, 80[128'd]
 1D2  3C206                          CALL NC, 206[rotate90]                         ; if I negative then need to bring back into RH 2 quadrants.
 1D3                                 ; now enter loop
 1D3  01800                          LOAD s8, 00                                    ; counter of times to iterate.
 1D4  00710              cordicloop: LOAD s7, s1                                    ; temporary store for I
 1D5  00600                          LOAD s6, s0                                    ; temp store
 1D6  1D380                          COMPARE s3, 80[128'd]                          ; is Q negative?
 1D7  3E1E6                          JUMP NC, 1E6[posrotate]                        ; if negative rotate positive
 1D8  00A20               negrotate: LOAD sA, s2
 1D9  00B30                          LOAD sB, s3                                    ; put Q into working registers
 1DA  201FF                          CALL 1FF[shift]                                ; shift Q by the amount in s8
 1DB  100A0                          ADD s0, sA                                     ; add shifted Q to I
 1DC  121B0                          ADDCY s1, sB
 1DD  00A60                          LOAD sA, s6                                    ; prepare working registers (sA,sB) with original value of I
 1DE  00B70                          LOAD sB, s7
 1DF  201FF                          CALL 1FF[shift]
 1E0  182A0                          SUB s2, sA
 1E1  1A3B0                          SUBCY s3, sB
 1E2  201F7                          CALL 1F7[GetPhaseIncrement]
 1E3  184A0                          SUB s4, sA
 1E4  1A5B0                          SUBCY s5, sB
 1E5  221F3                          JUMP 1F3[testcordicend]
 1E6  00A20               posrotate: LOAD sA, s2
 1E7  00B30                          LOAD sB, s3                                    ; put Q into working registers
 1E8  201FF                          CALL 1FF[shift]                                ; shift Q by the amount in s8
 1E9  180A0                          SUB s0, sA                                     ; add shifted Q to I
 1EA  1A1B0                          SUBCY s1, sB
 1EB  00A60                          LOAD sA, s6                                    ; prepare working registers with original value of I
 1EC  00B70                          LOAD sB, s7
 1ED  201FF                          CALL 1FF[shift]
 1EE  102A0                          ADD s2, sA
 1EF  123B0                          ADDCY s3, sB
 1F0  201F7                          CALL 1F7[GetPhaseIncrement]
 1F1  104A0                          ADD s4, sA
 1F2  125B0                          ADDCY s5, sB
 1F3  11801           testcordicend: ADD s8, 01
 1F4  1D809                          COMPARE s8, 09[m_plus_1]                       ;m + 1
 1F5  3A1D4                          JUMP C, 1D4[cordicloop]
 1F6  25000                          RETURN 
 1F7                                 ; routine to lookup from the cordic look up table (scratchpad), the phase increment - stored as 8 bits at the location pointed to be s8, returned as 16 bits in sA and sB
 1F7                                 ; sB is MSB
 1F7  0AB80       GetPhaseIncrement: FETCH sB, (s8)
 1F8  14B0E                          SR0 sB
 1F9  14A08                          SRA sA
 1FA  14B0E                          SR0 sB
 1FB  14A08                          SRA sA
 1FC  14B0E                          SR0 sB
 1FD  14A08                          SRA sA                                         ; This multiplies the 8 bit stored value by 32 so that max scratchpad value 255->255*32 equivalent to 44.82degrees
 1FE  25000                          RETURN 
 1FF  00980                   shift: LOAD s9, s8
 200  1D900               shiftloop: COMPARE s9, 00
 201  31000                          RETURN Z
 202  19901                          SUB s9, 01
 203  14B0A                          SRX sB
 204  14A08                          SRA sA
 205  22200                          JUMP 200[shiftloop]
 206  00710                rotate90: LOAD s7, s1                                    ; temporary store for I
 207  00600                          LOAD s6, s0                                    ; temp store
 208  1D380                          COMPARE s3, 80[128'd]                          ; is Q negative?
 209  3E213                          JUMP NC, 213[add90]                            ; if negative add 90
 20A  00130                   sub90: LOAD s1, s3
 20B  00020                          LOAD s0, s2                                    ; I=Q
 20C  01200                          LOAD s2, 00
 20D  01300                          LOAD s3, 00
 20E  18260                          SUB s2, s6
 20F  1A370                          SUBCY s3, s7                                   ; Q=-I
 210  19400                          SUB s4, 00[half_pi_LSB]
 211  1B540                          SUBCY s5, 40[half_pi_MSB]
 212  25000                          RETURN 
 213  01100                   add90: LOAD s1, 00
 214  01000                          LOAD s0, 00
 215  18020                          SUB s0, s2
 216  1A130                          SUBCY s1, s3                                   ; I=-Q
 217  00260                          LOAD s2, s6
 218  00370                          LOAD s3, s7                                    ; Q=I
 219  01400                          LOAD s4, 00[half_pi_LSB]
 21A  01540                          LOAD s5, 40[half_pi_MSB]
 21B  25000                          RETURN 
 21C  0B112            Transmitmode: FETCH s1, 12[State]
 21D  05102                          OR s1, 02
 21E  2F112                          STORE s1, 12[State]                            ; set bit 1
 21F  0B10E                          FETCH s1, 0E[AGCvalue]
 220  2F171                          STORE s1, 71[AGCvalueRX]
 221  0B170                          FETCH s1, 70[AGCvalueTX]                       ;recovers last used value for AGCvalur in this mode
 222  2F10E                          STORE s1, 0E[AGCvalue]
 223  25000                          RETURN 
 224                                 ;Streammode:   CALL Transmitmode
 224                                 ;     FETCH     s1, State
 224                                 ;                   OR        s1, 4
 224                                 ;                  STORE     s1, State           ; set bit 2
 224                                 ;     RET
 224                                 ;GetUartValues:  CALL      Get2Chars     ;Changed name of this routine
 224                                 ;     LOAD   s1,$AA     ;rough value
 224                                 ;     LOAD   s2,s5      ;now put into top byte
 224                                 ;     SRX    s2
 224                                 ;     SRA    s1      ;divide signal by 2
 224                                 ;     SRX    s2
 224                                 ;     SRA    s1      ;divide signal by 2 again
 224                                 ;     LOAD    s0,$AA      ;set lowest bits to rough value
 224                                 ;        RET
 224  0B10E          GrabTXAGCvalue: FETCH s1, 0E[AGCvalue]
 225  2F170                          STORE s1, 70[AGCvalueTX]
 226  25000                          RETURN 
 227  0B112             Receivemode: FETCH s1, 12[State]
 228  031FD                          AND s1, FD[253'd]                              ; 255 - 2
 229  2F112                          STORE s1, 12[State]                            ; reset bit 1
 22A  0B10E                          FETCH s1, 0E[AGCvalue]
 22B  2F170                          STORE s1, 70[AGCvalueTX]
 22C  0B171                          FETCH s1, 71[AGCvalueRX]                       ;recovers last used value for AGCvalur in this mode
 22D  2F10E                          STORE s1, 0E[AGCvalue]
 22E  25000                          RETURN 
 22F  011F0            BlockDSPpico: LOAD s1, F0[240'd]
 230  2D102                          OUTPUT s1, 02[SSBAmp]                          ; Set signal amp to high
 231  01100                          LOAD s1, 00
 232  2D10D                          OUTPUT s1, 0D[PhaseIncrement]                  ;Make sure phase doesn't wander
 233  09003                          INPUT s0, 03[Command]                          ; Check if FIFO character present
 234  1D080                          COMPARE s0, 80[128'd]                          ; is there a character?
 235  3E22F                          JUMP NC, 22F[BlockDSPpico]                     ; no command received so carry on blocking
 236  2024E                          CALL 24E[GetFifoChar]                          ;is command so get charcter
 237  1D052                          COMPARE s0, 52[82'd]                           ; character R
 238  31000                          RETURN Z                                       ;escape when R received from User Pico
 239  2222F                          JUMP 22F[BlockDSPpico]
 23A                                 ; Get fifo command and act on it.
 23A                   Respond2Fifo: 
 23A                                 ;         FETCH     s0,State
 23A                                 ;     AND    s0,04
 23A                                 ;     COMP   s0,04        ;is this stream mode
 23A                                 ;     RETURN Z       ;if so then stick (no backing out!)
 23A  2024E                          CALL 24E[GetFifoChar]
 23B                                 ;     COMPARE   s0,51'd       ;character 3
 23B                                 ;     CALL   Z,Streammode
 23B  1D032                          COMPARE s0, 32[50'd]                           ; character 2
 23C  30224                          CALL Z, 224[GrabTXAGCvalue]                    ;need to get this before userpico sends warble
 23D  1D031                          COMPARE s0, 31[49'd]                           ; character 1
 23E  3021C                          CALL Z, 21C[Transmitmode]
 23F  1D030                          COMPARE s0, 30[48'd]                           ; character 0
 240  30227                          CALL Z, 227[Receivemode]
 241  1D047                          COMPARE s0, 47[71'd]                           ; character G (request for AGCvalue info from userpico)
 242  30248                          CALL Z, 248[SendGParamBack]
 243  1D053                          COMPARE s0, 53[83'd]                           ; character S (request for AVEsignal info from userpico)
 244  3024B                          CALL Z, 24B[SendSParamBack]
 245  1D042                          COMPARE s0, 42[66'd]                           ; character B (block)
 246  3022F                          CALL Z, 22F[BlockDSPpico]
 247  25000                          RETURN 
 248                                 ;This can be adjusted for de-bugging AGCvalue
 248  0B50E          SendGParamBack: FETCH s5, 0E[AGCvalue]
 249  201C0                          CALL 1C0[Export2User]
 24A  25000                          RETURN 
 24B                                 ;This can be adjusted for de-bugging AVEsignal
 24B  005F0          SendSParamBack: LOAD s5, sF[AveSignalUSB]
 24C  201C0                          CALL 1C0[Export2User]
 24D  25000                          RETURN 
 24E                                 ; Routine to recover a character from the FIFO in s0
 24E  01020             GetFifoChar: LOAD s0, 20[AckFIFO]
 24F  2D00C                          OUTPUT s0, 0C[Controlbits]
 250  01020                          LOAD s0, 20[AckFIFO]                           ; Wait
 251  09003                          INPUT s0, 03[Command]                          ; now get my character
 252  0307F                          AND s0, 7F                                     ; mask off top bit
 253  25000                          RETURN 
 254                                 ; routine to look at command input and recover 2 characters and return the byte they represent in s5.
 254  09603               Get2Chars: INPUT s6, 03[Command]
 255  1D680                          COMPARE s6, 80[128'd]                          ; if greater than 128, then no character
 256  3E254                          JUMP NC, 254[Get2Chars]
 257  2024E                          CALL 24E[GetFifoChar]
 258  00600                          LOAD s6, s0
 259  09703              Get2ndChar: INPUT s7, 03[Command]
 25A  1D780                          COMPARE s7, 80[128'd]                          ; if greater than 128, then no character
 25B  3E259                          JUMP NC, 259[Get2ndChar]
 25C  2024E                          CALL 24E[GetFifoChar]
 25D  00700                          LOAD s7, s0
 25E  2225F                          JUMP 25F[Chars2Byte]
 25F                                 ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 25F  00860              Chars2Byte: LOAD s8, s6
 260  2026A                          CALL 26A[Get4bits]
 261  00580                          LOAD s5, s8
 262  14506                          SL0 s5
 263  14506                          SL0 s5
 264  14506                          SL0 s5
 265  14506                          SL0 s5                                         ; put these 4 bits to MSBs
 266  00870                          LOAD s8, s7
 267  2026A                          CALL 26A[Get4bits]
 268  10580                          ADD s5, s8
 269  25000                          RETURN 
 26A                                 ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 26A  1D83C                Get4bits: COMPARE s8, 3C[60'd]                           ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 26B  3A26F                          JUMP C, 26F[char0_9]
 26C  19837                          SUB s8, 37[55'd]                               ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 26D  0380F                          AND s8, 0F                                     ; make sure only return 4 bits
 26E  25000                          RETURN 
 26F  19830                 char0_9: SUB s8, 30[48'd]
 270  0380F                          AND s8, 0F                                     ; make sure only return 4 bits
 271  25000                          RETURN 
 272                                 ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 272  00850              Byte2Chars: LOAD s8, s5                                    ; assumes 8 bit data is in s5
 273  1450E                          SR0 s5
 274  1450E                          SR0 s5
 275  1450E                          SR0 s5
 276  1450E                          SR0 s5                                         ; get first hex character
 277  2027E                          CALL 27E[GetChar]
 278  00650                          LOAD s6, s5                                    ; first ascii char
 279  00580                          LOAD s5, s8
 27A  0350F                          AND s5, 0F
 27B  2027E                          CALL 27E[GetChar]                              ; send to LCD or UART
 27C  00750                          LOAD s7, s5                                    ; second ascii char
 27D  25000                          RETURN 
 27E                                 ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 27E  1950A                 GetChar: SUB s5, 0A[10'd]                               ; Test if s5 greater than 9
 27F  3A282                          JUMP C, 282[is_0_9]                            ; Hex character is 0_9
 280  11541                          ADD s5, 41[65'd]                               ; offset for Ascii code 'A'
 281  25000                          RETURN 
 282  1150A                  is_0_9: ADD s5, 0A[10'd]                               ; return to range 0-9
 283  11530                          ADD s5, 30[48'd]                               ; offset to Ascii code for '0'
 284  25000                          RETURN 
 285                                 ; Registers used s0, s1, s2, s3, s4 and s5.
 285                                 ;
 285  01500                delay_1s: LOAD s5, 00                                    ; clear cycle counter
 286  01400                          LOAD s4, 00
 287  20298                 wait_1s: CALL 298[delay_1ms]
 288  11401                          ADD s4, 01                                     ; increment cycle counter
 289  13500                          ADDCY s5, 00
 28A  1D4E8                          COMPARE s4, E8[count_1000_lsb]                 ; test for 1000ms
 28B  36287                          JUMP NZ, 287[wait_1s]
 28C  1D503                          COMPARE s5, 03[count_1000_msb]
 28D  36287                          JUMP NZ, 287[wait_1s]
 28E  25000                          RETURN 
 28F                                 ;
 28F                                 ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 28F                                 ;
 28F                                 ;
 28F                                 ; Registers used s0, s1, s2, s3 and s4.
 28F                                 ;
 28F  20293             delay_300ms: CALL 293[delay_100ms]
 290  20293             delay_200ms: CALL 293[delay_100ms]
 291  20293                          CALL 293[delay_100ms]
 292  25000                          RETURN 
 293                                 ;
 293                                 ; Delay of approximately 100ms used for switch debounce
 293                                 ;
 293                                 ; Registers used s0, s1, s2, s3 and s4.
 293                                 ;
 293  01464             delay_100ms: LOAD s4, 64                                    ; repeat 1ms delay 100 times
 294  20298              wait_100ms: CALL 298[delay_1ms]
 295  19401                          SUB s4, 01
 296  36294                          JUMP NZ, 294[wait_100ms]
 297  25000                          RETURN 
 298                                 ;
 298                                 ; Delay of approximately 1ms required by LCD display
 298                                 ;
 298                                 ; Registers used s0, s1, s2 and s3.
 298                                 ;
 298  01300               delay_1ms: LOAD s3, 00                                    ; clear cycle counter
 299  01200                          LOAD s2, 00
 29A  202A7                wait_1ms: CALL 2A7[delay_1us]
 29B  11201                          ADD s2, 01                                     ; increment cycle counter
 29C  13300                          ADDCY s3, 00
 29D  1D2E8                          COMPARE s2, E8[count_1000_lsb]                 ; test for 1000us
 29E  3629A                          JUMP NZ, 29A[wait_1ms]
 29F  1D303                          COMPARE s3, 03[count_1000_msb]
 2A0  3629A                          JUMP NZ, 29A[wait_1ms]
 2A1  25000                          RETURN 
 2A2                                 ;
 2A2                                 ; Delay of approximately 50us required by LCD display
 2A2                                 ;
 2A2                                 ; Registers used s0 and s1.
 2A2                                 ;
 2A2  01132              delay_50us: LOAD s1, 32[50'd]                              ; repeat 1us delay 50 times
 2A3  202A7               wait_50us: CALL 2A7[delay_1us]
 2A4  19101                          SUB s1, 01
 2A5  362A3                          JUMP NZ, 2A3[wait_50us]
 2A6  25000                          RETURN 
 2A7                                 ; Delay of approximately 1us used to provide timing reference for
 2A7                                 ; LCD operations. This must be adjusted to reflect the clock
 2A7                                 ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 2A7                                 ;
 2A7                                 ; The software delay loop is formed using register s0. This register
 2A7                                 ; must be loaded with an integer value close to the result of....
 2A7                                 ;
 2A7                                 ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 2A7                                 ;
 2A7                                 ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 2A7                                 ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 2A7                                 ; operation will become lower than the 100KHz target intended.
 2A7                                 ;
 2A7                                 ; Register used s0.
 2A7                                 ;
 2A7  01006               delay_1us: LOAD s0, 06[delay_1us_constant]                ; delay value of 12 decimal for a 50MHz clock
 2A8  19001                wait_1us: SUB s0, 01
 2A9  362A8                          JUMP NZ, 2A8[wait_1us]
 2AA  25000                          RETURN 
 2AB                                 ;
 2AB                                 ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\home\graham\Dropbox\N3workingG\TE0722Rebuild\N3SysGen\DSPpicoReduced.psm



List of defined constants

 CONSTANT name         Value        Source PSM File

 timestamp_hours       22'd         
 timestamp_minutes     47'd         
 timestamp_seconds     45'd         
 datestamp_year        16'd         
 datestamp_month       7'd          
 datestamp_day         11'd         
 NUL                   00           
 BEL                   07           
 BS                    08           
 HT                    09           
 LF                    0A           
 VT                    0B           
 CR                    0D           
 ESC                   1B           
 DEL                   7F           
 DCS                   90           
 ST                    9C           
 AGClowthreshold       3'd          DSPpicoReduced.psm
 AGClowthreshold2      1'd          DSPpicoReduced.psm
 AGCInitial            4'd          DSPpicoReduced.psm
 AGCuppthreshold       5'd          DSPpicoReduced.psm
 AGCuppthreshold2      8'd          DSPpicoReduced.psm
 AGCuppthreshold4      11'd         DSPpicoReduced.psm
 delay_1us_constant    06           DSPpicoReduced.psm
 m                     8'd          DSPpicoReduced.psm
 m_plus_1              9'd          DSPpicoReduced.psm
 count_1000_lsb        E8           DSPpicoReduced.psm
 count_1000_msb        03           DSPpicoReduced.psm
 half_pi_LSB           00           DSPpicoReduced.psm
 half_pi_MSB           40           DSPpicoReduced.psm
 audioTest             2'd          DSPpicoReduced.psm
 StrtToneAInc          9F           DSPpicoReduced.psm
 StrtToneBInc          69           DSPpicoReduced.psm
 StopToneAInc          5A           DSPpicoReduced.psm
 StopToneBInc          78           DSPpicoReduced.psm
 coeffI0MSB            F6           DSPpicoReduced.psm
 coeffI0LSB            92           DSPpicoReduced.psm
 coeffI1MSB            F4           DSPpicoReduced.psm
 coeffI1LSB            8A           DSPpicoReduced.psm
 coeffI2MSB            F2           DSPpicoReduced.psm
 coeffI2LSB            CC           DSPpicoReduced.psm
 coeffI3MSB            F1           DSPpicoReduced.psm
 coeffI3LSB            77           DSPpicoReduced.psm
 coeffI4MSB            F0           DSPpicoReduced.psm
 coeffI4LSB            A1           DSPpicoReduced.psm
 coeffI5MSB            40           DSPpicoReduced.psm
 coeffI5LSB            00           DSPpicoReduced.psm
 coeffQ0MSB            00           DSPpicoReduced.psm
 coeffQ0LSB            A7           DSPpicoReduced.psm
 coeffQ1MSB            05           DSPpicoReduced.psm
 coeffQ1LSB            2D           DSPpicoReduced.psm
 coeffQ2MSB            0C           DSPpicoReduced.psm
 coeffQ2LSB            83           DSPpicoReduced.psm
 coeffQ3MSB            1B           DSPpicoReduced.psm
 coeffQ3LSB            4F           DSPpicoReduced.psm
 coeffQ4MSB            5C           DSPpicoReduced.psm
 coeffQ4LSB            2F           DSPpicoReduced.psm
 AudioMSB              0'd          DSPpicoReduced.psm
 AudioLSB              1'd          DSPpicoReduced.psm
 Strobe                2'd          DSPpicoReduced.psm
 Command               3'd          DSPpicoReduced.psm
 MltplyMSB             4'd          DSPpicoReduced.psm
 MltplyLSB             5'd          DSPpicoReduced.psm
 BTaudioMSB            6'd          DSPpicoReduced.psm
 BTaudioLSB            7'd          DSPpicoReduced.psm
 RAMdataMSB            8'd          DSPpicoReduced.psm
 RAMdataLSB            9'd          DSPpicoReduced.psm
 Status                10'd         DSPpicoReduced.psm
 MSBAudio              0'd          DSPpicoReduced.psm
 LSBAudio              1'd          DSPpicoReduced.psm
 SSBAmp                2'd          DSPpicoReduced.psm
 CmdToUser             3'd          DSPpicoReduced.psm
 CoeffMSB              4'd          DSPpicoReduced.psm
 CoeffLSB              5'd          DSPpicoReduced.psm
 SignalMSB             6'd          DSPpicoReduced.psm
 SignalLSB             7'd          DSPpicoReduced.psm
 Data2archiveMSB       10'd         DSPpicoReduced.psm
 Data2archiveLSB       11'd         DSPpicoReduced.psm
 Controlbits           12'd         DSPpicoReduced.psm
 EnMult                1'd          DSPpicoReduced.psm
 AckFIFO               32'd         DSPpicoReduced.psm
 PhaseIncrement        13'd         DSPpicoReduced.psm
 AudioFreqLSB          14'd         DSPpicoReduced.psm
 AudioPhaseMSB         15'd         DSPpicoReduced.psm
 AudioPhaseLSB         16'd         DSPpicoReduced.psm
 EnableSpeaker         17'd         DSPpicoReduced.psm
 MUXport               18'd         DSPpicoReduced.psm
 StartToneA            19'd         DSPpicoReduced.psm
 StartToneALong        20'd         DSPpicoReduced.psm
 StartToneB            21'd         DSPpicoReduced.psm
 StartToneBLong        22'd         DSPpicoReduced.psm
 StopToneA             23'd         DSPpicoReduced.psm
 StopToneALong         24'd         DSPpicoReduced.psm
 StopToneB             25'd         DSPpicoReduced.psm
 StopToneBLong         26'd         DSPpicoReduced.psm
 MSBBTAudio            27'd         DSPpicoReduced.psm
 LSBBTAudio            28'd         DSPpicoReduced.psm
 AmpMSB                10'd         DSPpicoReduced.psm
 AmpLSB                11'd         DSPpicoReduced.psm
 PhaseMSB              12'd         DSPpicoReduced.psm
 PhaseLSB              13'd         DSPpicoReduced.psm
 AGCvalue              14'd         DSPpicoReduced.psm
 VolSetting            15'd         DSPpicoReduced.psm
 OldPhaseMSB           16'd         DSPpicoReduced.psm
 AudioScratch          17'd         DSPpicoReduced.psm
 State                 18'd         DSPpicoReduced.psm
 LVPtr                 20'd         DSPpicoReduced.psm
 IaccuMSB              21'd         DSPpicoReduced.psm
 IaccuLSB              22'd         DSPpicoReduced.psm
 QaccuMSB              23'd         DSPpicoReduced.psm
 QaccuLSB              24'd         DSPpicoReduced.psm
 OldPhaseLSB           25'd         DSPpicoReduced.psm
 startsine             30'd         DSPpicoReduced.psm
 endsine               45'd         DSPpicoReduced.psm
 HistoryStart          70'd         DSPpicoReduced.psm
 HistoryStart42        112'd        DSPpicoReduced.psm
 AGCvalueTX            112'd        DSPpicoReduced.psm
 AGCvalueRX            113'd        DSPpicoReduced.psm
 AGCcounter            114'd        DSPpicoReduced.psm
 UARTBitshift          115'd        DSPpicoReduced.psm
 AveStrtToneAMSB_I     116'd        DSPpicoReduced.psm
 AveStrtToneALSB_I     117'd        DSPpicoReduced.psm
 AveStrtToneBMSB_I     118'd        DSPpicoReduced.psm
 AveStrtToneBLSB_I     119'd        DSPpicoReduced.psm
 AveStopToneAMSB_I     120'd        DSPpicoReduced.psm
 AveStopToneALSB_I     121'd        DSPpicoReduced.psm
 AveStopToneBMSB_I     122'd        DSPpicoReduced.psm
 AveStopToneBLSB_I     123'd        DSPpicoReduced.psm
 LongAveStrtToneAMSB_I 124'd        DSPpicoReduced.psm
 LongAveStrtToneALSB_I 125'd        DSPpicoReduced.psm
 LongAveStrtToneBMSB_I 126'd        DSPpicoReduced.psm
 LongAveStrtToneBLSB_I 127'd        DSPpicoReduced.psm
 LongAveStopToneAMSB_I 128'd        DSPpicoReduced.psm
 LongAveStopToneALSB_I 129'd        DSPpicoReduced.psm
 LongAveStopToneBMSB_I 130'd        DSPpicoReduced.psm
 LongAveStopToneBLSB_I 131'd        DSPpicoReduced.psm
 AveStrtToneAMSB_Q     132'd        DSPpicoReduced.psm
 AveStrtToneALSB_Q     133'd        DSPpicoReduced.psm
 AveStrtToneBMSB_Q     134'd        DSPpicoReduced.psm
 AveStrtToneBLSB_Q     135'd        DSPpicoReduced.psm
 AveStopToneAMSB_Q     136'd        DSPpicoReduced.psm
 AveStopToneALSB_Q     137'd        DSPpicoReduced.psm
 AveStopToneBMSB_Q     138'd        DSPpicoReduced.psm
 AveStopToneBLSB_Q     139'd        DSPpicoReduced.psm
 LongAveStrtToneAMSB_Q 140'd        DSPpicoReduced.psm
 LongAveStrtToneALSB_Q 141'd        DSPpicoReduced.psm
 LongAveStrtToneBMSB_Q 142'd        DSPpicoReduced.psm
 LongAveStrtToneBLSB_Q 143'd        DSPpicoReduced.psm
 LongAveStopToneAMSB_Q 144'd        DSPpicoReduced.psm
 LongAveStopToneALSB_Q 145'd        DSPpicoReduced.psm
 LongAveStopToneBMSB_Q 146'd        DSPpicoReduced.psm
 LongAveStopToneBLSB_Q 147'd        DSPpicoReduced.psm
 StrtToneAPtrMSB       148'd        DSPpicoReduced.psm
 StrtToneAPtrLSB       149'd        DSPpicoReduced.psm
 StrtToneBPtrMSB       150'd        DSPpicoReduced.psm
 StrtToneBPtrLSB       151'd        DSPpicoReduced.psm
 StopToneAPtrMSB       152'd        DSPpicoReduced.psm
 StopToneAPtrLSB       153'd        DSPpicoReduced.psm
 StopToneBPtrMSB       154'd        DSPpicoReduced.psm
 StopToneBPtrLSB       155'd        DSPpicoReduced.psm
 FirstToneInc          156'd        DSPpicoReduced.psm
 FirstToneInc02        158'd        DSPpicoReduced.psm
 FirstToneInc04        160'd        DSPpicoReduced.psm
 FirstToneInc06        162'd        DSPpicoReduced.psm
 NormalisedMagMSB      164'd        DSPpicoReduced.psm
 NormalisedMagLSB      165'd        DSPpicoReduced.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "11 Jul 2016"  
 timestamp$        "22:47:45"     



List of line labels

   Label                    Addr  Source PSM File

 * cold_start               000   DSPpicoReduced.psm
   AwaitAudioVal            04A   DSPpicoReduced.psm
   AwaitRise                04E   DSPpicoReduced.psm
   BackfromTransmitting     068   DSPpicoReduced.psm
   Divide32                 093   DSPpicoReduced.psm
   Divide4                  098   DSPpicoReduced.psm
   AudioDouble              09D   DSPpicoReduced.psm
 * Negvalue                 09F   DSPpicoReduced.psm
   islessthanneg31          0A4   DSPpicoReduced.psm
   islessthanneg63          0A8   DSPpicoReduced.psm
   Posvalue                 0AC   DSPpicoReduced.psm
   ismorethan31             0B1   DSPpicoReduced.psm
   ismorethan63             0B5   DSPpicoReduced.psm
 * Divide2                  0B9   DSPpicoReduced.psm
   TransmitAudio            0BC   DSPpicoReduced.psm
 * OutAmp                   0C7   DSPpicoReduced.psm
   TryAndDouble             0DC   DSPpicoReduced.psm
   BiggerThan63             0E1   DSPpicoReduced.psm
   BiggerThan128            0E5   DSPpicoReduced.psm
   Abs16Val                 0E8   DSPpicoReduced.psm
 * absval                   0F1   DSPpicoReduced.psm
   makeposval               0F4   DSPpicoReduced.psm
 * invertval                0F8   DSPpicoReduced.psm
   increaseAGC              0FC   DSPpicoReduced.psm
   increaseAGC2             101   DSPpicoReduced.psm
   increaseAGC4             106   DSPpicoReduced.psm
   decreaseAGC              109   DSPpicoReduced.psm
   decreaseAGC2             10E   DSPpicoReduced.psm
   AGC                      113   DSPpicoReduced.psm
   decrease3dB              11D   DSPpicoReduced.psm
   decrease1_5dB            12C   DSPpicoReduced.psm
 * AGCtest                  139   DSPpicoReduced.psm
   AGClooptst               13D   DSPpicoReduced.psm
   PerformFIR               144   DSPpicoReduced.psm
   Ibussiness               17B   DSPpicoReduced.psm
   Qbussiness               181   DSPpicoReduced.psm
   doIplus                  187   DSPpicoReduced.psm
   doQplus                  18F   DSPpicoReduced.psm
   doQminus                 197   DSPpicoReduced.psm
   doMult                   19F   DSPpicoReduced.psm
   GetRovingHistoryValues   1AB   DSPpicoReduced.psm
   resetLVptr               1B0   DSPpicoReduced.psm
   AdvanceRptr              1B2   DSPpicoReduced.psm
   UpdateRptr               1B5   DSPpicoReduced.psm
   conjugateDiff            1BB   DSPpicoReduced.psm
   Export2User              1C0   DSPpicoReduced.psm
 * ArchiveData              1C8   DSPpicoReduced.psm
 * Frequency                1CB   DSPpicoReduced.psm
   cordic                   1CF   DSPpicoReduced.psm
   cordicloop               1D4   DSPpicoReduced.psm
 * negrotate                1D8   DSPpicoReduced.psm
   posrotate                1E6   DSPpicoReduced.psm
   testcordicend            1F3   DSPpicoReduced.psm
   GetPhaseIncrement        1F7   DSPpicoReduced.psm
   shift                    1FF   DSPpicoReduced.psm
   shiftloop                200   DSPpicoReduced.psm
   rotate90                 206   DSPpicoReduced.psm
 * sub90                    20A   DSPpicoReduced.psm
   add90                    213   DSPpicoReduced.psm
   Transmitmode             21C   DSPpicoReduced.psm
   GrabTXAGCvalue           224   DSPpicoReduced.psm
   Receivemode              227   DSPpicoReduced.psm
   BlockDSPpico             22F   DSPpicoReduced.psm
   Respond2Fifo             23A   DSPpicoReduced.psm
   SendGParamBack           248   DSPpicoReduced.psm
   SendSParamBack           24B   DSPpicoReduced.psm
   GetFifoChar              24E   DSPpicoReduced.psm
   Get2Chars                254   DSPpicoReduced.psm
   Get2ndChar               259   DSPpicoReduced.psm
   Chars2Byte               25F   DSPpicoReduced.psm
   Get4bits                 26A   DSPpicoReduced.psm
   char0_9                  26F   DSPpicoReduced.psm
   Byte2Chars               272   DSPpicoReduced.psm
   GetChar                  27E   DSPpicoReduced.psm
   is_0_9                   282   DSPpicoReduced.psm
 * delay_1s                 285   DSPpicoReduced.psm
   wait_1s                  287   DSPpicoReduced.psm
 * delay_300ms              28F   DSPpicoReduced.psm
 * delay_200ms              290   DSPpicoReduced.psm
   delay_100ms              293   DSPpicoReduced.psm
   wait_100ms               294   DSPpicoReduced.psm
   delay_1ms                298   DSPpicoReduced.psm
   wait_1ms                 29A   DSPpicoReduced.psm
 * delay_50us               2A2   DSPpicoReduced.psm
   wait_50us                2A3   DSPpicoReduced.psm
   delay_1us                2A7   DSPpicoReduced.psm
   wait_1us                 2A8   DSPpicoReduced.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            141
 STAR              -

 AND              10
 OR                1
 XOR               -

 ADD              30
 ADDCY            14
 SUB              28
 SUBCY            11

 TEST              -
 TESTCY            -
 COMPARE          45
 COMPARECY         -

 SL0               7
 SL1               -
 SLX               -
 SLA               4
 RL                -
 SR0              11
 SR1               -
 SRX              20
 SRA              20
 RR                -

 REGBANK           -

 INPUT            13
 OUTPUT           34
 OUTPUTK           -

 STORE            33
 FETCH            33

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             33
 JUMP@             -
 CALL             95
 CALL@             -
 RETURN           71
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
