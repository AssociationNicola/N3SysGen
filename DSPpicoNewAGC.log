KCPSM6 Assembler log file for program 'Z:\home\gnaylor\Dropbox\N3SysGen\DSPpicoNewAGC.psm'.
Generated by KCPSM6 version v2.63
Ken Chapman - Xilinx Ltd - 20th December 2013

Assembly datestamp: 08 Jul 2017
Assembly timestamp: 15:21:48

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 2B0 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 689
Memory locations available: 3407


Assembly listing

 Addr Code                             Instruction

 000                                   ;GV0B  To add code to take into account amplitude of start tone detected to adjust AGC, attack 32ms decay 1024ms
 000                                   ;GV07 correct incorrect data archive and demod peak display problem (MSB/LSB mixup!)
 000                                   ;GV06 increase SSB amplitude on TX
 000                                   ;GV03 corrected OutAmp doubling and increased speaker volume
 000                                   ;GV02 Halved AGC thresholds to avoid clipping
 000                                   ;GV01 Reduce Speaker volume by increasing AGC value to 63 on startup
 000                                   ;GV00 return counter to zero for new Zynq design
 000                                   ;GVA5 for TE0722, with RX/TX frequencies adjusted for 32.768MHz (mod in Keypad assembler)
 000                                   ;GVA4 correct bad setting of AvesignalMSB instead of USB (caused crashing)
 000                                   ;GVA2 BT input from mic is taken externally in logic - also removed audio double so as not to saturate voice on transmission (but will drop volume on handset ~6dB)
 000                                   ;AND over haul AGC to use 24 bit average level registering so level is monitored with AveSignalUSB
 000                                   ;GVA1 Try to implement tone detect parts
 000                                   ;GVA0 Project to get AGC to act on external MUX, but still use last 4 bits for decrease 3dB and 1.5dB in the Pico
 000                                   ;GV9B to do - mods to detect start and end tones
 000                                   ;GV96 readjust AGC settings and bit offsets
 000                                   ;GV93add back divide by 2 on transmit line 567
 000                                   ; GV51 remove level divide by 2 on transmit to compensate for drop in AGC level (so only reduces level for receive)
 000                                   ;GV50, drop DSP AGC levels back to just below as in GV45
 000                                   ;GV47 increase DSP AGC thresholds
 000                                   ;GV46 added further double on RF out amplitude
 000                                   ;GV45 Corrected resetting of AveSignalMSB to middle value so as to avoid double jump and increased allowable rang to avoid unnecessary jumps (abd corrected AGC wrapping in GV44 when limiting if greater than 44 rather than to 44 ie CALL Z not CALL NC !!!)
 000                                   ;GV44 add 1_5dB decrease - still need to correct AGC range (increase another factor 2) and decrease limits
 000                                   ;GV43 correct beacon phase wander
 000                                   ;GV42 disable UART streaming
 000                                   ;GV3F Add streaming over UART on TX (State bit 2 set)
 000                                   ;GV3E try adding small sine wave - not yet implemented
 000                                   ;For GV3D, need to add further routines, increaseAGC2 and increaseAGC4 that increase attenuation 6dB and 12dB respectively (within limits) - look at how AveSignalMSB is reset.
 000                                   ;For GV3B try to correct incorrect AGC operation with twice as many values
 000                                   ;store TX AGCvalue before warble (or when stable) and add 3dB steps to AGCvalue
 000                                   ;31/1/13 Added 12dB to BT mic level using Audiodouble
 000                                   ;GV38 Use audio double on transmitpath
 000                                   ;For GV37 Adjusted AGC thresholds and increased time constant a factor 8.
 000                                   ;31/12/12 increase volume and transmitted power by increasing AGC setting a factor of 2 (from 4,12 to 8,24 - AGCupp/lowthreshold). Also set AGCvalue to 06 INITIALY (may need to be adjusted) recall last AGCvalue when switch mode. Line 439 increase TX modulation.
 000                                   ;removed LPF
 000                                   ;Increased AGC setting -36 OK, 72 too high (bad clipping noise)
 000                                   ;Slow saturation of SSBamp
 000                                   ;Added BT signal not present flag (16/1/12)
 000                                   ;Try to fix failure to un-block DSP problem (18/11/11 in DSPblock routine)
 000                                   ;Uses phase representation of TX audio - works in study OK 18/11/11
 000                                   ;29/8/11 Increased audio frequency resolution to 16 bits
 000                                   ;19/8/11, tweaked audio scaling of TX
 000                                   ;Modified vor BT input
 000                                   ;This needs to be modified for COTS version at 49.152MHz - in particular calibration of audio frequency output to SSB modulator has been modified see line 398
 000                                   ; Inputs sine wave as audio
 000                                   ; 20/7 updated input and output ports for multipico version
 000                                   ; Feb 09 Start testing AGC part of streamed signal
 000                                   ; Now implementing on SSBN.mdl
 000                                   ;
 000                                   ; DSP routine for SSB picoblaze
 000                                   ;
 000                                   ; Implemented commands:
 000                                   ; 0 = RX mode
 000                                   ;Different AGC threshold values are now used for RX and TX
 000                                   ;CONSTANT AGClowthreshold,  6'd      ;;These are thresholds for the measured signal - Increase a factor of 2 17/4/14
 000                                   ;CONSTANT AGClowthreshold2,  2'd      ;;These are thresholds for the measured signal
 000                                   ;CONSTANT AGCInitial,  8'd      ;;This is mid way between thresholds Is upperthreshold2> SR0> minus 2
 000                                   ;CONSTANT AGCuppthreshold,  10'd
 000                                   ;CONSTANT AGCuppthreshold2,  16'd   ;3dB above first threshold
 000                                   ;CONSTANT AGCuppthreshold4,  22'd
 000                                   ;CONSTANT AGCuppthresholdRX2,  10'd   ;Change to 10 (June2017 after BCRC) Upp2 = 10 Upp =5 Initial = 4 low=2 low2=1
 000                                   ;CONSTANT AGCuppthresholdTX2,  6'd   ;Upp2=6 Upp=3 Initial=2 low=2 low2=1
 000                                   CONSTANT AGChigh, 40'd                              ;High threshold for AGC (accumulated over 32ms) (reduced back to 40)
 000                                   CONSTANT AGClow, 50'd                               ;Low threshold for AGC (accumulated over 1024ms) (increased from 20 with 512ms accumulation)
 000                                   CONSTANT AGClow2, 25'd                              ;Even lower threshold for AGC (accumulated over 1024ms)
 000                                   CONSTANT delay_1us_constant, 06                     ; Value (13)19 or 12? decimal suitable for 50MHz clock – about 6 for 33MHz?
 000                                   CONSTANT m, 8'd                                     ; No. of iterations for cordic
 000                                   CONSTANT m_plus_1, 9'd                              ; No. of iterations for cordic
 000                                   CONSTANT count_1000_lsb, E8                         ; lower 8-bits of 1000 count value
 000                                   CONSTANT count_1000_msb, 03                         ; upper 8-bits of 1000 count value
 000                                   CONSTANT half_pi_LSB, 00                            ;
 000                                   CONSTANT half_pi_MSB, 40                            ; 360 degrees = $10000
 000                                   CONSTANT audioTest, 2'd                             ; Frequency 2=800Hz, 3=1200Hz, 4=1.6kHz 7=2.8kHz
 000                                   ;Frequency values for start and stop tones
 000                                   ;CONSTANT StrtToneAInc,   9F
 000                                   ;CONSTANT StrtToneBInc,   69
 000                                   ;CONSTANT StopToneAInc,   5A
 000                                   ;CONSTANT StopToneBInc,   78
 000                                   ; FIR coefficients for 0 and 90 degree filterred signals, these are SIGNED values!!
 000                                   CONSTANT coeffI0MSB, F6                             ; Smallest coefficient (negative value!)
 000                                   CONSTANT coeffI0LSB, 92
 000                                   CONSTANT coeffI1MSB, F4
 000                                   CONSTANT coeffI1LSB, 8A
 000                                   CONSTANT coeffI2MSB, F2
 000                                   CONSTANT coeffI2LSB, CC
 000                                   CONSTANT coeffI3MSB, F1
 000                                   CONSTANT coeffI3LSB, 77
 000                                   CONSTANT coeffI4MSB, F0
 000                                   CONSTANT coeffI4LSB, A1
 000                                   CONSTANT coeffI5MSB, 40                             ; Actualy half value of peak
 000                                   CONSTANT coeffI5LSB, 00
 000                                   ; Q values are still signed but are all positive
 000                                   CONSTANT coeffQ0MSB, 00                             ; Smallest coefficient
 000                                   CONSTANT coeffQ0LSB, A7
 000                                   CONSTANT coeffQ1MSB, 05
 000                                   CONSTANT coeffQ1LSB, 2D
 000                                   CONSTANT coeffQ2MSB, 0C
 000                                   CONSTANT coeffQ2LSB, 83
 000                                   CONSTANT coeffQ3MSB, 1B
 000                                   CONSTANT coeffQ3LSB, 4F
 000                                   CONSTANT coeffQ4MSB, 5C
 000                                   CONSTANT coeffQ4LSB, 2F
 000                                   ; Registers
 000                                   NAMEREG sF, AveSignal1024ms                         ; In fact accumulate of magnitude over 1024ms
 000                                   NAMEREG sE, AveSignalMSB                            ;average up to 32ms
 000                                   NAMEREG sD, AveSignalLSB
 000                                   ;NAMEREG  sD, BaselineMSB                  ; In fact average of signed signal
 000                                   ;NAMEREG  sC, BaselineLSB
 000                                   NAMEREG sC, SineCtr                                 ;Aargh sB is used by the Cordic!! - but not used now
 000                                   ; registers sA-sD are used for longish term storage...!
 000                                   ; sA used for cordic calcs and FIR work for relative pos of roving ptr
 000                                   ; Scratch pad
 000                                   ; registers 0-8 used for cordic table:
 000                                   ; reg 0=45degrees
 000                                   ; ..
 000                                   ; reg 7=0.44761degrees
 000                                   ; Input port
 000                                   CONSTANT AudioMSB, 0'd
 000                                   CONSTANT AudioLSB, 1'd
 000                                   CONSTANT Strobe, 2'd                                ;     bit0=6kHz square wave - the rest are now zeros
 000                                   CONSTANT Command, 3'd                               ; From interface pico
 000                                   CONSTANT MltplyMSB, 4'd                             ; Top significant byte of multiplier output
 000                                   CONSTANT MltplyLSB, 5'd                             ; (only 16 bits retained)
 000                                   CONSTANT BTaudioMSB, 6'd                            ; Input from headset micro
 000                                   CONSTANT BTaudioLSB, 7'd                            ;
 000                                   CONSTANT SaturationBits, 8'd                        ;lowest 3 bits are the top 3 bits of the 18bit demod signal (indicate saturation) - the top 5 bits are zeros
 000                                   CONSTANT RAMdataLSB, 9'd
 000                                   CONSTANT Status, 10'd                               ;bit 0 is DSP2user fifo full, bit 1 is no BT audio stream from headset microphone, bit 2 is TX_high, bit 3 is speaker on (from tone detect)
 000                                   CONSTANT StartToneAmp, 11'd
 000                                   ; Output ports
 000                                   CONSTANT MSBAudio, 0'd
 000                                   CONSTANT LSBAudio, 1'd
 000                                   CONSTANT SSBAmp, 2'd
 000                                   CONSTANT CmdToUser, 3'd
 000                                   CONSTANT CoeffMSB, 4'd
 000                                   CONSTANT CoeffLSB, 5'd
 000                                   CONSTANT SignalMSB, 6'd
 000                                   CONSTANT SignalLSB, 7'd
 000                                   CONSTANT Data2archiveMSB, 10'd
 000                                   CONSTANT Data2archiveLSB, 11'd
 000                                   CONSTANT Controlbits, 12'd                          ; BIT OFFSETS:
 000                                   ; Bit offsets:
 000                                   CONSTANT EnMult, 1'd
 000                                   CONSTANT AckFIFO, 32'd                              ;   5 Acknowledge FIFO (present character)
 000                                   CONSTANT PhaseIncrement, 13'd
 000                                   CONSTANT AudioFreqLSB, 14'd
 000                                   CONSTANT AudioPhaseMSB, 15'd
 000                                   CONSTANT AudioPhaseLSB, 16'd
 000                                   CONSTANT EnableSpeaker, 17'd
 000                                   CONSTANT MUXport, 18'd                              ;New port to drive AGC MUX (middle 4 bits)- called AGCvalue in Sysgen model
 000                                   ;CONSTANT StartToneA,   19'd
 000                                   ;CONSTANT StartToneALong,   20'd
 000                                   ;CONSTANT StartToneB,   21'd
 000                                   ;CONSTANT StartToneBLong,   22'd
 000                                   ;CONSTANT NotUsed,   23'd
 000                                   CONSTANT AveSignal1024msport, 24'd
 000                                   CONSTANT AveSignalMSBport, 25'd
 000                                   CONSTANT AveSignalLSBport, 26'd
 000                                   CONSTANT MSBBTAudio, 27'd
 000                                   CONSTANT LSBBTAudio, 28'd
 000                                   ; Scratchpad registers
 000                                   ; 0-8 used for Cordic Table!
 000                                   CONSTANT AmpMSB, 10'd
 000                                   CONSTANT AmpLSB, 11'd                               ; Bit 0 toggles at 16kHz
 000                                   CONSTANT PhaseMSB, 12'd
 000                                   CONSTANT PhaseLSB, 13'd                             ; Is this necessary?
 000                                   CONSTANT AGCvalue, 14'd                             ; four times number of bits to shift (63-0) 63 is max attenuation
 000                                   CONSTANT VolSetting, 15'd
 000                                   CONSTANT OldPhaseMSB, 16'd
 000                                   CONSTANT AudioScratch, 17'd
 000                                   CONSTANT State, 18'd                                ; Bit 1 0=RX, 1=TX (TX_high), Bit 2 set is streaming TX data from UART, Bit 3 is 'Receiving' ie 0 when idle.
 000                                   ;CONSTANT NormalisedSignalMSB,   19'd                  ; Current signal MSB after AGC
 000                                   CONSTANT LVPtr, 20'd                                ; From HistoryStart to HistoryStart+41 (place to store most recent signal value)
 000                                   CONSTANT IaccuMSB, 21'd
 000                                   CONSTANT IaccuLSB, 22'd
 000                                   CONSTANT QaccuMSB, 23'd
 000                                   CONSTANT QaccuLSB, 24'd
 000                                   CONSTANT OldPhaseLSB, 25'd
 000                                   ; Scratch pad 30-69 used for sinewave - 20 values for sinewave, 40 for dirac
 000                                   CONSTANT startsine, 30'd
 000                                   CONSTANT endsine, 45'd
 000                                   CONSTANT HistoryStart, 70'd                         ; 2 bytes per historical sample - 21 2byte history values
 000                                   CONSTANT HistoryStart42, 112'd                      ; 2 bytes per historical sample - 21 2byte history values
 000                                   ; History values up to and including 111
 000                                   CONSTANT AGCvalueTX, 112'd
 000                                   CONSTANT AGCvalueRX, 113'd
 000                                   CONSTANT AGCcounter, 114'd                          ;store counter 0 to 255 to only perform AGC calc every 1 in 4 audio samples and sinewave increment every 8 samples
 000                                   ;Removed Tone related scratchregisters
 000                                   CONSTANT NormalisedMagMSB, 115'd                    ;Absolute value of current signal
 000                                   CONSTANT NormalisedMagLSB, 116'd                    ;Absolute value of current signal
 000                                   ;CONSTANT AGCupperThresholdRX2, 117'd ;This is in fact twice the Upper threshold SR0 for Upper threshold, SRO and +1 for lower threshold and SR0 again for lower threshold2
 000                                   ;CONSTANT AGCupperThresholdTX2, 118'd ;This is in fact twice the Upper threshold
 000                                   ;CONSTANT    AGCupperThresholdInUse, 119'd ;This is the value relevent to the current mode (RX/TX)
 000                                   CONSTANT AGCcounterMSB, 117'd                       ;Uses for 1024ms accumulation
 000                                   ;256 scratchpad addresses available
 000                                   ;GenerateCode        MEM       "S3eDSPprog.mem"
 000                                   ;start:              JUMP      cold_start       -Try without jump to $20 offset - should work!?
 000                                   ; Start of program (Jump instruction in preloaded memory!)
 000                                   ;                   ORG       $20
 000                                   ; pre-load scratchpad with cordic table.. 360 degrees is $0800 - then *32=$10000
 000  010FF                cold_start: LOAD s0, FF[255'd]                                  ; phase for 45 degrees- actually a bit less!
 001  2F000                            STORE s0, 00
 002  01097                            LOAD s0, 97[151'd]                                  ; phase for 26.565 degrees
 003  2F001                            STORE s0, 01
 004  01050                            LOAD s0, 50[80'd]                                   ; phase for 14.036 degrees
 005  2F002                            STORE s0, 02
 006  01029                            LOAD s0, 29[41'd]                                   ; phase for 7.125 degrees
 007  2F003                            STORE s0, 03
 008  01014                            LOAD s0, 14[20'd]                                   ; phase for 3.576 degrees
 009  2F004                            STORE s0, 04
 00A  0100A                            LOAD s0, 0A[10'd]                                   ; phase for 1.79 degrees
 00B  2F005                            STORE s0, 05
 00C  01005                            LOAD s0, 05[5'd]                                    ; phase for 0.895 degrees
 00D  2F006                            STORE s0, 06
 00E  01003                            LOAD s0, 03[3'd]                                    ; phase for 0.448 degrees
 00F  2F007                            STORE s0, 07
 010  01001                            LOAD s0, 01[1'd]                                    ; phase for 0.224 degrees
 011  2F008                            STORE s0, 08
 012                                   ;Do still need this with new AGC !!
 012  01032                            LOAD s0, 32[50'd]
 013  2F070                            STORE s0, 70[AGCvalueTX]
 014  01034                            LOAD s0, 34[52'd]
 015  2F071                            STORE s0, 71[AGCvalueRX]                            ;set to lowish value for RX
 016                                   ;    LOAD   s0,AGCuppthresholdRX2
 016                                   ;    STORE     s0,AGCupperThresholdRX2
 016                                   ;    LOAD   s0,AGCuppthresholdTX2
 016                                   ;    STORE     s0,AGCupperThresholdTX2
 016                                   ;Sinewave table: Step through this 1 in 8 loops to give 62.5Hz sinewave on transmission
 016  01002                            LOAD s0, 02[2'd]                                    ; 1st element of sinewave
 017  2F01E                            STORE s0, 1E[30'd]
 018  01003                            LOAD s0, 03[3'd]                                    ; 2nd element of sinewave
 019  2F01F                            STORE s0, 1F[31'd]
 01A  01004                            LOAD s0, 04[4'd]                                    ; 3rd element of sinewave
 01B  2F020                            STORE s0, 20[32'd]
 01C  01004                            LOAD s0, 04[4'd]                                    ; etc
 01D  2F021                            STORE s0, 21[33'd]
 01E  01004                            LOAD s0, 04[4'd]                                    ; etc
 01F  2F022                            STORE s0, 22[34'd]
 020  01003                            LOAD s0, 03[3'd]                                    ;
 021  2F023                            STORE s0, 23[35'd]
 022  01002                            LOAD s0, 02[2'd]                                    ; etc
 023  2F024                            STORE s0, 24[36'd]
 024  01000                            LOAD s0, 00[0'd]                                    ; etc
 025  2F025                            STORE s0, 25[37'd]
 026  010FE                            LOAD s0, FE[254'd]                                  ; etc
 027  2F026                            STORE s0, 26[38'd]
 028  010FD                            LOAD s0, FD[253'd]                                  ;
 029  2F027                            STORE s0, 27[39'd]
 02A  010FC                            LOAD s0, FC[252'd]                                  ; etc
 02B  2F028                            STORE s0, 28[40'd]
 02C  010FC                            LOAD s0, FC[252'd]                                  ; etc
 02D  2F029                            STORE s0, 29[41'd]
 02E  010FC                            LOAD s0, FC[252'd]                                  ; etc
 02F  2F02A                            STORE s0, 2A[42'd]
 030  010FD                            LOAD s0, FD[253'd]                                  ;
 031  2F02B                            STORE s0, 2B[43'd]
 032  010FE                            LOAD s0, FE[254'd]                                  ; etc
 033  2F02C                            STORE s0, 2C[44'd]
 034  01000                            LOAD s0, 00[0'd]                                    ; etc
 035  2F02D                            STORE s0, 2D[45'd]
 036                                   ;                LOAD      s0, 254'd             ; etc
 036                                   ;                   STORE     s0, 46'd
 036                                   ;                  LOAD      s0, 0'd             ;
 036                                   ;                 STORE     s0, 47'd
 036                                   ;                LOAD      s0, 247'd             ; etc
 036                                   ;               STORE     s0, 48'd
 036                                   ;              LOAD      s0, 0'd               ; etc
 036                                   ;             STORE     s0, 49'd
 036  0102A                            LOAD s0, 2A[42'd]
 037  2D002                            OUTPUT s0, 02[SSBAmp]
 038  01000                            LOAD s0, 00
 039  2F012                            STORE s0, 12[State]                                 ; Set state to 0 ie receive
 03A  01C1E                            LOAD sC[SineCtr], 1E[startsine]                     ; reset SineCtr
 03B  01046                            LOAD s0, 46[HistoryStart]                           ;aargh - had commented this out!!!! May2013
 03C  2F014                            STORE s0, 14[LVPtr]
 03D                                   ; Initialise AGC
 03D  010FF                            LOAD s0, FF[255'd]                                  ; - 1
 03E  2F00F                            STORE s0, 0F[VolSetting]
 03F  01020                            LOAD s0, 20[32'd]                                   ;Start with medium attenuation (max 63) value for external AGC MUX version
 040  2F00E                            STORE s0, 0E[AGCvalue]                              ;maybe start with 16 (was 8)?
 041                                   ; Routine to look at lowest bit of Strobe to detect rising edge.
 041  09002             AwaitAudioVal: INPUT s0, 02[Strobe]
 042  03001                            AND s0, 01                                          ; look only at lowest bit
 043  1D001                            COMPARE s0, 01
 044  32041                            JUMP Z, 041[AwaitAudioVal]                          ; if 1 wait...
 045  09002                 AwaitRise: INPUT s0, 02[Strobe]
 046  03001                            AND s0, 01                                          ; look only at lowest bit
 047  1D000                            COMPARE s0, 00
 048  32045                            JUMP Z, 045[AwaitRise]                              ; if 0 still, wait a bit more...
 049  09008                            INPUT s0, 08[SaturationBits]                        ;to get 3 "saturation bits"
 04A  1D007                            COMPARE s0, 07
 04B  32056                            JUMP Z, 056[Allswell]
 04C  1D000                            COMPARE s0, 00
 04D  32056                            JUMP Z, 056[Allswell]
 04E                                   ;So is hitting the rails!! but don't act on AGC as causes too much of a jump! - just clip instead!
 04E                                   ;     FETCH s1,AGCvalue
 04E                                   ;     COMPARE s1,60'd
 04E                                   ;     JUMP NC,isTopAGCalready  ;if AGCvalue 60,61,62 or 63
 04E                                   ;     ADD  s1,04
 04E                                   ;     AND  s1,FC ;Get rid of lower 2 bits
 04E                                   ;     STORE s1,AGCvalue ;increase attenuation!
 04E  1D004           isTopAGCalready: COMPARE s0, 04
 04F  3A053                            JUMP C, 053[SaturatedPositive]
 050  01000                            LOAD s0, 00                                         ;Is actually saturated negative
 051  01180                            LOAD s1, 80                                         ;This is the most negative number
 052  22058                            JUMP 058[HaveInput]
 053  010FF         SaturatedPositive: LOAD s0, FF
 054  0117F                            LOAD s1, 7F
 055  22058                            JUMP 058[HaveInput]
 056  09001                  Allswell: INPUT s0, 01[AudioLSB]                              ; Now have the new value (different addresses from before!)
 057  09100                            INPUT s1, 00[AudioMSB]
 058                                   ; perform automatic gain contrl
 058  0B30E                 HaveInput: FETCH s3, 0E[AGCvalue]                              ;This needs to be corrected from the value from tone detect when 'Receiving'
 059  20119                            CALL 119[AGC]                                       ;Now with external MUX to adjust AGC
 05A  200FB                            CALL 0FB[Abs16Val]
 05B  2F373                            STORE s3, 73[NormalisedMagMSB]
 05C  2F274                            STORE s2, 74[NormalisedMagLSB]
 05D                                   ;Now check if we are transmitting this value!
 05D  0B212                            FETCH s2, 12[State]
 05E  03202                            AND s2, 02
 05F  1D202                            COMPARE s2, 02                                      ; Check if transmit mode
 060  320D4                            JUMP Z, 0D4[TransmitAudio]
 061  2D100                            OUTPUT s1, 00[MSBAudio]
 062  2D001                            OUTPUT s0, 01[LSBAudio]
 063                                   ;       CALL AudioDouble     ;increase volume 6 dB! Add 2 of these 26/2/15
 063                                   ;       CALL AudioDouble     ;increase volume 12 dB! Add may 16
 063                                   ;      CALL AudioDouble     ;increase volume 12 dB!
 063                                   ;      AND s0, f8   ;Make bottom 3 bits zero in case is 13 bit linear and these are attenuation bits
 063  2D11B                            OUTPUT s1, 1B[MSBBTAudio]
 064  2D01C                            OUTPUT s0, 1C[LSBBTAudio]
 065                                   ;Display demodulated values only in receive
 065  2D10A                            OUTPUT s1, 0A[Data2archiveMSB]                      ;This is received demodulated data
 066  2D00B                            OUTPUT s0, 0B[Data2archiveLSB]
 067  14000                            SLA s0                                              ;shift top bit into carry
 068  13100                            ADDCY s1, 00                                        ;s1 now rounded value of upper 8 bits (but s0 wasted!)
 069                                   ; Check if there is a command from the User, return here with JUMP command from TransmitAudio macro
 069  09003      BackfromTransmitting: INPUT s0, 03[Command]                               ; Check if FIFO character present
 06A  1D080                            COMPARE s0, 80[128'd]                               ; is there a character?
 06B  38240                            CALL C, 240[Respond2Fifo]
 06C                                   ; Accumulate magnitudes over 32 and 1024ms
 06C                                   ;__________________________________________________________________________________________
 06C  0B373                            FETCH s3, 73[NormalisedMagMSB]
 06D  10D30                            ADD sD[AveSignalLSB], s3
 06E  13E00                            ADDCY sE[AveSignalMSB], 00
 06F  3808A                            CALL C, 08A[FourTimestooBig]                        ; Has saturated so need to go and cool it! - increase AGC by 16 steps!
 070  0B30E                            FETCH s3, 0E[AGCvalue]                              ;put AGCvalue in s3 incase we call BitTooBig
 071  1DE28                            COMPARE sE[AveSignalMSB], 28[AGChigh]
 072  3C092                            CALL NC, 092[BitTooBig]                             ;Accumulated magnitude during 32ms period is too big
 073  0B372                            FETCH s3, 72[AGCcounter]
 074  11301                            ADD s3, 01
 075  2F372                            STORE s3, 72[AGCcounter]
 076  1D300                            COMPARE s3, 00                                      ;Has it overflowed - ie after 32ms
 077  36041                            JUMP NZ, 041[AwaitAudioVal]                         ;Loop back if not
 078                                   ;The following executes every 32ms
 078                                   ;Add another counter here to go to 32x32ms
 078  0B30E                            FETCH s3, 0E[AGCvalue]                              ;put AGCvalue in s3 incase we call BitTooBig
 079  10FE0                            ADD sF[AveSignal1024ms], sE[AveSignalMSB]           ;accumulate 32ms sum into this register
 07A  38092                            CALL C, 092[BitTooBig]                              ;If 1s average goes over 255, then increase AGCvalue (added 7 July2017)
 07B  2DE19                            OUTPUT sE[AveSignalMSB], 19[AveSignalMSBport]       ;AveSignalMSB is actually a register 32ms average! - before resetting to zero!
 07C  2DD1A                            OUTPUT sD[AveSignalLSB], 1A[AveSignalLSBport]       ;AveSignalMSB is actually a register!
 07D  01E00                            LOAD sE[AveSignalMSB], 00                           ;and reset 32ms sum to zero
 07E  0B375                            FETCH s3, 75[AGCcounterMSB]
 07F  11301                            ADD s3, 01
 080  2F375                            STORE s3, 75[AGCcounterMSB]                         ;Increment second byte counter
 081  0331F                            AND s3, 1F                                          ;get 0-31 count of 32ms
 082  1D300                            COMPARE s3, 00                                      ;Are we at 1024ms
 083  36041                            JUMP NZ, 041[AwaitAudioVal]
 084                                   ;Have reached 1024ms
 084                                   ;Output AveSignalMSB to PS - ever ~0.5s AveSignal1024ms
 084  2DF18                            OUTPUT sF[AveSignal1024ms], 18[AveSignal1024msport] ;1024ms average
 085  0B30E                            FETCH s3, 0E[AGCvalue]
 086                                   ;AGCvalue still in s3
 086  1DF32                            COMPARE sF[AveSignal1024ms], 32[AGClow]
 087  380A4                            CALL C, 0A4[BitTooLow]
 088  01F00                            LOAD sF[AveSignal1024ms], 00                        ;and reset 1024ms sum to zero (had forgotten this!!)
 089                                   ;disable the following 7 lines for the moment
 089                                   ;Don't do this if Speaker is ON - ie is receiving a message, but on first time that Speaker on is high do a correction of AGCvalue
 089                                   ;   INPUT s0,Status
 089                                   ;   AND s0,08  ;Look at speaker on bit - this is information from the tone detect pico!
 089                                   ;   COMPARE s0,08
 089                                   ;   JUMP Z,Receiving ;Check if receiving state is alread latched or whether this is first time to notice that we are receiving
 089                                   ;If not receiving a signal better reset state bit 3
 089                                   ;   FETCH     s1, State
 089                                   ;              AND        s1, F7  ;bit 3 zero
 089                                   ;             STORE     s1, State           ; reset bit 3 (ie set internal DSP state to 'not receiving')
 089                                   ;ContinueReceiving:
 089                                   ; Now adjust AGC value if necessary
 089  22041                            JUMP 041[AwaitAudioVal]
 08A                                   ; -------------This is end of main loop--------------------------------
 08A                                   ;Well big!!
 08A  0B30E           FourTimestooBig: FETCH s3, 0E[AGCvalue]
 08B  01E00                            LOAD sE[AveSignalMSB], 00                           ;reset 32ms accumulation - so only increase once!
 08C  01204             FourTimesLoop: LOAD s2, 04
 08D  2010F                            CALL 10F[increaseAGC]                               ;need to do this just 4 times!
 08E  19201                            SUB s2, 01                                          ;decrement counter
 08F  1D200                            COMPARE s2, 00                                      ;Has counter reached zero
 090  3608C                            JUMP NZ, 08C[FourTimesLoop]
 091  25000                            RETURN                                              ;Return after 16 loops
 092                                   ; So need to adjust AGCvalue:
 092                                   ;Enter with AGCvalue in s3
 092  01E00                 BitTooBig: LOAD sE[AveSignalMSB], 00                           ;and reset 32ms sum to zero
 093  2010F                            CALL 10F[increaseAGC]                               ; signal slightly too big, increase attenuation by 1_5dB
 094  25000                            RETURN                                              ;keep to a single step
 095  20099                            CALL 099[reduceAveSignalMSB_1_5dB]                  ;reduce magnitude of
 096  1DE28                            COMPARE sE[AveSignalMSB], 28[AGChigh]               ;see if we need to reduce the level (ie increase AGC) some more
 097  3E092                            JUMP NC, 092[BitTooBig]                             ;loop back if still too big
 098  25000                            RETURN 
 099                                   ;this effectively multiplies AveSignalMSB by 0.84375 (ie reduces it by 1.5dB) - maybe don't need?
 099  14E0E  reduceAveSignalMSB_1_5dB: SR0 sE[AveSignalMSB]                                ;half of AveSignalMSB
 09A  002E0                            LOAD s2, sE[AveSignalMSB]
 09B  14E0E                            SR0 sE[AveSignalMSB]                                ;quarter of AveSignalMSB
 09C  102E0                            ADD s2, sE[AveSignalMSB]
 09D  14E0E                            SR0 sE[AveSignalMSB]                                ;eighth of AveSignalMSB
 09E  14E0E                            SR0 sE[AveSignalMSB]                                ;16th of AveSignalMSB
 09F  102E0                            ADD s2, sE[AveSignalMSB]
 0A0  14E0E                            SR0 sE[AveSignalMSB]                                ;32nd of AveSignalMSB
 0A1  102E0                            ADD s2, sE[AveSignalMSB]                            ;now should be about 0.84375 times original value
 0A2  00E20                            LOAD sE[AveSignalMSB], s2                           ;put back in AveSignalMSB
 0A3  25000                            RETURN 
 0A4                                   ;Again enter with AGCvalue in s3
 0A4  20114                 BitTooLow: CALL 114[decreaseAGC]
 0A5  1DF19                            COMPARE sF[AveSignal1024ms], 19[AGClow2]            ;Is the level 2 times too low?
 0A6  3D000                            RETURN NC                                           ;Return in Ave level over 1024ms is greater than the half the lower threshold
 0A7  20114                            CALL 114[decreaseAGC]
 0A8  20114                            CALL 114[decreaseAGC]
 0A9  20114                            CALL 114[decreaseAGC]                               ;make up to a drop in AGCvalue of 4 (reduce attenuation a factor 2) to bring volume up quickly
 0AA  25000                            RETURN 
 0AB                                   ;Receiving: FETCH     s1, State
 0AB                                   ;   AND       s1,08 ;look at current state of 'receiving' bit.
 0AB                                   ;   COMPARE   s1,08   ;This is looking at the internal recorded state rather than the 'Status' input which takes bit 3 input from the TD pico
 0AB                                   ;   JUMP     Z,Somewhere??; ;Carry on if already acnowledged in receive mode (and still perform AGC)
 0AB                                   ;   FETCH     s1, State
 0AB                                   ;
 0AB                                   ;           OR        s1, 08
 0AB                                   ;          STORE     s1, State           ; set bit 3 (ie set internal DSP state to 'receiving')
 0AB                                   ;!!!!!!!!!!!!!!!!!!!!!!!!! is this really needed??? - maybe need to return here, or jump??
 0AB                                   ;Now update AGC value
 0AB                                   ;First check if received tone is too strong and need to increase attenuation - Need to check Target values!!!!!!!!!!!!!!!!!!!!!!!!!!!!! (23/4/17)
 0AB                                   ;   FETCH s3, AGCvalue
 0AB                                   ;   INPUT s1,StartToneAmp
 0AB                                   ;   COMPARE s1,36'd  ;is it 36 of bigger (ie 1.5dB above target value of 30)
 0AB                                   ;   CALL NC,increaseAGC
 0AB                                   ;   COMPARE s1,43'd  ;is it 43 of bigger
 0AB                                   ;   CALL NC,increaseAGC
 0AB                                   ;   COMPARE s1,51'd  ;is it 51 of bigger
 0AB                                   ;   CALL NC,increaseAGC
 0AB                                   ;   COMPARE s1,61'd  ;is it 61 of bigger
 0AB                                   ;   CALL NC,increaseAGC
 0AB                                   ;   COMPARE s1,72'd  ;is it 72 of bigger
 0AB                                   ;   CALL NC,increaseAGC
 0AB                                   ;   COMPARE s1,85'd  ;is it 85 of bigger
 0AB                                   ;   CALL NC,increaseAGC
 0AB                                   ;   COMPARE s1,101'd  ;is it 101 of bigger
 0AB                                   ;   CALL NC,increaseAGC
 0AB                                   ;   COMPARE s1,121'd  ;is it 121 of bigger
 0AB                                   ;   CALL NC,increaseAGC
 0AB                                   ;   COMPARE s1,143'd  ;is it 143 of bigger
 0AB                                   ;   CALL NC,increaseAGC
 0AB                                   ;   COMPARE s1,170'd  ;is it 170 of bigger
 0AB                                   ;   CALL NC,increaseAGC
 0AB                                   ;   COMPARE s1,202'd  ;is it 202 of bigger
 0AB                                   ;   CALL NC,increaseAGC
 0AB                                   ;   COMPARE s1,241'd  ;is it 241 of bigger
 0AB                                   ;   CALL NC,increaseAGC
 0AB                                   ;
 0AB                                   ;   COMPARE s1,26'd  ;is it less than 26 (ie 1.5dB below target value of 30)
 0AB                                   ;   CALL C,decreaseAGC
 0AB                                   ;   COMPARE s1,22'd  ;is it less than 22
 0AB                                   ;   CALL C,decreaseAGC
 0AB                                   ;   COMPARE s1,18'd  ;is it less than 18
 0AB                                   ;   CALL C,decreaseAGC
 0AB                                   ;   COMPARE s1,15'd  ;is it less than 15
 0AB                                   ;   CALL C,decreaseAGC
 0AB                                   ;   COMPARE s1,13'd  ;is it less than 13
 0AB                                   ;   CALL C,decreaseAGC
 0AB                                   ;   COMPARE s1,11'd  ;is it less than 11
 0AB                                   ;   CALL C,decreaseAGC
 0AB                                   ;   COMPARE s1,9'd  ;is it less than 9
 0AB                                   ;   CALL C,decreaseAGC
 0AB                                   ;   COMPARE s1,8'd  ;is it less than 8
 0AB                                   ;   CALL C,decreaseAGC
 0AB                                   ;
 0AB                                   ;Now updata AGCvalue
 0AB                                   ;   STORE s3, AGCvalue
 0AB                                   ;LOOK carefully at this as may need to do AGC (and so do a return)
 0AB                                   ;            JUMP      AwaitAudioVal
 0AB                                   ;Routine to take 16 bit value in s3,s2 and shift right by 5 to divide by 32 and leave value in s3,s2
 0AB                                   ;Assumes this is an unsigned numbers - normally used on a magnitude.
 0AB  200B0                  Divide32: CALL 0B0[Divide4]
 0AC  200B0                            CALL 0B0[Divide4]
 0AD  1430E                            SR0 s3
 0AE  14208                            SRA s2
 0AF  25000                            RETURN 
 0B0  1430E                   Divide4: SR0 s3
 0B1  14208                            SRA s2
 0B2  1430E                            SR0 s3
 0B3  14208                            SRA s2
 0B4  25000                            RETURN 
 0B5                                   ;This routine aims to double the signed analogue value in s0,s1 by finding sign of the value and doubling if small, increasing magnitude by 32 if less than 95 but more than 32 then limiting to 127 if more than 95
 0B5  1D180               AudioDouble: COMPARE s1, 80[128'd]
 0B6  3A0C4                            JUMP C, 0C4[Posvalue]
 0B7                                   ;otherwise must be negative
 0B7  1D1E1                  Negvalue: COMPARE s1, E1[225'd]                               ;256-31
 0B8  3A0BC                            JUMP C, 0BC[islessthanneg31]
 0B9  14006                            SL0 s0
 0BA  14100                            SLA s1                                              ;double value
 0BB  25000                            RETURN 
 0BC  1D1C1           islessthanneg31: COMPARE s1, C1[193'd]                               ;256-63
 0BD  3A0C0                            JUMP C, 0C0[islessthanneg63]
 0BE  19120                            SUB s1, 20[32'd]
 0BF  25000                            RETURN 
 0C0  1410A           islessthanneg63: SRX s1
 0C1  14008                            SRA s0                                              ;half value
 0C2  19140                            SUB s1, 40[64'd]
 0C3  25000                            RETURN 
 0C4  1D120                  Posvalue: COMPARE s1, 20[32'd]
 0C5  3E0C9                            JUMP NC, 0C9[ismorethan31]
 0C6  14006                            SL0 s0
 0C7  14100                            SLA s1                                              ;double value
 0C8  25000                            RETURN 
 0C9  1D140              ismorethan31: COMPARE s1, 40[64'd]
 0CA  3E0CD                            JUMP NC, 0CD[ismorethan63]                          ;positive and 64 or greater
 0CB  11120                            ADD s1, 20[32'd]
 0CC  25000                            RETURN 
 0CD  1410A              ismorethan63: SRX s1                                              ;sign extension should be zero!
 0CE  14008                            SRA s0
 0CF  11140                            ADD s1, 40[64'd]
 0D0  25000                            RETURN 
 0D1                                   ;-----------End Audio double
 0D1                                   ;Divides 16 bit signed value in s0,s1 by 2.
 0D1  1410A                   Divide2: SRX s1
 0D2  14008                            SRA s0
 0D3  25000                            RETURN 
 0D4                                   ;SUB16bit:   SUB    s8,s0
 0D4                                   ;     SUBC   s9,s1    ;16 bit subtract
 0D4                                   ;     RETURN
 0D4                                   ;ADD16bit:   ADD    s8,s0
 0D4                                   ;     ADDC   s9,s1    ;16 bit addition
 0D4                                   ;     RETURN
 0D4                    TransmitAudio: 
 0D4                                   ;     IN  s2,Status
 0D4                                   ;     AND s2,2  ;look at bit 1
 0D4                                   ;In this version switching to BT input is through external multiplexer to go through emphasis filter
 0D4                                   ;     COMP s2,0  ;True if BT signal present
 0D4                                   ;     JUMP NZ,SkipNoBT   ;keep value from ADC if flag set
 0D4                                   ;     IN  s0,BTaudioLSB  ;Use BT values instead if present
 0D4                                   ;     IN  s1,BTaudioMSB
 0D4                                   ;     CALL AudioDouble     ;increase volume 6 dB!  14/3/15
 0D4                         SkipNoBT: 
 0D4                                   ;Nov 2014 - have reduced DSP AGC level, so shouldn't need to do this? -reinstate Feb2015
 0D4                                   ;                SRX  s1    ;halve value before FIR to keep I and Q below $30 limit after FIR for CORDIC
 0D4                                   ;                SRA  s0
 0D4                                   ;Store data in RAM
 0D4                                   ;       OUTPUT     s0,Data2archiveLSB
 0D4                                   ;       OUTPUT     s1,Data2archiveMSB
 0D4  2014A                            CALL 14A[PerformFIR]
 0D5                                   ;This should have decreased amplitude by about 6dB
 0D5  2D10A                            OUTPUT s1, 0A[Data2archiveMSB]
 0D6  2D00B                            OUTPUT s0, 0B[Data2archiveLSB]
 0D7                                   ;need to make sure that s3/s2 and s1/s0 DO NOT EXCEED $3000, ie 48 in the MSBs!
 0D7  201D5                            CALL 1D5[cordic]                                    ;This is upsettng the AGC when sinectr used sB!
 0D8                                   ;April 2017 try to stop tx saturation
 0D8  200EF                            CALL 0EF[TryAndDouble]                              ;Bump amplitude to saturate! (Jan 2016)
 0D9  200EF                            CALL 0EF[TryAndDouble]
 0DA  200EF                            CALL 0EF[TryAndDouble]
 0DB  200EF                            CALL 0EF[TryAndDouble]
 0DC                                   ;     CALL TryAndDouble ;try add for upgrade of production code
 0DC                           OutAmp: 
 0DC                                   ;_______________________________
 0DC                                   ;Test value by sending out to Uart - shift this section as required - but check s3 not used! Disable in GV44a to allow receipt of other values!
 0DC                                   ;       LOAD   s3,s1
 0DC                                   ;       SRX   s3             ;make sure am not spoiling s3!!!!!
 0DC                                   ;                     OUT       s3, CmdToUser    ;Send amp in 7 bits (divide by 2!) to user pico to send to UART
 0DC                                   ;__________________________________
 0DC  2D102                            OUTPUT s1, 02[SSBAmp]                               ;********************disable for beacon tests
 0DD  0B310                            FETCH s3, 10[OldPhaseMSB]
 0DE  0B219                            FETCH s2, 19[OldPhaseLSB]
 0DF  2F510                            STORE s5, 10[OldPhaseMSB]
 0E0  2F419                            STORE s4, 19[OldPhaseLSB]                           ;s2,3 old phase, s4,5 new phase
 0E1  2D30F                            OUTPUT s3, 0F[AudioPhaseMSB]                        ;send old phase directly
 0E2  2D210                            OUTPUT s2, 10[AudioPhaseLSB]                        ;send old phase directly
 0E3  18420                            SUB s4, s2
 0E4  1A530                            SUBCY s5, s3                                        ;New phase-old phase
 0E5  1450A                            SRX s5
 0E6  00350                            LOAD s3, s5                                         ;divide MSB by2 and copy
 0E7  1430A                            SRX s3
 0E8  1430A                            SRX s3                                              ;s5/4
 0E9  10530                            ADD s5, s3
 0EA  1430A                            SRX s3
 0EB  1430A                            SRX s3                                              ;s5/16, s5 should now be 4/3rds of Phase shift/2^9, or 2/3rds of phase shift/2^8 (should be 2/3rds of s5/2^11) so need further 2^3 attenuaion)
 0EC  10530                            ADD s5, s3
 0ED  2D50D                            OUTPUT s5, 0D[PhaseIncrement]
 0EE  22069                            JUMP 069[BackfromTransmitting]
 0EF  1D140              TryAndDouble: COMPARE s1, 40[64'd]                                ;see if it is not too big already
 0F0  3E0F4                            JUMP NC, 0F4[BiggerThan63]                          ;Skip if too big
 0F1  14006                            SL0 s0                                              ;add 6dB 4/10/11
 0F2  14100                            SLA s1
 0F3  25000                            RETURN 
 0F4  1D181              BiggerThan63: COMPARE s1, 81[129'd]
 0F5  3E0F8                            JUMP NC, 0F8[BiggerThan128]
 0F6  11140                            ADD s1, 40[64'd]
 0F7  25000                            RETURN 
 0F8  1410E             BiggerThan128: SR0 s1                                              ;half value (127 max value)
 0F9  11180                            ADD s1, 80[128'd]                                   ;add 128 (gives 255 max)
 0FA  25000                            RETURN 
 0FB                                   ;Enter with signed 16 bit value in s1,s0 and return magnitude in s3,s2
 0FB  00310                  Abs16Val: LOAD s3, s1
 0FC  00200                            LOAD s2, s0
 0FD  1D180                            COMPARE s1, 80[128'd]
 0FE  39000                            RETURN C
 0FF  01300                            LOAD s3, 00
 100  01200                            LOAD s2, 00
 101  18200                            SUB s2, s0
 102  1A310                            SUBCY s3, s1
 103  25000                            RETURN 
 104  1D380                    absval: COMPARE s3, 80[128'd]
 105  3C107                            CALL NC, 107[makeposval]
 106  25000                            RETURN 
 107                                   ; Turn negative value in s3 into a positive one (well will actualy make a positive value negative as well).
 107  01400                makeposval: LOAD s4, 00
 108  18430                            SUB s4, s3
 109  00340                            LOAD s3, s4
 10A  25000                            RETURN 
 10B                                   ;invert value - actually same as makeposval, but works on s1
 10B  01400                 invertval: LOAD s4, 00
 10C  18410                            SUB s4, s1
 10D  00140                            LOAD s1, s4
 10E  25000                            RETURN 
 10F                                   ;Feb 2013 icrease number of AGC steps factor 2 and another factor 2 July 2013 (now granularity 1.5dB)
 10F                                   ; increment attenuation
 10F  1D33F               increaseAGC: COMPARE s3, 3F[63'd]                                ; was44
 110  3D000                            RETURN NC                                           ; don't do anything if already 63 or bigger (was 44 (was 22, before that 11))
 111  11301                            ADD s3, 01[1'd]                                     ; so yes signal really has been too big for too long!
 112  2F30E                            STORE s3, 0E[AGCvalue]                              ;put s3 back in AGCvalue
 113  25000                            RETURN 
 114                                   ; decrement attenuation
 114  1D300               decreaseAGC: COMPARE s3, 00                                      ; was232
 115  31000                            RETURN Z                                            ; don't do anything if already  0   (was 232 ie -24 (was 244, before that 250 ie -6) )
 116                                   ;    LOAD      s2,AveSignalMSB - this didn't seem to do anything (A0)
 116  19301                            SUB s3, 01                                          ; so yes signal really has been too small for too long!
 117  2F30E                            STORE s3, 0E[AGCvalue]                              ;put s3 back in AGCvalue
 118  25000                            RETURN 
 119                                   ; AGC takes 16 bit value, MSB in s1, LSB in s0 and returns normalised 16 bit value in s1,s0 using AGC value from s3, using external MUX for coarse control
 119                                   ;AGC value in s3 should vary  0-63 in this version - higher value is higher attenuation so use higher significant bits on input MUX (4 bits - 16 inputs)
 119                                   ; This routine can also be use for the volume setting if value put in s3 ????????
 119  0920A                       AGC: INPUT s2, 0A[Status]
 11A  03206                            AND s2, 06                                          ;look at bit 1 and 2
 11B                                   ;In this version switching to BT input is through external multiplexer to go through emphasis filter
 11B  1D204                            COMPARE s2, 04                                      ;True if BT signal present and TX_high
 11C  31000                            RETURN Z                                            ;Don't do anything if on BT and TX_high
 11D  2D312                            OUTPUT s3, 12[MUXport]                              ;Now simply use middle 4 bits to drive the MUX (or 'AGCvalue' in sysgen model) (this had been lower in the program and used the lowest bits)
 11E  1430A                            SRX s3                                              ;divide s3 by 2 to get last AGC and put last bit into carry
 11F  38132                            CALL C, 132[decrease1_5dB]                          ;if last bit set then reduce by 3dB
 120  1430A                            SRX s3                                              ;divide s3 by 2 to get old AGC and put last bit into carry
 121  38123                            CALL C, 123[decrease3dB]                            ;if last bit set then reduce by 3dB
 122  25000                            RETURN 
 123                                   ;AGCloop:            COMPARE      s3, 00
 123                                   ;                   RETURN       Z                   ; escape if AGC value zero
 123                                   ;                  SRX       s2
 123                                   ;                 SRA       s1
 123                                   ;                SRA       s0
 123                                   ;               SUB       s3, 1
 123                                   ;              JUMP      AGCloop
 123                                   ;negAGC:             COMP      s3, 0
 123                                   ;     RET       Z                   ; escape if AGC value zero
 123                                   ;                   SL0       s0      ;increase 24 bit value by 6dB
 123                                   ;                  SLA       s1
 123                                   ;                 SLA       s2
 123                                   ;                ADD       s3, 1
 123                                   ;               JUMP      negAGC
 123                                   ;this decreases value in (not s2),s1,s0 by factor 0.6875 (roughly 1/sqrt(2)) s2 not used with external MUX
 123  1410A               decrease3dB: SRX s1
 124  14008                            SRA s0
 125  00400                            LOAD s4, s0
 126  00510                            LOAD s5, s1
 127  1450A                            SRX s5
 128  14408                            SRA s4
 129  1450A                            SRX s5
 12A  14408                            SRA s4
 12B  10040                            ADD s0, s4
 12C  12150                            ADDCY s1, s5
 12D  1450A                            SRX s5
 12E  14408                            SRA s4
 12F  10040                            ADD s0, s4
 130  12150                            ADDCY s1, s5
 131  25000                            RETURN 
 132                                   ;multiply by 0.875 - modified for using only s1,s0
 132  1410A             decrease1_5dB: SRX s1
 133  14008                            SRA s0
 134  00400                            LOAD s4, s0
 135  00510                            LOAD s5, s1
 136  1450A                            SRX s5
 137  14408                            SRA s4
 138  10040                            ADD s0, s4
 139  12150                            ADDCY s1, s5
 13A  1450A                            SRX s5
 13B  14408                            SRA s4
 13C  10040                            ADD s0, s4
 13D  12150                            ADDCY s1, s5
 13E  25000                            RETURN 
 13F                                   ;multiply s2 by factor 1.25 (only used for AveSignalMSB) (not needed?)
 13F                                   ;increase1_5dB:      LOAD   s6,s2
 13F                                   ;     SRX       s6
 13F                                   ;                   SRX       s6
 13F                                   ;                  ADD    s2,s6
 13F                                   ;
 13F                                   ;     RET
 13F                                   ;This is never called???????????????????
 13F  01308                   AGCtest: LOAD s3, 08
 140  00010                            LOAD s0, s1
 141  00120                            LOAD s1, s2
 142  25000                            RETURN 
 143                                   ;This is never called???????????????????
 143  1D300                AGClooptst: COMPARE s3, 00
 144  31000                            RETURN Z                                            ; escape if AGC value zero
 145  1420A                            SRX s2
 146  14108                            SRA s1
 147  14008                            SRA s0
 148  19301                            SUB s3, 01
 149  22143                            JUMP 143[AGClooptst]
 14A                                   ; Routine to perform FIR takes new signal value in s1,s0 (s1 is MSB) and puts into scratch buffer and then outputs new filterred values for I in s1,s0 and Q in s3,s2
 14A                                   ; First store latest value then increment LVptr
 14A                                   ;OK Sept 2010
 14A                                   ;reasonable match between I and Q components (within ~1dB), but about 6dB attenuation from input - OK.
 14A  2D106                PerformFIR: OUTPUT s1, 06[SignalMSB]
 14B  2D007                            OUTPUT s0, 07[SignalLSB]
 14C  0B414                            FETCH s4, 14[LVPtr]                                 ; value of the previous latest value
 14D  11402                            ADD s4, 02                                          ; advance LVptr
 14E  1D470                            COMPARE s4, 70[HistoryStart42]                      ; + 42
 14F  3C1B6                            CALL NC, 1B6[resetLVptr]                            ; if gone past end of buffer reset pointer to start
 150  2F414                            STORE s4, 14[LVPtr]                                 ; update incremented value of LVptr (by step +2)
 151  2E140                            STORE s1, (s4)                                      ; Store signalMSB at LVptr in scratch
 152  11401                            ADD s4, 01
 153  2E040                            STORE s0, (s4)                                      ; Store signalLSB at LVptr+1 in scratch
 154  19401                            SUB s4, 01                                          ; return to LVptr
 155  01A00                            LOAD sA, 00                                         ; Reset the register used for the difference between LVptr and Rptr (diff)
 156  2FA16                            STORE sA, 16[IaccuLSB]
 157  2FA15                            STORE sA, 15[IaccuMSB]
 158  2FA18                            STORE sA, 18[QaccuLSB]
 159  2FA17                            STORE sA, 17[QaccuMSB]                              ; Reset all accumulators
 15A                                   ; now start filter with roving pointer in s5 starting at LVptr
 15A                                   ; LOAD      s5, s4
 15A  201BB                            CALL 1BB[UpdateRptr]                                ; this should be equivalent to previous line!
 15B  017F6                            LOAD s7, F6[coeffI0MSB]                             ; Smallest coefficients of I FIR - load values to go to multiplier input.
 15C  01692                            LOAD s6, 92[coeffI0LSB]
 15D  20181                            CALL 181[Ibussiness]
 15E  01700                            LOAD s7, 00[coeffQ0MSB]                             ; Smallest coefficients of Q FIR
 15F  016A7                            LOAD s6, A7[coeffQ0LSB]
 160  20187                            CALL 187[Qbussiness]
 161  017F4                            LOAD s7, F4[coeffI1MSB]                             ; coefficient of I FIR
 162  0168A                            LOAD s6, 8A[coeffI1LSB]
 163  20181                            CALL 181[Ibussiness]
 164  01705                            LOAD s7, 05[coeffQ1MSB]                             ; coefficient of Q FIR
 165  0162D                            LOAD s6, 2D[coeffQ1LSB]
 166  20187                            CALL 187[Qbussiness]
 167  017F2                            LOAD s7, F2[coeffI2MSB]                             ; coefficient of I FIR
 168  016CC                            LOAD s6, CC[coeffI2LSB]
 169  20181                            CALL 181[Ibussiness]
 16A  0170C                            LOAD s7, 0C[coeffQ2MSB]                             ; coefficient of Q FIR
 16B  01683                            LOAD s6, 83[coeffQ2LSB]
 16C  20187                            CALL 187[Qbussiness]
 16D  017F1                            LOAD s7, F1[coeffI3MSB]                             ; coefficient of I FIR
 16E  01677                            LOAD s6, 77[coeffI3LSB]
 16F  20181                            CALL 181[Ibussiness]
 170  0171B                            LOAD s7, 1B[coeffQ3MSB]                             ; coefficient of Q FIR
 171  0164F                            LOAD s6, 4F[coeffQ3LSB]
 172  20187                            CALL 187[Qbussiness]
 173  017F0                            LOAD s7, F0[coeffI4MSB]                             ; coefficient of I FIR
 174  016A1                            LOAD s6, A1[coeffI4LSB]
 175  20181                            CALL 181[Ibussiness]
 176  0175C                            LOAD s7, 5C[coeffQ4MSB]                             ; coefficient of Q FIR
 177  0162F                            LOAD s6, 2F[coeffQ4LSB]
 178  20187                            CALL 187[Qbussiness]
 179  01740                            LOAD s7, 40[coeffI5MSB]                             ; half of middle coefficient of I FIR
 17A  01600                            LOAD s6, 00[coeffI5LSB]
 17B  20181                            CALL 181[Ibussiness]                                ; Roving pointer is advanced an 11th time but is reset before being used!
 17C  0B016                            FETCH s0, 16[IaccuLSB]
 17D  0B115                            FETCH s1, 15[IaccuMSB]
 17E  0B218                            FETCH s2, 18[QaccuLSB]
 17F  0B317                            FETCH s3, 17[QaccuMSB]
 180  25000                            RETURN                                              ; return from PerformFIR
 181                                   ; These assume coefficient is in s6,7 (LSB,MSB)
 181  2018D                Ibussiness: CALL 18D[doIplus]
 182  201C1                            CALL 1C1[conjugateDiff]                             ; Roving, difference pointer in sA sent to conjugate value and update roving pointer s5
 183  2018D                            CALL 18D[doIplus]
 184  201C1                            CALL 1C1[conjugateDiff]                             ; Return difference pointer in sA from its conjugate value
 185  201B8                            CALL 1B8[AdvanceRptr]                               ; This is relative shift to roving pointer (0->10 x2 ie 20)
 186  25000                            RETURN 
 187  20195                Qbussiness: CALL 195[doQplus]
 188  201C1                            CALL 1C1[conjugateDiff]                             ; Roving, difference pointer in sA sent to conjugate value, also update roving pointer.
 189  2019D                            CALL 19D[doQminus]
 18A  201C1                            CALL 1C1[conjugateDiff]                             ; Roving, difference pointer in sA sent to conjugate value, should go back to value before calling this function.
 18B  201B8                            CALL 1B8[AdvanceRptr]                               ; This uses relative shift to roving pointer (0->10x2 ie 20), sA used for difference value.
 18C  25000                            RETURN 
 18D                                   ; These assume coefficient is in s6,7 (LSB,MSB) for doMult, so make sure it doesn't pollute it for the next time!
 18D  201A5                   doIplus: CALL 1A5[doMult]
 18E  0B016                            FETCH s0, 16[IaccuLSB]
 18F  0B115                            FETCH s1, 15[IaccuMSB]
 190  10080                            ADD s0, s8
 191  12190                            ADDCY s1, s9
 192  2F016                            STORE s0, 16[IaccuLSB]
 193  2F115                            STORE s1, 15[IaccuMSB]
 194  25000                            RETURN 
 195  201A5                   doQplus: CALL 1A5[doMult]
 196  0B018                            FETCH s0, 18[QaccuLSB]
 197  0B117                            FETCH s1, 17[QaccuMSB]
 198  10080                            ADD s0, s8
 199  12190                            ADDCY s1, s9
 19A  2F018                            STORE s0, 18[QaccuLSB]
 19B  2F117                            STORE s1, 17[QaccuMSB]
 19C  25000                            RETURN 
 19D  201A5                  doQminus: CALL 1A5[doMult]
 19E  0B018                            FETCH s0, 18[QaccuLSB]
 19F  0B117                            FETCH s1, 17[QaccuMSB]
 1A0  18080                            SUB s0, s8
 1A1  1A190                            SUBCY s1, s9
 1A2  2F018                            STORE s0, 18[QaccuLSB]
 1A3  2F117                            STORE s1, 17[QaccuMSB]
 1A4  25000                            RETURN 
 1A5                                   ; History signal is first output to SignalMSB and SignalLSB, the signal is then multiplied by the coefficient (provided in s6,7 - LSB,MSB) and the result is returned in s8,9 (LSB,MSB)
 1A5  201B1                    doMult: CALL 1B1[GetRovingHistoryValues]
 1A6  2D106                            OUTPUT s1, 06[SignalMSB]
 1A7  2D007                            OUTPUT s0, 07[SignalLSB]                            ; Historical signal sent to multiplier
 1A8  2D704                            OUTPUT s7, 04[CoeffMSB]
 1A9  2D605                            OUTPUT s6, 05[CoeffLSB]
 1AA  01000                            LOAD s0, 00
 1AB  01000                            LOAD s0, 00
 1AC  01000                            LOAD s0, 00                                         ; wait a bit (8 clock cycles enough?)
 1AD  01000                            LOAD s0, 00
 1AE  09904                            INPUT s9, 04[MltplyMSB]
 1AF  09805                            INPUT s8, 05[MltplyLSB]
 1B0  25000                            RETURN 
 1B1  0A150    GetRovingHistoryValues: FETCH s1, (s5)                                      ; Historical SignalMSB
 1B2  11501                            ADD s5, 01
 1B3  0A050                            FETCH s0, (s5)                                      ; Historical SignalLSB
 1B4  19501                            SUB s5, 01                                          ; return s5 vlue as there will be another mult before updating s5!!
 1B5  25000                            RETURN 
 1B6                                   ; To reset LVptr to start of history rolling buffer space. LVptr is 'Last Value Pointer'
 1B6  01446                resetLVptr: LOAD s4, 46[HistoryStart]
 1B7  25000                            RETURN 
 1B8                                   ; and Rptr (Rptr is 'Roving Pointer'), next value (back 2 places), using advance of diff (sA) diff takes even values 0-40 inclusive (10 steps, ie 11 values, should never go beyond!, at each value conjugate point is also used. 11 value is diff=20 repeats itself at conjugate point)
 1B8  11A02               AdvanceRptr: ADD sA, 02                                          ; advance diff (goes from 0 to 20)
 1B9  201BB                            CALL 1BB[UpdateRptr]
 1BA  25000                            RETURN 
 1BB                                   ; uses value of diff to update value of Rptr
 1BB  00540                UpdateRptr: LOAD s5, s4                                         ; put LVptr in Rptr
 1BC  185A0                            SUB s5, sA                                          ; take off value of diff (sA)
 1BD  1D546                            COMPARE s5, 46[HistoryStart]
 1BE  3D000                            RETURN NC                                           ; if not gone below bottom of buffer return!, else....
 1BF  1152A                            ADD s5, 2A[42'd]                                    ; send up again
 1C0  25000                            RETURN 
 1C1                                   ; - acts on diff (sA)
 1C1  01028             conjugateDiff: LOAD s0, 28[40'd]
 1C2  180A0                            SUB s0, sA                                          ; 40-sA
 1C3  00A00                            LOAD sA, s0                                         ; so sA is conjugate eg: 0->40,40->0, 20->20 etc
 1C4  201BB                            CALL 1BB[UpdateRptr]                                ; calculate corresponding Rptr
 1C5  25000                            RETURN 
 1C6                                   ; the negative case means when the roving ptr is less than LVptr - is it done OK above 10 lines? diff is always positive (Rptr less than LVptr)
 1C6                                   ; conjugateneg:
 1C6                                   ; RET
 1C6                                   ; Takes value in s5 and converts to 2 ascii codes which are sent to the user picoblaze.
 1C6  20278               Export2User: CALL 278[Byte2Chars]
 1C7  2D603                            OUTPUT s6, 03[CmdToUser]
 1C8  2D703                            OUTPUT s7, 03[CmdToUser]
 1C9  0100D                            LOAD s0, 0D[13'd]                                   ; terminate with CR
 1CA  2D003                            OUTPUT s0, 03[CmdToUser]
 1CB  0100A                            LOAD s0, 0A[10'd]                                   ; and with LF
 1CC  2D003                            OUTPUT s0, 03[CmdToUser]
 1CD  25000                            RETURN 
 1CE                                   ; Takes 16 bit value in s6,s7 (MSB,LSB) and outputs to the archive memory (write enabled and selected by user picoblaze)
 1CE  2D60B               ArchiveData: OUTPUT s6, 0B[Data2archiveLSB]
 1CF  2D70A                            OUTPUT s7, 0A[Data2archiveMSB]
 1D0  25000                            RETURN 
 1D1                                   ; Frequency works out the phase increment - (this is to ~7 bit precission, but using LSB could get 8 bit?)
 1D1                                   ; Takes phase in s4 (and s5) and uses old phase value from scratchpad (which is then updated). The phase increment is returned in s4.
 1D1  0B010                 Frequency: FETCH s0, 10[OldPhaseMSB]
 1D2  2F410                            STORE s4, 10[OldPhaseMSB]
 1D3  18400                            SUB s4, s0
 1D4  25000                            RETURN 
 1D5                                   ; CORDIC  Takes I in s0(LSB)and s1(MSB) and Q in s2,s3 and returns the amplitude in s0,s1 and the phase in s4,s5. s8 is the loop counter
 1D5                                   ; Useable range is for I and Q up to about +/-$3000
 1D5  01400                    cordic: LOAD s4, 00
 1D6  01500                            LOAD s5, 00
 1D7  1D180                            COMPARE s1, 80[128'd]
 1D8  3C20C                            CALL NC, 20C[rotate90]                              ; if I negative then need to bring back into RH 2 quadrants.
 1D9                                   ; now enter loop
 1D9  01800                            LOAD s8, 00                                         ; counter of times to iterate.
 1DA  00710                cordicloop: LOAD s7, s1                                         ; temporary store for I
 1DB  00600                            LOAD s6, s0                                         ; temp store
 1DC  1D380                            COMPARE s3, 80[128'd]                               ; is Q negative?
 1DD  3E1EC                            JUMP NC, 1EC[posrotate]                             ; if negative rotate positive
 1DE  00A20                 negrotate: LOAD sA, s2
 1DF  00B30                            LOAD sB, s3                                         ; put Q into working registers
 1E0  20205                            CALL 205[shift]                                     ; shift Q by the amount in s8
 1E1  100A0                            ADD s0, sA                                          ; add shifted Q to I
 1E2  121B0                            ADDCY s1, sB
 1E3  00A60                            LOAD sA, s6                                         ; prepare working registers (sA,sB) with original value of I
 1E4  00B70                            LOAD sB, s7
 1E5  20205                            CALL 205[shift]
 1E6  182A0                            SUB s2, sA
 1E7  1A3B0                            SUBCY s3, sB
 1E8  201FD                            CALL 1FD[GetPhaseIncrement]
 1E9  184A0                            SUB s4, sA
 1EA  1A5B0                            SUBCY s5, sB
 1EB  221F9                            JUMP 1F9[testcordicend]
 1EC  00A20                 posrotate: LOAD sA, s2
 1ED  00B30                            LOAD sB, s3                                         ; put Q into working registers
 1EE  20205                            CALL 205[shift]                                     ; shift Q by the amount in s8
 1EF  180A0                            SUB s0, sA                                          ; add shifted Q to I
 1F0  1A1B0                            SUBCY s1, sB
 1F1  00A60                            LOAD sA, s6                                         ; prepare working registers with original value of I
 1F2  00B70                            LOAD sB, s7
 1F3  20205                            CALL 205[shift]
 1F4  102A0                            ADD s2, sA
 1F5  123B0                            ADDCY s3, sB
 1F6  201FD                            CALL 1FD[GetPhaseIncrement]
 1F7  104A0                            ADD s4, sA
 1F8  125B0                            ADDCY s5, sB
 1F9  11801             testcordicend: ADD s8, 01
 1FA  1D809                            COMPARE s8, 09[m_plus_1]                            ;m + 1
 1FB  3A1DA                            JUMP C, 1DA[cordicloop]
 1FC  25000                            RETURN 
 1FD                                   ; routine to lookup from the cordic look up table (scratchpad), the phase increment - stored as 8 bits at the location pointed to be s8, returned as 16 bits in sA and sB
 1FD                                   ; sB is MSB
 1FD  0AB80         GetPhaseIncrement: FETCH sB, (s8)
 1FE  14B0E                            SR0 sB
 1FF  14A08                            SRA sA
 200  14B0E                            SR0 sB
 201  14A08                            SRA sA
 202  14B0E                            SR0 sB
 203  14A08                            SRA sA                                              ; This multiplies the 8 bit stored value by 32 so that max scratchpad value 255->255*32 equivalent to 44.82degrees
 204  25000                            RETURN 
 205  00980                     shift: LOAD s9, s8
 206  1D900                 shiftloop: COMPARE s9, 00
 207  31000                            RETURN Z
 208  19901                            SUB s9, 01
 209  14B0A                            SRX sB
 20A  14A08                            SRA sA
 20B  22206                            JUMP 206[shiftloop]
 20C  00710                  rotate90: LOAD s7, s1                                         ; temporary store for I
 20D  00600                            LOAD s6, s0                                         ; temp store
 20E  1D380                            COMPARE s3, 80[128'd]                               ; is Q negative?
 20F  3E219                            JUMP NC, 219[add90]                                 ; if negative add 90
 210  00130                     sub90: LOAD s1, s3
 211  00020                            LOAD s0, s2                                         ; I=Q
 212  01200                            LOAD s2, 00
 213  01300                            LOAD s3, 00
 214  18260                            SUB s2, s6
 215  1A370                            SUBCY s3, s7                                        ; Q=-I
 216  19400                            SUB s4, 00[half_pi_LSB]
 217  1B540                            SUBCY s5, 40[half_pi_MSB]
 218  25000                            RETURN 
 219  01100                     add90: LOAD s1, 00
 21A  01000                            LOAD s0, 00
 21B  18020                            SUB s0, s2
 21C  1A130                            SUBCY s1, s3                                        ; I=-Q
 21D  00260                            LOAD s2, s6
 21E  00370                            LOAD s3, s7                                         ; Q=I
 21F  01400                            LOAD s4, 00[half_pi_LSB]
 220  01540                            LOAD s5, 40[half_pi_MSB]
 221  25000                            RETURN 
 222  0B112              Transmitmode: FETCH s1, 12[State]
 223  05102                            OR s1, 02
 224  2F112                            STORE s1, 12[State]                                 ; set bit 1
 225  0B10E                            FETCH s1, 0E[AGCvalue]
 226  2F171                            STORE s1, 71[AGCvalueRX]
 227  0B170                            FETCH s1, 70[AGCvalueTX]                            ;recovers last used value for AGCvalur in this mode
 228  2F10E                            STORE s1, 0E[AGCvalue]
 229                                   ;     FETCH      s1,AGCupperThresholdTX2
 229                                   ;     STORE  s1,AGCupperThresholdInUse ;Updates the threshold values in use
 229  25000                            RETURN 
 22A                                   ;Streammode:   CALL Transmitmode
 22A                                   ;     FETCH     s1, State
 22A                                   ;                   OR        s1, 4
 22A                                   ;                  STORE     s1, State           ; set bit 2
 22A                                   ;     RET
 22A                                   ;GetUartValues:  CALL      Get2Chars     ;Changed name of this routine
 22A                                   ;     LOAD   s1,$AA     ;rough value
 22A                                   ;     LOAD   s2,s5      ;now put into top byte
 22A                                   ;     SRX    s2
 22A                                   ;     SRA    s1      ;divide signal by 2
 22A                                   ;     SRX    s2
 22A                                   ;     SRA    s1      ;divide signal by 2 again
 22A                                   ;     LOAD    s0,$AA      ;set lowest bits to rough value
 22A                                   ;        RET
 22A  0B10E            GrabTXAGCvalue: FETCH s1, 0E[AGCvalue]
 22B  2F170                            STORE s1, 70[AGCvalueTX]
 22C  25000                            RETURN 
 22D  0B112               Receivemode: FETCH s1, 12[State]
 22E  031FD                            AND s1, FD[253'd]                                   ; 255 - 2
 22F  2F112                            STORE s1, 12[State]                                 ; reset bit 1
 230  0B10E                            FETCH s1, 0E[AGCvalue]
 231  2F170                            STORE s1, 70[AGCvalueTX]
 232  0B171                            FETCH s1, 71[AGCvalueRX]                            ;recovers last used value for AGCvalur in this mode
 233  2F10E                            STORE s1, 0E[AGCvalue]
 234                                   ;     FETCH      s1,AGCupperThresholdRX2
 234                                   ;     STORE  s1,AGCupperThresholdInUse ;Updates the threshold values in use
 234  25000                            RETURN 
 235  011F0              BlockDSPpico: LOAD s1, F0[240'd]
 236  2D102                            OUTPUT s1, 02[SSBAmp]                               ; Set signal amp to high
 237  01100                            LOAD s1, 00
 238  2D10D                            OUTPUT s1, 0D[PhaseIncrement]                       ;Make sure phase doesn't wander
 239  09003                            INPUT s0, 03[Command]                               ; Check if FIFO character present
 23A  1D080                            COMPARE s0, 80[128'd]                               ; is there a character?
 23B  3E235                            JUMP NC, 235[BlockDSPpico]                          ; no command received so carry on blocking
 23C  20254                            CALL 254[GetFifoChar]                               ;is command so get charcter
 23D  1D052                            COMPARE s0, 52[82'd]                                ; character R
 23E  31000                            RETURN Z                                            ;escape when R received from User Pico
 23F  22235                            JUMP 235[BlockDSPpico]
 240                                   ; Get fifo command and act on it.
 240                     Respond2Fifo: 
 240                                   ;         FETCH     s0,State
 240                                   ;     AND    s0,04
 240                                   ;     COMP   s0,04        ;is this stream mode
 240                                   ;     RETURN Z       ;if so then stick (no backing out!)
 240  20254                            CALL 254[GetFifoChar]
 241                                   ;     COMPARE   s0,51'd       ;character 3
 241                                   ;     CALL   Z,Streammode
 241  1D032                            COMPARE s0, 32[50'd]                                ; character 2
 242  3022A                            CALL Z, 22A[GrabTXAGCvalue]                         ;need to get this before userpico sends warble
 243  1D031                            COMPARE s0, 31[49'd]                                ; character 1
 244  30222                            CALL Z, 222[Transmitmode]
 245  1D030                            COMPARE s0, 30[48'd]                                ; character 0
 246  3022D                            CALL Z, 22D[Receivemode]
 247  1D047                            COMPARE s0, 47[71'd]                                ; character G (request for AGCvalue info from userpico)
 248  3024E                            CALL Z, 24E[SendGParamBack]
 249  1D053                            COMPARE s0, 53[83'd]                                ; character S (request for AVEsignal info from userpico)
 24A  30251                            CALL Z, 251[SendSParamBack]
 24B  1D042                            COMPARE s0, 42[66'd]                                ; character B (block)
 24C  30235                            CALL Z, 235[BlockDSPpico]
 24D  25000                            RETURN 
 24E                                   ;This can be adjusted for de-bugging AGCvalue
 24E  0B50E            SendGParamBack: FETCH s5, 0E[AGCvalue]
 24F  201C6                            CALL 1C6[Export2User]
 250  25000                            RETURN 
 251                                   ;This can be adjusted for de-bugging AVEsignal
 251  005F0            SendSParamBack: LOAD s5, sF[AveSignal1024ms]
 252  201C6                            CALL 1C6[Export2User]
 253  25000                            RETURN 
 254                                   ; Routine to recover a character from the FIFO in s0
 254  01020               GetFifoChar: LOAD s0, 20[AckFIFO]
 255  2D00C                            OUTPUT s0, 0C[Controlbits]
 256  01020                            LOAD s0, 20[AckFIFO]                                ; Wait
 257  09003                            INPUT s0, 03[Command]                               ; now get my character
 258  0307F                            AND s0, 7F                                          ; mask off top bit
 259  25000                            RETURN 
 25A                                   ; routine to look at command input and recover 2 characters and return the byte they represent in s5.
 25A  09603                 Get2Chars: INPUT s6, 03[Command]
 25B  1D680                            COMPARE s6, 80[128'd]                               ; if greater than 128, then no character
 25C  3E25A                            JUMP NC, 25A[Get2Chars]
 25D  20254                            CALL 254[GetFifoChar]
 25E  00600                            LOAD s6, s0
 25F  09703                Get2ndChar: INPUT s7, 03[Command]
 260  1D780                            COMPARE s7, 80[128'd]                               ; if greater than 128, then no character
 261  3E25F                            JUMP NC, 25F[Get2ndChar]
 262  20254                            CALL 254[GetFifoChar]
 263  00700                            LOAD s7, s0
 264  22265                            JUMP 265[Chars2Byte]
 265                                   ; Routine to take ascii codes in s6 and s7 and return a byte in s5 given by this character representation
 265  00860                Chars2Byte: LOAD s8, s6
 266  20270                            CALL 270[Get4bits]
 267  00580                            LOAD s5, s8
 268  14506                            SL0 s5
 269  14506                            SL0 s5
 26A  14506                            SL0 s5
 26B  14506                            SL0 s5                                              ; put these 4 bits to MSBs
 26C  00870                            LOAD s8, s7
 26D  20270                            CALL 270[Get4bits]
 26E  10580                            ADD s5, s8
 26F  25000                            RETURN 
 270                                   ; This routine takes an ascii code in s8 and returns a 4 bit value in s8
 270  1D83C                  Get4bits: COMPARE s8, 3C[60'd]                                ; if character is 0-9 it is less than 60, if it is A-F then it is greater than 60
 271  3A275                            JUMP C, 275[char0_9]
 272  19837                            SUB s8, 37[55'd]                                    ; assumes hex codes A-F are in capitals!!, A (code 65) gives 10...
 273  0380F                            AND s8, 0F                                          ; make sure only return 4 bits
 274  25000                            RETURN 
 275  19830                   char0_9: SUB s8, 30[48'd]
 276  0380F                            AND s8, 0F                                          ; make sure only return 4 bits
 277  25000                            RETURN 
 278                                   ; takes data in s5 and returns two ascii codes in s6,s7 (s7 is character for lower 4 bits)
 278  00850                Byte2Chars: LOAD s8, s5                                         ; assumes 8 bit data is in s5
 279  1450E                            SR0 s5
 27A  1450E                            SR0 s5
 27B  1450E                            SR0 s5
 27C  1450E                            SR0 s5                                              ; get first hex character
 27D  20284                            CALL 284[GetChar]
 27E  00650                            LOAD s6, s5                                         ; first ascii char
 27F  00580                            LOAD s5, s8
 280  0350F                            AND s5, 0F
 281  20284                            CALL 284[GetChar]                                   ; send to LCD or UART
 282  00750                            LOAD s7, s5                                         ; second ascii char
 283  25000                            RETURN 
 284                                   ; routine to convert 4bit value in s5 to an ascii code, returned in s5
 284  1950A                   GetChar: SUB s5, 0A[10'd]                                    ; Test if s5 greater than 9
 285  3A288                            JUMP C, 288[is_0_9]                                 ; Hex character is 0_9
 286  11541                            ADD s5, 41[65'd]                                    ; offset for Ascii code 'A'
 287  25000                            RETURN 
 288  1150A                    is_0_9: ADD s5, 0A[10'd]                                    ; return to range 0-9
 289  11530                            ADD s5, 30[48'd]                                    ; offset to Ascii code for '0'
 28A  25000                            RETURN 
 28B                                   ; Registers used s0, s1, s2, s3, s4 and s5.
 28B                                   ;
 28B  01500                  delay_1s: LOAD s5, 00                                         ; clear cycle counter
 28C  01400                            LOAD s4, 00
 28D  2029E                   wait_1s: CALL 29E[delay_1ms]
 28E  11401                            ADD s4, 01                                          ; increment cycle counter
 28F  13500                            ADDCY s5, 00
 290  1D4E8                            COMPARE s4, E8[count_1000_lsb]                      ; test for 1000ms
 291  3628D                            JUMP NZ, 28D[wait_1s]
 292  1D503                            COMPARE s5, 03[count_1000_msb]
 293  3628D                            JUMP NZ, 28D[wait_1s]
 294  25000                            RETURN 
 295                                   ;
 295                                   ; Delays of approximately 200ms and 300ms used for LCD display scrolling
 295                                   ;
 295                                   ;
 295                                   ; Registers used s0, s1, s2, s3 and s4.
 295                                   ;
 295  20299               delay_300ms: CALL 299[delay_100ms]
 296  20299               delay_200ms: CALL 299[delay_100ms]
 297  20299                            CALL 299[delay_100ms]
 298  25000                            RETURN 
 299                                   ;
 299                                   ; Delay of approximately 100ms used for switch debounce
 299                                   ;
 299                                   ; Registers used s0, s1, s2, s3 and s4.
 299                                   ;
 299  01464               delay_100ms: LOAD s4, 64                                         ; repeat 1ms delay 100 times
 29A  2029E                wait_100ms: CALL 29E[delay_1ms]
 29B  19401                            SUB s4, 01
 29C  3629A                            JUMP NZ, 29A[wait_100ms]
 29D  25000                            RETURN 
 29E                                   ;
 29E                                   ; Delay of approximately 1ms required by LCD display
 29E                                   ;
 29E                                   ; Registers used s0, s1, s2 and s3.
 29E                                   ;
 29E  01300                 delay_1ms: LOAD s3, 00                                         ; clear cycle counter
 29F  01200                            LOAD s2, 00
 2A0  202AD                  wait_1ms: CALL 2AD[delay_1us]
 2A1  11201                            ADD s2, 01                                          ; increment cycle counter
 2A2  13300                            ADDCY s3, 00
 2A3  1D2E8                            COMPARE s2, E8[count_1000_lsb]                      ; test for 1000us
 2A4  362A0                            JUMP NZ, 2A0[wait_1ms]
 2A5  1D303                            COMPARE s3, 03[count_1000_msb]
 2A6  362A0                            JUMP NZ, 2A0[wait_1ms]
 2A7  25000                            RETURN 
 2A8                                   ;
 2A8                                   ; Delay of approximately 50us required by LCD display
 2A8                                   ;
 2A8                                   ; Registers used s0 and s1.
 2A8                                   ;
 2A8  01132                delay_50us: LOAD s1, 32[50'd]                                   ; repeat 1us delay 50 times
 2A9  202AD                 wait_50us: CALL 2AD[delay_1us]
 2AA  19101                            SUB s1, 01
 2AB  362A9                            JUMP NZ, 2A9[wait_50us]
 2AC  25000                            RETURN 
 2AD                                   ; Delay of approximately 1us used to provide timing reference for
 2AD                                   ; LCD operations. This must be adjusted to reflect the clock
 2AD                                   ; applied to KCPSM3. The provided code is for a 50MHz clock rate.
 2AD                                   ;
 2AD                                   ; The software delay loop is formed using register s0. This register
 2AD                                   ; must be loaded with an integer value close to the result of....
 2AD                                   ;
 2AD                                   ; value =  (clock_rate - 4)/4          Where 'clock_rate' is in MHz
 2AD                                   ;
 2AD                                   ; So for a 50MHz clock the value is (50-4)/4 = 11.5 and 12 would be used.
 2AD                                   ; For clock rates below 8MHz the value of 1 must be used and the I2C bus
 2AD                                   ; operation will become lower than the 100KHz target intended.
 2AD                                   ;
 2AD                                   ; Register used s0.
 2AD                                   ;
 2AD  01006                 delay_1us: LOAD s0, 06[delay_1us_constant]                     ; delay value of 12 decimal for a 50MHz clock
 2AE  19001                  wait_1us: SUB s0, 01
 2AF  362AE                            JUMP NZ, 2AE[wait_1us]
 2B0  25000                            RETURN 
 2B1                                   ;
 2B1                                   ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Z:\home\gnaylor\Dropbox\N3SysGen\DSPpicoNewAGC.psm



List of defined constants

 CONSTANT name       Value        Source PSM File

 timestamp_hours     15'd         
 timestamp_minutes   21'd         
 timestamp_seconds   48'd         
 datestamp_year      17'd         
 datestamp_month     7'd          
 datestamp_day       08'd         
 NUL                 00           
 BEL                 07           
 BS                  08           
 HT                  09           
 LF                  0A           
 VT                  0B           
 CR                  0D           
 ESC                 1B           
 DEL                 7F           
 DCS                 90           
 ST                  9C           
 AGChigh             40'd         DSPpicoNewAGC.psm
 AGClow              50'd         DSPpicoNewAGC.psm
 AGClow2             25'd         DSPpicoNewAGC.psm
 delay_1us_constant  06           DSPpicoNewAGC.psm
 m                   8'd          DSPpicoNewAGC.psm
 m_plus_1            9'd          DSPpicoNewAGC.psm
 count_1000_lsb      E8           DSPpicoNewAGC.psm
 count_1000_msb      03           DSPpicoNewAGC.psm
 half_pi_LSB         00           DSPpicoNewAGC.psm
 half_pi_MSB         40           DSPpicoNewAGC.psm
 audioTest           2'd          DSPpicoNewAGC.psm
 coeffI0MSB          F6           DSPpicoNewAGC.psm
 coeffI0LSB          92           DSPpicoNewAGC.psm
 coeffI1MSB          F4           DSPpicoNewAGC.psm
 coeffI1LSB          8A           DSPpicoNewAGC.psm
 coeffI2MSB          F2           DSPpicoNewAGC.psm
 coeffI2LSB          CC           DSPpicoNewAGC.psm
 coeffI3MSB          F1           DSPpicoNewAGC.psm
 coeffI3LSB          77           DSPpicoNewAGC.psm
 coeffI4MSB          F0           DSPpicoNewAGC.psm
 coeffI4LSB          A1           DSPpicoNewAGC.psm
 coeffI5MSB          40           DSPpicoNewAGC.psm
 coeffI5LSB          00           DSPpicoNewAGC.psm
 coeffQ0MSB          00           DSPpicoNewAGC.psm
 coeffQ0LSB          A7           DSPpicoNewAGC.psm
 coeffQ1MSB          05           DSPpicoNewAGC.psm
 coeffQ1LSB          2D           DSPpicoNewAGC.psm
 coeffQ2MSB          0C           DSPpicoNewAGC.psm
 coeffQ2LSB          83           DSPpicoNewAGC.psm
 coeffQ3MSB          1B           DSPpicoNewAGC.psm
 coeffQ3LSB          4F           DSPpicoNewAGC.psm
 coeffQ4MSB          5C           DSPpicoNewAGC.psm
 coeffQ4LSB          2F           DSPpicoNewAGC.psm
 AudioMSB            0'd          DSPpicoNewAGC.psm
 AudioLSB            1'd          DSPpicoNewAGC.psm
 Strobe              2'd          DSPpicoNewAGC.psm
 Command             3'd          DSPpicoNewAGC.psm
 MltplyMSB           4'd          DSPpicoNewAGC.psm
 MltplyLSB           5'd          DSPpicoNewAGC.psm
 BTaudioMSB          6'd          DSPpicoNewAGC.psm
 BTaudioLSB          7'd          DSPpicoNewAGC.psm
 SaturationBits      8'd          DSPpicoNewAGC.psm
 RAMdataLSB          9'd          DSPpicoNewAGC.psm
 Status              10'd         DSPpicoNewAGC.psm
 StartToneAmp        11'd         DSPpicoNewAGC.psm
 MSBAudio            0'd          DSPpicoNewAGC.psm
 LSBAudio            1'd          DSPpicoNewAGC.psm
 SSBAmp              2'd          DSPpicoNewAGC.psm
 CmdToUser           3'd          DSPpicoNewAGC.psm
 CoeffMSB            4'd          DSPpicoNewAGC.psm
 CoeffLSB            5'd          DSPpicoNewAGC.psm
 SignalMSB           6'd          DSPpicoNewAGC.psm
 SignalLSB           7'd          DSPpicoNewAGC.psm
 Data2archiveMSB     10'd         DSPpicoNewAGC.psm
 Data2archiveLSB     11'd         DSPpicoNewAGC.psm
 Controlbits         12'd         DSPpicoNewAGC.psm
 EnMult              1'd          DSPpicoNewAGC.psm
 AckFIFO             32'd         DSPpicoNewAGC.psm
 PhaseIncrement      13'd         DSPpicoNewAGC.psm
 AudioFreqLSB        14'd         DSPpicoNewAGC.psm
 AudioPhaseMSB       15'd         DSPpicoNewAGC.psm
 AudioPhaseLSB       16'd         DSPpicoNewAGC.psm
 EnableSpeaker       17'd         DSPpicoNewAGC.psm
 MUXport             18'd         DSPpicoNewAGC.psm
 AveSignal1024msport 24'd         DSPpicoNewAGC.psm
 AveSignalMSBport    25'd         DSPpicoNewAGC.psm
 AveSignalLSBport    26'd         DSPpicoNewAGC.psm
 MSBBTAudio          27'd         DSPpicoNewAGC.psm
 LSBBTAudio          28'd         DSPpicoNewAGC.psm
 AmpMSB              10'd         DSPpicoNewAGC.psm
 AmpLSB              11'd         DSPpicoNewAGC.psm
 PhaseMSB            12'd         DSPpicoNewAGC.psm
 PhaseLSB            13'd         DSPpicoNewAGC.psm
 AGCvalue            14'd         DSPpicoNewAGC.psm
 VolSetting          15'd         DSPpicoNewAGC.psm
 OldPhaseMSB         16'd         DSPpicoNewAGC.psm
 AudioScratch        17'd         DSPpicoNewAGC.psm
 State               18'd         DSPpicoNewAGC.psm
 LVPtr               20'd         DSPpicoNewAGC.psm
 IaccuMSB            21'd         DSPpicoNewAGC.psm
 IaccuLSB            22'd         DSPpicoNewAGC.psm
 QaccuMSB            23'd         DSPpicoNewAGC.psm
 QaccuLSB            24'd         DSPpicoNewAGC.psm
 OldPhaseLSB         25'd         DSPpicoNewAGC.psm
 startsine           30'd         DSPpicoNewAGC.psm
 endsine             45'd         DSPpicoNewAGC.psm
 HistoryStart        70'd         DSPpicoNewAGC.psm
 HistoryStart42      112'd        DSPpicoNewAGC.psm
 AGCvalueTX          112'd        DSPpicoNewAGC.psm
 AGCvalueRX          113'd        DSPpicoNewAGC.psm
 AGCcounter          114'd        DSPpicoNewAGC.psm
 NormalisedMagMSB    115'd        DSPpicoNewAGC.psm
 NormalisedMagLSB    116'd        DSPpicoNewAGC.psm
 AGCcounterMSB       117'd        DSPpicoNewAGC.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.63"        
 datestamp$        "08 Jul 2017"  
 timestamp$        "15:21:48"     



List of line labels

   Label                      Addr  Source PSM File

 * cold_start                 000   DSPpicoNewAGC.psm
   AwaitAudioVal              041   DSPpicoNewAGC.psm
   AwaitRise                  045   DSPpicoNewAGC.psm
 * isTopAGCalready            04E   DSPpicoNewAGC.psm
   SaturatedPositive          053   DSPpicoNewAGC.psm
   Allswell                   056   DSPpicoNewAGC.psm
   HaveInput                  058   DSPpicoNewAGC.psm
   BackfromTransmitting       069   DSPpicoNewAGC.psm
   FourTimestooBig            08A   DSPpicoNewAGC.psm
   FourTimesLoop              08C   DSPpicoNewAGC.psm
   BitTooBig                  092   DSPpicoNewAGC.psm
   reduceAveSignalMSB_1_5dB   099   DSPpicoNewAGC.psm
   BitTooLow                  0A4   DSPpicoNewAGC.psm
 * Divide32                   0AB   DSPpicoNewAGC.psm
   Divide4                    0B0   DSPpicoNewAGC.psm
 * AudioDouble                0B5   DSPpicoNewAGC.psm
 * Negvalue                   0B7   DSPpicoNewAGC.psm
   islessthanneg31            0BC   DSPpicoNewAGC.psm
   islessthanneg63            0C0   DSPpicoNewAGC.psm
   Posvalue                   0C4   DSPpicoNewAGC.psm
   ismorethan31               0C9   DSPpicoNewAGC.psm
   ismorethan63               0CD   DSPpicoNewAGC.psm
 * Divide2                    0D1   DSPpicoNewAGC.psm
   TransmitAudio              0D4   DSPpicoNewAGC.psm
 * SkipNoBT                   0D4   DSPpicoNewAGC.psm
 * OutAmp                     0DC   DSPpicoNewAGC.psm
   TryAndDouble               0EF   DSPpicoNewAGC.psm
   BiggerThan63               0F4   DSPpicoNewAGC.psm
   BiggerThan128              0F8   DSPpicoNewAGC.psm
   Abs16Val                   0FB   DSPpicoNewAGC.psm
 * absval                     104   DSPpicoNewAGC.psm
   makeposval                 107   DSPpicoNewAGC.psm
 * invertval                  10B   DSPpicoNewAGC.psm
   increaseAGC                10F   DSPpicoNewAGC.psm
   decreaseAGC                114   DSPpicoNewAGC.psm
   AGC                        119   DSPpicoNewAGC.psm
   decrease3dB                123   DSPpicoNewAGC.psm
   decrease1_5dB              132   DSPpicoNewAGC.psm
 * AGCtest                    13F   DSPpicoNewAGC.psm
   AGClooptst                 143   DSPpicoNewAGC.psm
   PerformFIR                 14A   DSPpicoNewAGC.psm
   Ibussiness                 181   DSPpicoNewAGC.psm
   Qbussiness                 187   DSPpicoNewAGC.psm
   doIplus                    18D   DSPpicoNewAGC.psm
   doQplus                    195   DSPpicoNewAGC.psm
   doQminus                   19D   DSPpicoNewAGC.psm
   doMult                     1A5   DSPpicoNewAGC.psm
   GetRovingHistoryValues     1B1   DSPpicoNewAGC.psm
   resetLVptr                 1B6   DSPpicoNewAGC.psm
   AdvanceRptr                1B8   DSPpicoNewAGC.psm
   UpdateRptr                 1BB   DSPpicoNewAGC.psm
   conjugateDiff              1C1   DSPpicoNewAGC.psm
   Export2User                1C6   DSPpicoNewAGC.psm
 * ArchiveData                1CE   DSPpicoNewAGC.psm
 * Frequency                  1D1   DSPpicoNewAGC.psm
   cordic                     1D5   DSPpicoNewAGC.psm
   cordicloop                 1DA   DSPpicoNewAGC.psm
 * negrotate                  1DE   DSPpicoNewAGC.psm
   posrotate                  1EC   DSPpicoNewAGC.psm
   testcordicend              1F9   DSPpicoNewAGC.psm
   GetPhaseIncrement          1FD   DSPpicoNewAGC.psm
   shift                      205   DSPpicoNewAGC.psm
   shiftloop                  206   DSPpicoNewAGC.psm
   rotate90                   20C   DSPpicoNewAGC.psm
 * sub90                      210   DSPpicoNewAGC.psm
   add90                      219   DSPpicoNewAGC.psm
   Transmitmode               222   DSPpicoNewAGC.psm
   GrabTXAGCvalue             22A   DSPpicoNewAGC.psm
   Receivemode                22D   DSPpicoNewAGC.psm
   BlockDSPpico               235   DSPpicoNewAGC.psm
   Respond2Fifo               240   DSPpicoNewAGC.psm
   SendGParamBack             24E   DSPpicoNewAGC.psm
   SendSParamBack             251   DSPpicoNewAGC.psm
   GetFifoChar                254   DSPpicoNewAGC.psm
   Get2Chars                  25A   DSPpicoNewAGC.psm
   Get2ndChar                 25F   DSPpicoNewAGC.psm
   Chars2Byte                 265   DSPpicoNewAGC.psm
   Get4bits                   270   DSPpicoNewAGC.psm
   char0_9                    275   DSPpicoNewAGC.psm
   Byte2Chars                 278   DSPpicoNewAGC.psm
   GetChar                    284   DSPpicoNewAGC.psm
   is_0_9                     288   DSPpicoNewAGC.psm
 * delay_1s                   28B   DSPpicoNewAGC.psm
   wait_1s                    28D   DSPpicoNewAGC.psm
 * delay_300ms                295   DSPpicoNewAGC.psm
 * delay_200ms                296   DSPpicoNewAGC.psm
   delay_100ms                299   DSPpicoNewAGC.psm
   wait_100ms                 29A   DSPpicoNewAGC.psm
   delay_1ms                  29E   DSPpicoNewAGC.psm
   wait_1ms                   2A0   DSPpicoNewAGC.psm
 * delay_50us                 2A8   DSPpicoNewAGC.psm
   wait_50us                  2A9   DSPpicoNewAGC.psm
   delay_1us                  2AD   DSPpicoNewAGC.psm
   wait_1us                   2AE   DSPpicoNewAGC.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            140
 STAR              -

 AND              10
 OR                1
 XOR               -

 ADD              35
 ADDCY            13
 SUB              28
 SUBCY             9

 TEST              -
 TESTCY            -
 COMPARE          49
 COMPARECY         -

 SL0               7
 SL1               -
 SLX               -
 SLA               4
 RL                -
 SR0              16
 SR1               -
 SRX              19
 SRA              19
 RR                -

 REGBANK           -

 INPUT            13
 OUTPUT           32
 OUTPUTK           -

 STORE            34
 FETCH            34

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             41
 JUMP@             -
 CALL             85
 CALL@             -
 RETURN           74
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
